import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, IterableDiffers, LOCALE_ID, NgModule, NgZone, Optional, Output, PLATFORM_ID, Renderer2, SimpleChange, TemplateRef, Type, ViewChild, ViewChildren, ViewContainerRef, forwardRef, isDevMode, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import * as i0 from '@angular/core';
import { CommonModule, DOCUMENT, DatePipe, FormStyle, FormatWidth, Location, TranslationWidth, getLocaleDayNames, getLocaleFirstDayOfWeek, getLocaleMonthNames, getLocaleTimeFormat, isPlatformBrowser } from '@angular/common';
import { BehaviorSubject, EMPTY, Observable, ReplaySubject, Subject, combineLatest, forkJoin, from, fromEvent, interval, merge, of, timer } from 'rxjs';
import { debounceTime, delay, distinctUntilChanged, filter, finalize, map, pairwise, refCount, repeat, share, skip, startWith, switchMap, take, takeUntil, takeWhile, tap } from 'rxjs/operators';
import { FormsModule, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { ActivatedRoute, NavigationEnd, Router, RouterModule } from '@angular/router';
import { ActiveDescendantKeyManager, FocusKeyManager, FocusMonitor, FocusTrap, FocusTrapFactory, InteractivityChecker } from '@angular/cdk/a11y';
import { CdkPortal, CdkPortalOutlet, ComponentPortal, PortalInjector, PortalModule, TemplatePortal } from '@angular/cdk/portal';
import { BlockScrollStrategy, FlexibleConnectedPositionStrategy, GlobalPositionStrategy, Overlay, OverlayContainer, OverlayModule, OverlayPositionBuilder, ScrollDispatcher, ScrollStrategyOptions, ViewportRuler } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import * as i1 from '@angular/cdk/platform';
import { DomSanitizer } from '@angular/platform-browser';
import { animate, state, style, transition, trigger } from '@angular/animations';
import 'intersection-observer';
import { BidiModule, Directionality } from '@angular/cdk/bidi';
import { CdkCell, CdkCellDef, CdkCellOutlet, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkFooterRow, CdkFooterRowDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkRow, CdkRowDef, CdkTable, CdkTableModule, DataRowOutlet, DataSource, FooterRowOutlet, HeaderRowOutlet, NoDataRowOutlet, _COALESCED_STYLE_SCHEDULER, _CoalescedStyleScheduler } from '@angular/cdk/table';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { _DisposeViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY } from '@angular/cdk/collections';
import { BACKSPACE, DELETE, ENTER, ESCAPE, SPACE } from '@angular/cdk/keycodes';
import * as _angular_cdk_keycodes from '@angular/cdk/keycodes';

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/a11y';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/platform-browser';
import * as ɵngcc5 from '@angular/router';
import * as ɵngcc6 from '@angular/forms';
import * as ɵngcc7 from '@angular/cdk/table';

function NbOverlayContainerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.content);
} }
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) { }
const _c0 = ["*"];
const _c1 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
const _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
function NbRevealCardComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 2);
    ɵngcc0.ɵɵlistener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 3);
    ɵngcc0.ɵɵelementEnd();
} }
const _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
const _c4 = ["nb-card-front", "nb-card-back"];
function NbFlipCardComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵlistener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} }
function NbFlipCardComponent_a_6_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵlistener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} }
const _c5 = [[["nb-card"]]];
const _c6 = ["nb-card"];
const _c7 = ["nbButton", ""];
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-calendar-week-numbers", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("weeks", ctx_r0.weeks)("size", ctx_r0.size)("weekNumberSymbol", ctx_r0.weekNumberSymbol);
} }
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("holiday", day_r1.isHoliday);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r1.name);
} }
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker-row", 1);
    ɵngcc0.ɵɵlistener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.select.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("row", row_r1)("visibleDate", ctx_r0.visibleDate)("selectedValue", ctx_r0.selectedValue)("component", ctx_r0.cellComponent)("min", ctx_r0.min)("max", ctx_r0.max)("filter", ctx_r0.filter)("size", ctx_r0.size);
} }
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) { }
function NbCalendarWeekNumberComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const weekNumber_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(weekNumber_r1);
} }
const _c8 = "[_nghost-%COMP%]{display:flex;flex-direction:column}";
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-card-header", 5);
    ɵngcc0.ɵɵelementStart(1, "nb-calendar-view-mode", 6);
    ɵngcc0.ɵɵlistener("changeMode", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_view_mode_changeMode_1_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onChangeViewMode(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "nb-calendar-pageable-navigation", 7);
    ɵngcc0.ɵɵlistener("prev", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_prev_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.navigatePrev(); })("next", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_next_2_listener() { ɵngcc0.ɵɵrestoreView(_r5); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.navigateNext(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("date", ctx_r0.visibleDate)("viewMode", ctx_r0.activeViewMode);
} }
function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-day-picker", 8);
    ɵngcc0.ɵɵlistener("dateChange", function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template_nb_calendar_day_picker_dateChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.dateChange.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("boundingMonths", ctx_r1.boundingMonth)("cellComponent", ctx_r1.dayCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("visibleDate", ctx_r1.visibleDate)("size", ctx_r1.size)("date", ctx_r1.date)("showWeekNumber", ctx_r1.showWeekNumber)("weekNumberSymbol", ctx_r1.weekNumberSymbol);
} }
function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-year-picker", 9);
    ɵngcc0.ɵɵlistener("yearChange", function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template_nb_calendar_year_picker_yearChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); const ctx_r10 = ɵngcc0.ɵɵnextContext(); ctx_r10.setVisibleDate($event); return ctx_r10.setViewMode(ctx_r10.ViewMode.MONTH); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cellComponent", ctx_r2.yearCellComponent)("date", ctx_r2.date)("min", ctx_r2.min)("max", ctx_r2.max)("filter", ctx_r2.filter)("size", ctx_r2.size)("year", ctx_r2.visibleDate);
} }
function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-month-picker", 10);
    ɵngcc0.ɵɵlistener("monthChange", function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template_nb_calendar_month_picker_monthChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); const ctx_r12 = ɵngcc0.ɵɵnextContext(); ctx_r12.setVisibleDate($event); return ctx_r12.setViewMode(ctx_r12.ViewMode.DATE); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cellComponent", ctx_r3.monthCellComponent)("min", ctx_r3.min)("max", ctx_r3.max)("filter", ctx_r3.filter)("size", ctx_r3.size)("month", ctx_r3.visibleDate)("date", ctx_r3.date);
} }
function NbTimePickerComponent_nb_card_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 8);
    ɵngcc0.ɵɵtext(2, "Time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r8.secondsText);
} }
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r9.ampmText);
} }
function NbTimePickerComponent_nb_card_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template, 2, 1, "div", 9);
    ɵngcc0.ɵɵtemplate(5, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template, 2, 1, "div", 9);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.hoursText);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.minutesText);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.withSeconds);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.twelveHoursFormat);
} }
function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template(rf, ctx) { if (rf & 1) {
    const _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-list-item", 12);
    ɵngcc0.ɵɵelementStart(1, "nb-timepicker-cell", 13);
    ɵngcc0.ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template_nb_timepicker_cell_select_1_listener() { ɵngcc0.ɵɵrestoreView(_r13); const item_r11 = ctx.$implicit; const ctx_r12 = ɵngcc0.ɵɵnextContext(3); return ctx_r12.selectFullTime(item_r11); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r11 = ctx.$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵclassProp("selected", ctx_r10.isSelectedFullTimeValue(item_r11));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r10.getFullTimeString(item_r11))("selected", ctx_r10.isSelectedFullTimeValue(item_r11));
} }
function NbTimePickerComponent_nb_card_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "nb-list", 10);
    ɵngcc0.ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template, 2, 4, "nb-list-item", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.fullTimeOptions)("ngForTrackBy", ctx_r4.trackBySingleColumnValue.bind(ctx_r4));
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r20 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-list-item", 12);
    ɵngcc0.ɵɵelementStart(1, "nb-timepicker-cell", 13);
    ɵngcc0.ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() { ɵngcc0.ɵɵrestoreView(_r20); const item_r18 = ctx.$implicit; const ctx_r19 = ɵngcc0.ɵɵnextContext(3); return ctx_r19.setHour(item_r18.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r18 = ctx.$implicit;
    const ctx_r14 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵclassProp("selected", ctx_r14.isSelectedHour(item_r18.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", item_r18.text)("selected", ctx_r14.isSelectedHour(item_r18.value));
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template(rf, ctx) { if (rf & 1) {
    const _r23 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-list-item", 12);
    ɵngcc0.ɵɵelementStart(1, "nb-timepicker-cell", 13);
    ɵngcc0.ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template_nb_timepicker_cell_select_1_listener() { ɵngcc0.ɵɵrestoreView(_r23); const item_r21 = ctx.$implicit; const ctx_r22 = ɵngcc0.ɵɵnextContext(3); return ctx_r22.setMinute(item_r21.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r21 = ctx.$implicit;
    const ctx_r15 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵclassProp("selected", ctx_r15.isSelectedMinute(item_r21.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", item_r21.text)("selected", ctx_r15.isSelectedMinute(item_r21.value));
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-list-item", 12);
    ɵngcc0.ɵɵelementStart(1, "nb-timepicker-cell", 13);
    ɵngcc0.ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() { ɵngcc0.ɵɵrestoreView(_r27); const item_r25 = ctx.$implicit; const ctx_r26 = ɵngcc0.ɵɵnextContext(4); return ctx_r26.setSecond(item_r25.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r25 = ctx.$implicit;
    const ctx_r24 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵclassProp("selected", ctx_r24.isSelectedSecond(item_r25.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", item_r25.text)("selected", ctx_r24.isSelectedSecond(item_r25.value));
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-list", 10);
    ɵngcc0.ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template, 2, 4, "nb-list-item", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r16 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r16.secondsColumnOptions)("ngForTrackBy", ctx_r16.trackByTimeValues);
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r31 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-list-item", 16);
    ɵngcc0.ɵɵelementStart(1, "nb-timepicker-cell", 13);
    ɵngcc0.ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() { ɵngcc0.ɵɵrestoreView(_r31); const dayPeriod_r29 = ctx.$implicit; const ctx_r30 = ɵngcc0.ɵɵnextContext(4); return ctx_r30.changeDayPeriod(dayPeriod_r29); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dayPeriod_r29 = ctx.$implicit;
    const ctx_r28 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵclassProp("selected", ctx_r28.isSelectedDayPeriod(dayPeriod_r29));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", dayPeriod_r29)("selected", ctx_r28.isSelectedDayPeriod(dayPeriod_r29));
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-list", 10);
    ɵngcc0.ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template, 2, 4, "nb-list-item", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r17 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r17.dayPeriodColumnOptions)("ngForTrackBy", ctx_r17.trackByDayPeriod);
} }
function NbTimePickerComponent_nb_card_0_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-list", 10);
    ɵngcc0.ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template, 2, 4, "nb-list-item", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "nb-list", 10);
    ɵngcc0.ɵɵtemplate(3, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template, 2, 4, "nb-list-item", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template, 2, 2, "nb-list", 14);
    ɵngcc0.ɵɵtemplate(5, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template, 2, 2, "nb-list", 14);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.hoursColumnOptions)("ngForTrackBy", ctx_r6.trackByTimeValues);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.minutesColumnOptions)("ngForTrackBy", ctx_r6.trackByTimeValues);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.showSeconds());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r6.twelveHoursFormat);
} }
function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-card-footer", 17);
    ɵngcc0.ɵɵelementStart(1, "nb-calendar-actions", 18);
    ɵngcc0.ɵɵlistener("setCurrentTime", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_setCurrentTime_1_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(2); return ctx_r32.setCurrentTime(); })("saveValue", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_saveValue_1_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r34 = ɵngcc0.ɵɵnextContext(2); return ctx_r34.saveValue(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("applyButtonText", ctx_r7.applyButtonText)("currentTimeButtonText", ctx_r7.currentTimeButtonText);
} }
function NbTimePickerComponent_nb_card_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-card", 1);
    ɵngcc0.ɵɵelementStart(1, "nb-card-header", 2);
    ɵngcc0.ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_2_Template, 3, 0, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(3, NbTimePickerComponent_nb_card_0_ng_template_3_Template, 6, 4, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 5);
    ɵngcc0.ɵɵtemplate(6, NbTimePickerComponent_nb_card_0_ng_container_6_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(7, NbTimePickerComponent_nb_card_0_ng_template_7_Template, 6, 6, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(9, NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template, 2, 2, "nb-card-footer", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r2 = ɵngcc0.ɵɵreference(4);
    const _r5 = ɵngcc0.ɵɵreference(8);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("supports-scrollbar-theming", !ctx_r0.isFirefox());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", _r2);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", _r5);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showFooter);
} }
const _c9 = ["layoutTopDynamicArea"];
const _c10 = ["scrollableContainer"];
const _c11 = ["layoutContainer"];
const _c12 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
const _c13 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
const _c14 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r8.menuItem.icon);
} }
function NbMenuItemComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.menuItem.title, "\n");
} }
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r9.menuItem.icon);
} }
function NbMenuItemComponent_a_1_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 11);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function NbMenuItemComponent_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onHoverItem(ctx_r11.menuItem); })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onItemClick(ctx_r13.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_1_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.menuItem.selected);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r1.menuItem.link)("queryParams", ctx_r1.menuItem.queryParams)("fragment", ctx_r1.menuItem.fragment)("queryParamsHandling", ctx_r1.menuItem.queryParamsHandling)("preserveFragment", ctx_r1.menuItem.preserveFragment)("skipLocationChange", ctx_r1.menuItem.skipLocationChange);
    ɵngcc0.ɵɵattribute("target", ctx_r1.menuItem.target)("title", ctx_r1.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.badge);
} }
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r14.menuItem.icon);
} }
function NbMenuItemComponent_a_2_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 11);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function NbMenuItemComponent_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 12);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.onHoverItem(ctx_r16.menuItem); })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.onSelectItem(ctx_r18.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_2_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r2.menuItem.selected);
    ɵngcc0.ɵɵattribute("href", ctx_r2.menuItem.url, ɵngcc0.ɵɵsanitizeUrl)("target", ctx_r2.menuItem.target)("title", ctx_r2.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.badge);
} }
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r19.menuItem.icon);
} }
function NbMenuItemComponent_a_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 11);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function NbMenuItemComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 12);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.onHoverItem(ctx_r21.menuItem); })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); const ctx_r23 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r23.onItemClick(ctx_r23.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_3_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r3.menuItem.selected);
    ɵngcc0.ɵɵattribute("target", ctx_r3.menuItem.target)("title", ctx_r3.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.badge);
} }
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r24.menuItem.icon);
} }
function NbMenuItemComponent_a_4_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, 11);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r6 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r6);
} }
function NbMenuItemComponent_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 13);
    ɵngcc0.ɵɵlistener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r26 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r26.onToggleSubMenu(ctx_r26.menuItem); })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r27); const ctx_r28 = ɵngcc0.ɵɵnextContext(); return ctx_r28.onHoverItem(ctx_r28.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵelementStart(2, "span", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_4_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵngcc0.ɵɵelement(5, "nb-icon", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r4.menuItem.selected);
    ɵngcc0.ɵɵattribute("target", ctx_r4.menuItem.target)("title", ctx_r4.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.badge);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("icon", ctx_r4.getExpandStateIcon());
} }
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 18);
    ɵngcc0.ɵɵlistener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(3); return ctx_r32.onHoverItem($event); })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r34 = ɵngcc0.ɵɵnextContext(3); return ctx_r34.onToggleSubMenu($event); })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r35 = ɵngcc0.ɵɵnextContext(3); return ctx_r35.onSelectItem($event); })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r36 = ɵngcc0.ɵɵnextContext(3); return ctx_r36.onItemClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r30 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("menu-group", item_r30.group);
    ɵngcc0.ɵɵproperty("menuItem", item_r30)("badge", item_r30.badge);
} }
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 4, "li", 17);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r30 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r30.hidden);
} }
function NbMenuItemComponent_ul_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ul", 15);
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("collapsed", !(ctx_r5.menuItem.children && ctx_r5.menuItem.expanded))("expanded", ctx_r5.menuItem.expanded);
    ɵngcc0.ɵɵproperty("@toggle", ctx_r5.toggleState);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.menuItem.children);
} }
function NbMenuItemComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 19);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("text", ctx_r7.badge.text)("dotMode", ctx_r7.badge.dotMode)("status", ctx_r7.badge.status);
} }
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(2); return ctx_r3.onHoverItem($event); })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r5 = ɵngcc0.ɵɵnextContext(2); return ctx_r5.onToggleSubMenu($event); })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.onSelectItem($event); })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r7 = ɵngcc0.ɵɵnextContext(2); return ctx_r7.onItemClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("menu-group", item_r1.group);
    ɵngcc0.ɵɵproperty("menuItem", item_r1)("badge", item_r1.badge);
} }
function NbMenuComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 4, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1.hidden);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 8);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("config", tab_r1.icon);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.title);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("responsive", tab_r1.responsive);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.title);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 12);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("icon", tab_r1.icon);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.title);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 10);
    ɵngcc0.ɵɵlistener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r14 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r14.selectTab(tab_r1); });
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_2_Template, 1, 1, "nb-icon", 11);
    ɵngcc0.ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("responsive", tab_r1.responsive);
    ɵngcc0.ɵɵproperty("routerLink", tab_r1.route)("routerLinkActiveOptions", ctx_r4.activeLinkOptions);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.title);
} }
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 2);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 4, 6, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const _r3 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.disabled)("ngIfElse", _r3);
} }
const _c15 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
const _c16 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("config", tab_r1.tabIcon);
} }
function NbTabsetComponent_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.tabTitle);
} }
function NbTabsetComponent_li_1_nb_badge_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 9);
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("text", tab_r1.badgeText)("dotMode", tab_r1.badgeDot)("status", tab_r1.badgeStatus)("position", tab_r1.badgePosition);
} }
function NbTabsetComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 2);
    ɵngcc0.ɵɵlistener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const tab_r1 = ctx.$implicit; const ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.selectTab(tab_r1); })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const tab_r1 = ctx.$implicit; const ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.selectTab(tab_r1); })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r9); const tab_r1 = ctx.$implicit; const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.selectTab(tab_r1); });
    ɵngcc0.ɵɵelementStart(1, "a", 3);
    ɵngcc0.ɵɵlistener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 4);
    ɵngcc0.ɵɵtemplate(3, NbTabsetComponent_li_1_span_3_Template, 2, 1, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbTabsetComponent_li_1_nb_badge_4_Template, 1, 4, "nb-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("responsive", tab_r1.responsive)("active", tab_r1.active)("disabled", tab_r1.disabled);
    ɵngcc0.ɵɵattribute("tabindex", tab_r1.disabled ? -1 : 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.tabIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.tabTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r1.badgeText || tab_r1.badgeDot);
} }
const _c17 = [[["nb-tab"]]];
const _c18 = ["nb-tab"];
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 8);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("text", ctx_r4.badgeText)("status", ctx_r4.badgeStatus)("position", ctx_r4.badgePosition);
} }
function NbUserComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r0.imageBackgroundStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.badgeText);
} }
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.getInitials(), " ");
} }
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 8);
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("text", ctx_r6.badgeText)("status", ctx_r6.badgeStatus)("position", ctx_r6.badgePosition);
} }
function NbUserComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r1.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.showInitials);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.badgeText);
} }
function NbUserComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.name);
} }
function NbUserComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.title);
} }
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 6);
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementContainer(2, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r5.link)("title", ctx_r5.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r5.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 9);
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementContainer(2, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("href", ctx_r6.href, ɵngcc0.ɵɵsanitizeUrl)("title", ctx_r6.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r6.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 10);
    ɵngcc0.ɵɵlistener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) { return $event.preventDefault(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementContainer(2, 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("title", ctx_r7.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r7.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NbActionComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbActionComponent_ng_container_0_a_1_Template, 3, 4, "a", 3);
    ɵngcc0.ɵɵtemplate(2, NbActionComponent_ng_container_0_a_2_Template, 3, 4, "a", 4);
    ɵngcc0.ɵɵtemplate(3, NbActionComponent_ng_container_0_a_3_Template, 3, 3, "a", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.link);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.href && !ctx_r0.link);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.href && !ctx_r0.link);
} }
function NbActionComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
    ɵngcc0.ɵɵelementContainer(1, 8);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r3 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r3);
} }
function NbActionComponent_ng_template_3_nb_badge_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 12);
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("text", ctx_r9.badgeText)("dotMode", ctx_r9.badgeDot)("status", ctx_r9.badgeStatus)("position", ctx_r9.badgePosition);
} }
function NbActionComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, NbActionComponent_ng_template_3_nb_badge_0_Template, 1, 4, "nb-badge", 11);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.badgeText || ctx_r4.badgeDot);
} }
const _c19 = [[["nb-action"]]];
const _c20 = ["nb-action"];
const _c21 = ["searchInput"];
const _c22 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) { if (rf & 1) {
    const _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-search-field", 4);
    ɵngcc0.ɵɵlistener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.search($event); })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.emitInput($event); })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.emitDeactivate(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("show", ctx_r1.showSearchField)("type", ctx_r1.type)("placeholder", ctx_r1.placeholder)("hint", ctx_r1.hint);
} }
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} }
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} }
function NbProgressBarComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.value, "%");
} }
function NbAlertComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1.onClose(); });
    ɵngcc0.ɵɵelementStart(1, "span", 2);
    ɵngcc0.ɵɵtext(2, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "span", 8);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r8); const file_r3 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r6 = ɵngcc0.ɵɵnextContext(2); return ctx_r6.removeFile(file_r3); });
    ɵngcc0.ɵɵtext(2, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵstyleProp("background-image", file_r3.urlStyle);
} }
function NbChatFormComponent_div_0_ng_container_1_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 9);
} }
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 6);
    ɵngcc0.ɵɵelementStart(2, "div");
    ɵngcc0.ɵɵtemplate(3, NbChatFormComponent_div_0_ng_container_1_nb_icon_3_Template, 1, 0, "nb-icon", 7);
    ɵngcc0.ɵɵelementStart(4, "span", 8);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_Template_span_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r11); const file_r3 = ctx.$implicit; const ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.removeFile(file_r3); });
    ɵngcc0.ɵɵtext(5, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const file_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", file_r3.urlStyle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !file_r3.urlStyle);
} }
function NbChatFormComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_Template, 6, 2, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.droppedFiles);
} }
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 13);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("icon", ctx_r12.buttonIcon);
} }
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r14.buttonTitle);
} }
function NbChatFormComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.sendMessage(); });
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 11);
    ɵngcc0.ɵɵtemplate(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r13 = ɵngcc0.ɵɵreference(3);
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("with-icon", !ctx_r1.buttonTitle);
    ɵngcc0.ɵɵproperty("status", ctx_r1.getButtonStatus());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.buttonTitle)("ngIfElse", _r13);
} }
function NbChatMessageComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.getInitials(), " ");
} }
function NbChatMessageComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, NbChatMessageComponent_div_0_ng_container_1_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r0.avatarStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.avatarStyle);
} }
function NbChatMessageComponent_nb_chat_message_file_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-file", 9);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r1.sender)("date", ctx_r1.date)("dateFormat", ctx_r1.dateFormat)("message", ctx_r1.message)("files", ctx_r1.files);
} }
function NbChatMessageComponent_nb_chat_message_quote_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-quote", 10);
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r2.sender)("date", ctx_r2.date)("dateFormat", ctx_r2.dateFormat)("message", ctx_r2.message)("quote", ctx_r2.quote);
} }
function NbChatMessageComponent_nb_chat_message_map_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-map", 11);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r3.sender)("date", ctx_r3.date)("message", ctx_r3.message)("latitude", ctx_r3.latitude)("longitude", ctx_r3.longitude);
} }
function NbChatMessageComponent_nb_chat_message_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-text", 12);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r4.sender)("date", ctx_r4.date)("dateFormat", ctx_r4.dateFormat)("message", ctx_r4.message);
} }
const _c23 = ["scrollable"];
function NbChatComponent_p_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.noMessagesPlaceholder);
} }
const _c24 = [[["nb-chat-message"]], [["nb-chat-form"]]];
const _c25 = ["nb-chat-message", "nb-chat-form"];
const _c26 = function (a0) { return [a0]; };
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const file_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("icon", file_r3.icon);
} }
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const file_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵstyleProp("background-image", file_r3.urlStyle);
} }
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵtemplate(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r3 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("href", file_r3.url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !file_r3.urlStyle && file_r3.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", file_r3.urlStyle);
} }
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.readyFiles);
} }
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r8 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("icon", ctx_r8.readyFiles[0].icon);
} }
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r9.readyFiles[0].urlStyle);
} }
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "a", 4);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵtemplate(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("href", ctx_r1.readyFiles[0].url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.readyFiles[0].urlStyle && ctx_r1.readyFiles[0].icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.readyFiles[0].urlStyle);
} }
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementStart(2, "time");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
} }
function NbChatMessageTextComponent_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementStart(2, "time");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
} }
function NbChatMessageTextComponent_p_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.message);
} }
function NbSpinnerComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.message);
} }
function NbStepComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NbStepperComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 6);
} if (rf & 2) {
    const index_r3 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("connector-past", index_r3 <= ctx_r5.selectedIndex);
} }
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const index_r3 = ɵngcc0.ɵɵnextContext(2).index;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(index_r3 + 1);
} }
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 12);
} }
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r2 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r10 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r10.getStepTemplate(step_r2));
} }
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r2 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(step_r2.label);
} }
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵlistener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); const step_r2 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r16 = ɵngcc0.ɵɵnextContext(); return !ctx_r16.disableStepNavigation && step_r2.select(); });
    ɵngcc0.ɵɵelementStart(1, "div", 8);
    ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9);
    ɵngcc0.ɵɵtemplate(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 11);
    ɵngcc0.ɵɵtemplate(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9);
    ɵngcc0.ɵɵtemplate(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("selected", ctx_r6.isStepSelected(step_r2))("completed", !ctx_r6.isStepSelected(step_r2) && step_r2.completed)("noninteractive", ctx_r6.disableStepNavigation);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !step_r2.completed || ctx_r6.isStepSelected(step_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r6.isStepSelected(step_r2) && step_r2.completed);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", step_r2.isLabelTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !step_r2.isLabelTemplate);
} }
function NbStepperComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4);
    ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r2 = ctx.$implicit;
    const first_r4 = ctx.first;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !first_r4 && !step_r2.hidden);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !step_r2.hidden);
} }
const _c27 = [[["nb-step"]]];
const _c28 = ["nb-step"];
const _c29 = [[["nb-accordion-item"]]];
const _c30 = ["nb-accordion-item"];
const _c31 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
const _c32 = ["nb-accordion-item-header", "nb-accordion-item-body"];
const _c33 = function (a0) { return { value: a0 }; };
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@expansionIndicator", ctx_r0.state);
} }
const _c34 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
const _c35 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
const _c36 = [[["nb-list-item"]]];
const _c37 = ["nb-list-item"];
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) { }
function NbToastComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r0.icon);
} }
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-toast", 1);
} if (rf & 2) {
    const toast_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@fadeIn", ctx_r0.fadeIn)("toast", toast_r1);
} }
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("config", ctx_r0.context.icon);
} }
function NbTooltipComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.content);
} }
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-checkbox", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
} }
const _c38 = ["selectButton"];
function NbSelectComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NbSelectComponent_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r7.selectionView);
} }
function NbSelectComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbSelectComponent_ng_container_2_ng_container_1_Template, 2, 0, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, NbSelectComponent_ng_container_2_ng_template_2_Template, 1, 1, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r6 = ɵngcc0.ɵɵreference(3);
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", _r6);
} }
function NbSelectComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.placeholder);
} }
function NbSelectComponent_nb_option_list_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-option-list", 7);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r4.hostWidth, "px");
    ɵngcc0.ɵɵproperty("size", ctx_r4.size)("position", ctx_r4.overlayPosition)("ngClass", ctx_r4.optionsListClass);
} }
const _c39 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
const _c40 = ["nb-select-label", "nb-option, nb-option-group"];
const _c41 = [[["nb-option"], ["ng-container"]]];
const _c42 = ["nb-option, ng-container"];
function NbAutocompleteComponent_nb_option_list_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-option-list", 1);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r0.hostWidth, "px");
    ɵngcc0.ɵɵclassProp("empty", !(ctx_r0.options == null ? null : ctx_r0.options.length));
    ɵngcc0.ɵɵproperty("size", ctx_r0.size)("position", ctx_r0.overlayPosition)("id", ctx_r0.id)("ngClass", ctx_r0.optionsListClass);
} }
const _c43 = [[["nb-option"], ["nb-option-group"]]];
const _c44 = ["nb-option, nb-option-group"];
const _c45 = ["viewContainerRef"];
function NbWindowComponent_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NbWindowComponent_button_7_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.maximize(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} }
function NbWindowComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NbWindowComponent_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.maximizeOrFullScreen(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 8);
    ɵngcc0.ɵɵelementEnd();
} }
function NbWindowComponent_nb_card_body_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-card-body");
    ɵngcc0.ɵɵelement(1, "nb-overlay-container");
    ɵngcc0.ɵɵelementEnd();
} }
const _c46 = ["valueContainer"];
const _c47 = ["input"];
const _c48 = [[["nb-radio"]]];
const _c49 = ["nb-radio"];
function NbTagComponent_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    const _r2 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-icon", 1);
    ɵngcc0.ɵɵlistener("click", function NbTagComponent_nb_icon_1_Template_nb_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1._remove(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("nb-tag-remove size-", ctx_r0.size, "");
} }
const _c50 = [[["nb-tag"], ["input", "nbTagInput", ""]]];
const _c51 = ["nb-tag, input[nbTagInput]"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 3);
} }
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 4);
} }
function NbSortIconComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1);
    ɵngcc0.ɵɵtemplate(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isAscending());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isDescending());
} }
const _c52 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-sort-icon", 4);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r0.direction);
} }
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) { }
const _c53 = ["nbTreeGrid", ""];
const _c54 = ["nbTreeGridRow", ""];
const _c55 = ["nbTreeGridHeaderRow", ""];
const _c56 = ["nbTreeGridFooterRow", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} }
function NbFormFieldComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r0.prefixClasses$));
} }
function NbFormFieldComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵpipe(1, "async");
    ɵngcc0.ɵɵprojection(2, 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r1.suffixClasses$));
} }
const _c57 = ["*", [["", "nbPrefix", ""]], [["", "nbSuffix", ""]]];
const _c58 = ["*", "[nbPrefix]", "[nbSuffix]"];
const NB_THEME_OPTIONS = new InjectionToken('Nebular Theme Options');
const NB_MEDIA_BREAKPOINTS = new InjectionToken('Nebular Media Breakpoints');
const NB_BUILT_IN_JS_THEMES = new InjectionToken('Nebular Built-in JS Themes');
const NB_JS_THEMES = new InjectionToken('Nebular JS Themes');
/**
 * We're providing browser apis with tokens to improve testing capabilities.
 * */
const NB_WINDOW = new InjectionToken('Window');
const NB_DOCUMENT = new InjectionToken('Document');

const palette = {
    primary: '#3366ff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const DEFAULT_THEME = {
    name: 'default',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#ffffff',
        bg2: '#f7f9fc',
        bg3: '#edf1f7',
        bg4: '#e4e9f2',
        border: '#ffffff',
        border2: '#f7f9fc',
        border3: '#edf1f7',
        border4: '#e4e9f2',
        border5: '#c5cee0',
        fg: '#8f9bb3',
        fgHeading: '#1a2138',
        fgText: '#1a2138',
        fgHighlight: palette.primary,
        layoutBg: '#f7f9fc',
        separator: '#edf1f7',
        primary: palette.primary,
        success: palette.success,
        info: palette.info,
        warning: palette.warning,
        danger: palette.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$1 = {
    primary: '#a16eff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const COSMIC_THEME = {
    name: 'cosmic',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#323259',
        bg2: '#252547',
        bg3: '#1b1b38',
        bg4: '#13132b',
        border: '#323259',
        border2: '#252547',
        border3: '#1b1b38',
        border4: '#13132b',
        border5: '#13132b',
        fg: '#b4b4db',
        fgHeading: '#ffffff',
        fgText: '#ffffff',
        fgHighlight: palette$1.primary,
        layoutBg: '#151a30',
        separator: '#151a30',
        primary: palette$1.primary,
        success: palette$1.success,
        info: palette$1.info,
        warning: palette$1.warning,
        danger: palette$1.danger,
        primaryLight: '#b18aff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$2 = {
    primary: '#73a1ff',
    success: '#5dcfe3',
    info: '#ba7fec',
    warning: '#ffa36b',
    danger: '#ff6b83',
};
const CORPORATE_THEME = {
    name: 'corporate',
    base: 'default',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#ffffff',
        bg2: '#f7f9fc',
        bg3: '#edf1f7',
        bg4: '#e4e9f2',
        border: '#ffffff',
        border2: '#f7f9fc',
        border3: '#edf1f7',
        border4: '#e4e9f2',
        border5: '#c5cee0',
        fg: '#8f9bb3',
        fgHeading: '#1a2138',
        fgText: '#1a2138',
        fgHighlight: palette$2.primary,
        layoutBg: '#f7f9fc',
        separator: '#edf1f7',
        primary: palette$2.primary,
        success: palette$2.success,
        info: palette$2.info,
        warning: palette$2.warning,
        danger: palette$2.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$3 = {
    primary: '#3366ff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const DARK_THEME = {
    name: 'dark',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#222b45',
        bg2: '#1a2138',
        bg3: '#151a30',
        bg4: '#101426',
        border: '#222b45',
        border2: '#1a2138',
        border3: '#151a30',
        border4: '#101426',
        border5: '#101426',
        fg: '#8f9bb3',
        fgHeading: '#ffffff',
        fgText: '#ffffff',
        fgHighlight: palette$3.primary,
        layoutBg: '#1b1b38',
        separator: '#1b1b38',
        primary: palette$3.primary,
        success: palette$3.success,
        info: palette$3.info,
        warning: palette$3.warning,
        danger: palette$3.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const BUILT_IN_THEMES = [
    DEFAULT_THEME,
    COSMIC_THEME,
    CORPORATE_THEME,
    DARK_THEME,
];
/**
 * Js Themes registry - provides access to the JS themes' variables.
 * Usually shouldn't be used directly, but through the NbThemeService class methods (getJsTheme).
 */
class NbJSThemesRegistry {
    constructor(builtInThemes, newThemes = []) {
        this.themes = {};
        const themes = this.combineByNames(newThemes, builtInThemes);
        themes.forEach((theme) => {
            this.register(theme, theme.name, theme.base);
        });
    }
    /**
     * Registers a new JS theme
     * @param config any
     * @param themeName string
     * @param baseTheme string
     */
    register(config, themeName, baseTheme) {
        const base = this.has(baseTheme) ? this.get(baseTheme) : {};
        this.themes[themeName] = this.mergeDeep({}, base, config);
    }
    /**
     * Checks whether the theme is registered
     * @param themeName
     * @returns boolean
     */
    has(themeName) {
        return !!this.themes[themeName];
    }
    /**
     * Return a theme
     * @param themeName
     * @returns NbJSThemeOptions
     */
    get(themeName) {
        if (!this.themes[themeName]) {
            throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
        }
        return JSON.parse(JSON.stringify(this.themes[themeName]));
    }
    combineByNames(newThemes, oldThemes) {
        if (newThemes) {
            const mergedThemes = [];
            newThemes.forEach((theme) => {
                const sameOld = oldThemes.find((tm) => tm.name === theme.name)
                    || {};
                const mergedTheme = this.mergeDeep({}, sameOld, theme);
                mergedThemes.push(mergedTheme);
            });
            oldThemes.forEach((theme) => {
                if (!mergedThemes.find((tm) => tm.name === theme.name)) {
                    mergedThemes.push(theme);
                }
            });
            return mergedThemes;
        }
        return oldThemes;
    }
    isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item);
    }
    // TODO: move to helpers
    mergeDeep(target, ...sources) {
        if (!sources.length) {
            return target;
        }
        const source = sources.shift();
        if (this.isObject(target) && this.isObject(source)) {
            for (const key in source) {
                if (this.isObject(source[key])) {
                    if (!target[key]) {
                        Object.assign(target, { [key]: {} });
                    }
                    this.mergeDeep(target[key], source[key]);
                }
                else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return this.mergeDeep(target, ...sources);
    }
}
NbJSThemesRegistry.ɵfac = function NbJSThemesRegistry_Factory(t) { return new (t || NbJSThemesRegistry)(ɵngcc0.ɵɵinject(NB_BUILT_IN_JS_THEMES), ɵngcc0.ɵɵinject(NB_JS_THEMES)); };
NbJSThemesRegistry.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbJSThemesRegistry, factory: NbJSThemesRegistry.ɵfac });
NbJSThemesRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [NB_BUILT_IN_JS_THEMES,] }] },
    { type: Array, decorators: [{ type: Inject, args: [NB_JS_THEMES,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbJSThemesRegistry, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [NB_BUILT_IN_JS_THEMES]
            }] }, { type: Array, decorators: [{
                type: Inject,
                args: [NB_JS_THEMES]
            }] }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const DEFAULT_MEDIA_BREAKPOINTS = [
    {
        name: 'xs',
        width: 0,
    },
    {
        name: 'is',
        width: 400,
    },
    {
        name: 'sm',
        width: 576,
    },
    {
        name: 'md',
        width: 768,
    },
    {
        name: 'lg',
        width: 992,
    },
    {
        name: 'xl',
        width: 1200,
    },
    {
        name: 'xxl',
        width: 1400,
    },
    {
        name: 'xxxl',
        width: 1600,
    },
];
/**
 * Manages media breakpoints
 *
 * Provides access to available media breakpoints to convert window width to a configured breakpoint,
 * e.g. 200px - *xs* breakpoint
 */
class NbMediaBreakpointsService {
    constructor(breakpoints) {
        this.breakpoints = breakpoints;
        this.breakpointsMap = this.breakpoints.reduce((res, b) => {
            res[b.name] = b.width;
            return res;
        }, {});
    }
    /**
     * Returns a configured breakpoint by width
     * @param width number
     * @returns {Z|{name: string, width: number}}
     */
    getByWidth(width) {
        const unknown = { name: 'unknown', width: width };
        const breakpoints = this.getBreakpoints();
        return breakpoints
            .find((point, index) => {
            const next = breakpoints[index + 1];
            return width >= point.width && (!next || width < next.width);
        }) || unknown;
    }
    /**
     * Returns a configured breakpoint by name
     * @param name string
     * @returns NbMediaBreakpoint
     */
    getByName(name) {
        const unknown = { name: 'unknown', width: NaN };
        const breakpoints = this.getBreakpoints();
        return breakpoints.find((point) => name === point.name) || unknown;
    }
    /**
     * Returns a list of configured breakpoints for the theme
     * @returns NbMediaBreakpoint[]
     */
    getBreakpoints() {
        return this.breakpoints;
    }
    /**
     * Returns a map of configured breakpoints for the theme
     * @returns {[p: string]: number}
     */
    getBreakpointsMap() {
        return this.breakpointsMap;
    }
}
NbMediaBreakpointsService.ɵfac = function NbMediaBreakpointsService_Factory(t) { return new (t || NbMediaBreakpointsService)(ɵngcc0.ɵɵinject(NB_MEDIA_BREAKPOINTS)); };
NbMediaBreakpointsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMediaBreakpointsService, factory: NbMediaBreakpointsService.ɵfac });
NbMediaBreakpointsService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_MEDIA_BREAKPOINTS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMediaBreakpointsService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_MEDIA_BREAKPOINTS]
            }] }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Main Nebular service. Includes various helper methods.
 */
class NbThemeService {
    constructor(options, breakpointService, jsThemesRegistry) {
        this.options = options;
        this.breakpointService = breakpointService;
        this.jsThemesRegistry = jsThemesRegistry;
        this.themeChanges$ = new ReplaySubject(1);
        this.appendLayoutClass$ = new Subject();
        this.removeLayoutClass$ = new Subject();
        this.changeWindowWidth$ = new ReplaySubject(2);
        if (options && options.name) {
            this.changeTheme(options.name);
        }
    }
    /**
     * Change current application theme
     * @param {string} name
     */
    changeTheme(name) {
        this.themeChanges$.next({ name, previous: this.currentTheme });
        this.currentTheme = name;
    }
    changeWindowWidth(width) {
        this.changeWindowWidth$.next(width);
    }
    /**
     * Returns a theme object with variables (color/paddings/etc) on a theme change.
     * Once subscribed - returns current theme.
     *
     * @returns {Observable<NbJSThemeOptions>}
     */
    getJsTheme() {
        return this.onThemeChange().pipe(map((theme) => {
            return this.jsThemesRegistry.get(theme.name);
        }));
    }
    /**
     * Triggers media query breakpoint change
     * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
     * ```ts
     *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
     * ```
     * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
     */
    onMediaQueryChange() {
        return this.changeWindowWidth$
            .pipe(startWith(undefined), pairwise(), map(([prevWidth, width]) => {
            return [
                this.breakpointService.getByWidth(prevWidth),
                this.breakpointService.getByWidth(width),
            ];
        }), filter(([prevPoint, point]) => {
            return prevPoint.name !== point.name;
        }), distinctUntilChanged(null, params => params[0].name + params[1].name), share());
    }
    /**
     * Triggered when current theme is changed
     * @returns {Observable<any>}
     */
    onThemeChange() {
        return this.themeChanges$.pipe(share());
    }
    /**
     * Append a class to nb-layout
     * @param {string} className
     */
    appendLayoutClass(className) {
        this.appendLayoutClass$.next(className);
    }
    /**
     * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
     * @returns {Observable<any>}
     */
    onAppendLayoutClass() {
        return this.appendLayoutClass$.pipe(share());
    }
    /**
     * Removes a class from nb-layout
     * @param {string} className
     */
    removeLayoutClass(className) {
        this.removeLayoutClass$.next(className);
    }
    /**
     * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
     * @returns {Observable<any>}
     */
    onRemoveLayoutClass() {
        return this.removeLayoutClass$.pipe(share());
    }
}
NbThemeService.ɵfac = function NbThemeService_Factory(t) { return new (t || NbThemeService)(ɵngcc0.ɵɵinject(NB_THEME_OPTIONS), ɵngcc0.ɵɵinject(NbMediaBreakpointsService), ɵngcc0.ɵɵinject(NbJSThemesRegistry)); };
NbThemeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbThemeService, factory: NbThemeService.ɵfac });
NbThemeService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_THEME_OPTIONS,] }] },
    { type: NbMediaBreakpointsService },
    { type: NbJSThemesRegistry }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbThemeService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_THEME_OPTIONS]
            }] }, { type: NbMediaBreakpointsService }, { type: NbJSThemesRegistry }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Service to control the global page spinner.
 */
class NbSpinnerService {
    constructor(document) {
        this.document = document;
        this.loaders = [];
        this.selector = 'nb-global-spinner';
    }
    /**
     * Appends new loader to the list of loader to be completed before
     * spinner will be hidden
     * @param method Promise<any>
     */
    registerLoader(method) {
        this.loaders.push(method);
    }
    /**
     * Clears the list of loader
     */
    clear() {
        this.loaders = [];
    }
    /**
     * Start the loader process, show spinnder and execute loaders
     */
    load() {
        this.showSpinner();
        this.executeAll();
    }
    executeAll(done = () => { }) {
        Promise.all(this.loaders).then((values) => {
            this.hideSpinner();
            done.call(null, values);
        })
            .catch((error) => {
            // TODO: Promise.reject
            console.error(error);
        });
    }
    // TODO is there any better way of doing this?
    showSpinner() {
        const el = this.getSpinnerElement();
        if (el) {
            el.style['display'] = 'block';
        }
    }
    hideSpinner() {
        const el = this.getSpinnerElement();
        if (el) {
            el.style['display'] = 'none';
        }
    }
    getSpinnerElement() {
        return this.document.getElementById(this.selector);
    }
}
NbSpinnerService.ɵfac = function NbSpinnerService_Factory(t) { return new (t || NbSpinnerService)(ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbSpinnerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSpinnerService, factory: NbSpinnerService.ɵfac });
NbSpinnerService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSpinnerService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

/**
 * Layout direction.
 * */
var NbLayoutDirection;
(function (NbLayoutDirection) {
    NbLayoutDirection["LTR"] = "ltr";
    NbLayoutDirection["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));

/**
 * Layout direction setting injection token.
 * */
const NB_LAYOUT_DIRECTION = new InjectionToken('Layout direction');
/**
 * Layout Direction Service.
 * Allows to set or get layout direction and listen to its changes
 */
class NbLayoutDirectionService {
    constructor(direction = NbLayoutDirection.LTR) {
        this.direction = direction;
        this.$directionChange = new ReplaySubject(1);
        this.setDirection(direction);
    }
    /**
     * Returns true if layout direction set to left to right.
     * @returns boolean.
     * */
    isLtr() {
        return this.direction === NbLayoutDirection.LTR;
    }
    /**
     * Returns true if layout direction set to right to left.
     * @returns boolean.
     * */
    isRtl() {
        return this.direction === NbLayoutDirection.RTL;
    }
    /**
     * Returns current layout direction.
     * @returns NbLayoutDirection.
     * */
    getDirection() {
        return this.direction;
    }
    /**
     * Sets layout direction
     * @param {NbLayoutDirection} direction
     */
    setDirection(direction) {
        this.direction = direction;
        this.$directionChange.next(direction);
    }
    /**
     * Triggered when direction was changed.
     * @returns Observable<NbLayoutDirection>.
     */
    onDirectionChange() {
        return this.$directionChange.pipe(share());
    }
}
NbLayoutDirectionService.ɵfac = function NbLayoutDirectionService_Factory(t) { return new (t || NbLayoutDirectionService)(ɵngcc0.ɵɵinject(NB_LAYOUT_DIRECTION, 8)); };
NbLayoutDirectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutDirectionService, factory: NbLayoutDirectionService.ɵfac });
NbLayoutDirectionService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_LAYOUT_DIRECTION,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutDirectionService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_LAYOUT_DIRECTION]
            }] }]; }, null); })();

/**
 * Layout scroll service. Provides information about current scroll position,
 * as well as methods to update position of the scroll.
 *
 * The reason we added this service is that in Nebular there are two scroll modes:
 * - the default mode when scroll is on body
 * - and the `withScroll` mode, when scroll is removed from the body and moved to an element inside of the
 * `nb-layout` component
 */
class NbLayoutScrollService {
    constructor() {
        this.scrollPositionReq$ = new Subject();
        this.manualScroll$ = new Subject();
        this.scroll$ = new Subject();
        this.scrollable$ = new Subject();
    }
    /**
     * Returns scroll position
     *
     * @returns {Observable<NbScrollPosition>}
     */
    getPosition() {
        return Observable.create((observer) => {
            const listener = new Subject();
            listener.subscribe(observer);
            this.scrollPositionReq$.next({ listener });
            return () => listener.complete();
        });
    }
    /**
     * Sets scroll position
     *
     * @param {number} x
     * @param {number} y
     */
    scrollTo(x = null, y = null) {
        this.manualScroll$.next({ x, y });
    }
    /**
     * Returns a stream of scroll events
     *
     * @returns {Observable<any>}
     */
    onScroll() {
        return this.scroll$.pipe(share());
    }
    /**
     * @private
     * @returns Observable<NbScrollPosition>.
     */
    onManualScroll() {
        return this.manualScroll$.pipe(share());
    }
    /**
     * @private
     * @returns {Subject<any>}
     */
    onGetPosition() {
        return this.scrollPositionReq$;
    }
    onScrollableChange() {
        return this.scrollable$.pipe(share());
    }
    /**
     * @private
     * @param {any} event
     */
    fireScrollChange(event) {
        this.scroll$.next(event);
    }
    scrollable(scrollable) {
        this.scrollable$.next(scrollable);
    }
}
NbLayoutScrollService.ɵfac = function NbLayoutScrollService_Factory(t) { return new (t || NbLayoutScrollService)(); };
NbLayoutScrollService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutScrollService, factory: NbLayoutScrollService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutScrollService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * Simple helper service to return Layout dimensions
 * Depending of current Layout scroll mode (default or `withScroll` when scroll is moved to an element
 * inside of the layout) corresponding dimensions will be returns  - of `documentElement` in first case and
 * `.scrollable-container` in the second.
 */
class NbLayoutRulerService {
    constructor() {
        this.contentDimensionsReq$ = new Subject();
    }
    /**
     * Content dimensions
     * @returns {Observable<NbLayoutDimensions>}
     */
    getDimensions() {
        return Observable.create((observer) => {
            const listener = new Subject();
            listener.subscribe(observer);
            this.contentDimensionsReq$.next({ listener });
            return () => listener.complete();
        });
    }
    /**
     * @private
     * @returns {Subject<any>}
     */
    onGetDimensions() {
        return this.contentDimensionsReq$;
    }
}
NbLayoutRulerService.ɵfac = function NbLayoutRulerService_Factory(t) { return new (t || NbLayoutRulerService)(); };
NbLayoutRulerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutRulerService, factory: NbLayoutRulerService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutRulerService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbSharedModule {
}
NbSharedModule.ɵfac = function NbSharedModule_Factory(t) { return new (t || NbSharedModule)(); };
NbSharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSharedModule });
NbSharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSharedModule, { exports: function () { return [CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSharedModule, [{
        type: NgModule,
        args: [{
                exports: [
                    CommonModule,
                    // TODO: probably we don't need FormsModule in SharedModule
                    FormsModule,
                    RouterModule,
                ]
            }]
    }], null, null); })();

/**
 * Overrides angular cdk focus trap to keep restore functionality inside trap.
 * */
class NbFocusTrap extends FocusTrap {
    constructor(element, checker, ngZone, document, deferAnchors) {
        super(element, checker, ngZone, document, deferAnchors);
        this.element = element;
        this.checker = checker;
        this.ngZone = ngZone;
        this.document = document;
        this.savePreviouslyFocusedElement();
    }
    restoreFocus() {
        this.previouslyFocusedElement.focus();
        this.destroy();
    }
    blurPreviouslyFocusedElement() {
        this.previouslyFocusedElement.blur();
    }
    savePreviouslyFocusedElement() {
        this.previouslyFocusedElement = this.document.activeElement;
    }
}
class NbFocusTrapFactoryService extends FocusTrapFactory {
    constructor(checker, ngZone, document) {
        super(checker, ngZone, document);
        this.checker = checker;
        this.ngZone = ngZone;
        this.document = document;
    }
    create(element, deferCaptureElements) {
        return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
    }
}
NbFocusTrapFactoryService.ɵfac = function NbFocusTrapFactoryService_Factory(t) { return new (t || NbFocusTrapFactoryService)(ɵngcc0.ɵɵinject(ɵngcc1.InteractivityChecker), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbFocusTrapFactoryService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbFocusTrapFactoryService, factory: NbFocusTrapFactoryService.ɵfac });
NbFocusTrapFactoryService.ctorParameters = () => [
    { type: InteractivityChecker },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFocusTrapFactoryService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.InteractivityChecker }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

class NbFocusKeyManager extends FocusKeyManager {
}
class NbFocusKeyManagerFactoryService {
    create(items) {
        return new NbFocusKeyManager(items);
    }
}

class NbActiveDescendantKeyManager extends ActiveDescendantKeyManager {
}
class NbActiveDescendantKeyManagerFactoryService {
    create(items) {
        return new NbActiveDescendantKeyManager(items);
    }
}
var NbKeyManagerActiveItemMode;
(function (NbKeyManagerActiveItemMode) {
    NbKeyManagerActiveItemMode[NbKeyManagerActiveItemMode["RESET_ACTIVE"] = -1] = "RESET_ACTIVE";
    NbKeyManagerActiveItemMode[NbKeyManagerActiveItemMode["FIRST_ACTIVE"] = 0] = "FIRST_ACTIVE";
})(NbKeyManagerActiveItemMode || (NbKeyManagerActiveItemMode = {}));

class NbFocusMonitor extends FocusMonitor {
}
NbFocusMonitor.ɵfac = function NbFocusMonitor_Factory(t) { return ɵNbFocusMonitor_BaseFactory(t || NbFocusMonitor); };
NbFocusMonitor.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbFocusMonitor, factory: NbFocusMonitor.ɵfac });
const ɵNbFocusMonitor_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFocusMonitor);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFocusMonitor, [{
        type: Injectable
    }], null, null); })();
class NbA11yModule {
    static forRoot() {
        return {
            ngModule: NbA11yModule,
            providers: [
                NbFocusTrapFactoryService,
                NbFocusKeyManagerFactoryService,
                NbActiveDescendantKeyManagerFactoryService,
                { provide: NbFocusMonitor, useClass: FocusMonitor },
            ],
        };
    }
}
NbA11yModule.ɵfac = function NbA11yModule_Factory(t) { return new (t || NbA11yModule)(); };
NbA11yModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbA11yModule });
NbA11yModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbA11yModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();

class NbPortalDirective extends CdkPortal {
}
NbPortalDirective.ɵfac = function NbPortalDirective_Factory(t) { return ɵNbPortalDirective_BaseFactory(t || NbPortalDirective); };
NbPortalDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPortalDirective, selectors: [["", "nbPortal", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbPortalDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbPortalDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPortalDirective, [{
        type: Directive,
        args: [{ selector: '[nbPortal]' }]
    }], null, null); })();
class NbPortalOutletDirective extends CdkPortalOutlet {
}
NbPortalOutletDirective.ɵfac = function NbPortalOutletDirective_Factory(t) { return ɵNbPortalOutletDirective_BaseFactory(t || NbPortalOutletDirective); };
NbPortalOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPortalOutletDirective, selectors: [["", "nbPortalOutlet", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbPortalOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbPortalOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPortalOutletDirective, [{
        type: Directive,
        args: [{ selector: '[nbPortalOutlet]' }]
    }], null, null); })();
class NbComponentPortal extends ComponentPortal {
}
class NbOverlay extends Overlay {
}
NbOverlay.ɵfac = function NbOverlay_Factory(t) { return ɵNbOverlay_BaseFactory(t || NbOverlay); };
NbOverlay.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlay, factory: NbOverlay.ɵfac });
const ɵNbOverlay_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbOverlay);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlay, [{
        type: Injectable
    }], null, null); })();
class NbOverlayPositionBuilder extends OverlayPositionBuilder {
}
NbOverlayPositionBuilder.ɵfac = function NbOverlayPositionBuilder_Factory(t) { return ɵNbOverlayPositionBuilder_BaseFactory(t || NbOverlayPositionBuilder); };
NbOverlayPositionBuilder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayPositionBuilder, factory: NbOverlayPositionBuilder.ɵfac });
const ɵNbOverlayPositionBuilder_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbOverlayPositionBuilder);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayPositionBuilder, [{
        type: Injectable
    }], null, null); })();
class NbTemplatePortal extends TemplatePortal {
    constructor(template, viewContainerRef, context) {
        super(template, viewContainerRef, context);
    }
}
class NbOverlayContainer extends OverlayContainer {
}
NbOverlayContainer.ɵfac = function NbOverlayContainer_Factory(t) { return ɵNbOverlayContainer_BaseFactory(t || NbOverlayContainer); };
NbOverlayContainer.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayContainer, factory: NbOverlayContainer.ɵfac });
const ɵNbOverlayContainer_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbOverlayContainer);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayContainer, [{
        type: Injectable
    }], null, null); })();
class NbFlexibleConnectedPositionStrategy extends FlexibleConnectedPositionStrategy {
}
class NbPortalInjector extends PortalInjector {
}
const CDK_MODULES = [OverlayModule, PortalModule];
/**
 * This module helps us to keep all angular/cdk deps inside our cdk module via providing aliases.
 * Approach will help us move cdk in separate npm package and refactor nebular/theme code.
 * */
class NbCdkMappingModule {
    static forRoot() {
        return {
            ngModule: NbCdkMappingModule,
            providers: [
                NbOverlay,
                NbOverlayPositionBuilder,
            ],
        };
    }
}
NbCdkMappingModule.ɵfac = function NbCdkMappingModule_Factory(t) { return new (t || NbCdkMappingModule)(); };
NbCdkMappingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCdkMappingModule });
NbCdkMappingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[...CDK_MODULES], OverlayModule, PortalModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCdkMappingModule, { declarations: [NbPortalDirective, NbPortalOutletDirective], imports: [OverlayModule, PortalModule], exports: [OverlayModule, PortalModule, NbPortalDirective, NbPortalOutletDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCdkMappingModule, [{
        type: NgModule,
        args: [{
                imports: [...CDK_MODULES],
                exports: [
                    ...CDK_MODULES,
                    NbPortalDirective,
                    NbPortalOutletDirective,
                ],
                declarations: [NbPortalDirective, NbPortalOutletDirective]
            }]
    }], null, null); })();

class NbPlatform extends Platform {
}
NbPlatform.ɵfac = function NbPlatform_Factory(t) { return ɵNbPlatform_BaseFactory(t || NbPlatform); };
NbPlatform.ɵprov = ɵɵdefineInjectable({ factory: function NbPlatform_Factory() { return new Platform(ɵɵinject(PLATFORM_ID)); }, token: NbPlatform, providedIn: "root" });
const ɵNbPlatform_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbPlatform);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPlatform, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useClass: Platform
            }]
    }], null, null); })();

/**
 * Provides nb-layout as overlay container.
 * Container has to be cleared when layout destroys.
 * Another way previous version of the container will be used
 * but it isn't inserted in DOM and exists in memory only.
 * This case important only if you switch between multiple layouts.
 * */
class NbOverlayContainerAdapter extends NbOverlayContainer {
    setContainer(container) {
        this.container = container;
    }
    clearContainer() {
        this.container = null;
        this._containerElement = null;
    }
    _createContainer() {
        const container = this._document.createElement('div');
        container.classList.add('cdk-overlay-container');
        this.container.appendChild(container);
        this._containerElement = container;
    }
}
NbOverlayContainerAdapter.ɵfac = function NbOverlayContainerAdapter_Factory(t) { return ɵNbOverlayContainerAdapter_BaseFactory(t || NbOverlayContainerAdapter); };
NbOverlayContainerAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayContainerAdapter, factory: NbOverlayContainerAdapter.ɵfac });
const ɵNbOverlayContainerAdapter_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbOverlayContainerAdapter);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayContainerAdapter, [{
        type: Injectable
    }], null, null); })();

class NbViewportRulerAdapter extends ViewportRuler {
    constructor(platform, ngZone, ruler, scroll, document) {
        super(platform, ngZone, document);
        this.ruler = ruler;
        this.scroll = scroll;
    }
    getViewportSize() {
        let res;
        /*
        * getDimensions call is really synchronous operation.
        * And we have to conform with the interface of the original service.
        * */
        this.ruler.getDimensions()
            .pipe(map(dimensions => ({ width: dimensions.clientWidth, height: dimensions.clientHeight })))
            .subscribe(rect => res = rect);
        return res;
    }
    getViewportScrollPosition() {
        let res;
        /*
        * getPosition call is really synchronous operation.
        * And we have to conform with the interface of the original service.
        * */
        this.scroll.getPosition()
            .pipe(map((position) => ({ top: position.y, left: position.x })))
            .subscribe(position => res = position);
        return res;
    }
}
NbViewportRulerAdapter.ɵfac = function NbViewportRulerAdapter_Factory(t) { return new (t || NbViewportRulerAdapter)(ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbLayoutRulerService), ɵngcc0.ɵɵinject(NbLayoutScrollService), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbViewportRulerAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbViewportRulerAdapter, factory: NbViewportRulerAdapter.ɵfac });
NbViewportRulerAdapter.ctorParameters = () => [
    { type: NbPlatform },
    { type: NgZone },
    { type: NbLayoutRulerService },
    { type: NbLayoutScrollService },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbViewportRulerAdapter, [{
        type: Injectable
    }], function () { return [{ type: NbPlatform }, { type: ɵngcc0.NgZone }, { type: NbLayoutRulerService }, { type: NbLayoutScrollService }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

var NbGlobalLogicalPosition;
(function (NbGlobalLogicalPosition) {
    NbGlobalLogicalPosition["TOP_START"] = "top-start";
    NbGlobalLogicalPosition["TOP_END"] = "top-end";
    NbGlobalLogicalPosition["BOTTOM_START"] = "bottom-start";
    NbGlobalLogicalPosition["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function (NbGlobalPhysicalPosition) {
    NbGlobalPhysicalPosition["TOP_RIGHT"] = "top-right";
    NbGlobalPhysicalPosition["TOP_LEFT"] = "top-left";
    NbGlobalPhysicalPosition["BOTTOM_RIGHT"] = "bottom-right";
    NbGlobalPhysicalPosition["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
class NbPositionHelper {
    constructor(layoutDirection) {
        this.layoutDirection = layoutDirection;
    }
    toLogicalPosition(position) {
        if (Object.values(NbGlobalLogicalPosition).includes(position)) {
            return position;
        }
        if (this.layoutDirection.isLtr()) {
            return this.toLogicalPositionWhenLtr(position);
        }
        else {
            return this.toLogicalPositionWhenRtl(position);
        }
    }
    toPhysicalPosition(position) {
        if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
            return position;
        }
        if (this.layoutDirection.isLtr()) {
            return this.toPhysicalPositionWhenLtr(position);
        }
        else {
            return this.toPhysicalPositionWhenRtl(position);
        }
    }
    isTopPosition(position) {
        const logicalPosition = this.toLogicalPosition(position);
        return logicalPosition === NbGlobalLogicalPosition.TOP_END
            || logicalPosition === NbGlobalLogicalPosition.TOP_START;
    }
    isRightPosition(position) {
        const physicalPosition = this.toPhysicalPosition(position);
        return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT
            || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
    toLogicalPositionWhenLtr(position) {
        switch (position) {
            case NbGlobalPhysicalPosition.TOP_RIGHT:
                return NbGlobalLogicalPosition.TOP_END;
            case NbGlobalPhysicalPosition.TOP_LEFT:
                return NbGlobalLogicalPosition.TOP_START;
            case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
                return NbGlobalLogicalPosition.BOTTOM_END;
            case NbGlobalPhysicalPosition.BOTTOM_LEFT:
                return NbGlobalLogicalPosition.BOTTOM_START;
        }
    }
    toLogicalPositionWhenRtl(position) {
        switch (position) {
            case NbGlobalPhysicalPosition.TOP_RIGHT:
                return NbGlobalLogicalPosition.TOP_START;
            case NbGlobalPhysicalPosition.TOP_LEFT:
                return NbGlobalLogicalPosition.TOP_END;
            case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
                return NbGlobalLogicalPosition.BOTTOM_START;
            case NbGlobalPhysicalPosition.BOTTOM_LEFT:
                return NbGlobalLogicalPosition.BOTTOM_END;
        }
    }
    toPhysicalPositionWhenLtr(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return NbGlobalPhysicalPosition.TOP_LEFT;
            case NbGlobalLogicalPosition.TOP_END:
                return NbGlobalPhysicalPosition.TOP_RIGHT;
            case NbGlobalLogicalPosition.BOTTOM_START:
                return NbGlobalPhysicalPosition.BOTTOM_LEFT;
            case NbGlobalLogicalPosition.BOTTOM_END:
                return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
        }
    }
    toPhysicalPositionWhenRtl(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return NbGlobalPhysicalPosition.TOP_RIGHT;
            case NbGlobalLogicalPosition.TOP_END:
                return NbGlobalPhysicalPosition.TOP_LEFT;
            case NbGlobalLogicalPosition.BOTTOM_START:
                return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
            case NbGlobalLogicalPosition.BOTTOM_END:
                return NbGlobalPhysicalPosition.BOTTOM_LEFT;
        }
    }
}
NbPositionHelper.ɵfac = function NbPositionHelper_Factory(t) { return new (t || NbPositionHelper)(ɵngcc0.ɵɵinject(NbLayoutDirectionService)); };
NbPositionHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbPositionHelper, factory: NbPositionHelper.ɵfac });
NbPositionHelper.ctorParameters = () => [
    { type: NbLayoutDirectionService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPositionHelper, [{
        type: Injectable
    }], function () { return [{ type: NbLayoutDirectionService }]; }, null); })();

var NbAdjustment;
(function (NbAdjustment) {
    NbAdjustment["NOOP"] = "noop";
    NbAdjustment["CLOCKWISE"] = "clockwise";
    NbAdjustment["COUNTERCLOCKWISE"] = "counterclockwise";
    NbAdjustment["VERTICAL"] = "vertical";
    NbAdjustment["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function (NbPosition) {
    NbPosition["TOP"] = "top";
    NbPosition["BOTTOM"] = "bottom";
    NbPosition["LEFT"] = "left";
    NbPosition["RIGHT"] = "right";
    NbPosition["START"] = "start";
    NbPosition["END"] = "end";
    NbPosition["TOP_END"] = "top-end";
    NbPosition["TOP_START"] = "top-start";
    NbPosition["BOTTOM_END"] = "bottom-end";
    NbPosition["BOTTOM_START"] = "bottom-start";
    NbPosition["END_TOP"] = "end-top";
    NbPosition["END_BOTTOM"] = "end-bottom";
    NbPosition["START_TOP"] = "start-top";
    NbPosition["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
const POSITIONS = {
    [NbPosition.RIGHT](offset) {
        return { originX: 'end', originY: 'center', overlayX: 'start', overlayY: 'center', offsetX: offset };
    },
    [NbPosition.BOTTOM](offset) {
        return { originX: 'center', originY: 'bottom', overlayX: 'center', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.LEFT](offset) {
        return { originX: 'start', originY: 'center', overlayX: 'end', overlayY: 'center', offsetX: -offset };
    },
    [NbPosition.TOP](offset) {
        return { originX: 'center', originY: 'top', overlayX: 'center', overlayY: 'bottom', offsetY: -offset };
    },
    [NbPosition.START](offset) {
        return this[NbPosition.LEFT](offset);
    },
    [NbPosition.END](offset) {
        return this[NbPosition.RIGHT](offset);
    },
    [NbPosition.END_TOP](offset) {
        return { originX: 'end', originY: 'bottom', overlayX: 'start', overlayY: 'bottom', offsetX: offset };
    },
    [NbPosition.END_BOTTOM](offset) {
        return { originX: 'end', originY: 'top', overlayX: 'start', overlayY: 'top', offsetX: offset };
    },
    [NbPosition.BOTTOM_START](offset) {
        return { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.BOTTOM_END](offset) {
        return { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.START_TOP](offset) {
        return { originX: 'start', originY: 'bottom', overlayX: 'end', overlayY: 'bottom', offsetX: -offset };
    },
    [NbPosition.START_BOTTOM](offset) {
        return { originX: 'start', originY: 'top', overlayX: 'end', overlayY: 'top', offsetX: -offset };
    },
    [NbPosition.TOP_START](offset) {
        return { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', offsetY: -offset };
    },
    [NbPosition.TOP_END](offset) {
        return { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', offsetY: -offset };
    },
};
const COUNTER_CLOCKWISE_POSITIONS = [
    NbPosition.TOP,
    NbPosition.TOP_END,
    NbPosition.TOP_START,
    NbPosition.START,
    NbPosition.START_TOP,
    NbPosition.START_BOTTOM,
    NbPosition.BOTTOM,
    NbPosition.BOTTOM_START,
    NbPosition.BOTTOM_END,
    NbPosition.END,
    NbPosition.END_BOTTOM,
    NbPosition.END_TOP,
];
const CLOCKWISE_POSITIONS = [
    NbPosition.TOP,
    NbPosition.TOP_START,
    NbPosition.TOP_END,
    NbPosition.END,
    NbPosition.END_TOP,
    NbPosition.END_BOTTOM,
    NbPosition.BOTTOM,
    NbPosition.BOTTOM_END,
    NbPosition.BOTTOM_START,
    NbPosition.START,
    NbPosition.START_BOTTOM,
    NbPosition.START_TOP,
];
const VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
const HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
    return p1.originX === p2.originX
        && p1.originY === p2.originY
        && p1.overlayX === p2.overlayX
        && p1.overlayY === p2.overlayY;
}
/**
 * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.
 * You have to provide adjustment and appropriate strategy will be chosen in runtime.
 * */
class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy {
    constructor() {
        super(...arguments);
        this._offset = 15;
        this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
            return this.appliedPositions.find(({ connectedPosition }) => {
                return comparePositions(connectedPosition, connectionPair);
            }).key;
        }));
    }
    attach(overlayRef) {
        /**
         * We have to apply positions before attach because super.attach() validates positions and crashes app
         * if no positions provided.
         * */
        this.applyPositions();
        super.attach(overlayRef);
    }
    apply() {
        this.applyPositions();
        super.apply();
    }
    position(position) {
        this._position = position;
        return this;
    }
    adjustment(adjustment) {
        this._adjustment = adjustment;
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    applyPositions() {
        const positions = this.createPositions();
        this.persistChosenPositions(positions);
        this.withPositions(this.appliedPositions.map(({ connectedPosition }) => connectedPosition));
    }
    createPositions() {
        switch (this._adjustment) {
            case NbAdjustment.NOOP:
                return [this._position];
            case NbAdjustment.CLOCKWISE:
                return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
            case NbAdjustment.COUNTERCLOCKWISE:
                return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
            case NbAdjustment.HORIZONTAL:
                return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
            case NbAdjustment.VERTICAL:
                return this.reorderPreferredPositions(VERTICAL_POSITIONS);
        }
    }
    persistChosenPositions(positions) {
        this.appliedPositions = positions.map(position => ({
            key: position,
            connectedPosition: POSITIONS[position](this._offset),
        }));
    }
    reorderPreferredPositions(positions) {
        // Physical positions should be mapped to logical as adjustments use logical positions.
        const startPositionIndex = positions.indexOf(this.mapToLogicalPosition(this._position));
        const firstPart = positions.slice(startPositionIndex);
        const secondPart = positions.slice(0, startPositionIndex);
        return firstPart.concat(secondPart);
    }
    mapToLogicalPosition(position) {
        if (position === NbPosition.LEFT) {
            return NbPosition.START;
        }
        if (position === NbPosition.RIGHT) {
            return NbPosition.END;
        }
        return position;
    }
}
class NbGlobalPositionStrategy extends GlobalPositionStrategy {
    position(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return this.top().left();
            case NbGlobalLogicalPosition.TOP_END:
                return this.top().right();
            case NbGlobalLogicalPosition.BOTTOM_START:
                return this.bottom().left();
            case NbGlobalLogicalPosition.BOTTOM_END:
                return this.bottom().right();
        }
    }
}
class NbPositionBuilderService {
    constructor(document, viewportRuler, platform, positionBuilder, overlayContainer) {
        this.document = document;
        this.viewportRuler = viewportRuler;
        this.platform = platform;
        this.positionBuilder = positionBuilder;
        this.overlayContainer = overlayContainer;
    }
    global() {
        return new NbGlobalPositionStrategy();
    }
    connectedTo(elementRef) {
        return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer)
            .withFlexibleDimensions(false)
            .withPush(false);
    }
}
NbPositionBuilderService.ɵfac = function NbPositionBuilderService_Factory(t) { return new (t || NbPositionBuilderService)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(NbOverlayPositionBuilder), ɵngcc0.ɵɵinject(NbOverlayContainerAdapter)); };
NbPositionBuilderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbPositionBuilderService, factory: NbPositionBuilderService.ɵfac });
NbPositionBuilderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbViewportRulerAdapter },
    { type: NbPlatform },
    { type: NbOverlayPositionBuilder },
    { type: NbOverlayContainerAdapter }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPositionBuilderService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbViewportRulerAdapter }, { type: NbPlatform }, { type: NbOverlayPositionBuilder }, { type: NbOverlayContainerAdapter }]; }, null); })();

class NbPositionedContainerComponent {
    get top() {
        return this.position === NbPosition.TOP;
    }
    get topStart() {
        return this.position === NbPosition.TOP_START;
    }
    get topEnd() {
        return this.position === NbPosition.TOP_END;
    }
    get right() {
        return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
    }
    get endTop() {
        return this.position === NbPosition.END_TOP;
    }
    get endBottom() {
        return this.position === NbPosition.END_BOTTOM;
    }
    get bottom() {
        return this.position === NbPosition.BOTTOM;
    }
    get bottomStart() {
        return this.position === NbPosition.BOTTOM_START;
    }
    get bottomEnd() {
        return this.position === NbPosition.BOTTOM_END;
    }
    get left() {
        return this.position === NbPosition.LEFT || this.position === NbPosition.START;
    }
    get startTop() {
        return this.position === NbPosition.START_TOP;
    }
    get startBottom() {
        return this.position === NbPosition.START_BOTTOM;
    }
}
NbPositionedContainerComponent.ɵfac = function NbPositionedContainerComponent_Factory(t) { return new (t || NbPositionedContainerComponent)(); };
NbPositionedContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbPositionedContainerComponent, selectors: [["ng-component"]], hostVars: 24, hostBindings: function NbPositionedContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
    } }, inputs: { position: "position" }, decls: 0, vars: 0, template: function NbPositionedContainerComponent_Template(rf, ctx) { }, encapsulation: 2 });
NbPositionedContainerComponent.propDecorators = {
    position: [{ type: Input }],
    top: [{ type: HostBinding, args: ['class.nb-overlay-top',] }],
    topStart: [{ type: HostBinding, args: ['class.nb-overlay-top-start',] }],
    topEnd: [{ type: HostBinding, args: ['class.nb-overlay-top-end',] }],
    right: [{ type: HostBinding, args: ['class.nb-overlay-right',] }],
    endTop: [{ type: HostBinding, args: ['class.nb-overlay-end-top',] }],
    endBottom: [{ type: HostBinding, args: ['class.nb-overlay-end-bottom',] }],
    bottom: [{ type: HostBinding, args: ['class.nb-overlay-bottom',] }],
    bottomStart: [{ type: HostBinding, args: ['class.nb-overlay-bottom-start',] }],
    bottomEnd: [{ type: HostBinding, args: ['class.nb-overlay-bottom-end',] }],
    left: [{ type: HostBinding, args: ['class.nb-overlay-left',] }],
    startTop: [{ type: HostBinding, args: ['class.nb-overlay-start-top',] }],
    startBottom: [{ type: HostBinding, args: ['class.nb-overlay-start-bottom',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPositionedContainerComponent, [{
        type: Component,
        args: [{
                template: ''
            }]
    }], null, { top: [{
            type: HostBinding,
            args: ['class.nb-overlay-top']
        }], topStart: [{
            type: HostBinding,
            args: ['class.nb-overlay-top-start']
        }], topEnd: [{
            type: HostBinding,
            args: ['class.nb-overlay-top-end']
        }], right: [{
            type: HostBinding,
            args: ['class.nb-overlay-right']
        }], endTop: [{
            type: HostBinding,
            args: ['class.nb-overlay-end-top']
        }], endBottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-end-bottom']
        }], bottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom']
        }], bottomStart: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom-start']
        }], bottomEnd: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom-end']
        }], left: [{
            type: HostBinding,
            args: ['class.nb-overlay-left']
        }], startTop: [{
            type: HostBinding,
            args: ['class.nb-overlay-start-top']
        }], startBottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-start-bottom']
        }], position: [{
            type: Input
        }] }); })();
class NbOverlayContainerComponent {
    constructor(vcr, injector, changeDetectorRef) {
        this.vcr = vcr;
        this.injector = injector;
        this.changeDetectorRef = changeDetectorRef;
        this.isAttached = false;
    }
    get isStringContent() {
        return !!this.content;
    }
    attachComponentPortal(portal, context) {
        portal.injector = this.createChildInjector(portal.componentFactoryResolver);
        const componentRef = this.portalOutlet.attachComponentPortal(portal);
        if (context) {
            Object.assign(componentRef.instance, context);
        }
        componentRef.changeDetectorRef.markForCheck();
        componentRef.changeDetectorRef.detectChanges();
        this.isAttached = true;
        return componentRef;
    }
    attachTemplatePortal(portal) {
        const templateRef = this.portalOutlet.attachTemplatePortal(portal);
        templateRef.detectChanges();
        this.isAttached = true;
        return templateRef;
    }
    attachStringContent(content) {
        this.content = content;
        this.changeDetectorRef.markForCheck();
        this.changeDetectorRef.detectChanges();
        this.isAttached = true;
    }
    detach() {
        if (this.portalOutlet.hasAttached()) {
            this.portalOutlet.detach();
        }
        this.attachStringContent(null);
        this.isAttached = false;
    }
    createChildInjector(cfr) {
        return new NbPortalInjector(this.injector, new WeakMap([
            [ComponentFactoryResolver, cfr],
        ]));
    }
}
NbOverlayContainerComponent.ɵfac = function NbOverlayContainerComponent_Factory(t) { return new (t || NbOverlayContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbOverlayContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOverlayContainerComponent, selectors: [["nb-overlay-container"]], viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalOutletDirective, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, decls: 2, vars: 1, consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]], template: function NbOverlayContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isStringContent);
    } }, directives: [ɵngcc2.NgIf, NbPortalOutletDirective], encapsulation: 2 });
NbOverlayContainerComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: ChangeDetectorRef }
];
NbOverlayContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [NbPortalOutletDirective, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-overlay-container',
                template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [NbPortalOutletDirective, { static: true }]
        }] }); })();

function patch(container, containerContext) {
    Object.assign(container.instance, containerContext);
    container.changeDetectorRef.detectChanges();
    return container;
}
function createContainer(ref, container, context, componentFactoryResolver) {
    const containerRef = ref.attach(new NbComponentPortal(container, null, null, componentFactoryResolver));
    patch(containerRef, context);
    return containerRef;
}
class NbOverlayService {
    constructor(overlay, layoutDirection) {
        this.overlay = overlay;
        this.layoutDirection = layoutDirection;
    }
    get scrollStrategies() {
        return this.overlay.scrollStrategies;
    }
    create(config) {
        const overlayRef = this.overlay.create(config);
        this.layoutDirection.onDirectionChange()
            .subscribe(dir => overlayRef.setDirection(dir));
        return overlayRef;
    }
}
NbOverlayService.ɵfac = function NbOverlayService_Factory(t) { return new (t || NbOverlayService)(ɵngcc0.ɵɵinject(NbOverlay), ɵngcc0.ɵɵinject(NbLayoutDirectionService)); };
NbOverlayService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayService, factory: NbOverlayService.ɵfac });
NbOverlayService.ctorParameters = () => [
    { type: NbOverlay },
    { type: NbLayoutDirectionService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayService, [{
        type: Injectable
    }], function () { return [{ type: NbOverlay }, { type: NbLayoutDirectionService }]; }, null); })();

class NbScrollDispatcherAdapter extends ScrollDispatcher {
    constructor(ngZone, platform, scrollService, document) {
        super(ngZone, platform, document);
        this.scrollService = scrollService;
    }
    scrolled(auditTimeInMs) {
        return this.scrollService.onScroll();
    }
}
NbScrollDispatcherAdapter.ɵfac = function NbScrollDispatcherAdapter_Factory(t) { return new (t || NbScrollDispatcherAdapter)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(NbLayoutScrollService), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbScrollDispatcherAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbScrollDispatcherAdapter, factory: NbScrollDispatcherAdapter.ɵfac });
NbScrollDispatcherAdapter.ctorParameters = () => [
    { type: NgZone },
    { type: NbPlatform },
    { type: NbLayoutScrollService },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbScrollDispatcherAdapter, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: NbPlatform }, { type: NbLayoutScrollService }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

/**
 * Overrides default block scroll strategy because default strategy blocks scrolling on the body only.
 * But Nebular has its own scrollable container - nb-layout. So, we need to block scrolling in it to.
 * */
class NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
    constructor(document, viewportRuler, scrollService) {
        super(viewportRuler, document);
        this.scrollService = scrollService;
    }
    enable() {
        super.enable();
        this.scrollService.scrollable(false);
    }
    disable() {
        super.disable();
        this.scrollService.scrollable(true);
    }
}
NbBlockScrollStrategyAdapter.ɵfac = function NbBlockScrollStrategyAdapter_Factory(t) { return new (t || NbBlockScrollStrategyAdapter)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(NbLayoutScrollService)); };
NbBlockScrollStrategyAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbBlockScrollStrategyAdapter, factory: NbBlockScrollStrategyAdapter.ɵfac });
NbBlockScrollStrategyAdapter.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbViewportRulerAdapter },
    { type: NbLayoutScrollService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBlockScrollStrategyAdapter, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbViewportRulerAdapter }, { type: NbLayoutScrollService }]; }, null); })();
class NbScrollStrategyOptions extends ScrollStrategyOptions {
    constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document) {
        super(scrollDispatcher, viewportRuler, ngZone, document);
        this.scrollService = scrollService;
        this.scrollDispatcher = scrollDispatcher;
        this.viewportRuler = viewportRuler;
        this.ngZone = ngZone;
        this.document = document;
        this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
    }
}
NbScrollStrategyOptions.ɵfac = function NbScrollStrategyOptions_Factory(t) { return new (t || NbScrollStrategyOptions)(ɵngcc0.ɵɵinject(NbLayoutScrollService), ɵngcc0.ɵɵinject(ɵngcc3.ScrollDispatcher), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbScrollStrategyOptions.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbScrollStrategyOptions, factory: NbScrollStrategyOptions.ɵfac });
NbScrollStrategyOptions.ctorParameters = () => [
    { type: NbLayoutScrollService },
    { type: ScrollDispatcher },
    { type: NbViewportRulerAdapter },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbScrollStrategyOptions, [{
        type: Injectable
    }], function () { return [{ type: NbLayoutScrollService }, { type: ɵngcc3.ScrollDispatcher }, { type: NbViewportRulerAdapter }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

class NbCdkAdapterModule {
    static forRoot() {
        return {
            ngModule: NbCdkAdapterModule,
            providers: [
                NbViewportRulerAdapter,
                NbOverlayContainerAdapter,
                NbBlockScrollStrategyAdapter,
                NbScrollDispatcherAdapter,
                NbScrollStrategyOptions,
                { provide: OverlayContainer, useExisting: NbOverlayContainerAdapter },
                { provide: NbOverlayContainer, useExisting: NbOverlayContainerAdapter },
                { provide: ScrollDispatcher, useExisting: NbScrollDispatcherAdapter },
                { provide: ScrollStrategyOptions, useExisting: NbScrollStrategyOptions },
            ],
        };
    }
}
NbCdkAdapterModule.ɵfac = function NbCdkAdapterModule_Factory(t) { return new (t || NbCdkAdapterModule)(); };
NbCdkAdapterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCdkAdapterModule });
NbCdkAdapterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCdkAdapterModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();

var NbTrigger;
(function (NbTrigger) {
    NbTrigger["NOOP"] = "noop";
    NbTrigger["CLICK"] = "click";
    NbTrigger["HOVER"] = "hover";
    NbTrigger["HINT"] = "hint";
    NbTrigger["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
/**
 * TODO maybe we have to use renderer.listen instead of observableFromEvent?
 * Renderer provides capability use it in service worker, ssr and so on.
 * */
class NbTriggerStrategyBase {
    constructor(document, host, container) {
        this.document = document;
        this.host = host;
        this.container = container;
        this.destroyed$ = new Subject();
    }
    destroy() {
        this.destroyed$.next();
    }
    isNotOnHostOrContainer(event) {
        return !this.isOnHost(event) && !this.isOnContainer(event);
    }
    isOnHostOrContainer(event) {
        return this.isOnHost(event) || this.isOnContainer(event);
    }
    isOnHost({ target }) {
        return this.host.contains(target);
    }
    isOnContainer({ target }) {
        return this.container() && this.container().location.nativeElement.contains(target);
    }
}
/**
 * Creates show and hide event streams.
 * Fires toggle event when the click was performed on the host element.
 * Fires close event when the click was performed on the document but
 * not on the host or container.
 * */
class NbClickTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        // since we should track click for both SHOW and HIDE event we firstly need to track the click and the state
        // of the container and then later on decide should we hide it or show
        // if we track the click & state separately this will case a behavior when the container is getting shown
        // and then hidden right away
        this.click$ = fromEvent(this.document, 'click')
            .pipe(map((event) => [!this.container() && this.isOnHost(event), event]), share(), takeUntil(this.destroyed$));
        this.show$ = this.click$
            .pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
        this.hide$ = this.click$
            .pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event)), map(([, event]) => event), takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element and stops out of the host and popover container.
 * */
class NbHoverTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = fromEvent(this.host, 'mouseenter')
            .pipe(filter(() => !this.container()), 
        // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
        // meaning that if one event occurs in some time after the initial one we won't react to it
        delay(100), 
        // tslint:disable-next-line:rxjs-no-unsafe-takeuntil
        takeUntil(fromEvent(this.host, 'mouseleave')), repeat(), takeUntil(this.destroyed$));
        this.hide$ = fromEvent(this.host, 'mouseleave')
            .pipe(switchMap(() => fromEvent(this.document, 'mousemove')
            .pipe(debounceTime(100), takeWhile(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)))), takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element.
 * */
class NbHintTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = fromEvent(this.host, 'mouseenter')
            .pipe(
        // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
        // meaning that if one event occurs in some time after the initial one we won't react to it
        delay(100), 
        // tslint:disable-next-line:rxjs-no-unsafe-takeuntil
        takeUntil(fromEvent(this.host, 'mouseleave')), repeat(), takeUntil(this.destroyed$));
        this.hide$ = fromEvent(this.host, 'mouseleave')
            .pipe(takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.
 * Fires close event when the focus leaves the host element.
 * */
class NbFocusTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.focusOut$ = fromEvent(this.host, 'focusout')
            .pipe(switchMap(() => fromEvent(this.document, 'focusin')
            .pipe(takeWhile(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)))), takeUntil(this.destroyed$));
        this.clickIn$ = fromEvent(this.host, 'click')
            .pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
        this.clickOut$ = fromEvent(this.document, 'click')
            .pipe(filter(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)), takeUntil(this.destroyed$));
        this.tabKeyPress$ = fromEvent(this.document, 'keydown')
            .pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
        this.show$ = merge(fromEvent(this.host, 'focusin'), this.clickIn$)
            .pipe(filter(() => !this.container()), debounceTime(100), 
        // tslint:disable-next-line:rxjs-no-unsafe-takeuntil
        takeUntil(fromEvent(this.host, 'focusout')), repeat(), takeUntil(this.destroyed$));
        this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$)
            .pipe(takeUntil(this.destroyed$));
    }
}
/**
 * Creates empty show and hide event streams.
 * */
class NbNoopTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = EMPTY;
        this.hide$ = EMPTY;
    }
}
class NbTriggerStrategyBuilderService {
    constructor(_document) {
        this._document = _document;
    }
    trigger(trigger$$1) {
        this._trigger = trigger$$1;
        return this;
    }
    host(host) {
        this._host = host;
        return this;
    }
    container(container) {
        this._container = container;
        return this;
    }
    build() {
        switch (this._trigger) {
            case NbTrigger.CLICK:
                return new NbClickTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.HINT:
                return new NbHintTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.HOVER:
                return new NbHoverTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.FOCUS:
                return new NbFocusTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.NOOP:
                return new NbNoopTriggerStrategy(this._document, this._host, this._container);
            default:
                throw new Error('Trigger have to be provided');
        }
    }
}
NbTriggerStrategyBuilderService.ɵfac = function NbTriggerStrategyBuilderService_Factory(t) { return new (t || NbTriggerStrategyBuilderService)(ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbTriggerStrategyBuilderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTriggerStrategyBuilderService, factory: NbTriggerStrategyBuilderService.ɵfac });
NbTriggerStrategyBuilderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTriggerStrategyBuilderService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

class NbOverlayModule {
    static forRoot() {
        return {
            ngModule: NbOverlayModule,
            providers: [
                NbPositionBuilderService,
                NbTriggerStrategyBuilderService,
                NbOverlayService,
                NbPositionHelper,
                ...NbCdkMappingModule.forRoot().providers,
                ...NbCdkAdapterModule.forRoot().providers,
                ...NbA11yModule.forRoot().providers,
            ],
        };
    }
}
NbOverlayModule.ɵfac = function NbOverlayModule_Factory(t) { return new (t || NbOverlayModule)(); };
NbOverlayModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbOverlayModule });
NbOverlayModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbCdkMappingModule,
            NbSharedModule,
        ], NbCdkMappingModule, NbCdkAdapterModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbOverlayModule, { declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent], imports: [NbCdkMappingModule, NbSharedModule], exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOverlayModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbCdkMappingModule,
                    NbSharedModule,
                ],
                declarations: [
                    NbPositionedContainerComponent,
                    NbOverlayContainerComponent,
                ],
                exports: [
                    NbCdkMappingModule,
                    NbCdkAdapterModule,
                    NbOverlayContainerComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbStatusService {
    constructor() {
        this.coreStatuses = ['basic', 'primary', 'info', 'warning', 'danger', 'control'];
    }
    isCoreStatus(status) {
        return this.coreStatuses.includes(status);
    }
    isCustomStatus(status) {
        if (this.isValidStatusString(status)) {
            return !this.isCoreStatus(status);
        }
        return false;
    }
    getStatusClass(status) {
        if (this.isValidStatusString(status)) {
            return `status-${status}`;
        }
        return undefined;
    }
    isValidStatusString(status) {
        return typeof status === 'string' && status.length > 0;
    }
}
NbStatusService.ɵfac = function NbStatusService_Factory(t) { return new (t || NbStatusService)(); };
NbStatusService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbStatusService, factory: NbStatusService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStatusService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function windowFactory(platformId) {
    if (isPlatformBrowser(platformId)) {
        return window;
    }
    // Provide undefined to get the error when trying to access the window as it
    // shouldn't be used outside the browser. Those who need to provide something
    // instead of window (e.g. domino window when running in node) could override
    // NB_WINDOW token.
    return undefined;
}
class NbThemeModule {
    // TODO: check the options (throw exception?)
    /**
     * Main Theme Module
     *
     * @param nbThemeOptions {NbThemeOptions} Main theme options
     * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
     * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
     * @param layoutDirection {NbLayoutDirection} Layout direction
     *
     * @returns {ModuleWithProviders}
     */
    static forRoot(nbThemeOptions = { name: 'default' }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
        return {
            ngModule: NbThemeModule,
            providers: [
                { provide: NB_THEME_OPTIONS, useValue: nbThemeOptions || {} },
                { provide: NB_BUILT_IN_JS_THEMES, useValue: BUILT_IN_THEMES },
                { provide: NB_JS_THEMES, useValue: nbJSThemes || [] },
                { provide: NB_MEDIA_BREAKPOINTS, useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS },
                { provide: NB_DOCUMENT, useExisting: DOCUMENT },
                { provide: NB_WINDOW, useFactory: windowFactory, deps: [PLATFORM_ID] },
                NbJSThemesRegistry,
                NbThemeService,
                NbMediaBreakpointsService,
                NbSpinnerService,
                { provide: NB_LAYOUT_DIRECTION, useValue: layoutDirection || NbLayoutDirection.LTR },
                NbLayoutDirectionService,
                NbLayoutScrollService,
                NbLayoutRulerService,
                ...NbOverlayModule.forRoot().providers,
                NbStatusService,
            ],
        };
    }
}
NbThemeModule.ɵfac = function NbThemeModule_Factory(t) { return new (t || NbThemeModule)(); };
NbThemeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbThemeModule });
NbThemeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbThemeModule, { imports: function () { return [CommonModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbThemeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                exports: []
            }]
    }], null, null); })();

class NbColorHelper {
    static shade(color, weight) {
        return NbColorHelper.mix('#000000', color, weight);
    }
    static tint(color, weight) {
        return NbColorHelper.mix('#ffffff', color, weight);
    }
    static mix(color1, color2, weight) {
        const d2h = (d) => d.toString(16);
        const h2d = (h) => parseInt(h, 16);
        let result = '#';
        for (let i = 1; i < 7; i += 2) {
            const firstPart = h2d(color1.substr(i, 2));
            const secondPart = h2d(color2.substr(i, 2));
            const resultPart = d2h(Math.floor(secondPart + (firstPart - secondPart) * (weight / 100.0)));
            result += ('0' + resultPart).slice(-2);
        }
        return result;
    }
    static hexToRgbA(hex, alpha) {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
        }
        throw new Error('Bad Hex');
    }
}

var NbIconPackType;
(function (NbIconPackType) {
    NbIconPackType["SVG"] = "svg";
    NbIconPackType["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));

class NbFontIcon {
    constructor(name, content, params = {}) {
        this.name = name;
        this.content = content;
        this.params = params;
    }
    getClasses(options) {
        const classes = [];
        if (this.params.packClass) {
            classes.push(this.params.packClass);
        }
        const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
        classes.push(name);
        return classes;
    }
    getContent(options) {
        return this.content;
    }
}
class NbSvgIcon {
    constructor(name, content, params = {}) {
        this.name = name;
        this.content = content;
        this.params = params;
    }
    getClasses(options) {
        const classes = [];
        if (this.params.packClass) {
            classes.push(this.params.packClass);
        }
        return classes;
    }
    getContent(options) {
        return this.content;
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbIconDefinition {
}
function throwPackNotFoundError(name) {
    throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
    throw Error('Default pack is not registered.');
}
function throwWrongPackTypeError(name, type, desiredType) {
    throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
/**
 * This service allows to register multiple icon packs to use them later within `<nb-icon></nb-icon>` component.
 */
class NbIconLibraries {
    constructor() {
        this.packs = new Map();
    }
    /**
     * Registers new Svg icon pack
     * @param {string} name
     * @param {NbIcon} icons
     * @param {NbIconPackParams} params
     */
    registerSvgPack(name, icons, params = {}) {
        this.packs.set(name, {
            name,
            icons: new Map(Object.entries(icons)),
            params,
            type: NbIconPackType.SVG,
        });
    }
    /**
     * Registers new font pack
     * @param {string} name
     * @param {NbIconPackParams} params
     */
    registerFontPack(name, params = {}) {
        this.packs.set(name, {
            name,
            params,
            icons: new Map(),
            type: NbIconPackType.FONT,
        });
    }
    /**
     * Returns pack by name
     * @param {string} name
     */
    getPack(name) {
        return this.packs.get(name);
    }
    /**
     * Sets pack as a default
     * @param {string} name
     */
    setDefaultPack(name) {
        if (!this.packs.has(name)) {
            throwPackNotFoundError(name);
        }
        this.defaultPack = this.packs.get(name);
    }
    /**
     * Returns Svg icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getSvgIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type !== NbIconPackType.SVG) {
            throwWrongPackTypeError(iconsPack.name, iconsPack.type, 'SVG');
        }
        const icon = this.getIconFromPack(name, iconsPack);
        if (!icon) {
            return null;
        }
        return {
            name,
            pack: iconsPack.name,
            type: NbIconPackType.SVG,
            icon: this.createSvgIcon(name, icon, iconsPack.params),
        };
    }
    /**
     * Returns Font icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getFontIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type !== NbIconPackType.FONT) {
            throwWrongPackTypeError(iconsPack.name, iconsPack.type, 'Font');
        }
        const icon = this.getIconFromPack(name, iconsPack);
        return {
            name,
            pack: iconsPack.name,
            type: NbIconPackType.FONT,
            icon: this.createFontIcon(name, icon ? icon : '', iconsPack.params),
        };
    }
    /**
     * Returns an icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type === NbIconPackType.SVG) {
            return this.getSvgIcon(name, pack);
        }
        return this.getFontIcon(name, pack);
    }
    createSvgIcon(name, content, params) {
        return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
    }
    createFontIcon(name, content, params) {
        return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
    }
    getPackOrThrow(name) {
        const pack = this.packs.get(name);
        if (!pack) {
            throwPackNotFoundError(name);
        }
        return pack;
    }
    getDefaultPackOrThrow() {
        if (!this.defaultPack) {
            throwNoDefaultPackError();
        }
        return this.defaultPack;
    }
    getIconFromPack(name, pack) {
        if (pack.icons.has(name)) {
            return pack.icons.get(name);
        }
        return null;
    }
}
NbIconLibraries.ɵfac = function NbIconLibraries_Factory(t) { return new (t || NbIconLibraries)(); };
NbIconLibraries.ɵprov = ɵɵdefineInjectable({ factory: function NbIconLibraries_Factory() { return new NbIconLibraries(); }, token: NbIconLibraries, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbIconLibraries, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Icon component. Allows to render both `svg` and `font` icons.
 * Starting from Nebular 4.0 uses [Eva Icons](https://akveo.github.io/eva-icons/) pack by default.
 *
 * Basic icon example:
 * @stacked-example(Showcase, icon/icon-showcase.component)
 *
 * Icon configuration:
 *
 * ```html
 * <nb-icon icon="star"></nb-icon>
 * ```
 * ### Installation
 *
 * By default Nebular comes without any pre-installed icon pack.
 * Starting with Nebular 4.0.0 we ship separate package called `@nebular/eva-icons`
 * which integrates SVG [Eva Icons](https://akveo.github.io/eva-icons/) pack to Nebular. To add it to your
 * project run:
 * ```sh
 * npm i eva-icons @nebular/eva-icons
 * ```
 * This command will install Eva Icons pack. Then register `NbEvaIconsModule` into your app module:
 * ```ts
 * import { NbEvaIconsModule } from '@nebular/eva-icons';
 *
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbEvaIconsModule,
 *   ],
 * })
 * export class AppModule { }
 * ```
 * Last thing, import `NbIconModule` to your feature module where you need to show an icon:
 * ```ts
 * import { NbIconModule } from '@nebular/theme';
 *
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbIconModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Icon can be colored using `status` input:
 * ```html
 * <nb-icon icon="star" status="warning"></nb-icon>
 * ```
 *
 * Colored icons:
 * @stacked-example(Colored Icons, icon/icon-colors.component)
 *
 * In case you need to specify an icon from a specific icon pack, this could be done using `pack` input property:
 * ```html
 * <nb-icon icon="star" pack="font-awesome"></nb-icon>
 * ```
 * Additional icon settings (if available by the icon pack) could be passed using `options` input:
 *
 * ```html
 * <nb-icon icon="star" [options]="{ animation: { type: 'zoom' } }"></nb-icon>
 * ```
 *
 * @styles
 *
 * icon-font-size:
 * icon-line-height:
 * icon-width:
 * icon-height:
 * icon-svg-vertical-align:
 * icon-basic-color:
 * icon-primary-color:
 * icon-info-color:
 * icon-success-color:
 * icon-warning-color:
 * icon-danger-color:
 * icon-control-color:
 */
class NbIconComponent {
    constructor(sanitizer, iconLibrary, el, renderer, statusService) {
        this.sanitizer = sanitizer;
        this.iconLibrary = iconLibrary;
        this.el = el;
        this.renderer = renderer;
        this.statusService = statusService;
        this.prevClasses = [];
        this.html = '';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    /**
     * Sets all icon configurable properties via config object.
     * If passed value is a string set icon name.
     * @docs-private
     */
    get config() {
        return this._config;
    }
    set config(value) {
        if (!value) {
            return;
        }
        this._config = value;
        if (typeof value === 'string') {
            this.icon = value;
        }
        else {
            this.icon = value.icon;
            this.pack = value.pack;
            this.status = value.status;
            this.options = value.options;
        }
    }
    ngOnInit() {
        this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
    }
    ngOnChanges() {
        const iconDef = this.iconLibrary.getIcon(this.icon, this.pack);
        if (iconDef) {
            this.renderIcon(this.icon, this.pack, this.options);
        }
        else {
            this.clearIcon();
        }
    }
    renderIcon(name, pack, options) {
        const iconDefinition = this.iconLibrary.getIcon(name, pack);
        if (!iconDefinition) {
            return;
        }
        const content = iconDefinition.icon.getContent(options);
        if (content) {
            this.html = this.sanitizer.bypassSecurityTrustHtml(content);
        }
        this.assignClasses(iconDefinition.icon.getClasses(options));
        return iconDefinition;
    }
    clearIcon() {
        this.html = '';
        this.assignClasses([]);
    }
    assignClasses(classes) {
        this.prevClasses.forEach((className) => {
            this.renderer.removeClass(this.el.nativeElement, className);
        });
        classes.forEach((className) => {
            this.renderer.addClass(this.el.nativeElement, className);
        });
        this.prevClasses = classes;
    }
}
NbIconComponent.ɵfac = function NbIconComponent_Factory(t) { return new (t || NbIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(NbIconLibraries), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbIconComponent, selectors: [["nb-icon"]], hostVars: 17, hostBindings: function NbIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("innerHtml", ctx.html, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { config: "config", icon: "icon", pack: "pack", status: "status", options: "options" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function NbIconComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%]{display:inline-block}"], changeDetection: 0 });
NbIconComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: NbIconLibraries },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NbStatusService }
];
NbIconComponent.propDecorators = {
    html: [{ type: HostBinding, args: ['innerHtml',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    icon: [{ type: Input }],
    pack: [{ type: Input }],
    options: [{ type: Input }],
    status: [{ type: Input }],
    config: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbIconComponent, [{
        type: Component,
        args: [{
                selector: 'nb-icon',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block}\n"]
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }, { type: NbIconLibraries }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: NbStatusService }]; }, { html: [{
            type: HostBinding,
            args: ['innerHtml']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], config: [{
            type: Input
        }], icon: [{
            type: Input
        }], pack: [{
            type: Input
        }], status: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbIconModule {
    constructor(iconsLibrary) {
        this.iconsLibrary = iconsLibrary;
        this.essentialsPackName = 'nebular-essentials';
        // in case of consequent calls we don't need to enable `nebular-essentials` pack again
        if (this.iconsLibrary.getPack(this.essentialsPackName)) {
            return;
        }
        // tslint:disable:max-line-length
        this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
            'chevron-down-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
            'chevron-up-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
            'chevron-left-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
            'chevron-right-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
            'checkmark-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
            'paper-plane-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
            'file-text-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
            'alert-triangle-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
            'question-mark-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
            'email-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
            'flash-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
            'search-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
            'close-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
            'collapse-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
            'expand-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
            'minus-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
            'minus-bold-outline': '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
            'checkmark-bold-outline': '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
            'arrow-back': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>',
        });
        // tslint:enable:max-line-length
    }
}
NbIconModule.ɵfac = function NbIconModule_Factory(t) { return new (t || NbIconModule)(ɵngcc0.ɵɵinject(NbIconLibraries)); };
NbIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbIconModule });
NbIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
        ]] });
NbIconModule.ctorParameters = () => [
    { type: NbIconLibraries }
];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbIconModule, { declarations: function () { return [NbIconComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NbIconComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbIconModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    NbIconComponent,
                ],
                exports: [
                    NbIconComponent,
                ]
            }]
    }], function () { return [{ type: NbIconLibraries }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Component intended to be used within the `<nb-card>` component.
 * It adds styles for a preset header section.
 *
 * @styles
 *
 * card-header-text-color:
 * card-header-text-font-family:
 * card-header-text-font-size:
 * card-header-text-font-weight:
 * card-header-text-line-height:
 * card-header-basic-background-color:
 * card-header-basic-text-color:
 * card-header-primary-background-color:
 * card-header-primary-text-color:
 * card-header-info-background-color:
 * card-header-info-text-color:
 * card-header-success-background-color:
 * card-header-success-text-color:
 * card-header-warning-background-color:
 * card-header-warning-text-color:
 * card-header-danger-background-color:
 * card-header-danger-text-color:
 * card-header-control-background-color:
 * card-header-control-text-color:
 */
class NbCardHeaderComponent {
}
NbCardHeaderComponent.ɵfac = function NbCardHeaderComponent_Factory(t) { return new (t || NbCardHeaderComponent)(); };
NbCardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardHeaderComponent, selectors: [["nb-card-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-header',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/**
 * Component intended to be used within  the `<nb-card>` component.
 * Adds styles for a preset body section.
 */
class NbCardBodyComponent {
}
NbCardBodyComponent.ɵfac = function NbCardBodyComponent_Factory(t) { return new (t || NbCardBodyComponent)(); };
NbCardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardBodyComponent, selectors: [["nb-card-body"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-body',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/**
 * Component intended to be used within  the `<nb-card>` component.
 * Adds styles for a preset footer section.
 */
class NbCardFooterComponent {
}
NbCardFooterComponent.ɵfac = function NbCardFooterComponent_Factory(t) { return new (t || NbCardFooterComponent)(); };
NbCardFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardFooterComponent, selectors: [["nb-card-footer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-footer',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/**
 * Basic content container component.
 *
 * Basic card example:
 * @stacked-example(Showcase, card/card-showcase.component)
 *
 * Basic card configuration:
 *
 * ```html
 * <nb-card>
 *   <nb-card-body>
 *     Card
 *   </nb-card-body>
 * </nb-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Card with header and footer:
 * @stacked-example(With Header & Footer, card/card-full.component)
 *
 * Most of the time main card content goes to `nb-card-body`,
 * so it is styled and aligned in accordance with the header and footer.
 * In case you need a higher level of control, you can pass contend directly to `nb-card`,
 * so `nb-card-body` styling will not be applied.
 *
 * Consider an example with `nb-list` component:
 * @stacked-example(Card with list, card/card-without-body.component)
 *
 * Colored cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, card/card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, card/card-accents.component)
 *
 * Cards of smaller sizes could be combined and put on the same row with a bigger card so they have the same heights.
 * @stacked-example(Card sizes combinations, card/card-sizes-combinations.component)
 *
 * @additional-example(Multiple Sizes, card/card-sizes.component)
 *
 * @styles
 *
 * card-background-color:
 * card-text-color:
 * card-text-font-family:
 * card-text-font-size:
 * card-text-font-weight:
 * card-text-line-height:
 * card-border-width:
 * card-border-style:
 * card-border-color:
 * card-border-radius:
 * card-padding:
 * card-shadow:
 * card-divider-color:
 * card-divider-style:
 * card-divider-width:
 * card-height-tiny:
 * card-height-small:
 * card-height-medium:
 * card-height-large:
 * card-height-giant:
 * card-margin-bottom:
 * card-scrollbar-color:
 * card-scrollbar-background-color:
 * card-scrollbar-width:
 */
class NbCardComponent {
    constructor(statusService) {
        this.statusService = statusService;
        this._size = '';
        /**
         * Card status:
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = '';
        /**
         * Card accent (color of the top border):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.accent = '';
    }
    /**
     * Card size, available sizes:
     * tiny, small, medium, large, giant
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get hasAccent() {
        return this.accent;
    }
    get primaryAccent() {
        return this.accent === 'primary';
    }
    get infoAccent() {
        return this.accent === 'info';
    }
    get successAccent() {
        return this.accent === 'success';
    }
    get warningAccent() {
        return this.accent === 'warning';
    }
    get dangerAccent() {
        return this.accent === 'danger';
    }
    get basicAccent() {
        return this.accent === 'basic';
    }
    get controlAccent() {
        return this.accent === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
}
NbCardComponent.ɵfac = function NbCardComponent_Factory(t) { return new (t || NbCardComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardComponent, selectors: [["nb-card"]], hostVars: 42, hostBindings: function NbCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
    } }, inputs: { status: "status", accent: "accent", size: "size" }, ngContentSelectors: _c2, decls: 4, vars: 0, template: function NbCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵprojection(2, 2);
        ɵngcc0.ɵɵprojection(3, 3);
    } }, styles: [_c8] });
NbCardComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbCardComponent.propDecorators = {
    size: [{ type: Input }],
    status: [{ type: Input }],
    accent: [{ type: Input }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    hasAccent: [{ type: HostBinding, args: ['class.accent',] }],
    primaryAccent: [{ type: HostBinding, args: ['class.accent-primary',] }],
    infoAccent: [{ type: HostBinding, args: ['class.accent-info',] }],
    successAccent: [{ type: HostBinding, args: ['class.accent-success',] }],
    warningAccent: [{ type: HostBinding, args: ['class.accent-warning',] }],
    dangerAccent: [{ type: HostBinding, args: ['class.accent-danger',] }],
    basicAccent: [{ type: HostBinding, args: ['class.accent-basic',] }],
    controlAccent: [{ type: HostBinding, args: ['class.accent-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card',
                template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { status: [{
            type: Input
        }], accent: [{
            type: Input
        }], size: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], hasAccent: [{
            type: HostBinding,
            args: ['class.accent']
        }], primaryAccent: [{
            type: HostBinding,
            args: ['class.accent-primary']
        }], infoAccent: [{
            type: HostBinding,
            args: ['class.accent-info']
        }], successAccent: [{
            type: HostBinding,
            args: ['class.accent-success']
        }], warningAccent: [{
            type: HostBinding,
            args: ['class.accent-warning']
        }], dangerAccent: [{
            type: HostBinding,
            args: ['class.accent-danger']
        }], basicAccent: [{
            type: HostBinding,
            args: ['class.accent-basic']
        }], controlAccent: [{
            type: HostBinding,
            args: ['class.accent-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

/**
 *
 * Reveal card example:
 * @stacked-example(My example, reveal-card/reveal-card-showcase.component)
 *
 * As a content Reveal card accepts two instances of `nb-card` - for front and back sides.
 *
 * Basic reveal card configuration:
 *
 * ```html
 * <nb-reveal-card>
 *   <nb-card-front>
 *     <nb-card>
 *       <nb-card-body>
 *         Front
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-front>
 *   <nb-card-back>
 *     <nb-card>
 *       <nb-card-body>
 *         Back
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-back>
 * </nb-reveal-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Reveal Card with header and footer:
 * @stacked-example(With Header & Footer, reveal-card/reveal-card-full.component)
 *
 * Colored reveal-cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, reveal-card/reveal-card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, reveal-card/reveal-card-accents.component)
 *
 * @additional-example(Multiple Sizes, reveal-card/reveal-card-sizes.component)
 */
class NbRevealCardComponent {
    constructor() {
        /**
         * Reveal state
         * @type boolean
         */
        this.revealed = false;
        /**
         * Show/hide toggle button to be able to control toggle from your code
         * @type {boolean}
         */
        this.showToggleButton = true;
    }
    toggle() {
        this.revealed = !this.revealed;
    }
}
NbRevealCardComponent.ɵfac = function NbRevealCardComponent_Factory(t) { return new (t || NbRevealCardComponent)(); };
NbRevealCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRevealCardComponent, selectors: [["nb-reveal-card"]], hostVars: 2, hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("revealed", ctx.revealed);
    } }, inputs: { revealed: "revealed", showToggleButton: "showToggleButton" }, ngContentSelectors: _c4, decls: 4, vars: 1, consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbRevealCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c3);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s 0.5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top 0.5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform 0.3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"] });
NbRevealCardComponent.propDecorators = {
    revealed: [{ type: Input }, { type: HostBinding, args: ['class.revealed',] }],
    showToggleButton: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRevealCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-reveal-card',
                template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
                styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s 0.5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top 0.5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform 0.3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
            }]
    }], function () { return []; }, { revealed: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.revealed']
        }], showToggleButton: [{
            type: Input
        }] }); })();

/**
 *
 * Flip card example:
 * @stacked-example(Showcase, flip-card/flip-card-showcase.component)
 *
 * As a content Flip card accepts two instances of `nb-card` - for front and back sides.
 *
 * Basic flip card configuration:
 *
 * ```html
 * <nb-flip-card>
 *   <nb-card-front>
 *     <nb-card>
 *       <nb-card-body>
 *         Front
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-front>
 *   <nb-card-back>
 *     <nb-card>
 *       <nb-card-body>
 *         Back
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-back>
 * </nb-flip-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Flip Card with header and footer:
 * @stacked-example(With Header & Footer, flip-card/flip-card-full.component.ts)
 *
 * Colored flip-cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, flip-card/flip-card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, flip-card/flip-card-accents.component)
 *
 * @additional-example(Multiple Sizes, flip-card/flip-card-sizes.component)
 *
 */
class NbFlipCardComponent {
    constructor() {
        /**
         * Flip state
         * @type boolean
         */
        this.flipped = false;
        /**
         * Show/hide toggle button to be able to control toggle from your code
         * @type {boolean}
         */
        this.showToggleButton = true;
    }
    toggle() {
        this.flipped = !this.flipped;
    }
}
NbFlipCardComponent.ɵfac = function NbFlipCardComponent_Factory(t) { return new (t || NbFlipCardComponent)(); };
NbFlipCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbFlipCardComponent, selectors: [["nb-flip-card"]], hostVars: 2, hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("flipped", ctx.flipped);
    } }, inputs: { flipped: "flipped", showToggleButton: "showToggleButton" }, ngContentSelectors: _c4, decls: 7, vars: 2, consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbFlipCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c3);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵtemplate(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:block;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s 0.25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform 0.5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s 0.15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s 0.2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}"] });
NbFlipCardComponent.propDecorators = {
    flipped: [{ type: Input }, { type: HostBinding, args: ['class.flipped',] }],
    showToggleButton: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFlipCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-flip-card',
                template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
                styles: [":host{display:block;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s 0.25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform 0.5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s 0.15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s 0.2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n"]
            }]
    }], function () { return []; }, { flipped: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.flipped']
        }], showToggleButton: [{
            type: Input
        }] }); })();

/**
 * Component intended to be used within the `<nb-flip-card>` and `<nb-reveal-card>` components.
 *
 * Use it as a container for the front card.
 */
class NbCardFrontComponent {
}
NbCardFrontComponent.ɵfac = function NbCardFrontComponent_Factory(t) { return new (t || NbCardFrontComponent)(); };
NbCardFrontComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardFrontComponent, selectors: [["nb-card-front"]], ngContentSelectors: _c6, decls: 1, vars: 0, template: function NbCardFrontComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardFrontComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-front',
                template: '<ng-content select="nb-card"></ng-content>'
            }]
    }], null, null); })();
/**
 * Component intended to be used within the `<nb-flip-card>` and `<nb-reveal-card>` components.
 *
 * Use it as a container for the back card.
 */
class NbCardBackComponent {
}
NbCardBackComponent.ɵfac = function NbCardBackComponent_Factory(t) { return new (t || NbCardBackComponent)(); };
NbCardBackComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardBackComponent, selectors: [["nb-card-back"]], ngContentSelectors: _c6, decls: 1, vars: 0, template: function NbCardBackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardBackComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-back',
                template: '<ng-content select="nb-card"></ng-content>'
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_CARD_COMPONENTS = [
    NbCardComponent,
    NbCardBodyComponent,
    NbCardFooterComponent,
    NbCardHeaderComponent,
    NbRevealCardComponent,
    NbFlipCardComponent,
    NbCardFrontComponent,
    NbCardBackComponent,
];
class NbCardModule {
}
NbCardModule.ɵfac = function NbCardModule_Factory(t) { return new (t || NbCardModule)(); };
NbCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCardModule });
NbCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCardModule, { declarations: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent], imports: [NbSharedModule, NbIconModule], exports: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCardModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_CARD_COMPONENTS,
                ],
                exports: [
                    ...NB_CARD_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var NbCalendarViewMode;
(function (NbCalendarViewMode) {
    NbCalendarViewMode["YEAR"] = "year";
    NbCalendarViewMode["MONTH"] = "month";
    NbCalendarViewMode["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function (NbCalendarSize) {
    NbCalendarSize["MEDIUM"] = "medium";
    NbCalendarSize["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function convertToBoolProperty(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === '');
    }
    return !!val;
}

function firstChildNotComment(node) {
    const children = Array
        .from(node.childNodes)
        .filter((child) => child.nodeType !== Node.COMMENT_NODE);
    return children[0];
}
function lastChildNotComment(node) {
    const children = Array
        .from(node.childNodes)
        .filter((child) => child.nodeType !== Node.COMMENT_NODE);
    return children[children.length - 1];
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Calendar component provides a capability to choose a date.
 *
 * ```html
 * <nb-calendar [(date)]="date"></nb-calendar>
 * <nb-calendar [date]="date" (dateChange)="handleDateChange($event)"></nb-calendar>
 * ```
 *
 * Basic usage example
 * @stacked-example(Showcase, calendar/calendar-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCalendarModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCalendarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to select ranges you can use `NbCalendarRangeComponent`.
 *
 * ```html
 * <nb-calendar-range [(range)]="range"></nb-calendar-range>
 * <nb-calendar-range [range]="range" (rangeChange)="handleRangeChange($event)"></nb-calendar-range>
 * ```
 *
 * In order to use it, you have to import `NbCalendarRangeModule`.
 * @stacked-example(Range, calendar/calendar-range-showcase.component)
 *
 * The calendar component is supplied with a calendar navigation that contains navigate buttons.
 * If you do not want to use it you can hide calendar navigation using `showNavigation` property.
 * @stacked-example(Without navigation, calendar/calendar-without-navigation.component)
 *
 * As you can see in the basic usage example calendar contains previous and next month days
 * which can be disabled using `boundingMonth` property.
 * @stacked-example(Bounding months, calendar/calendar-bounding-month.component)
 *
 * You can define starting view of the calendar by setting `startView` property.
 * Available values: year, month and date.
 * @stacked-example(Start view, calendar/calendar-start-view.component)
 *
 * You can use a larger version of the calendar by defining size property.
 * Available values: medium(which is default) and large.
 * @stacked-example(Size, calendar/calendar-size.component)
 *
 * Calendar supports min and max dates which disables values out of min-max range.
 * @stacked-example(Borders, calendar/calendar-min-max.component)
 *
 * Also, you can define custom filter property that should be predicate which receives
 * date and returns false if this date has to be disabled. In this example, we provide the filter
 * which disables weekdays.
 * @stacked-example(Filter, calendar/calendar-filter.component)
 *
 * Week numbers column could be enabled via `showWeekNumber` binding:
 * @stacked-example(Week number, calendar/calendar-week-number.component)
 *
 * If you need create custom cells you can easily provide custom components for
 * calendar. For examples if you want to show any average price under each date you can
 * just provide custom `dayCellComponent`. Custom cells for month and year can be provided
 * the same way, check API reference.
 * @stacked-example(Custom day cell, calendar/calendar-custom-day-cell-showcase.component)
 *
 * @styles
 *
 * calendar-width:
 * calendar-background-color:
 * calendar-border-color:
 * calendar-border-style:
 * calendar-border-width:
 * calendar-border-radius:
 * calendar-text-color:
 * calendar-text-font-family:
 * calendar-text-font-size:
 * calendar-text-font-weight:
 * calendar-text-line-height:
 * calendar-picker-padding-top:
 * calendar-picker-padding-bottom:
 * calendar-picker-padding-start:
 * calendar-picker-padding-end:
 * calendar-navigation-text-color:
 * calendar-navigation-text-font-family:
 * calendar-navigation-title-text-font-size:
 * calendar-navigation-title-text-font-weight:
 * calendar-navigation-title-text-line-height:
 * calendar-navigation-padding:
 * calendar-cell-inactive-text-color:
 * calendar-cell-disabled-text-color:
 * calendar-cell-hover-background-color:
 * calendar-cell-hover-border-color:
 * calendar-cell-hover-text-color:
 * calendar-cell-hover-text-font-size:
 * calendar-cell-hover-text-font-weight:
 * calendar-cell-hover-text-line-height:
 * calendar-cell-active-background-color:
 * calendar-cell-active-border-color:
 * calendar-cell-active-text-color:
 * calendar-cell-active-text-font-size:
 * calendar-cell-active-text-font-weight:
 * calendar-cell-active-text-line-height:
 * calendar-cell-today-background-color:
 * calendar-cell-today-border-color:
 * calendar-cell-today-text-color:
 * calendar-cell-today-text-font-size:
 * calendar-cell-today-text-font-weight:
 * calendar-cell-today-text-line-height:
 * calendar-cell-today-hover-background-color:
 * calendar-cell-today-hover-border-color:
 * calendar-cell-today-active-background-color:
 * calendar-cell-today-active-border-color:
 * calendar-cell-today-disabled-border-color:
 * calendar-cell-today-selected-background-color:
 * calendar-cell-today-selected-border-color:
 * calendar-cell-today-selected-text-color:
 * calendar-cell-today-selected-hover-background-color:
 * calendar-cell-today-selected-hover-border-color:
 * calendar-cell-today-selected-active-background-color:
 * calendar-cell-today-selected-active-border-color:
 * calendar-cell-today-in-range-background-color:
 * calendar-cell-today-in-range-border-color:
 * calendar-cell-today-in-range-text-color:
 * calendar-cell-today-in-range-hover-background-color:
 * calendar-cell-today-in-range-hover-border-color:
 * calendar-cell-today-in-range-active-background-color:
 * calendar-cell-today-in-range-active-border-color:
 * calendar-cell-selected-background-color:
 * calendar-cell-selected-border-color:
 * calendar-cell-selected-text-color:
 * calendar-cell-selected-text-font-size:
 * calendar-cell-selected-text-font-weight:
 * calendar-cell-selected-text-line-height:
 * calendar-cell-selected-hover-background-color:
 * calendar-cell-selected-hover-border-color:
 * calendar-cell-selected-active-background-color:
 * calendar-cell-selected-active-border-color:
 * calendar-day-cell-width:
 * calendar-day-cell-height:
 * calendar-month-cell-width:
 * calendar-month-cell-height:
 * calendar-year-cell-width:
 * calendar-year-cell-height:
 * calendar-weekday-background:
 * calendar-weekday-divider-color:
 * calendar-weekday-divider-width:
 * calendar-weekday-text-color:
 * calendar-weekday-text-font-size:
 * calendar-weekday-text-font-weight:
 * calendar-weekday-text-line-height:
 * calendar-weekday-holiday-text-color:
 * calendar-weekday-height:
 * calendar-weekday-width:
 * calendar-weeknumber-background:
 * calendar-weeknumber-divider-color:
 * calendar-weeknumber-divider-width:
 * calendar-weeknumber-text-color:
 * calendar-weeknumber-text-font-size:
 * calendar-weeknumber-text-font-weight:
 * calendar-weeknumber-text-line-height:
 * calendar-weeknumber-height:
 * calendar-weeknumber-width:
 * calendar-large-width:
 * calendar-day-cell-large-width:
 * calendar-day-cell-large-height:
 * calendar-weekday-large-height:
 * calendar-weekday-large-width:
 * calendar-weeknumber-large-height:
 * calendar-weeknumber-large-width:
 * calendar-month-cell-large-width:
 * calendar-month-cell-large-height:
 * calendar-year-cell-large-width:
 * calendar-year-cell-large-height:
 * */
class NbCalendarComponent {
    constructor() {
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines should we show calendars navigation or not.
         * */
        this.showNavigation = true;
        this._showWeekNumber = false;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        /**
         * Emits date when selected.
         * */
        this.dateChange = new EventEmitter();
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
}
NbCalendarComponent.ɵfac = function NbCalendarComponent_Factory(t) { return new (t || NbCalendarComponent)(); };
NbCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarComponent, selectors: [["nb-calendar"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", size: "size", showNavigation: "showNavigation", weekNumberSymbol: "weekNumberSymbol", showWeekNumber: "showWeekNumber", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", visibleDate: "visibleDate", date: "date" }, outputs: { dateChange: "dateChange" }, decls: 1, vars: 14, consts: [[3, "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "dateChange"]], template: function NbCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-base-calendar", 0);
        ɵngcc0.ɵɵlistener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) { return ctx.dateChange.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol);
    } }, directives: function () { return [NbBaseCalendarComponent]; }, encapsulation: 2 });
NbCalendarComponent.propDecorators = {
    boundingMonth: [{ type: Input }],
    startView: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    dayCellComponent: [{ type: Input }],
    monthCellComponent: [{ type: Input }],
    yearCellComponent: [{ type: Input }],
    size: [{ type: Input }],
    visibleDate: [{ type: Input }],
    showNavigation: [{ type: Input }],
    date: [{ type: Input }],
    showWeekNumber: [{ type: Input }],
    weekNumberSymbol: [{ type: Input }],
    dateChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar',
                template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `
            }]
    }], function () { return []; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], size: [{
            type: Input
        }], showNavigation: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], showWeekNumber: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();

// tslint:disable-next-line:directive-class-suffix
class NbButton {
    constructor(renderer, hostElement, cd, zone, statusService) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cd = cd;
        this.zone = zone;
        this.statusService = statusService;
        /**
         * Button size, available sizes:
         * `tiny`, `small`, `medium`, `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Button status (adds specific styles):
         * `primary`, `info`, `success`, `warning`, `danger`
         */
        this.status = 'basic';
        /**
         * Button shapes: `rectangle`, `round`, `semi-round`
         */
        this.shape = 'rectangle';
        /**
         * Button appearance: `filled`, `outline`, `ghost`, `hero`
         */
        this.appearance = 'filled';
        this._fullWidth = false;
        this._disabled = false;
    }
    /**
     * Sets `filled` appearance
     */
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    /**
     * Sets `outline` appearance
     */
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    /**
     * Sets `ghost` appearance
     */
    get ghost() {
        return this.appearance === 'ghost';
    }
    set ghost(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'ghost';
        }
    }
    /**
     * If set element will fill its container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    /**
     * Disables the button
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this.disabled !== convertToBoolProperty(value)) {
            this._disabled = !this.disabled;
            this.renderer.setProperty(this.hostElement.nativeElement, 'disabled', this.disabled);
        }
    }
    // issue #794
    get tabbable() {
        if (this.disabled) {
            return '-1';
        }
        if (this.tabIndex == null) {
            return '0';
        }
        return this.tabIndex.toString();
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get round() {
        return this.shape === 'round';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get iconLeft() {
        const el = this.hostElement.nativeElement;
        const icon = this.iconElement;
        return !!(icon && firstChildNotComment(el) === icon);
    }
    get iconRight() {
        const el = this.hostElement.nativeElement;
        const icon = this.iconElement;
        return !!(icon && lastChildNotComment(el) === icon);
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.hostElement.nativeElement, 'nb-transition');
        }));
    }
    /**
     * @docs-private
     **/
    updateProperties(config) {
        let isPropertyChanged = false;
        for (const key in config) {
            if (config.hasOwnProperty(key) && this[key] !== config[key]) {
                this[key] = config[key];
                isPropertyChanged = true;
            }
        }
        if (isPropertyChanged) {
            this.cd.markForCheck();
        }
    }
    get iconElement() {
        const el = this.hostElement.nativeElement;
        return el.querySelector('nb-icon');
    }
}
NbButton.ɵfac = function NbButton_Factory(t) { return new (t || NbButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbButton.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbButton, hostVars: 34, hostBindings: function NbButton_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight);
    } }, inputs: { size: "size", status: "status", shape: "shape", appearance: "appearance", filled: "filled", outline: "outline", ghost: "ghost", fullWidth: "fullWidth", disabled: "disabled", tabIndex: "tabIndex" } });
NbButton.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: NbStatusService }
];
NbButton.propDecorators = {
    size: [{ type: Input }],
    status: [{ type: Input }],
    shape: [{ type: Input }],
    appearance: [{ type: Input }],
    filled: [{ type: Input }, { type: HostBinding, args: ['class.appearance-filled',] }],
    outline: [{ type: Input }, { type: HostBinding, args: ['class.appearance-outline',] }],
    ghost: [{ type: Input }, { type: HostBinding, args: ['class.appearance-ghost',] }],
    fullWidth: [{ type: Input }, { type: HostBinding, args: ['class.full-width',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.btn-disabled',] }],
    tabIndex: [{ type: Input }],
    tabbable: [{ type: HostBinding, args: ['attr.tabindex',] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    rectangle: [{ type: HostBinding, args: ['class.shape-rectangle',] }],
    round: [{ type: HostBinding, args: ['class.shape-round',] }],
    semiRound: [{ type: HostBinding, args: ['class.shape-semi-round',] }],
    iconLeft: [{ type: HostBinding, args: ['class.icon-start',] }],
    iconRight: [{ type: HostBinding, args: ['class.icon-end',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButton, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], appearance: [{
            type: Input
        }], filled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-filled']
        }], outline: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-outline']
        }], ghost: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-ghost']
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.btn-disabled']
        }], tabbable: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], iconLeft: [{
            type: HostBinding,
            args: ['class.icon-start']
        }], iconRight: [{
            type: HostBinding,
            args: ['class.icon-end']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], tabIndex: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Basic button component.
 *
 * Default button size is `medium` and status color is `basic`:
 * @stacked-example(Button Showcase, button/button-showcase.component)
 *
 * ```html
 * <button nbButton></button>
 * ```
 * ### Installation
 *
 * Import `NbButtonModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbButtonModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Buttons are available in multiple colors using `status` property:
 * @stacked-example(Button Colors, button/button-colors.component.html)
 *
 * There are three button sizes:
 *
 * @stacked-example(Button Sizes, button/button-sizes.component.html)
 *
 * And two additional style types - `outline`:
 *
 * @stacked-example(Outline Buttons, button/button-outline.component.html)
 *
 * and `hero`:
 *
 * @stacked-example(Button Hero, button/button-hero.component.html)
 *
 * Buttons available in different shapes, which could be combined with the other properties:
 * @stacked-example(Button Shapes, button/button-shapes.component)
 *
 * `nbButton` could be applied to the following selectors - `button`, `input[type="button"]`, `input[type="submit"]`
 * and `a`:
 * @stacked-example(Button Elements, button/button-types.component.html)
 *
 * Button can be made `fullWidth`:
 * @stacked-example(Full Width Button, button/button-full-width.component.html)
 *
 * Icon can be placed inside of a button as a child element:
 * @stacked-example(Icon Button, button/button-icon.component.html)
 *
 * @additional-example(Interactive example, button/button-interactive.component)
 *
 * @styles
 *
 * button-cursor:
 * button-outline-width:
 * button-outline-color:
 * button-text-font-family:
 * button-text-font-weight:
 * button-disabled-cursor:
 * button-tiny-text-font-size:
 * button-tiny-text-line-height:
 * button-tiny-icon-size:
 * button-tiny-icon-vertical-margin:
 * button-tiny-icon-offset:
 * button-small-text-font-size:
 * button-small-text-line-height:
 * button-small-icon-size:
 * button-small-icon-vertical-margin:
 * button-small-icon-offset:
 * button-medium-text-font-size:
 * button-medium-text-line-height:
 * button-medium-icon-size:
 * button-medium-icon-vertical-margin:
 * button-medium-icon-offset:
 * button-large-text-font-size:
 * button-large-text-line-height:
 * button-large-icon-size:
 * button-large-icon-vertical-margin:
 * button-large-icon-offset:
 * button-giant-text-font-size:
 * button-giant-text-line-height:
 * button-giant-icon-size:
 * button-giant-icon-vertical-margin:
 * button-giant-icon-offset:
 * button-rectangle-border-radius:
 * button-semi-round-border-radius:
 * button-round-border-radius:
 * button-filled-border-style:
 * button-filled-border-width:
 * button-filled-text-transform:
 * button-filled-tiny-padding:
 * button-filled-small-padding:
 * button-filled-medium-padding:
 * button-filled-large-padding:
 * button-filled-giant-padding:
 * button-filled-basic-background-color:
 * button-filled-basic-border-color:
 * button-filled-basic-text-color:
 * button-filled-basic-focus-background-color:
 * button-filled-basic-focus-border-color:
 * button-filled-basic-hover-background-color:
 * button-filled-basic-hover-border-color:
 * button-filled-basic-active-background-color:
 * button-filled-basic-active-border-color:
 * button-filled-basic-disabled-background-color:
 * button-filled-basic-disabled-border-color:
 * button-filled-basic-disabled-text-color:
 * button-filled-primary-background-color:
 * button-filled-primary-border-color:
 * button-filled-primary-text-color:
 * button-filled-primary-focus-background-color:
 * button-filled-primary-focus-border-color:
 * button-filled-primary-hover-background-color:
 * button-filled-primary-hover-border-color:
 * button-filled-primary-active-background-color:
 * button-filled-primary-active-border-color:
 * button-filled-primary-disabled-background-color:
 * button-filled-primary-disabled-border-color:
 * button-filled-primary-disabled-text-color:
 * button-filled-success-background-color:
 * button-filled-success-border-color:
 * button-filled-success-text-color:
 * button-filled-success-focus-background-color:
 * button-filled-success-focus-border-color:
 * button-filled-success-hover-background-color:
 * button-filled-success-hover-border-color:
 * button-filled-success-active-background-color:
 * button-filled-success-active-border-color:
 * button-filled-success-disabled-background-color:
 * button-filled-success-disabled-border-color:
 * button-filled-success-disabled-text-color:
 * button-filled-info-background-color:
 * button-filled-info-border-color:
 * button-filled-info-text-color:
 * button-filled-info-focus-background-color:
 * button-filled-info-focus-border-color:
 * button-filled-info-hover-background-color:
 * button-filled-info-hover-border-color:
 * button-filled-info-active-background-color:
 * button-filled-info-active-border-color:
 * button-filled-info-disabled-background-color:
 * button-filled-info-disabled-border-color:
 * button-filled-info-disabled-text-color:
 * button-filled-warning-background-color:
 * button-filled-warning-border-color:
 * button-filled-warning-text-color:
 * button-filled-warning-focus-background-color:
 * button-filled-warning-focus-border-color:
 * button-filled-warning-hover-background-color:
 * button-filled-warning-hover-border-color:
 * button-filled-warning-active-background-color:
 * button-filled-warning-active-border-color:
 * button-filled-warning-disabled-background-color:
 * button-filled-warning-disabled-border-color:
 * button-filled-warning-disabled-text-color:
 * button-filled-danger-background-color:
 * button-filled-danger-border-color:
 * button-filled-danger-text-color:
 * button-filled-danger-focus-background-color:
 * button-filled-danger-focus-border-color:
 * button-filled-danger-hover-background-color:
 * button-filled-danger-hover-border-color:
 * button-filled-danger-active-background-color:
 * button-filled-danger-active-border-color:
 * button-filled-danger-disabled-background-color:
 * button-filled-danger-disabled-border-color:
 * button-filled-danger-disabled-text-color:
 * button-filled-control-background-color:
 * button-filled-control-border-color:
 * button-filled-control-text-color:
 * button-filled-control-focus-background-color:
 * button-filled-control-focus-border-color:
 * button-filled-control-hover-background-color:
 * button-filled-control-hover-border-color:
 * button-filled-control-active-background-color:
 * button-filled-control-active-border-color:
 * button-filled-control-disabled-background-color:
 * button-filled-control-disabled-border-color:
 * button-filled-control-disabled-text-color:
 * button-outline-border-style:
 * button-outline-border-width:
 * button-outline-text-transform:
 * button-outline-focus-inset-shadow-length:
 * button-outline-tiny-padding:
 * button-outline-small-padding:
 * button-outline-medium-padding:
 * button-outline-large-padding:
 * button-outline-giant-padding:
 * button-outline-basic-background-color:
 * button-outline-basic-border-color:
 * button-outline-basic-text-color:
 * button-outline-basic-focus-background-color:
 * button-outline-basic-focus-border-color:
 * button-outline-basic-focus-text-color:
 * button-outline-basic-hover-background-color:
 * button-outline-basic-hover-border-color:
 * button-outline-basic-hover-text-color:
 * button-outline-basic-active-background-color:
 * button-outline-basic-active-border-color:
 * button-outline-basic-active-text-color:
 * button-outline-basic-disabled-background-color:
 * button-outline-basic-disabled-border-color:
 * button-outline-basic-disabled-text-color:
 * button-outline-primary-background-color:
 * button-outline-primary-border-color:
 * button-outline-primary-text-color:
 * button-outline-primary-focus-background-color:
 * button-outline-primary-focus-border-color:
 * button-outline-primary-focus-text-color:
 * button-outline-primary-hover-background-color:
 * button-outline-primary-hover-border-color:
 * button-outline-primary-hover-text-color:
 * button-outline-primary-active-background-color:
 * button-outline-primary-active-border-color:
 * button-outline-primary-active-text-color:
 * button-outline-primary-disabled-background-color:
 * button-outline-primary-disabled-border-color:
 * button-outline-primary-disabled-text-color:
 * button-outline-success-background-color:
 * button-outline-success-border-color:
 * button-outline-success-text-color:
 * button-outline-success-focus-background-color:
 * button-outline-success-focus-border-color:
 * button-outline-success-focus-text-color:
 * button-outline-success-hover-background-color:
 * button-outline-success-hover-border-color:
 * button-outline-success-hover-text-color:
 * button-outline-success-active-background-color:
 * button-outline-success-active-border-color:
 * button-outline-success-active-text-color:
 * button-outline-success-disabled-background-color:
 * button-outline-success-disabled-border-color:
 * button-outline-success-disabled-text-color:
 * button-outline-info-background-color:
 * button-outline-info-border-color:
 * button-outline-info-text-color:
 * button-outline-info-focus-background-color:
 * button-outline-info-focus-border-color:
 * button-outline-info-focus-text-color:
 * button-outline-info-hover-background-color:
 * button-outline-info-hover-border-color:
 * button-outline-info-hover-text-color:
 * button-outline-info-active-background-color:
 * button-outline-info-active-border-color:
 * button-outline-info-active-text-color:
 * button-outline-info-disabled-background-color:
 * button-outline-info-disabled-border-color:
 * button-outline-info-disabled-text-color:
 * button-outline-warning-background-color:
 * button-outline-warning-border-color:
 * button-outline-warning-text-color:
 * button-outline-warning-focus-background-color:
 * button-outline-warning-focus-border-color:
 * button-outline-warning-focus-text-color:
 * button-outline-warning-hover-background-color:
 * button-outline-warning-hover-border-color:
 * button-outline-warning-hover-text-color:
 * button-outline-warning-active-background-color:
 * button-outline-warning-active-border-color:
 * button-outline-warning-active-text-color:
 * button-outline-warning-disabled-background-color:
 * button-outline-warning-disabled-border-color:
 * button-outline-warning-disabled-text-color:
 * button-outline-danger-background-color:
 * button-outline-danger-border-color:
 * button-outline-danger-text-color:
 * button-outline-danger-focus-background-color:
 * button-outline-danger-focus-border-color:
 * button-outline-danger-focus-text-color:
 * button-outline-danger-hover-background-color:
 * button-outline-danger-hover-border-color:
 * button-outline-danger-hover-text-color:
 * button-outline-danger-active-background-color:
 * button-outline-danger-active-border-color:
 * button-outline-danger-active-text-color:
 * button-outline-danger-disabled-background-color:
 * button-outline-danger-disabled-border-color:
 * button-outline-danger-disabled-text-color:
 * button-outline-control-background-color:
 * button-outline-control-border-color:
 * button-outline-control-text-color:
 * button-outline-control-focus-background-color:
 * button-outline-control-focus-border-color:
 * button-outline-control-focus-text-color:
 * button-outline-control-hover-background-color:
 * button-outline-control-hover-border-color:
 * button-outline-control-hover-text-color:
 * button-outline-control-active-background-color:
 * button-outline-control-active-border-color:
 * button-outline-control-active-text-color:
 * button-outline-control-disabled-background-color:
 * button-outline-control-disabled-border-color:
 * button-outline-control-disabled-text-color:
 * button-ghost-background-color:
 * button-ghost-border-color:
 * button-ghost-border-style:
 * button-ghost-border-width:
 * button-ghost-text-transform:
 * button-ghost-focus-inset-shadow-length:
 * button-ghost-tiny-padding:
 * button-ghost-small-padding:
 * button-ghost-medium-padding:
 * button-ghost-large-padding:
 * button-ghost-giant-padding:
 * button-ghost-basic-text-color:
 * button-ghost-basic-focus-background-color:
 * button-ghost-basic-focus-border-color:
 * button-ghost-basic-focus-text-color:
 * button-ghost-basic-hover-background-color:
 * button-ghost-basic-hover-border-color:
 * button-ghost-basic-hover-text-color:
 * button-ghost-basic-active-background-color:
 * button-ghost-basic-active-border-color:
 * button-ghost-basic-active-text-color:
 * button-ghost-basic-disabled-background-color:
 * button-ghost-basic-disabled-border-color:
 * button-ghost-basic-disabled-text-color:
 * button-ghost-primary-text-color:
 * button-ghost-primary-focus-background-color:
 * button-ghost-primary-focus-border-color:
 * button-ghost-primary-focus-text-color:
 * button-ghost-primary-hover-background-color:
 * button-ghost-primary-hover-border-color:
 * button-ghost-primary-hover-text-color:
 * button-ghost-primary-active-background-color:
 * button-ghost-primary-active-border-color:
 * button-ghost-primary-active-text-color:
 * button-ghost-primary-disabled-background-color:
 * button-ghost-primary-disabled-border-color:
 * button-ghost-primary-disabled-text-color:
 * button-ghost-success-text-color:
 * button-ghost-success-focus-background-color:
 * button-ghost-success-focus-border-color:
 * button-ghost-success-focus-text-color:
 * button-ghost-success-hover-background-color:
 * button-ghost-success-hover-border-color:
 * button-ghost-success-hover-text-color:
 * button-ghost-success-active-background-color:
 * button-ghost-success-active-border-color:
 * button-ghost-success-active-text-color:
 * button-ghost-success-disabled-background-color:
 * button-ghost-success-disabled-border-color:
 * button-ghost-success-disabled-text-color:
 * button-ghost-info-text-color:
 * button-ghost-info-focus-background-color:
 * button-ghost-info-focus-border-color:
 * button-ghost-info-focus-text-color:
 * button-ghost-info-hover-background-color:
 * button-ghost-info-hover-border-color:
 * button-ghost-info-hover-text-color:
 * button-ghost-info-active-background-color:
 * button-ghost-info-active-border-color:
 * button-ghost-info-active-text-color:
 * button-ghost-info-disabled-background-color:
 * button-ghost-info-disabled-border-color:
 * button-ghost-info-disabled-text-color:
 * button-ghost-warning-text-color:
 * button-ghost-warning-focus-background-color:
 * button-ghost-warning-focus-border-color:
 * button-ghost-warning-focus-text-color:
 * button-ghost-warning-hover-background-color:
 * button-ghost-warning-hover-border-color:
 * button-ghost-warning-hover-text-color:
 * button-ghost-warning-active-background-color:
 * button-ghost-warning-active-border-color:
 * button-ghost-warning-active-text-color:
 * button-ghost-warning-disabled-background-color:
 * button-ghost-warning-disabled-border-color:
 * button-ghost-warning-disabled-text-color:
 * button-ghost-danger-text-color:
 * button-ghost-danger-focus-background-color:
 * button-ghost-danger-focus-border-color:
 * button-ghost-danger-focus-text-color:
 * button-ghost-danger-hover-background-color:
 * button-ghost-danger-hover-border-color:
 * button-ghost-danger-hover-text-color:
 * button-ghost-danger-active-background-color:
 * button-ghost-danger-active-border-color:
 * button-ghost-danger-active-text-color:
 * button-ghost-danger-disabled-background-color:
 * button-ghost-danger-disabled-border-color:
 * button-ghost-danger-disabled-text-color:
 * button-ghost-control-text-color:
 * button-ghost-control-focus-background-color:
 * button-ghost-control-focus-border-color:
 * button-ghost-control-focus-text-color:
 * button-ghost-control-hover-background-color:
 * button-ghost-control-hover-border-color:
 * button-ghost-control-hover-text-color:
 * button-ghost-control-active-background-color:
 * button-ghost-control-active-border-color:
 * button-ghost-control-active-text-color:
 * button-ghost-control-disabled-background-color:
 * button-ghost-control-disabled-border-color:
 * button-ghost-control-disabled-text-color:
 * button-hero-border-color:
 * button-hero-border-style:
 * button-hero-border-width:
 * button-hero-text-transform:
 * button-hero-tiny-padding:
 * button-hero-small-padding:
 * button-hero-medium-padding:
 * button-hero-large-padding:
 * button-hero-giant-padding:
 * button-hero-shadow:
 * button-hero-text-shadow:
 * button-hero-bevel-size:
 * button-hero-glow-size:
 * button-hero-outline-color:
 * button-hero-outline-width:
 * button-hero-basic-text-color:
 * button-hero-basic-bevel-color:
 * button-hero-basic-glow-color:
 * button-hero-basic-left-background-color:
 * button-hero-basic-right-background-color:
 * button-hero-basic-focus-left-background-color:
 * button-hero-basic-focus-right-background-color:
 * button-hero-basic-hover-left-background-color:
 * button-hero-basic-hover-right-background-color:
 * button-hero-basic-active-left-background-color:
 * button-hero-basic-active-right-background-color:
 * button-hero-basic-disabled-background-color:
 * button-hero-basic-disabled-text-color:
 * button-hero-primary-text-color:
 * button-hero-primary-bevel-color:
 * button-hero-primary-glow-color:
 * button-hero-primary-left-background-color:
 * button-hero-primary-right-background-color:
 * button-hero-primary-focus-left-background-color:
 * button-hero-primary-focus-right-background-color:
 * button-hero-primary-hover-left-background-color:
 * button-hero-primary-hover-right-background-color:
 * button-hero-primary-active-left-background-color:
 * button-hero-primary-active-right-background-color:
 * button-hero-primary-disabled-background-color:
 * button-hero-primary-disabled-text-color:
 * button-hero-success-text-color:
 * button-hero-success-bevel-color:
 * button-hero-success-glow-color:
 * button-hero-success-left-background-color:
 * button-hero-success-right-background-color:
 * button-hero-success-focus-left-background-color:
 * button-hero-success-focus-right-background-color:
 * button-hero-success-hover-left-background-color:
 * button-hero-success-hover-right-background-color:
 * button-hero-success-active-left-background-color:
 * button-hero-success-active-right-background-color:
 * button-hero-success-disabled-background-color:
 * button-hero-success-disabled-text-color:
 * button-hero-info-text-color:
 * button-hero-info-bevel-color:
 * button-hero-info-glow-color:
 * button-hero-info-left-background-color:
 * button-hero-info-right-background-color:
 * button-hero-info-focus-left-background-color:
 * button-hero-info-focus-right-background-color:
 * button-hero-info-hover-left-background-color:
 * button-hero-info-hover-right-background-color:
 * button-hero-info-active-left-background-color:
 * button-hero-info-active-right-background-color:
 * button-hero-info-disabled-background-color:
 * button-hero-info-disabled-text-color:
 * button-hero-warning-text-color:
 * button-hero-warning-bevel-color:
 * button-hero-warning-glow-color:
 * button-hero-warning-left-background-color:
 * button-hero-warning-right-background-color:
 * button-hero-warning-focus-left-background-color:
 * button-hero-warning-focus-right-background-color:
 * button-hero-warning-hover-left-background-color:
 * button-hero-warning-hover-right-background-color:
 * button-hero-warning-active-left-background-color:
 * button-hero-warning-active-right-background-color:
 * button-hero-warning-disabled-background-color:
 * button-hero-warning-disabled-text-color:
 * button-hero-danger-text-color:
 * button-hero-danger-bevel-color:
 * button-hero-danger-glow-color:
 * button-hero-danger-left-background-color:
 * button-hero-danger-right-background-color:
 * button-hero-danger-focus-left-background-color:
 * button-hero-danger-focus-right-background-color:
 * button-hero-danger-hover-left-background-color:
 * button-hero-danger-hover-right-background-color:
 * button-hero-danger-active-left-background-color:
 * button-hero-danger-active-right-background-color:
 * button-hero-danger-disabled-background-color:
 * button-hero-danger-disabled-text-color:
 * button-hero-control-text-color:
 * button-hero-control-bevel-color:
 * button-hero-control-glow-color:
 * button-hero-control-left-background-color:
 * button-hero-control-right-background-color:
 * button-hero-control-focus-left-background-color:
 * button-hero-control-focus-right-background-color:
 * button-hero-control-hover-left-background-color:
 * button-hero-control-hover-right-background-color:
 * button-hero-control-active-left-background-color:
 * button-hero-control-active-right-background-color:
 * button-hero-control-disabled-background-color:
 * button-hero-control-disabled-text-color:
 */
class NbButtonComponent extends NbButton {
    constructor(renderer, hostElement, cd, zone, statusService) {
        super(renderer, hostElement, cd, zone, statusService);
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cd = cd;
        this.zone = zone;
        this.statusService = statusService;
    }
    /**
     * Sets `hero` appearance
     */
    get hero() {
        return this.appearance === 'hero';
    }
    set hero(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'hero';
        }
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    /**
     * @private
     * Keep this handler to partially support anchor disabling.
     * Unlike button, anchor doesn't have 'disabled' DOM property,
     * so handler will be called anyway. We preventing navigation and bubbling.
     * Disabling is partial due to click handlers precedence. Consider example:
     * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
     * 'clickHandler' will be called before our host listener below. We can't prevent
     * such handlers call.
     */
    onClick(event) {
        if (this.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
}
NbButtonComponent.ɵfac = function NbButtonComponent_Factory(t) { return new (t || NbButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbButtonComponent, selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]], hostVars: 16, hostBindings: function NbButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbButtonComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("appearance-hero", ctx.hero)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { hero: "hero" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbButton, useExisting: NbButtonComponent },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c7, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
NbButtonComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: NbStatusService }
];
NbButtonComponent.propDecorators = {
    hero: [{ type: Input }, { type: HostBinding, args: ['class.appearance-hero',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButtonComponent, [{
        type: Component,
        args: [{
                selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
                template: `
    <ng-content></ng-content>
  `,
                providers: [
                    { provide: NbButton, useExisting: NbButtonComponent },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { hero: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-hero']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], 
    /**
     * @private
     * Keep this handler to partially support anchor disabling.
     * Unlike button, anchor doesn't have 'disabled' DOM property,
     * so handler will be called anyway. We preventing navigation and bubbling.
     * Disabling is partial due to click handlers precedence. Consider example:
     * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
     * 'clickHandler' will be called before our host listener below. We can't prevent
     * such handlers call.
     */
    onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_BUTTON_COMPONENTS = [
    NbButtonComponent,
];
class NbButtonModule {
}
NbButtonModule.ɵfac = function NbButtonModule_Factory(t) { return new (t || NbButtonModule)(); };
NbButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbButtonModule });
NbButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbButtonModule, { declarations: [NbButtonComponent], imports: [NbSharedModule], exports: [NbButtonComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButtonModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_BUTTON_COMPONENTS,
                ],
                exports: [
                    ...NB_BUTTON_COMPONENTS,
                ]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDateService {
    constructor() {
        this.DAYS_IN_WEEK = 7;
        /**
         * Number of hours in AM/PM day periods.
         **/
        this.HOURS_IN_DAY_PERIOD = 12;
    }
    setLocale(locale) {
        this.locale = locale;
    }
    /**
     * Checks if the date is between the start date and the end date.
     * */
    isBetween(date, start, end) {
        return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
    }
    ;
    /**
     * Checks is two dates have the same day.
     * */
    isSameDaySafe(date1, date2) {
        return date1 && date2 && this.isSameDay(date1, date2);
    }
    ;
    /**
     * Checks is two dates have the same month.
     * */
    isSameMonthSafe(date1, date2) {
        return date1 && date2 && this.isSameMonth(date1, date2);
    }
    /**
     * Checks is two dates have the same year.
     * */
    isSameYearSafe(date1, date2) {
        return date1 && date2 && this.isSameYear(date1, date2);
    }
    isSameHourAndMinute(date1, date2) {
        return this.isSameHour(date1, date2) && this.isSameMinute(date1, date2);
    }
    isSameHour(date1, date2) {
        return this.getHours(date1) === this.getHours(date2);
    }
    isSameMinute(date1, date2) {
        return this.getMinutes(date1) === this.getMinutes(date2);
    }
    getTwentyFourHoursFormat() {
        return 'HH:mm';
    }
    getTwentyFourHoursFormatWithSeconds() {
        return 'HH:mm:ss';
    }
    getTwelveHoursFormatWithSeconds() {
        return 'hh:mm:ss a';
    }
    getDayPeriod(date) {
        const isFirstDayPeriod = this.getHours(date) < this.HOURS_IN_DAY_PERIOD;
        if (isFirstDayPeriod) {
            return "AM" /* AM */;
        }
        else {
            return "PM" /* PM */;
        }
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const batch = (target, batchSize, offset = 0) => {
    return target.reduce((res, item, index) => {
        const chunkIndex = Math.floor((index + offset) / batchSize);
        if (!res[chunkIndex]) {
            res[chunkIndex] = [];
        }
        res[chunkIndex].push(item);
        return res;
    }, []);
};
/**
 * returns array with numbers from first argument to bound.
 * */
const rangeFromTo = (from$$1, to = 0, producer = i => i) => {
    const arr = [];
    for (let i = from$$1; i < to; i++) {
        arr.push(producer(i));
    }
    return arr;
};
/**
 * returns array with numbers from zero to bound.
 * */
const range = (bound, producer = i => i) => {
    return rangeFromTo(0, bound, producer);
};

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarMonthModelService {
    constructor(dateService) {
        this.dateService = dateService;
    }
    createDaysGrid(activeMonth, boundingMonth = true) {
        const weeks = this.createDates(activeMonth);
        return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
    }
    createDates(activeMonth) {
        const days = this.createDateRangeForMonth(activeMonth);
        const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth);
        return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
    }
    withBoundingMonths(weeks, activeMonth, boundingMonth) {
        let withBoundingMonths = weeks;
        if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
            withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
        }
        if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
            withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
        }
        return withBoundingMonths;
    }
    addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
        const firstWeek = weeks.shift();
        const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
        firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
        return [firstWeek, ...weeks];
    }
    addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
        const lastWeek = weeks.pop();
        const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
        lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
        return [...weeks, lastWeek];
    }
    createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
        const month = this.dateService.addMonth(activeMonth, -1);
        const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
        return this.createDateRangeForMonth(month)
            .slice(daysInMonth - requiredItems)
            .map(date => boundingMonth ? date : null);
    }
    createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
        const month = this.dateService.addMonth(activeMonth, 1);
        return this.createDateRangeForMonth(month)
            .slice(0, requiredItems)
            .map(date => boundingMonth ? date : null);
    }
    getStartOfWeekDayDiff(date) {
        const startOfMonth = this.dateService.getMonthStart(date);
        return this.getWeekStartDiff(startOfMonth);
    }
    getWeekStartDiff(date) {
        return (7 - this.dateService.getFirstDayOfWeek() + this.dateService.getDayOfWeek(date)) % 7;
    }
    isShouldAddPrevBoundingMonth(weeks) {
        return weeks[0].length < this.dateService.DAYS_IN_WEEK;
    }
    isShouldAddNextBoundingMonth(weeks) {
        return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
    }
    createDateRangeForMonth(date) {
        const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
        return range(daysInMonth, i => {
            const year = this.dateService.getYear(date);
            const month = this.dateService.getMonth(date);
            return this.dateService.createDate(year, month, i + 1);
        });
    }
}
NbCalendarMonthModelService.ɵfac = function NbCalendarMonthModelService_Factory(t) { return new (t || NbCalendarMonthModelService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbCalendarMonthModelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbCalendarMonthModelService, factory: NbCalendarMonthModelService.ɵfac });
NbCalendarMonthModelService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarMonthModelService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarDayCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.dayCellClass = true;
    }
    get today() {
        return this.dateService.isSameDaySafe(this.date, this.dateService.today());
    }
    get boundingMonth() {
        return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
    }
    get selected() {
        return this.dateService.isSameDaySafe(this.date, this.selectedValue);
    }
    get empty() {
        return !this.date;
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    get day() {
        return this.date && this.dateService.getDate(this.date);
    }
    onClick() {
        if (this.disabled || this.empty) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
    }
    dontFitFilter() {
        return this.date && this.filter && !this.filter(this.date);
    }
}
NbCalendarDayCellComponent.ɵfac = function NbCalendarDayCellComponent_Factory(t) { return new (t || NbCalendarDayCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarDayCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDayCellComponent, selectors: [["nb-calendar-day-cell"]], hostVars: 14, hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("day-cell", ctx.dayCellClass)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", selectedValue: "selectedValue", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarDayCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.day, " ");
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarDayCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarDayCellComponent.propDecorators = {
    date: [{ type: Input }],
    selectedValue: [{ type: Input }],
    visibleDate: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    boundingMonth: [{ type: HostBinding, args: ['class.bounding-month',] }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    empty: [{ type: HostBinding, args: ['class.empty',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    dayCellClass: [{ type: HostBinding, args: ['class.day-cell',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarDayCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-day-cell',
                template: `
    <div class="cell-content">
      {{ day }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], dayCellClass: [{
            type: HostBinding,
            args: ['class.day-cell']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], boundingMonth: [{
            type: HostBinding,
            args: ['class.bounding-month']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], empty: [{
            type: HostBinding,
            args: ['class.empty']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Provides capability pick days.
 * */
class NbCalendarDayPickerComponent {
    constructor(monthModel) {
        this.monthModel = monthModel;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonths = true;
        this.cellComponent = NbCalendarDayCellComponent;
        /**
         * Size of the component.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        this._showWeekNumber = false;
        /**
         * Fires newly selected date.
         * */
        this.dateChange = new EventEmitter();
    }
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    set setCellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges({ visibleDate, boundingMonths }) {
        if (visibleDate || boundingMonths) {
            this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths);
        }
    }
    onSelect(day) {
        this.dateChange.emit(day);
    }
}
NbCalendarDayPickerComponent.ɵfac = function NbCalendarDayPickerComponent_Factory(t) { return new (t || NbCalendarDayPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbCalendarMonthModelService)); };
NbCalendarDayPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDayPickerComponent, selectors: [["nb-calendar-day-picker"]], hostVars: 2, hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.large);
    } }, inputs: { boundingMonths: "boundingMonths", size: "size", setCellComponent: ["cellComponent", "setCellComponent"], showWeekNumber: "showWeekNumber", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter", date: "date", weekNumberSymbol: "weekNumberSymbol" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 10, consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "size"], [3, "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size", "select"], [3, "weeks", "size", "weekNumberSymbol"]], template: function NbCalendarDayPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "nb-calendar-days-names", 2);
        ɵngcc0.ɵɵelementStart(3, "nb-calendar-picker", 3);
        ɵngcc0.ɵɵlistener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showWeekNumber);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("size", ctx.size);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("size", ctx.size);
    } }, directives: function () { return [ɵngcc2.NgIf, NbCalendarDaysNamesComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent]; }, styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"], changeDetection: 0 });
NbCalendarDayPickerComponent.ctorParameters = () => [
    { type: NbCalendarMonthModelService }
];
NbCalendarDayPickerComponent.propDecorators = {
    visibleDate: [{ type: Input }],
    boundingMonths: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    setCellComponent: [{ type: Input, args: ['cellComponent',] }],
    size: [{ type: Input }],
    date: [{ type: Input }],
    showWeekNumber: [{ type: Input }],
    weekNumberSymbol: [{ type: Input }],
    dateChange: [{ type: Output }],
    large: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarDayPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-day-picker',
                template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names [size]="size"></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [size]="size"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex}.days-container{width:100%}\n"]
            }]
    }], function () { return [{ type: NbCalendarMonthModelService }]; }, { boundingMonths: [{
            type: Input
        }], size: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], setCellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], showWeekNumber: [{
            type: Input
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], date: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarDaysNamesComponent {
    constructor(dateService) {
        this.dateService = dateService;
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnInit() {
        const days = this.createDaysNames();
        this.days = this.shiftStartOfWeek(days);
    }
    createDaysNames() {
        return this.dateService.getDayOfWeekNames()
            .map(this.markIfHoliday);
    }
    shiftStartOfWeek(days) {
        for (let i = 0; i < this.dateService.getFirstDayOfWeek(); i++) {
            days.push(days.shift());
        }
        return days;
    }
    markIfHoliday(name, i) {
        return { name, isHoliday: i % 6 === 0 };
    }
}
NbCalendarDaysNamesComponent.ɵfac = function NbCalendarDaysNamesComponent_Factory(t) { return new (t || NbCalendarDaysNamesComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarDaysNamesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDaysNamesComponent, selectors: [["nb-calendar-days-names"]], hostVars: 2, hostBindings: function NbCalendarDaysNamesComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.isLarge);
    } }, inputs: { size: "size" }, decls: 1, vars: 1, consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]], template: function NbCalendarDaysNamesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.days);
    } }, directives: [ɵngcc2.NgForOf], styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}"], changeDetection: 0 });
NbCalendarDaysNamesComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarDaysNamesComponent.propDecorators = {
    size: [{ type: Input }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarDaysNamesComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-days-names',
                template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n"]
            }]
    }], function () { return [{ type: NbDateService }]; }, { isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], size: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarMonthCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.monthCellClass = true;
    }
    get selected() {
        return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
    }
    get today() {
        return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    get month() {
        return this.dateService.getMonthName(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
    }
    monthStart() {
        return this.dateService.getMonthStart(this.date);
    }
    monthEnd() {
        return this.dateService.getMonthEnd(this.date);
    }
}
NbCalendarMonthCellComponent.ɵfac = function NbCalendarMonthCellComponent_Factory(t) { return new (t || NbCalendarMonthCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarMonthCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarMonthCellComponent, selectors: [["nb-calendar-month-cell"]], hostVars: 10, hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("month-cell", ctx.monthCellClass)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", selectedValue: "selectedValue", min: "min", max: "max" }, outputs: { select: "select" }, decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarMonthCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.month, " ");
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarMonthCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarMonthCellComponent.propDecorators = {
    date: [{ type: Input }],
    selectedValue: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    monthCellClass: [{ type: HostBinding, args: ['class.month-cell',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarMonthCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-month-cell',
                template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], monthCellClass: [{
            type: HostBinding,
            args: ['class.month-cell']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const MONTHS_IN_VIEW = 12;
const MONTHS_IN_COLUMN = 4;
class NbCalendarMonthPickerComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.monthChange = new EventEmitter();
        this.cellComponent = NbCalendarMonthCellComponent;
    }
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges(changes) {
        if (changes.month) {
            this.initMonths();
        }
    }
    initMonths() {
        const date = this.dateService.getDate(this.month);
        const year = this.dateService.getYear(this.month);
        const firstMonth = this.dateService.createDate(year, 0, date);
        const months = [firstMonth];
        for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
            months.push(this.dateService.addMonth(firstMonth, monthIndex));
        }
        this.months = batch(months, MONTHS_IN_COLUMN);
    }
    onSelect(month) {
        this.monthChange.emit(month);
    }
}
NbCalendarMonthPickerComponent.ɵfac = function NbCalendarMonthPickerComponent_Factory(t) { return new (t || NbCalendarMonthPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarMonthPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarMonthPickerComponent, selectors: [["nb-calendar-month-picker"]], hostVars: 2, hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.large);
    } }, inputs: { size: "size", _cellComponent: ["cellComponent", "_cellComponent"], min: "min", max: "max", filter: "filter", month: "month", date: "date" }, outputs: { monthChange: "monthChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 8, consts: [[3, "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size", "select"]], template: function NbCalendarMonthPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker", 0);
        ɵngcc0.ɵɵlistener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.month)("cellComponent", ctx.cellComponent)("size", ctx.size);
    } }, directives: function () { return [NbCalendarPickerComponent]; }, encapsulation: 2, changeDetection: 0 });
NbCalendarMonthPickerComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarMonthPickerComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    size: [{ type: Input }],
    month: [{ type: Input }],
    date: [{ type: Input }],
    monthChange: [{ type: Output }],
    _cellComponent: [{ type: Input, args: ['cellComponent',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarMonthPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-month-picker',
                template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="month"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], monthChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], month: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarYearModelService {
    constructor(dateService) {
        this.dateService = dateService;
        this.yearsInView = 12;
        this.yearsInRow = 4;
    }
    getYearsInView() {
        return this.yearsInView;
    }
    getYearsInRow() {
        return this.yearsInRow;
    }
    getViewYears(viewYear) {
        const year = this.dateService.getYear(viewYear);
        let viewStartYear;
        if (year >= 0) {
            viewStartYear = year - (year % this.yearsInView);
        }
        else {
            viewStartYear = year - (year % this.yearsInView + this.yearsInView);
        }
        const years = range(this.yearsInView).map(i => this.copyWithYear(viewStartYear + i, viewYear));
        return batch(years, this.yearsInRow);
    }
    copyWithYear(year, date) {
        return this.dateService.createDate(year, this.dateService.getMonth(date), this.dateService.getDate(date));
    }
}
NbCalendarYearModelService.ɵfac = function NbCalendarYearModelService_Factory(t) { return new (t || NbCalendarYearModelService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbCalendarYearModelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbCalendarYearModelService, factory: NbCalendarYearModelService.ɵfac });
NbCalendarYearModelService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarYearModelService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarViewModeComponent {
    constructor(dateService, yearModelService) {
        this.dateService = dateService;
        this.yearModelService = yearModelService;
        this.viewMode = NbCalendarViewMode.DATE;
        this.changeMode = new EventEmitter(true);
    }
    getText() {
        if (!this.date) {
            return '';
        }
        switch (this.viewMode) {
            case NbCalendarViewMode.DATE: {
                const month = this.dateService.getMonthName(this.date, TranslationWidth.Wide);
                const year = this.dateService.getYear(this.date);
                return `${month} ${year}`;
            }
            case NbCalendarViewMode.MONTH:
                return `${this.dateService.getYear(this.date)}`;
            case NbCalendarViewMode.YEAR:
                return `${this.getFirstYear()} - ${this.getLastYear()}`;
        }
    }
    getIcon() {
        if (this.viewMode === NbCalendarViewMode.DATE) {
            return 'chevron-down-outline';
        }
        return 'chevron-up-outline';
    }
    getFirstYear() {
        const years = this.yearModelService.getViewYears(this.date);
        return this.dateService.getYear(years[0][0]).toString();
    }
    getLastYear() {
        const years = this.yearModelService.getViewYears(this.date);
        const lastRow = years[years.length - 1];
        const lastYear = lastRow[lastRow.length - 1];
        return this.dateService.getYear(lastYear).toString();
    }
}
NbCalendarViewModeComponent.ɵfac = function NbCalendarViewModeComponent_Factory(t) { return new (t || NbCalendarViewModeComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NbCalendarYearModelService)); };
NbCalendarViewModeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarViewModeComponent, selectors: [["nb-calendar-view-mode"]], inputs: { viewMode: "viewMode", date: "date" }, outputs: { changeMode: "changeMode" }, decls: 3, vars: 2, consts: [["nbButton", "", "ghost", "", "status", "basic", 3, "click"], ["pack", "nebular-essentials", 3, "icon"]], template: function NbCalendarViewModeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbCalendarViewModeComponent_Template_button_click_0_listener() { return ctx.changeMode.emit(); });
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelement(2, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.getText(), " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("icon", ctx.getIcon());
    } }, directives: [NbButtonComponent, NbIconComponent], encapsulation: 2, changeDetection: 0 });
NbCalendarViewModeComponent.ctorParameters = () => [
    { type: NbDateService },
    { type: NbCalendarYearModelService }
];
NbCalendarViewModeComponent.propDecorators = {
    date: [{ type: Input }],
    viewMode: [{ type: Input }],
    changeMode: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarViewModeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-view-mode',
                template: `
    <button nbButton (click)="changeMode.emit()" ghost status="basic">
      {{ getText() }}
      <nb-icon [icon]="getIcon()" pack="nebular-essentials"></nb-icon>
    </button>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }, { type: NbCalendarYearModelService }]; }, { viewMode: [{
            type: Input
        }], changeMode: [{
            type: Output
        }], date: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarPageableNavigationComponent {
    constructor(directionService) {
        this.directionService = directionService;
        this.next = new EventEmitter();
        this.prev = new EventEmitter();
    }
    get isLtr() {
        return this.directionService.isLtr();
    }
}
NbCalendarPageableNavigationComponent.ɵfac = function NbCalendarPageableNavigationComponent_Factory(t) { return new (t || NbCalendarPageableNavigationComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService)); };
NbCalendarPageableNavigationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPageableNavigationComponent, selectors: [["nb-calendar-pageable-navigation"]], outputs: { next: "next", prev: "prev" }, decls: 4, vars: 2, consts: [["nbButton", "", "ghost", "", "status", "basic", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], ["nbButton", "", "ghost", "", "status", "basic", 1, "next-month", 3, "click"]], template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() { return ctx.prev.emit(); });
        ɵngcc0.ɵɵelement(1, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_2_listener() { return ctx.next.emit(); });
        ɵngcc0.ɵɵelement(3, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
    } }, directives: [NbButtonComponent, NbIconComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:flex-start}"] });
NbCalendarPageableNavigationComponent.ctorParameters = () => [
    { type: NbLayoutDirectionService }
];
NbCalendarPageableNavigationComponent.propDecorators = {
    next: [{ type: Output }],
    prev: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarPageableNavigationComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-pageable-navigation',
                template: `
    <button nbButton (click)="prev.emit()" ghost status="basic" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <button nbButton (click)="next.emit()" ghost status="basic" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
                styles: [":host{display:flex;align-items:center;justify-content:flex-start}\n"]
            }]
    }], function () { return [{ type: NbLayoutDirectionService }]; }, { next: [{
            type: Output
        }], prev: [{
            type: Output
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarPickerComponent {
    constructor() {
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
}
NbCalendarPickerComponent.ɵfac = function NbCalendarPickerComponent_Factory(t) { return new (t || NbCalendarPickerComponent)(); };
NbCalendarPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPickerComponent, selectors: [["nb-calendar-picker"]], hostVars: 2, hostBindings: function NbCalendarPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.isLarge);
    } }, inputs: { size: "size", data: "data", visibleDate: "visibleDate", selectedValue: "selectedValue", cellComponent: "cellComponent", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, decls: 1, vars: 1, consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select", 4, "ngFor", "ngForOf"], [3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select"]], template: function NbCalendarPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 8, "nb-calendar-picker-row", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data);
    } }, directives: function () { return [ɵngcc2.NgForOf, NbCalendarPickerRowComponent]; }, encapsulation: 2, changeDetection: 0 });
NbCalendarPickerComponent.propDecorators = {
    data: [{ type: Input }],
    visibleDate: [{ type: Input }],
    selectedValue: [{ type: Input }],
    cellComponent: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-picker',
                template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [size]="size"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], data: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], cellComponent: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarPickerRowComponent {
    constructor(cfr) {
        this.cfr = cfr;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter();
    }
    ngOnChanges() {
        const factory = this.cfr.resolveComponentFactory(this.component);
        this.containerRef.clear();
        this.row.forEach((date) => {
            const component = this.containerRef.createComponent(factory);
            this.patchWithContext(component.instance, date);
            component.changeDetectorRef.detectChanges();
        });
    }
    patchWithContext(component, date) {
        component.visibleDate = this.visibleDate;
        component.selectedValue = this.selectedValue;
        component.date = date;
        component.min = this.min;
        component.max = this.max;
        component.filter = this.filter;
        component.size = this.size;
        component.select.subscribe(this.select.emit.bind(this.select));
    }
}
NbCalendarPickerRowComponent.ɵfac = function NbCalendarPickerRowComponent_Factory(t) { return new (t || NbCalendarPickerRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
NbCalendarPickerRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPickerRowComponent, selectors: [["nb-calendar-picker-row"]], viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(TemplateRef, 3, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);
    } }, inputs: { size: "size", row: "row", selectedValue: "selectedValue", visibleDate: "visibleDate", component: "component", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, template: function NbCalendarPickerRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
    } }, styles: ["[_nghost-%COMP%] {\n      display: flex;\n      justify-content: space-between;\n    }"], changeDetection: 0 });
NbCalendarPickerRowComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];
NbCalendarPickerRowComponent.propDecorators = {
    row: [{ type: Input }],
    selectedValue: [{ type: Input }],
    visibleDate: [{ type: Input }],
    component: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    containerRef: [{ type: ViewChild, args: [TemplateRef, { read: ViewContainerRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarPickerRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-picker-row',
                template: '<ng-template></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: flex;
      justify-content: space-between;
    }
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], row: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], component: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], containerRef: [{
            type: ViewChild,
            args: [TemplateRef, { read: ViewContainerRef, static: true }]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarYearCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.yearCellClass = true;
    }
    get selected() {
        return this.dateService.isSameYearSafe(this.date, this.selectedValue);
    }
    get today() {
        return this.dateService.isSameYearSafe(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    get year() {
        return this.dateService.getYear(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
    }
    yearStart() {
        return this.dateService.getYearStart(this.date);
    }
    yearEnd() {
        return this.dateService.getYearEnd(this.date);
    }
}
NbCalendarYearCellComponent.ɵfac = function NbCalendarYearCellComponent_Factory(t) { return new (t || NbCalendarYearCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarYearCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarYearCellComponent, selectors: [["nb-calendar-year-cell"]], hostVars: 10, hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("year-cell", ctx.yearCellClass)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", min: "min", max: "max", selectedValue: "selectedValue" }, outputs: { select: "select" }, decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarYearCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.year, " ");
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarYearCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarYearCellComponent.propDecorators = {
    date: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    selectedValue: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    yearCellClass: [{ type: HostBinding, args: ['class.year-cell',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarYearCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-year-cell',
                template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], yearCellClass: [{
            type: HostBinding,
            args: ['class.year-cell']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarYearPickerComponent {
    constructor(dateService, yearModelService) {
        this.dateService = dateService;
        this.yearModelService = yearModelService;
        this.cellComponent = NbCalendarYearCellComponent;
        this.size = NbCalendarSize.MEDIUM;
        this.yearChange = new EventEmitter();
    }
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges() {
        this.years = this.yearModelService.getViewYears(this.year);
    }
    onSelect(year) {
        this.yearChange.emit(year);
    }
}
NbCalendarYearPickerComponent.ɵfac = function NbCalendarYearPickerComponent_Factory(t) { return new (t || NbCalendarYearPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NbCalendarYearModelService)); };
NbCalendarYearPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarYearPickerComponent, selectors: [["nb-calendar-year-picker"]], hostVars: 2, hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.large);
    } }, inputs: { size: "size", _cellComponent: ["cellComponent", "_cellComponent"], date: "date", min: "min", max: "max", filter: "filter", year: "year" }, outputs: { yearChange: "yearChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 8, consts: [[3, "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size", "select"]], template: function NbCalendarYearPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker", 0);
        ɵngcc0.ɵɵlistener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent)("size", ctx.size);
    } }, directives: [NbCalendarPickerComponent], encapsulation: 2, changeDetection: 0 });
NbCalendarYearPickerComponent.ctorParameters = () => [
    { type: NbDateService },
    { type: NbCalendarYearModelService }
];
NbCalendarYearPickerComponent.propDecorators = {
    date: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    _cellComponent: [{ type: Input, args: ['cellComponent',] }],
    size: [{ type: Input }],
    year: [{ type: Input }],
    yearChange: [{ type: Output }],
    large: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarYearPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-year-picker',
                template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }, { type: NbCalendarYearModelService }]; }, { size: [{
            type: Input
        }], yearChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], year: [{
            type: Input
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarWeekNumberComponent {
    constructor(dateService) {
        this.dateService = dateService;
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges(changes) {
        if (changes.weeks) {
            this.weekNumbers = this.getWeeks();
        }
    }
    getWeeks() {
        return this.weeks.map((week) => {
            // Find last defined day as week could contain null days in case
            // boundingMonth set to false
            const lastDay = [...week].reverse().find((day) => !!day);
            // Use last day of the week to determine week number.
            // This way weeks which span between sibling years is marked first
            return this.dateService.getWeekNumber(lastDay);
        });
    }
}
NbCalendarWeekNumberComponent.ɵfac = function NbCalendarWeekNumberComponent_Factory(t) { return new (t || NbCalendarWeekNumberComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarWeekNumberComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarWeekNumberComponent, selectors: [["nb-calendar-week-numbers"]], hostVars: 2, hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-large", ctx.isLarge);
    } }, inputs: { weeks: "weeks", size: "size", weekNumberSymbol: "weekNumberSymbol" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 4, vars: 2, consts: [[1, "sign-container"], [1, "sign"], ["class", "week-number", 4, "ngFor", "ngForOf"], [1, "week-number"]], template: function NbCalendarWeekNumberComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbCalendarWeekNumberComponent_div_3_Template, 2, 1, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.weekNumberSymbol);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.weekNumbers);
    } }, directives: [ɵngcc2.NgForOf], styles: [_c8], changeDetection: 0 });
NbCalendarWeekNumberComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarWeekNumberComponent.propDecorators = {
    weeks: [{ type: Input }],
    size: [{ type: Input }],
    weekNumberSymbol: [{ type: Input }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarWeekNumberComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-week-numbers',
                template: `
    <div class="sign-container">
      <div class="sign">{{ weekNumberSymbol }}</div>
    </div>
    <div class="week-number" *ngFor="let weekNumber of weekNumbers">{{ weekNumber }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbDateService }]; }, { isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], weeks: [{
            type: Input
        }], size: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbNativeDateService` is basic implementation of `NbDateService` using
 * native js date objects and angular localization services.
 * */
class NbNativeDateService extends NbDateService {
    constructor(locale) {
        super();
        this.setLocale(locale);
    }
    setLocale(locale) {
        super.setLocale(locale);
        this.datePipe = new DatePipe(locale);
    }
    setHours(date, hour) {
        const result = this.clone(date);
        result.setHours(hour);
        return result;
    }
    setMinutes(date, minute) {
        const result = this.clone(date);
        result.setMinutes(minute);
        return result;
    }
    setSeconds(date, second) {
        const result = this.clone(date);
        result.setSeconds(second);
        return result;
    }
    setMilliseconds(date, second) {
        const result = this.clone(date);
        result.setMilliseconds(second);
        return result;
    }
    isValidDateString(date, format) {
        return !isNaN(this.parse(date, format).getTime());
    }
    isValidTimeString(date, format) {
        return this.isValidDateString(date, format);
    }
    today() {
        return new Date();
    }
    getLocaleTimeFormat() {
        return getLocaleTimeFormat(this.locale, FormatWidth.Short);
    }
    getDate(date) {
        return date.getDate();
    }
    getMonth(date) {
        return date.getMonth();
    }
    getYear(date) {
        return date.getFullYear();
    }
    getDayOfWeek(date) {
        return date.getDay();
    }
    /**
     * returns first day of the week, it can be 1 if week starts from monday
     * and 0 if from sunday and so on.
     * */
    getFirstDayOfWeek() {
        return getLocaleFirstDayOfWeek(this.locale);
    }
    getMonthName(date, style$$1 = TranslationWidth.Abbreviated) {
        const index = date.getMonth();
        return this.getMonthNameByIndex(index, style$$1);
    }
    getMonthNameByIndex(index, style$$1 = TranslationWidth.Abbreviated) {
        return getLocaleMonthNames(this.locale, FormStyle.Format, style$$1)[index];
    }
    getDayOfWeekNames() {
        return [...getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short)];
    }
    format(date, format) {
        return this.datePipe.transform(date, format);
    }
    /**
     * We haven't got capability to parse date using formatting without third party libraries.
     * */
    parse(date, format) {
        return new Date(Date.parse(date));
    }
    addDay(date, num) {
        return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
    }
    addMonth(date, num) {
        const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
        // In case of date has more days than calculated month js Date will change that month to the next one
        // because of the date overflow.
        month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
        return month;
    }
    addMinutes(date, minute) {
        const result = new Date(date);
        result.setMinutes(date.getMinutes() + minute);
        return result;
    }
    addHours(date, hour) {
        const result = new Date(date);
        result.setHours(date.getHours() + hour);
        return result;
    }
    getHours(date) {
        return date.getHours();
    }
    getMinutes(date) {
        return date.getMinutes();
    }
    getSeconds(date) {
        return date.getSeconds();
    }
    getMilliseconds(date) {
        return date.getMilliseconds();
    }
    addYear(date, num) {
        return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
    }
    clone(date) {
        return new Date(date.getTime());
    }
    compareDates(date1, date2) {
        return date1.getTime() - date2.getTime();
    }
    createDate(year, month, date) {
        const result = new Date(year, month, date);
        // We need to correct for the fact that JS native Date treats years in range [0, 99] as
        // abbreviations for 19xx.
        if (year >= 0 && year < 100) {
            result.setFullYear(result.getFullYear() - 1900);
        }
        return result;
    }
    getMonthEnd(date) {
        return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
    }
    getMonthStart(date) {
        return this.createDate(date.getFullYear(), date.getMonth(), 1);
    }
    getNumberOfDaysInMonth(date) {
        return this.getMonthEnd(date).getDate();
    }
    getYearEnd(date) {
        return this.createDate(date.getFullYear(), 11, 31);
    }
    getYearStart(date) {
        return this.createDate(date.getFullYear(), 0, 1);
    }
    valueOf(date) {
        return date.valueOf();
    }
    isSameDay(date1, date2) {
        return this.isSameMonth(date1, date2) &&
            date1.getDate() === date2.getDate();
    }
    isSameMonth(date1, date2) {
        return this.isSameYear(date1, date2) &&
            date1.getMonth() === date2.getMonth();
    }
    isSameYear(date1, date2) {
        return date1.getFullYear() === date2.getFullYear();
    }
    getId() {
        return 'native';
    }
    getWeekNumber(date) {
        return parseInt(this.datePipe.transform(date, 'w'), 10);
    }
    getDateFormat() {
        return 'yyyy-MM-dd';
    }
    getTwelveHoursFormat() {
        return 'hh:mm a';
    }
}
NbNativeDateService.ɵfac = function NbNativeDateService_Factory(t) { return new (t || NbNativeDateService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
NbNativeDateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbNativeDateService, factory: NbNativeDateService.ɵfac });
NbNativeDateService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbNativeDateService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();

class NbCalendarTimeModelService {
    constructor(dateService) {
        this.dateService = dateService;
        this.MINUTES_AND_SECONDS = 60;
    }
    getHoursRange(step = this.MINUTES_AND_SECONDS) {
        let date = this.getResetTime();
        const endDate = this.dateService.addDay(date, 1);
        const result = [];
        while (this.dateService.compareDates(date, endDate) < 0) {
            result.push(date);
            date = this.dateService.addMinutes(date, step);
        }
        return result;
    }
    getResetTime() {
        let today = this.dateService.today();
        today = this.dateService.setHours(today, 0);
        today = this.dateService.setMinutes(today, 0);
        today = this.dateService.setSeconds(today, 0);
        today = this.dateService.setMilliseconds(today, 0);
        return today;
    }
    paddToTwoSymbols(n) {
        if (n < 10) {
            return '0' + n;
        }
        return n.toString();
    }
    buildDateFormat(twelveHoursFormat, withSeconds = false) {
        if (twelveHoursFormat) {
            return `${this.dateService.getDateFormat()} ${this.dateService.getTwelveHoursFormat()}`;
        }
        if (withSeconds) {
            return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormatWithSeconds()}`;
        }
        return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormat()}`;
    }
}
NbCalendarTimeModelService.ɵfac = function NbCalendarTimeModelService_Factory(t) { return new (t || NbCalendarTimeModelService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbCalendarTimeModelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbCalendarTimeModelService, factory: NbCalendarTimeModelService.ɵfac });
NbCalendarTimeModelService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarTimeModelService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();

class NbCalendarActionsComponent {
    constructor() {
        this._applyButtonText = 'ok';
        this._currentTimeButtonText = 'now';
        this.setCurrentTime = new EventEmitter();
        this.saveValue = new EventEmitter();
    }
    set applyButtonText(value) {
        if (value) {
            this._applyButtonText = value;
        }
    }
    ;
    get applyText() {
        return this._applyButtonText;
    }
    ;
    set currentTimeButtonText(value) {
        if (value) {
            this._currentTimeButtonText = value;
        }
    }
    get currentTimeText() {
        return this._currentTimeButtonText;
    }
    ;
}
NbCalendarActionsComponent.ɵfac = function NbCalendarActionsComponent_Factory(t) { return new (t || NbCalendarActionsComponent)(); };
NbCalendarActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarActionsComponent, selectors: [["nb-calendar-actions"]], inputs: { applyButtonText: "applyButtonText", currentTimeButtonText: "currentTimeButtonText" }, outputs: { setCurrentTime: "setCurrentTime", saveValue: "saveValue" }, decls: 4, vars: 2, consts: [["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click"], ["nbButton", "", "status", "primary", "size", "small", 3, "click"]], template: function NbCalendarActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbCalendarActionsComponent_Template_button_click_0_listener() { return ctx.setCurrentTime.emit(); });
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NbCalendarActionsComponent_Template_button_click_2_listener() { return ctx.saveValue.emit(); });
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.currentTimeText, "");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.applyText, "");
    } }, directives: [NbButtonComponent], styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}"], changeDetection: 0 });
NbCalendarActionsComponent.propDecorators = {
    applyButtonText: [{ type: Input }],
    currentTimeButtonText: [{ type: Input }],
    setCurrentTime: [{ type: Output }],
    saveValue: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarActionsComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-actions',
                template: `
    <button
      nbButton
      ghost
      status="primary"
      size="small"
      (click)="setCurrentTime.emit()">
      {{ currentTimeText }}</button>
    <button
      nbButton
      status="primary"
      size="small"
      (click)="saveValue.emit()">
      {{ applyText }}</button>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;justify-content:space-between}\n"]
            }]
    }], function () { return []; }, { setCurrentTime: [{
            type: Output
        }], saveValue: [{
            type: Output
        }], applyButtonText: [{
            type: Input
        }], currentTimeButtonText: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const SERVICES = [
    { provide: NbDateService, useClass: NbNativeDateService },
    DatePipe,
    NbCalendarMonthModelService,
    NbCalendarYearModelService,
    NbCalendarTimeModelService,
];
const COMPONENTS = [
    NbCalendarViewModeComponent,
    NbCalendarPageableNavigationComponent,
    NbCalendarDaysNamesComponent,
    NbCalendarYearPickerComponent,
    NbCalendarMonthPickerComponent,
    NbCalendarDayPickerComponent,
    NbCalendarDayCellComponent,
    NbCalendarActionsComponent,
    NbCalendarMonthCellComponent,
    NbCalendarYearCellComponent,
    NbCalendarPickerRowComponent,
    NbCalendarPickerComponent,
    NbCalendarWeekNumberComponent,
];
/**
 * `NbCalendarKitModule` is a module that contains multiple useful components for building custom calendars.
 * So if you think our calendars is not enough powerful for you just use calendar-kit and build your own calendar!
 *
 * Available components:
 * - `NbCalendarDayPicker`
 * - `NbCalendarDayCell`
 * - `NbCalendarMonthPicker`
 * - `NbCalendarMonthCell`
 * - `NbCalendarYearPicker`
 * - `NbCalendarYearCell`
 * - `NbCalendarViewModeComponent`
 * - `NbCalendarPageableNavigation`
 *
 * For example you can easily build full calendar:
 * @stacked-example(Full calendar, calendar-kit/calendar-kit-full-calendar.component)
 * */
class NbCalendarKitModule {
}
NbCalendarKitModule.ɵfac = function NbCalendarKitModule_Factory(t) { return new (t || NbCalendarKitModule)(); };
NbCalendarKitModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarKitModule });
NbCalendarKitModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [...SERVICES], imports: [[NbSharedModule, NbButtonModule, NbIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarKitModule, { declarations: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent], imports: [NbSharedModule, NbButtonModule, NbIconModule], exports: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarKitModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbButtonModule, NbIconModule],
                exports: [...COMPONENTS],
                declarations: [...COMPONENTS],
                providers: [...SERVICES],
                entryComponents: [
                    NbCalendarDayCellComponent,
                    NbCalendarMonthCellComponent,
                    NbCalendarYearCellComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The basis for calendar and range calendar components.
 * Encapsulates common behavior - store calendar state and perform navigation
 * between pickers.
 * */
class NbBaseCalendarComponent {
    constructor(dateService, yearModelService) {
        this.dateService = dateService;
        this.yearModelService = yearModelService;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines active view for calendar.
         * */
        this.activeViewMode = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines whether we should show calendar navigation or not.
         * */
        this.showNavigation = true;
        this._showWeekNumber = false;
        /**
         * Emits date when selected.
         * */
        this.dateChange = new EventEmitter();
        this.ViewMode = NbCalendarViewMode;
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    ngOnInit() {
        if (!this.visibleDate) {
            this.visibleDate = this.dateService.today();
        }
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    setViewMode(viewMode) {
        this.activeViewMode = viewMode;
    }
    setVisibleDate(visibleDate) {
        this.visibleDate = visibleDate;
    }
    prevMonth() {
        this.changeVisibleMonth(-1);
    }
    nextMonth() {
        this.changeVisibleMonth(1);
    }
    prevYear() {
        this.changeVisibleYear(-1);
    }
    nextYear() {
        this.changeVisibleYear(1);
    }
    prevYears() {
        this.changeVisibleYears(-1);
    }
    nextYears() {
        this.changeVisibleYears(1);
    }
    navigatePrev() {
        switch (this.activeViewMode) {
            case NbCalendarViewMode.DATE:
                return this.prevMonth();
            case NbCalendarViewMode.MONTH:
                return this.prevYear();
            case NbCalendarViewMode.YEAR:
                return this.prevYears();
        }
    }
    navigateNext() {
        switch (this.activeViewMode) {
            case NbCalendarViewMode.DATE:
                return this.nextMonth();
            case NbCalendarViewMode.MONTH:
                return this.nextYear();
            case NbCalendarViewMode.YEAR:
                return this.nextYears();
        }
    }
    onChangeViewMode() {
        if (this.activeViewMode === NbCalendarViewMode.DATE) {
            return this.setViewMode(NbCalendarViewMode.YEAR);
        }
        this.setViewMode(NbCalendarViewMode.DATE);
    }
    changeVisibleMonth(direction) {
        this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
    }
    changeVisibleYear(direction) {
        this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
    }
    changeVisibleYears(direction) {
        this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
    }
}
NbBaseCalendarComponent.ɵfac = function NbBaseCalendarComponent_Factory(t) { return new (t || NbBaseCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NbCalendarYearModelService)); };
NbBaseCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBaseCalendarComponent, selectors: [["nb-base-calendar"]], hostVars: 6, hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("has-navigation", ctx.showNavigation)("has-week-number", ctx.showWeekNumber)("size-large", ctx.large);
    } }, inputs: { boundingMonth: "boundingMonth", activeViewMode: ["startView", "activeViewMode"], size: "size", showNavigation: "showNavigation", showWeekNumber: "showWeekNumber", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", date: "date", weekNumberSymbol: "weekNumberSymbol" }, outputs: { dateChange: "dateChange" }, decls: 6, vars: 5, consts: [["class", "calendar-navigation", 4, "ngIf"], [3, "ngSwitch"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "weekNumberSymbol", "dateChange", 4, "ngSwitchCase"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange", 4, "ngSwitchCase"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange", 4, "ngSwitchCase"], [1, "calendar-navigation"], [3, "date", "viewMode", "changeMode"], [3, "prev", "next"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "weekNumberSymbol", "dateChange"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange"]], template: function NbBaseCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-card");
        ɵngcc0.ɵɵtemplate(1, NbBaseCalendarComponent_nb_card_header_1_Template, 3, 2, "nb-card-header", 0);
        ɵngcc0.ɵɵelementStart(2, "nb-card-body", 1);
        ɵngcc0.ɵɵtemplate(3, NbBaseCalendarComponent_nb_calendar_day_picker_3_Template, 1, 10, "nb-calendar-day-picker", 2);
        ɵngcc0.ɵɵtemplate(4, NbBaseCalendarComponent_nb_calendar_year_picker_4_Template, 1, 7, "nb-calendar-year-picker", 3);
        ɵngcc0.ɵɵtemplate(5, NbBaseCalendarComponent_nb_calendar_month_picker_5_Template, 1, 7, "nb-calendar-month-picker", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.activeViewMode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.DATE);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.YEAR);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.MONTH);
    } }, directives: [NbCardComponent, ɵngcc2.NgIf, NbCardBodyComponent, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, NbCardHeaderComponent, NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDayPickerComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent], encapsulation: 2 });
NbBaseCalendarComponent.ctorParameters = () => [
    { type: NbDateService },
    { type: NbCalendarYearModelService }
];
NbBaseCalendarComponent.propDecorators = {
    boundingMonth: [{ type: Input }],
    activeViewMode: [{ type: Input, args: ['startView',] }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    dayCellComponent: [{ type: Input }],
    monthCellComponent: [{ type: Input }],
    yearCellComponent: [{ type: Input }],
    size: [{ type: Input }],
    visibleDate: [{ type: Input }],
    showNavigation: [{ type: Input }, { type: HostBinding, args: ['class.has-navigation',] }],
    date: [{ type: Input }],
    showWeekNumber: [{ type: Input }, { type: HostBinding, args: ['class.has-week-number',] }],
    weekNumberSymbol: [{ type: Input }],
    dateChange: [{ type: Output }],
    large: [{ type: HostBinding, args: ['class.size-large',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBaseCalendarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-base-calendar',
                template: "<nb-card>\n  <nb-card-header *ngIf=\"showNavigation\" class=\"calendar-navigation\">\n    <nb-calendar-view-mode [date]=\"visibleDate\"\n                           [viewMode]=\"activeViewMode\"\n                           (changeMode)=\"onChangeViewMode()\">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)=\"navigatePrev()\" (next)=\"navigateNext()\">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]=\"activeViewMode\">\n\n    <nb-calendar-day-picker *ngSwitchCase=\"ViewMode.DATE\"\n                            [boundingMonths]=\"boundingMonth\"\n                            [cellComponent]=\"dayCellComponent\"\n                            [min]=\"min\"\n                            [max]=\"max\"\n                            [filter]=\"filter\"\n                            [visibleDate]=\"visibleDate\"\n                            [size]=\"size\"\n                            [date]=\"date\"\n                            [showWeekNumber]=\"showWeekNumber\"\n                            (dateChange)=\"dateChange.emit($any($event))\"\n                            [weekNumberSymbol]=\"weekNumberSymbol\">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase=\"ViewMode.YEAR\"\n                             [cellComponent]=\"yearCellComponent\"\n                             [date]=\"$any(date)\"\n                             [min]=\"min\"\n                             [max]=\"max\"\n                             [filter]=\"filter\"\n                             [size]=\"size\"\n                             [year]=\"visibleDate\"\n                             (yearChange)=\"setVisibleDate($event); setViewMode(ViewMode.MONTH)\">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase=\"ViewMode.MONTH\"\n                              [cellComponent]=\"monthCellComponent\"\n                              [min]=\"min\"\n                              [max]=\"max\"\n                              [filter]=\"filter\"\n                              [size]=\"size\"\n                              [month]=\"visibleDate\"\n                              [date]=\"$any(date)\"\n                              (monthChange)=\"setVisibleDate($event); setViewMode(ViewMode.DATE)\">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n"
            }]
    }], function () { return [{ type: NbDateService }, { type: NbCalendarYearModelService }]; }, { boundingMonth: [{
            type: Input
        }], activeViewMode: [{
            type: Input,
            args: ['startView']
        }], size: [{
            type: Input
        }], showNavigation: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.has-navigation']
        }], dateChange: [{
            type: Output
        }], showWeekNumber: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.has-week-number']
        }], visibleDate: [{
            type: Input
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], date: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbBaseCalendarModule {
}
NbBaseCalendarModule.ɵfac = function NbBaseCalendarModule_Factory(t) { return new (t || NbBaseCalendarModule)(); };
NbBaseCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBaseCalendarModule });
NbBaseCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbCalendarKitModule, NbSharedModule, NbCardModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbBaseCalendarModule, { declarations: [NbBaseCalendarComponent], imports: [NbCalendarKitModule, NbSharedModule, NbCardModule], exports: [NbBaseCalendarComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBaseCalendarModule, [{
        type: NgModule,
        args: [{
                imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
                exports: [NbBaseCalendarComponent],
                declarations: [NbBaseCalendarComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarModule {
}
NbCalendarModule.ɵfac = function NbCalendarModule_Factory(t) { return new (t || NbCalendarModule)(); };
NbCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarModule });
NbCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbBaseCalendarModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarModule, { declarations: [NbCalendarComponent], imports: [NbBaseCalendarModule], exports: [NbCalendarComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarModule, [{
        type: NgModule,
        args: [{
                imports: [NbBaseCalendarModule],
                exports: [NbCalendarComponent],
                declarations: [NbCalendarComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbBaseCalendarRangeCell {
    get hasRange() {
        return !!(this.selectedValue && this.selectedValue.start && this.selectedValue.end);
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarRangeDayCellComponent extends NbBaseCalendarRangeCell {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.rangeCellClass = true;
        this.dayCellClass = true;
    }
    get inRange() {
        if (this.date && this.hasRange) {
            return this.isInRange(this.date, this.selectedValue);
        }
        return false;
    }
    get start() {
        return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.start);
    }
    get end() {
        return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.end);
    }
    get today() {
        return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
    }
    get boundingMonth() {
        return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
    }
    get selected() {
        if (this.inRange) {
            return true;
        }
        if (this.selectedValue) {
            return this.dateService.isSameDaySafe(this.date, this.selectedValue.start);
        }
    }
    get empty() {
        return !this.date;
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    get day() {
        return this.date && this.dateService.getDate(this.date);
    }
    onClick() {
        if (this.disabled || this.empty) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
    }
    dontFitFilter() {
        return this.date && this.filter && !this.filter(this.date);
    }
    isInRange(date, { start, end }) {
        const isGreaterThanStart = this.dateService.compareDates(this.date, start) >= 0;
        const isLessThanEnd = this.dateService.compareDates(this.date, end) <= 0;
        return isGreaterThanStart && isLessThanEnd;
    }
}
NbCalendarRangeDayCellComponent.ɵfac = function NbCalendarRangeDayCellComponent_Factory(t) { return new (t || NbCalendarRangeDayCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeDayCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeDayCellComponent, selectors: [["nb-calendar-range-day-cell"]], hostVars: 22, hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("range-cell", ctx.rangeCellClass)("day-cell", ctx.dayCellClass)("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", selectedValue: "selectedValue", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.day);
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarRangeDayCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarRangeDayCellComponent.propDecorators = {
    date: [{ type: Input }],
    selectedValue: [{ type: Input }],
    visibleDate: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    inRange: [{ type: HostBinding, args: ['class.in-range',] }],
    start: [{ type: HostBinding, args: ['class.start',] }],
    end: [{ type: HostBinding, args: ['class.end',] }],
    rangeCellClass: [{ type: HostBinding, args: ['class.range-cell',] }],
    dayCellClass: [{ type: HostBinding, args: ['class.day-cell',] }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    boundingMonth: [{ type: HostBinding, args: ['class.bounding-month',] }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    empty: [{ type: HostBinding, args: ['class.empty',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarRangeDayCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range-day-cell',
                template: `
    <div class="cell-content">{{ day }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], rangeCellClass: [{
            type: HostBinding,
            args: ['class.range-cell']
        }], dayCellClass: [{
            type: HostBinding,
            args: ['class.day-cell']
        }], inRange: [{
            type: HostBinding,
            args: ['class.in-range']
        }], start: [{
            type: HostBinding,
            args: ['class.start']
        }], end: [{
            type: HostBinding,
            args: ['class.end']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], boundingMonth: [{
            type: HostBinding,
            args: ['class.bounding-month']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], empty: [{
            type: HostBinding,
            args: ['class.empty']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarRangeYearCellComponent extends NbBaseCalendarRangeCell {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.yearCellClass = true;
        this.rangeCellClass = true;
    }
    get inRange() {
        return this.hasRange && this.isInRange(this.date, this.selectedValue);
    }
    get rangeStart() {
        return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.start);
    }
    get rangeEnd() {
        return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.end);
    }
    get selected() {
        if (this.inRange) {
            return true;
        }
        if (this.selectedValue) {
            return this.dateService.isSameYearSafe(this.date, this.selectedValue.start);
        }
    }
    get today() {
        return this.dateService.isSameYear(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    get year() {
        return this.dateService.getYear(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
    }
    yearStart() {
        return this.dateService.getYearStart(this.date);
    }
    yearEnd() {
        return this.dateService.getYearEnd(this.date);
    }
    isInRange(date, { start, end }) {
        if (start && end) {
            const cellYear = this.dateService.getYear(date);
            const startYear = this.dateService.getYear(start);
            const endYear = this.dateService.getYear(end);
            return cellYear >= startYear && cellYear <= endYear;
        }
        return this.dateService.isSameYear(date, start);
    }
}
NbCalendarRangeYearCellComponent.ɵfac = function NbCalendarRangeYearCellComponent_Factory(t) { return new (t || NbCalendarRangeYearCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeYearCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeYearCellComponent, selectors: [["nb-calendar-range-year-cell"]], hostVars: 18, hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("year-cell", ctx.yearCellClass)("range-cell", ctx.rangeCellClass)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", min: "min", max: "max", selectedValue: "selectedValue" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.year, " ");
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarRangeYearCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarRangeYearCellComponent.propDecorators = {
    date: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    selectedValue: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    inRange: [{ type: HostBinding, args: ['class.in-range',] }],
    rangeStart: [{ type: HostBinding, args: ['class.start',] }],
    rangeEnd: [{ type: HostBinding, args: ['class.end',] }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    yearCellClass: [{ type: HostBinding, args: ['class.year-cell',] }],
    rangeCellClass: [{ type: HostBinding, args: ['class.range-cell',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarRangeYearCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range-year-cell',
                template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], yearCellClass: [{
            type: HostBinding,
            args: ['class.year-cell']
        }], rangeCellClass: [{
            type: HostBinding,
            args: ['class.range-cell']
        }], inRange: [{
            type: HostBinding,
            args: ['class.in-range']
        }], rangeStart: [{
            type: HostBinding,
            args: ['class.start']
        }], rangeEnd: [{
            type: HostBinding,
            args: ['class.end']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarRangeMonthCellComponent extends NbBaseCalendarRangeCell {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.select = new EventEmitter(true);
        this.monthCellClass = true;
        this.rangeCellClass = true;
    }
    get month() {
        return this.dateService.getMonthName(this.date);
    }
    get selected() {
        if (this.inRange) {
            return true;
        }
        if (this.selectedValue) {
            return this.dateService.isSameMonthSafe(this.date, this.selectedValue.start);
        }
    }
    get inRange() {
        if (this.hasRange) {
            return this.isInRage(this.date, this.selectedValue);
        }
    }
    get rangeStart() {
        if (this.hasRange) {
            return this.dateService.isSameMonth(this.date, this.selectedValue.start);
        }
    }
    get rangeEnd() {
        if (this.hasRange) {
            return this.dateService.isSameMonth(this.date, this.selectedValue.end);
        }
    }
    get today() {
        return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
    }
    monthStart() {
        return this.dateService.getMonthStart(this.date);
    }
    monthEnd() {
        return this.dateService.getMonthEnd(this.date);
    }
    isInRage(date, range) {
        if (range.start && range.end) {
            const cellDate = this.dateService.getMonthStart(date);
            const start = this.dateService.getMonthStart(range.start);
            const end = this.dateService.getMonthStart(range.end);
            const isGreaterThanStart = this.dateService.compareDates(cellDate, start) >= 0;
            const isLessThanEnd = this.dateService.compareDates(cellDate, end) <= 0;
            return isGreaterThanStart && isLessThanEnd;
        }
        return this.dateService.isSameMonth(date, range.start);
    }
}
NbCalendarRangeMonthCellComponent.ɵfac = function NbCalendarRangeMonthCellComponent_Factory(t) { return new (t || NbCalendarRangeMonthCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeMonthCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeMonthCellComponent, selectors: [["nb-calendar-range-month-cell"]], hostVars: 18, hostBindings: function NbCalendarRangeMonthCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarRangeMonthCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("month-cell", ctx.monthCellClass)("range-cell", ctx.rangeCellClass)("selected", ctx.selected)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    } }, inputs: { size: "size", date: "date", visibleDate: "visibleDate", selectedValue: "selectedValue", min: "min", max: "max" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "cell-content"]], template: function NbCalendarRangeMonthCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.month, " ");
    } }, encapsulation: 2, changeDetection: 0 });
NbCalendarRangeMonthCellComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarRangeMonthCellComponent.propDecorators = {
    date: [{ type: Input }],
    visibleDate: [{ type: Input }],
    selectedValue: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    size: [{ type: Input }],
    select: [{ type: Output }],
    monthCellClass: [{ type: HostBinding, args: ['class.month-cell',] }],
    rangeCellClass: [{ type: HostBinding, args: ['class.range-cell',] }],
    selected: [{ type: HostBinding, args: ['class.selected',] }],
    inRange: [{ type: HostBinding, args: ['class.in-range',] }],
    rangeStart: [{ type: HostBinding, args: ['class.start',] }],
    rangeEnd: [{ type: HostBinding, args: ['class.end',] }],
    today: [{ type: HostBinding, args: ['class.today',] }],
    disabled: [{ type: HostBinding, args: ['class.disabled',] }],
    isLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarRangeMonthCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range-month-cell',
                template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], select: [{
            type: Output
        }], monthCellClass: [{
            type: HostBinding,
            args: ['class.month-cell']
        }], rangeCellClass: [{
            type: HostBinding,
            args: ['class.range-cell']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], inRange: [{
            type: HostBinding,
            args: ['class.in-range']
        }], rangeStart: [{
            type: HostBinding,
            args: ['class.start']
        }], rangeEnd: [{
            type: HostBinding,
            args: ['class.end']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * CalendarRange component provides a capability to choose a date range.
 *
 * ```html
 * <nb-calendar [(date)]="date"></nb-calendar>
 * <nb-calendar [date]="date" (dateChange)="handleDateChange($event)"></nb-calendar>
 * ```
 *
 * Basic usage example
 * @stacked-example(Range, calendar/calendar-range-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCalendarRangeModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCalendarRangeModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * CalendarRange component supports all of the Calendar component customization properties. More defails can be found
 * in the [Calendar component docs](docs/components/calendar).
 *
 * @styles
 *
 * calendar-width:
 * calendar-background-color:
 * calendar-border-color:
 * calendar-border-style:
 * calendar-border-width:
 * calendar-border-radius:
 * calendar-text-color:
 * calendar-text-font-family:
 * calendar-text-font-size:
 * calendar-text-font-weight:
 * calendar-text-line-height:
 * calendar-picker-padding-top:
 * calendar-picker-padding-bottom:
 * calendar-picker-padding-start:
 * calendar-picker-padding-end:
 * calendar-navigation-text-color:
 * calendar-navigation-text-font-family:
 * calendar-navigation-title-text-font-size:
 * calendar-navigation-title-text-font-weight:
 * calendar-navigation-title-text-line-height:
 * calendar-navigation-padding:
 * calendar-cell-inactive-text-color:
 * calendar-cell-disabled-text-color:
 * calendar-cell-hover-background-color:
 * calendar-cell-hover-border-color:
 * calendar-cell-hover-text-color:
 * calendar-cell-hover-text-font-size:
 * calendar-cell-hover-text-font-weight:
 * calendar-cell-hover-text-line-height:
 * calendar-cell-active-background-color:
 * calendar-cell-active-border-color:
 * calendar-cell-active-text-color:
 * calendar-cell-active-text-font-size:
 * calendar-cell-active-text-font-weight:
 * calendar-cell-active-text-line-height:
 * calendar-cell-today-background-color:
 * calendar-cell-today-border-color:
 * calendar-cell-today-text-color:
 * calendar-cell-today-text-font-size:
 * calendar-cell-today-text-font-weight:
 * calendar-cell-today-text-line-height:
 * calendar-cell-today-hover-background-color:
 * calendar-cell-today-hover-border-color:
 * calendar-cell-today-active-background-color:
 * calendar-cell-today-active-border-color:
 * calendar-cell-today-disabled-border-color:
 * calendar-cell-today-selected-background-color:
 * calendar-cell-today-selected-border-color:
 * calendar-cell-today-selected-text-color:
 * calendar-cell-today-selected-hover-background-color:
 * calendar-cell-today-selected-hover-border-color:
 * calendar-cell-today-selected-active-background-color:
 * calendar-cell-today-selected-active-border-color:
 * calendar-cell-today-in-range-background-color:
 * calendar-cell-today-in-range-border-color:
 * calendar-cell-today-in-range-text-color:
 * calendar-cell-today-in-range-hover-background-color:
 * calendar-cell-today-in-range-hover-border-color:
 * calendar-cell-today-in-range-active-background-color:
 * calendar-cell-today-in-range-active-border-color:
 * calendar-cell-selected-background-color:
 * calendar-cell-selected-border-color:
 * calendar-cell-selected-text-color:
 * calendar-cell-selected-text-font-size:
 * calendar-cell-selected-text-font-weight:
 * calendar-cell-selected-text-line-height:
 * calendar-cell-selected-hover-background-color:
 * calendar-cell-selected-hover-border-color:
 * calendar-cell-selected-active-background-color:
 * calendar-cell-selected-active-border-color:
 * calendar-day-cell-width:
 * calendar-day-cell-height:
 * calendar-month-cell-width:
 * calendar-month-cell-height:
 * calendar-year-cell-width:
 * calendar-year-cell-height:
 * calendar-weekday-background:
 * calendar-weekday-divider-color:
 * calendar-weekday-divider-width:
 * calendar-weekday-text-color:
 * calendar-weekday-text-font-size:
 * calendar-weekday-text-font-weight:
 * calendar-weekday-text-line-height:
 * calendar-weekday-holiday-text-color:
 * calendar-weekday-height:
 * calendar-weekday-width:
 * calendar-weeknumber-background:
 * calendar-weeknumber-divider-color:
 * calendar-weeknumber-divider-width:
 * calendar-weeknumber-text-color:
 * calendar-weeknumber-text-font-size:
 * calendar-weeknumber-text-font-weight:
 * calendar-weeknumber-text-line-height:
 * calendar-weeknumber-height:
 * calendar-weeknumber-width:
 * calendar-large-width:
 * calendar-day-cell-large-width:
 * calendar-day-cell-large-height:
 * calendar-weekday-large-height:
 * calendar-weekday-large-width:
 * calendar-weeknumber-large-height:
 * calendar-weeknumber-large-width:
 * calendar-month-cell-large-width:
 * calendar-month-cell-large-height:
 * calendar-year-cell-large-width:
 * calendar-year-cell-large-height:
 * */
class NbCalendarRangeComponent {
    constructor(dateService) {
        this.dateService = dateService;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for the calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        this.dayCellComponent = NbCalendarRangeDayCellComponent;
        this.monthCellComponent = NbCalendarRangeMonthCellComponent;
        this.yearCellComponent = NbCalendarRangeYearCellComponent;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines should we show calendars navigation or not.
         * */
        this.showNavigation = true;
        this._showWeekNumber = false;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        /**
         * Emits range when start selected and emits again when end selected.
         * */
        this.rangeChange = new EventEmitter();
    }
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.dayCellComponent = cellComponent;
        }
    }
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    set _monthCellComponent(cellComponent) {
        if (cellComponent) {
            this.monthCellComponent = cellComponent;
        }
    }
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    set _yearCellComponent(cellComponent) {
        if (cellComponent) {
            this.yearCellComponent = cellComponent;
        }
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    onChange(date) {
        this.initDateIfNull();
        this.handleSelected(date);
    }
    initDateIfNull() {
        if (!this.range) {
            this.range = { start: null, end: null };
        }
    }
    handleSelected(date) {
        if (this.selectionStarted()) {
            this.selectEnd(date);
        }
        else {
            this.selectStart(date);
        }
    }
    selectionStarted() {
        const { start, end } = this.range;
        return start && !end;
    }
    selectStart(start) {
        this.selectRange({ start });
    }
    selectEnd(date) {
        const { start } = this.range;
        if (this.dateService.compareDates(date, start) > 0) {
            this.selectRange({ start, end: date });
        }
        else {
            this.selectRange({ start: date, end: start });
        }
    }
    selectRange(range) {
        this.range = range;
        this.rangeChange.emit(range);
    }
}
NbCalendarRangeComponent.ɵfac = function NbCalendarRangeComponent_Factory(t) { return new (t || NbCalendarRangeComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeComponent, selectors: [["nb-calendar-range"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", monthCellComponent: "monthCellComponent", size: "size", showNavigation: "showNavigation", weekNumberSymbol: "weekNumberSymbol", _cellComponent: ["dayCellComponent", "_cellComponent"], _monthCellComponent: ["monthCellComponent", "_monthCellComponent"], _yearCellComponent: ["yearCellComponent", "_yearCellComponent"], showWeekNumber: "showWeekNumber", range: "range", min: "min", max: "max", filter: "filter", visibleDate: "visibleDate" }, outputs: { rangeChange: "rangeChange" }, decls: 1, vars: 14, consts: [[3, "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showNavigation", "size", "showWeekNumber", "weekNumberSymbol", "dateChange"]], template: function NbCalendarRangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-base-calendar", 0);
        ɵngcc0.ɵɵlistener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) { return ctx.onChange($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol);
    } }, directives: [NbBaseCalendarComponent], encapsulation: 2 });
NbCalendarRangeComponent.ctorParameters = () => [
    { type: NbDateService }
];
NbCalendarRangeComponent.propDecorators = {
    boundingMonth: [{ type: Input }],
    startView: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    _cellComponent: [{ type: Input, args: ['dayCellComponent',] }],
    _monthCellComponent: [{ type: Input, args: ['monthCellComponent',] }],
    monthCellComponent: [{ type: Input }],
    _yearCellComponent: [{ type: Input, args: ['yearCellComponent',] }],
    size: [{ type: Input }],
    visibleDate: [{ type: Input }],
    showNavigation: [{ type: Input }],
    range: [{ type: Input }],
    showWeekNumber: [{ type: Input }],
    weekNumberSymbol: [{ type: Input }],
    rangeChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarRangeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range',
                template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($any($event))"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
    ></nb-base-calendar>
  `
            }]
    }], function () { return [{ type: NbDateService }]; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], size: [{
            type: Input
        }], showNavigation: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], rangeChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['dayCellComponent']
        }], _monthCellComponent: [{
            type: Input,
            args: ['monthCellComponent']
        }], _yearCellComponent: [{
            type: Input,
            args: ['yearCellComponent']
        }], showWeekNumber: [{
            type: Input
        }], range: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCalendarRangeModule {
}
NbCalendarRangeModule.ɵfac = function NbCalendarRangeModule_Factory(t) { return new (t || NbCalendarRangeModule)(); };
NbCalendarRangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarRangeModule });
NbCalendarRangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbBaseCalendarModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarRangeModule, { declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent], imports: [NbBaseCalendarModule], exports: [NbCalendarRangeComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarRangeModule, [{
        type: NgModule,
        args: [{
                imports: [NbBaseCalendarModule],
                exports: [NbCalendarRangeComponent],
                declarations: [
                    NbCalendarRangeComponent,
                    NbCalendarRangeDayCellComponent,
                    NbCalendarRangeYearCellComponent,
                    NbCalendarRangeMonthCellComponent,
                ],
                entryComponents: [
                    NbCalendarRangeDayCellComponent,
                    NbCalendarRangeMonthCellComponent,
                    NbCalendarRangeYearCellComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TIME_PICKER_CONFIG = new InjectionToken('NB_TIME_PICKER_CONFIG');

/**
 * The TimePicker components itself.
 * Provides a proxy to `TimePicker` options as well as custom picker options.
 */
class NbTimePickerComponent {
    constructor(config, platformService, locale, cd, calendarTimeModelService, dateService) {
        this.config = config;
        this.platformService = platformService;
        this.cd = cd;
        this.calendarTimeModelService = calendarTimeModelService;
        this.dateService = dateService;
        this.blur$ = new Subject();
        this.dayPeriodColumnOptions = ["AM" /* AM */, "PM" /* PM */];
        this.isAM = true;
        /**
         * In timepicker value should be always true
         * In calendar-with-time.component  should set to false
         * @docs-private
         */
        this.showFooter = true;
        this.hoursText = 'Hr';
        this.minutesText = 'Min';
        this.secondsText = 'Sec';
        this.ampmText = 'Am/Pm';
        /**
         * Emits date when selected.
         * */
        this.onSelectTime = new EventEmitter();
        if (config) {
            this.twelveHoursFormat = config.twelveHoursFormat;
        }
        else {
            this.twelveHoursFormat = dateService.getLocaleTimeFormat().includes('h');
        }
    }
    /**
     * Emits when timepicker looses focus.
     */
    get blur() {
        return this.blur$.asObservable();
    }
    /**
     * Defines time format string.
     * */
    get timeFormat() {
        return this._timeFormat;
    }
    set timeFormat(timeFormat) {
        this._timeFormat = timeFormat;
    }
    /**
     * Defines 12 hours format .
     * */
    get twelveHoursFormat() {
        return this._twelveHoursFormat;
    }
    set twelveHoursFormat(value) {
        this._twelveHoursFormat = convertToBoolProperty(value);
    }
    ;
    /**
     * Show seconds in timepicker.
     * Ignored when singleColumn is true
     * */
    get withSeconds() {
        return this._withSeconds;
    }
    set withSeconds(value) {
        this._withSeconds = convertToBoolProperty(value);
    }
    ;
    /**
     * Show timepicker values in one column with 60 minutes step by default.
     * */
    get singleColumn() {
        return this._singleColumn;
    }
    set singleColumn(value) {
        this._singleColumn = convertToBoolProperty(value);
    }
    /**
     * Defines minutes offset for options, when timepicker is in single column mode.
     * By default it’s 60 minutes: '12:00, 13:00: 14:00, 15:00...'
     * */
    set step(step) {
        this._step = step;
    }
    get step() {
        return this._step;
    }
    /**
     * Date which will be rendered as selected.
     * */
    set date(date) {
        this._date = date;
        this.isAM = this.dateService.getDayPeriod(this.date) === "AM" /* AM */;
        this.buildColumnOptions();
        this.cd.markForCheck();
    }
    get date() {
        return this._date;
    }
    ngOnInit() {
        this.timeFormat = this.setupTimeFormat();
    }
    ngOnChanges({ step, twelveHoursFormat, withSeconds, singleColumn, }) {
        this.timeFormat = this.setupTimeFormat();
        const isConfigChanged = step || twelveHoursFormat || withSeconds || singleColumn;
        if (isConfigChanged || !this.fullTimeOptions) {
            this.buildColumnOptions();
        }
    }
    setHost(hostRef) {
        this.hostRef = hostRef;
    }
    attach(hostRef) {
        this.hostRef = hostRef;
    }
    setCurrentTime() {
        this.date = this.dateService.today();
        this.onSelectTime.emit({
            time: this.date,
            save: true,
        });
    }
    setHour(value) {
        this.updateValue(this.dateService.setHours(this.date, value));
    }
    setMinute(value) {
        this.updateValue(this.dateService.setMinutes(this.date, value));
    }
    setSecond(value) {
        this.updateValue(this.dateService.setSeconds(this.date, value));
    }
    selectFullTime(value) {
        this.updateValue(value);
    }
    changeDayPeriod(dayPeriodToSet) {
        if (this.dateService.getDayPeriod(this.date) === dayPeriodToSet) {
            return;
        }
        // Subtract hours when switching to AM (before midday, 0-11 in 24-hour) from PM (after midday, 12-24 in 24-hour),
        // otherwise add hours because switching to PM from AM.
        const direction = dayPeriodToSet === "AM" /* AM */ ? -1 : 1;
        const increment = direction * this.dateService.HOURS_IN_DAY_PERIOD;
        this.updateValue(this.dateService.addHours(this.date, increment));
    }
    updateValue(date) {
        this.onSelectTime.emit({ time: date });
    }
    saveValue() {
        this.onSelectTime.emit({
            time: this.date,
            save: true,
        });
    }
    trackByTimeValues(index, item) {
        return item.value;
    }
    trackBySingleColumnValue(index, item) {
        return this.dateService.valueOf(item);
    }
    trackByDayPeriod(index, item) {
        return item;
    }
    showSeconds() {
        return this.withSeconds && !this.singleColumn;
    }
    isSelectedHour(val) {
        if (this.date) {
            return this.dateService.getHours(this.date) === val;
        }
        return false;
    }
    isSelectedMinute(val) {
        if (this.date) {
            return this.dateService.getMinutes(this.date) === val;
        }
        return false;
    }
    isSelectedSecond(val) {
        if (this.date) {
            return this.dateService.getSeconds(this.date) === val;
        }
        return false;
    }
    isSelectedDayPeriod(dayPeriod) {
        if (this.date) {
            return dayPeriod === this.dateService.getDayPeriod(this.date);
        }
        return false;
    }
    getFullTimeString(item) {
        return this.dateService.format(item, this.timeFormat).toUpperCase();
    }
    isSelectedFullTimeValue(value) {
        if (this.date) {
            return this.dateService.isSameHourAndMinute(value, this.date);
        }
        return false;
    }
    buildColumnOptions() {
        this.timeFormat = this.setupTimeFormat();
        this.fullTimeOptions = this.singleColumn
            ? this.calendarTimeModelService.getHoursRange(this.step)
            : [];
        this.hoursColumnOptions = this.generateHours();
        this.minutesColumnOptions = this.generateMinutesOrSeconds();
        this.secondsColumnOptions = this.withSeconds ? this.generateMinutesOrSeconds() : [];
    }
    /**
     * @docs-private
     */
    isFirefox() {
        return this.platformService.FIREFOX;
    }
    generateHours() {
        if (!this.twelveHoursFormat) {
            return range(24, (v) => {
                return { value: v, text: this.calendarTimeModelService.paddToTwoSymbols(v) };
            });
        }
        if (this.isAM) {
            return (range(12, (v) => {
                const text = v === 0 ? 12 : v;
                return { value: v, text: this.calendarTimeModelService.paddToTwoSymbols(text) };
            }));
        }
        return (rangeFromTo(12, 24, (v) => {
            const text = v === 12 ? 12 : (v - 12);
            return { value: v, text: this.calendarTimeModelService.paddToTwoSymbols(text) };
        }));
    }
    generateMinutesOrSeconds() {
        return range(60, (v) => {
            return { value: v, text: this.calendarTimeModelService.paddToTwoSymbols(v) };
        });
    }
    setupTimeFormat() {
        if (!this.timeFormat) {
            return this.config.format || this.buildTimeFormat();
        }
        return this.timeFormat;
    }
    /**
     * @docs-private
     */
    buildTimeFormat() {
        if (this.twelveHoursFormat) {
            return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwelveHoursFormatWithSeconds()
                : this.dateService.getTwelveHoursFormat()}`;
        }
        else {
            return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds()
                : this.dateService.getTwentyFourHoursFormat()}`;
        }
    }
}
NbTimePickerComponent.ɵfac = function NbTimePickerComponent_Factory(t) { return new (t || NbTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(NB_TIME_PICKER_CONFIG), ɵngcc0.ɵɵdirectiveInject(NbPlatform), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbCalendarTimeModelService), ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbTimePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTimePickerComponent, selectors: [["nb-timepicker"]], viewQuery: function NbTimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portal = _t.first);
    } }, inputs: { showFooter: "showFooter", hoursText: "hoursText", minutesText: "minutesText", secondsText: "secondsText", ampmText: "ampmText", twelveHoursFormat: "twelveHoursFormat", timeFormat: "timeFormat", withSeconds: "withSeconds", singleColumn: "singleColumn", step: "step", date: "date", applyButtonText: "applyButtonText", currentTimeButtonText: "currentTimeButtonText" }, outputs: { onSelectTime: "onSelectTime" }, exportAs: ["nbTimepicker"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, consts: [["class", "nb-timepicker-container", 3, "supports-scrollbar-theming", 4, "nbPortal"], [1, "nb-timepicker-container"], [1, "column-header"], [4, "ngIf", "ngIfElse"], ["fullTimeHeadersBlock", ""], [1, "picker-body"], ["fullTimeColumnBlock", ""], ["class", "actions-footer", 4, "ngIf"], [1, "header-cell"], ["class", "header-cell", 4, "ngIf"], [1, "values-list"], ["class", "list-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item"], [3, "value", "selected", "select"], ["class", "values-list", 4, "ngIf"], ["class", "list-item am-pm-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item", "am-pm-item"], [1, "actions-footer"], [3, "applyButtonText", "currentTimeButtonText", "setCurrentTime", "saveValue"]], template: function NbTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbTimePickerComponent_nb_card_0_Template, 10, 7, "nb-card", 0);
    } }, directives: function () { return [NbPortalDirective, NbCardComponent, NbCardHeaderComponent, ɵngcc2.NgIf, NbListComponent, ɵngcc2.NgForOf, NbListItemComponent, NbTimePickerCellComponent, NbCardFooterComponent, NbCalendarActionsComponent]; }, styles: [".nb-timepicker-container[_ngcontent-%COMP%]{overflow:hidden;margin-bottom:0}.values-list[_ngcontent-%COMP%]{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list[_ngcontent-%COMP%]:hover{overflow-y:auto}.list-item[_ngcontent-%COMP%]{border:0;padding:0;cursor:pointer}.picker-body[_ngcontent-%COMP%]{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer[_ngcontent-%COMP%]{width:100%}nb-card-header[_ngcontent-%COMP%], nb-card-footer[_ngcontent-%COMP%]{flex:0 0 auto}"], changeDetection: 0 });
NbTimePickerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_TIME_PICKER_CONFIG,] }] },
    { type: NbPlatform },
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: ChangeDetectorRef },
    { type: NbCalendarTimeModelService },
    { type: NbDateService }
];
NbTimePickerComponent.propDecorators = {
    timeFormat: [{ type: Input }],
    twelveHoursFormat: [{ type: Input }],
    withSeconds: [{ type: Input }],
    singleColumn: [{ type: Input }],
    step: [{ type: Input }],
    date: [{ type: Input }],
    showFooter: [{ type: Input }],
    applyButtonText: [{ type: Input }],
    hoursText: [{ type: Input }],
    minutesText: [{ type: Input }],
    secondsText: [{ type: Input }],
    ampmText: [{ type: Input }],
    currentTimeButtonText: [{ type: Input }],
    onSelectTime: [{ type: Output }],
    portal: [{ type: ViewChild, args: [NbPortalDirective, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTimePickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-timepicker',
                template: "<nb-card *nbPortal\n         [class.supports-scrollbar-theming]=\"!isFirefox()\"\n         class=\"nb-timepicker-container\">\n  <nb-card-header class=\"column-header\">\n    <ng-container *ngIf=\"singleColumn; else fullTimeHeadersBlock\">\n      <div class=\"header-cell\">Time</div>\n    </ng-container>\n    <ng-template #fullTimeHeadersBlock>\n      <div class=\"header-cell\">{{ hoursText }}</div>\n      <div class=\"header-cell\">{{ minutesText }}</div>\n      <div *ngIf=\"withSeconds\" class=\"header-cell\">{{ secondsText }}</div>\n      <div *ngIf=\"twelveHoursFormat\" class=\"header-cell\">{{ ampmText }}</div>\n    </ng-template>\n  </nb-card-header>\n\n  <div class=\"picker-body\">\n    <ng-container *ngIf=\"singleColumn; else fullTimeColumnBlock\">\n      <nb-list class=\"values-list\">\n        <nb-list-item\n          class=\"list-item\"\n          [class.selected]=\"isSelectedFullTimeValue(item)\"\n          *ngFor=\"let item of fullTimeOptions; trackBy: trackBySingleColumnValue.bind(this)\">\n          <nb-timepicker-cell\n            [value]=\"getFullTimeString(item)\"\n            [selected]=\"isSelectedFullTimeValue(item)\"\n            (select)=\"selectFullTime(item)\">\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-container>\n\n    <ng-template #fullTimeColumnBlock>\n      <nb-list class=\"values-list\">\n        <nb-list-item\n          class=\"list-item\"\n          [class.selected]=\"isSelectedHour(item.value)\"\n          *ngFor=\"let item of hoursColumnOptions; trackBy: trackByTimeValues\">\n          <nb-timepicker-cell\n            [value]=\"item.text\"\n            [selected]=\"isSelectedHour(item.value)\"\n            (select)=\"setHour(item.value)\">\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list class=\"values-list\">\n        <nb-list-item\n          class=\"list-item\"\n          [class.selected]=\"isSelectedMinute(item.value)\"\n          *ngFor=\"let item of minutesColumnOptions; trackBy: trackByTimeValues\">\n          <nb-timepicker-cell\n            [value]=\"item.text\"\n            [selected]=\"isSelectedMinute(item.value)\"\n            (select)=\"setMinute(item.value)\">\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf=\"showSeconds()\" class=\"values-list\">\n        <nb-list-item\n          class=\"list-item\"\n          [class.selected]=\"isSelectedSecond(item.value)\"\n          *ngFor=\"let item of secondsColumnOptions; trackBy: trackByTimeValues\">\n          <nb-timepicker-cell\n            [value]=\"item.text\"\n            [selected]=\"isSelectedSecond(item.value)\"\n            (select)=\"setSecond(item.value)\">\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf=\"twelveHoursFormat\" class=\"values-list\">\n        <nb-list-item\n          class=\"list-item am-pm-item\"\n          [class.selected]=\"isSelectedDayPeriod(dayPeriod)\"\n          *ngFor=\"let dayPeriod of dayPeriodColumnOptions; trackBy: trackByDayPeriod\">\n          <nb-timepicker-cell\n            [value]=\"dayPeriod\"\n            [selected]=\"isSelectedDayPeriod(dayPeriod)\"\n            (select)=\"changeDayPeriod(dayPeriod)\">\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-template>\n  </div>\n\n  <nb-card-footer *ngIf=\"showFooter\" class=\"actions-footer\">\n    <nb-calendar-actions\n      [applyButtonText]=\"applyButtonText\"\n      [currentTimeButtonText]=\"currentTimeButtonText\"\n      (setCurrentTime)=\"setCurrentTime()\"\n      (saveValue)=\"saveValue()\"\n    ></nb-calendar-actions>\n  </nb-card-footer>\n</nb-card>\n",
                exportAs: 'nbTimepicker',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nb-timepicker-container{overflow:hidden;margin-bottom:0}.values-list{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list:hover{overflow-y:auto}.list-item{border:0;padding:0;cursor:pointer}.picker-body{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer{width:100%}nb-card-header,nb-card-footer{flex:0 0 auto}\n"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_TIME_PICKER_CONFIG]
            }] }, { type: NbPlatform }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbCalendarTimeModelService }, { type: NbDateService }]; }, { showFooter: [{
            type: Input
        }], hoursText: [{
            type: Input
        }], minutesText: [{
            type: Input
        }], secondsText: [{
            type: Input
        }], ampmText: [{
            type: Input
        }], onSelectTime: [{
            type: Output
        }], twelveHoursFormat: [{
            type: Input
        }], timeFormat: [{
            type: Input
        }], withSeconds: [{
            type: Input
        }], singleColumn: [{
            type: Input
        }], step: [{
            type: Input
        }], date: [{
            type: Input
        }], applyButtonText: [{
            type: Input
        }], currentTimeButtonText: [{
            type: Input
        }], portal: [{
            type: ViewChild,
            args: [NbPortalDirective, { static: true }]
        }] }); })();

class NbCalendarWithTimeComponent extends NbCalendarComponent {
    constructor(dateService, cd, calendarTimeModelService) {
        super();
        this.dateService = dateService;
        this.cd = cd;
        this.calendarTimeModelService = calendarTimeModelService;
    }
    ngOnInit() {
        if (!this.date) {
            this.date = this.calendarTimeModelService.getResetTime();
        }
    }
    ngAfterViewInit() {
        this.portalOutlet.attachTemplatePortal(this.timepicker.portal);
    }
    onDateValueChange(date) {
        const hours = this.dateService.getHours(this.date);
        const minutes = this.dateService.getMinutes(this.date);
        const seconds = this.dateService.getSeconds(this.date);
        const milliseconds = this.dateService.getMilliseconds(this.date);
        let newDate = this.dateService.setHours(date, hours);
        newDate = this.dateService.setMinutes(newDate, minutes);
        newDate = this.dateService.setMinutes(newDate, minutes);
        newDate = this.dateService.setSeconds(newDate, seconds);
        newDate = this.dateService.setMilliseconds(newDate, milliseconds);
        this.date = newDate;
    }
    onTimeChange(selectedTime) {
        let newDate = this.dateService.clone(this.date);
        newDate = this.dateService.setHours(newDate, this.dateService.getHours(selectedTime.time));
        newDate = this.dateService.setMinutes(newDate, this.dateService.getMinutes(selectedTime.time));
        newDate = this.dateService.setSeconds(newDate, this.dateService.getSeconds(selectedTime.time));
        newDate = this.dateService.setMilliseconds(newDate, this.dateService.getMilliseconds(selectedTime.time));
        this.date = newDate;
    }
    saveValue() {
        this.dateChange.emit(this.date);
    }
    saveCurrentTime() {
        this.dateChange.emit(this.dateService.today());
    }
    /**
     * We don't show seconds with twelve hours format
     * */
    showSeconds() {
        return this.withSeconds && !this.twelveHoursFormat;
    }
    isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
}
NbCalendarWithTimeComponent.ɵfac = function NbCalendarWithTimeComponent_Factory(t) { return new (t || NbCalendarWithTimeComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbCalendarTimeModelService)); };
NbCalendarWithTimeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarWithTimeComponent, selectors: [["nb-calendar-with-time"]], viewQuery: function NbCalendarWithTimeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalOutletDirective, 1);
        ɵngcc0.ɵɵviewQuery(NbTimePickerComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timepicker = _t.first);
    } }, inputs: { visibleDate: "visibleDate", twelveHoursFormat: "twelveHoursFormat", withSeconds: "withSeconds", singleColumn: "singleColumn", step: "step", timeFormat: "timeFormat", title: "title", applyButtonText: "applyButtonText", currentTimeButtonText: "currentTimeButtonText" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 29, consts: [[1, "calendar-with-time"], [1, "picker-body"], [3, "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "dateChange"], [1, "timepicker-section"], [1, "picker-title"], [3, "date", "twelveHoursFormat", "withSeconds", "showFooter", "singleColumn", "step", "onSelectTime"], ["nbPortalOutlet", ""], [1, "picker-footer"], [3, "applyButtonText", "currentTimeButtonText", "setCurrentTime", "saveValue"]], template: function NbCalendarWithTimeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-card", 0);
        ɵngcc0.ɵɵelementStart(1, "nb-card-body", 1);
        ɵngcc0.ɵɵelementStart(2, "nb-base-calendar", 2);
        ɵngcc0.ɵɵlistener("dateChange", function NbCalendarWithTimeComponent_Template_nb_base_calendar_dateChange_2_listener($event) { return ctx.onDateValueChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "nb-timepicker", 5);
        ɵngcc0.ɵɵlistener("onSelectTime", function NbCalendarWithTimeComponent_Template_nb_timepicker_onSelectTime_6_listener($event) { return ctx.onTimeChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainer(7, 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "nb-card-footer", 7);
        ɵngcc0.ɵɵelementStart(9, "nb-calendar-actions", 8);
        ɵngcc0.ɵɵlistener("setCurrentTime", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_setCurrentTime_9_listener() { return ctx.saveCurrentTime(); })("saveValue", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_saveValue_9_listener() { return ctx.saveValue(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("size-large", ctx.isLarge())("timepicker-single-column-width", ctx.singleColumn)("timepicker-multiple-column-width", !ctx.singleColumn);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("date", ctx.date)("twelveHoursFormat", ctx.twelveHoursFormat)("withSeconds", ctx.showSeconds())("showFooter", false)("singleColumn", ctx.singleColumn)("step", ctx.step);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("applyButtonText", ctx.applyButtonText)("currentTimeButtonText", ctx.currentTimeButtonText);
    } }, directives: [NbCardComponent, NbCardBodyComponent, NbBaseCalendarComponent, NbTimePickerComponent, NbPortalOutletDirective, NbCardFooterComponent, NbCalendarActionsComponent], styles: ["[_nghost-%COMP%]     nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-left:.625rem}[dir=rtl]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-right:.625rem}.picker-body[_ngcontent-%COMP%]{align-items:stretch;display:flex;padding:0}.picker-body[_ngcontent-%COMP%]   nb-base-calendar[_ngcontent-%COMP%]     nb-card{border-radius:0}.calendar-with-time[_ngcontent-%COMP%]{overflow:hidden}.timepicker-section[_ngcontent-%COMP%]{display:flex;flex-direction:column}"], changeDetection: 0 });
NbCalendarWithTimeComponent.ctorParameters = () => [
    { type: NbDateService },
    { type: ChangeDetectorRef },
    { type: NbCalendarTimeModelService }
];
NbCalendarWithTimeComponent.propDecorators = {
    visibleDate: [{ type: Input }],
    twelveHoursFormat: [{ type: Input }],
    withSeconds: [{ type: Input }],
    singleColumn: [{ type: Input }],
    step: [{ type: Input }],
    timeFormat: [{ type: Input }],
    title: [{ type: Input }],
    applyButtonText: [{ type: Input }],
    currentTimeButtonText: [{ type: Input }],
    portalOutlet: [{ type: ViewChild, args: [NbPortalOutletDirective,] }],
    timepicker: [{ type: ViewChild, args: [NbTimePickerComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCalendarWithTimeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-with-time',
                template: `
    <nb-card class="calendar-with-time">
      <nb-card-body class="picker-body">
        <nb-base-calendar
          [boundingMonth]="boundingMonth"
          [startView]="startView"
          [date]="date"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [dayCellComponent]="dayCellComponent"
          [monthCellComponent]="monthCellComponent"
          [yearCellComponent]="yearCellComponent"
          [size]="size"
          [visibleDate]="visibleDate"
          [showNavigation]="showNavigation"
          [showWeekNumber]="showWeekNumber"
          [weekNumberSymbol]="weekNumberSymbol"
          (dateChange)="onDateValueChange($event)">
        </nb-base-calendar>
        <div class="timepicker-section"
             [class.size-large]="isLarge()"
             [class.timepicker-single-column-width]="singleColumn"
             [class.timepicker-multiple-column-width]="!singleColumn">
          <div class="picker-title">{{ title }}</div>
          <nb-timepicker
            (onSelectTime)="onTimeChange($event)"
            [date]="date"
            [twelveHoursFormat]="twelveHoursFormat"
            [withSeconds]="showSeconds()"
            [showFooter]="false"
            [singleColumn]="singleColumn"
            [step]="step">
          </nb-timepicker>
          <ng-container nbPortalOutlet></ng-container>
        </div>
      </nb-card-body>
      <nb-card-footer class="picker-footer">
        <nb-calendar-actions
          [applyButtonText]="applyButtonText"
          [currentTimeButtonText]="currentTimeButtonText"
          (setCurrentTime)="saveCurrentTime()"
          (saveValue)="saveValue()"
        ></nb-calendar-actions>
      </nb-card-footer>
    </nb-card>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host ::ng-deep nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr] :host .picker-footer{padding-left:.625rem}[dir=rtl] :host .picker-footer{padding-right:.625rem}.picker-body{align-items:stretch;display:flex;padding:0}.picker-body nb-base-calendar ::ng-deep nb-card{border-radius:0}.calendar-with-time{overflow:hidden}.timepicker-section{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbDateService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbCalendarTimeModelService }]; }, { visibleDate: [{
            type: Input
        }], twelveHoursFormat: [{
            type: Input
        }], withSeconds: [{
            type: Input
        }], singleColumn: [{
            type: Input
        }], step: [{
            type: Input
        }], timeFormat: [{
            type: Input
        }], title: [{
            type: Input
        }], applyButtonText: [{
            type: Input
        }], currentTimeButtonText: [{
            type: Input
        }], portalOutlet: [{
            type: ViewChild,
            args: [NbPortalOutletDirective]
        }], timepicker: [{
            type: ViewChild,
            args: [NbTimePickerComponent]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDatepickerContainerComponent extends NbPositionedContainerComponent {
    attach(portal) {
        return this.overlayContainer.attachComponentPortal(portal);
    }
}
NbDatepickerContainerComponent.ɵfac = function NbDatepickerContainerComponent_Factory(t) { return ɵNbDatepickerContainerComponent_BaseFactory(t || NbDatepickerContainerComponent); };
NbDatepickerContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDatepickerContainerComponent, selectors: [["nb-datepicker-container"]], viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbOverlayContainerComponent, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, template: function NbDatepickerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "nb-overlay-container");
    } }, directives: [NbOverlayContainerComponent], encapsulation: 2 });
NbDatepickerContainerComponent.propDecorators = {
    overlayContainer: [{ type: ViewChild, args: [NbOverlayContainerComponent, { static: true },] }]
};
const ɵNbDatepickerContainerComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbDatepickerContainerComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDatepickerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-datepicker-container',
                template: `
    <nb-overlay-container></nb-overlay-container>
  `
            }]
    }], null, { overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent, { static: true }]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbDatepickerAdapter` instances provide way how to parse, format and validate
 * different date types.
 * */
class NbDatepickerAdapter {
}
/**
 * Datepicker is an control that can pick any values anyway.
 * It has to be bound to the datepicker directive through nbDatepicker input.
 * */
class NbDatepicker {
}
const NB_DATE_ADAPTER = new InjectionToken('Datepicker Adapter');
const NB_DATE_SERVICE_OPTIONS = new InjectionToken('Date service options');
/**
 * The `NbDatepickerDirective` is form control that gives you ability to select dates and ranges. The datepicker
 * is shown when input receives a `focus` event.
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker></nb-datepicker>
 * ```
 *
 * @stacked-example(Showcase, datepicker/datepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbDatepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbDatepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule,
 *   ],
 * })
 *
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use range selection, you have to use `NbRangepickerComponent` instead:
 *
 * ```html
 * <input [nbDatepicker]="rangepicker">
 * <nb-rangepicker #rangepicker></nb-rangepicker>
 * ```
 *
 * Both range and date pickers support all parameters as calendar, so, check `NbCalendarComponent` for additional
 * info.
 *
 * @stacked-example(Range showcase, datepicker/rangepicker-showcase.component)
 *
 * Datepicker is the form control so it can be bound with angular forms through ngModel and form controls.
 *
 * @stacked-example(Forms, datepicker/datepicker-forms.component)
 *
 * `NbDatepickerDirective` may be validated using `min` and `max` dates passed to the datepicker.
 * And `filter` predicate that receives date object and has to return a boolean value.
 *
 * @stacked-example(Validation, datepicker/datepicker-validation.component)
 *
 * If you need to pick a time along with the date, you can use nb-date-timepicker
 *
 * ```html
 * <input nbInput placeholder="Pick Date" [nbDatepicker]="dateTimePicker">
 * <nb-date-timepicker withSeconds #dateTimePicker></nb-date-timepicker>
 * ```
 * @stacked-example(Date timepicker, datepicker/date-timepicker-showcase.component)
 *
 * A single column picker with options value as time and minute, so users won’t be able to pick
 * hours and minutes individually.
 *
 * @stacked-example(Date timepicker single column, datepicker/date-timepicker-single-column.component)

 * The `NbDatepickerComponent` supports date formatting:
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker format="MM\dd\yyyy"></nb-datepicker>
 * ```
 * <span id="formatting-issue"></span>
 * ## Formatting Issue
 *
 * By default, datepicker uses angulars `LOCALE_ID` token for localization and `DatePipe` for dates formatting.
 * And native `Date.parse(...)` for dates parsing. But native `Date.parse` function doesn't support formats.
 * To provide custom formatting you have to use one of the following packages:
 *
 * - `@nebular/moment` - provides moment date adapter that uses moment for date objects. This means datepicker than
 * will operate only moment date objects. If you want to use it you have to install it: `npm i @nebular/moment`, and
 * import `NbMomentDateModule` from this package.
 *
 * - `@nebular/date-fns` - adapter for popular date-fns library. This way is preferred if you need only date formatting.
 * Because date-fns is treeshakable, tiny and operates native date objects. If you want to use it you have to
 * install it: `npm i @nebular/date-fns`, and import `NbDateFnsDateModule` from this package.
 *
 * ### NbDateFnsDateModule
 *
 * Format is required when using `NbDateFnsDateModule`. You can set it via `format` input on datepicker component:
 * ```html
 * <nb-datepicker format="dd.MM.yyyy"></nb-datepicker>
 * ```
 * Also format can be set globally with `NbDateFnsDateModule.forRoot({ format: 'dd.MM.yyyy' })` and
 * `NbDateFnsDateModule.forChild({ format: 'dd.MM.yyyy' })` methods.
 *
 * Please note to use some of the formatting tokens you also need to pass
 * `{ useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true }` to date-fns parse and format functions.
 * You can configure options passed this functions by setting `formatOptions` and
 * `parseOptions` of options object passed to `NbDateFnsDateModule.forRoot` and `NbDateFnsDateModule.forChild` methods.
 * ```ts
 * NbDateFnsDateModule.forRoot({
 *   parseOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 *   formatOptions: { useAdditionalWeekYearTokens: true, useAdditionalDayOfYearTokens: true },
 * })
 * ```
 * Further info on `date-fns` formatting tokens could be found at
 * [date-fns docs](https://date-fns.org/v2.0.0-alpha.27/docs/Unicode-Tokens).
 *
 * You can also use `parseOptions` and `formatOptions` to provide locale.
 * ```ts
 * import { eo } from 'date-fns/locale';
 *
 * @NgModule({
 *   imports: [
 *     NbDateFnsDateModule.forRoot({
 *       parseOptions: { locale: eo },
 *       formatOptions: { locale: eo },
 *     }),
 *   ],
 * })
 * ```
 *
 * @styles
 *
 * datepicker-background-color:
 * datepicker-border-color:
 * datepicker-border-style:
 * datepicker-border-width:
 * datepicker-border-radius:
 * datepicker-shadow:
 * */
class NbDatepickerDirective {
    constructor(document, datepickerAdapters, hostRef, dateService, changeDetector) {
        this.document = document;
        this.datepickerAdapters = datepickerAdapters;
        this.hostRef = hostRef;
        this.dateService = dateService;
        this.changeDetector = changeDetector;
        this.destroy$ = new Subject();
        this.isDatepickerReady = false;
        this.onChange = () => { };
        this.onTouched = () => { };
        /**
         * Form control validators will be called in validators context, so, we need to bind them.
         * */
        this.validator = Validators.compose([
            this.parseValidator,
            this.minValidator,
            this.maxValidator,
            this.filterValidator,
        ].map(fn => fn.bind(this)));
        this.subscribeOnInputChange();
    }
    /**
     * Provides datepicker component.
     * */
    set setPicker(picker) {
        this.picker = picker;
        this.setupPicker();
    }
    /**
     * Returns html input element.
     * */
    get input() {
        return this.hostRef.nativeElement;
    }
    /**
     * Returns host input value.
     * */
    get inputValue() {
        return this.input.value;
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Writes value in picker and html input element.
     * */
    writeValue(value) {
        if (this.isDatepickerReady) {
            this.writePicker(value);
            this.writeInput(value);
        }
        else {
            this.queue = value;
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.input.disabled = isDisabled;
    }
    /**
     * Form control validation based on picker validator config.
     * */
    validate() {
        return this.validator(null);
    }
    /**
     * Hides picker, focuses the input
     */
    hidePicker() {
        this.input.focus();
        this.picker.hide();
    }
    /**
     * Validates that we can parse value correctly.
     * */
    parseValidator() {
        /**
         * Date services treat empty string as invalid date.
         * That's why we're getting invalid formControl in case of empty input which is not required.
         * */
        if (this.inputValue === '') {
            return null;
        }
        const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
        return isValid ? null : { nbDatepickerParse: { value: this.inputValue } };
    }
    /**
     * Validates passed value is greater than min.
     * */
    minValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.min || !date || this.dateService.compareDates(config.min, date) <= 0) ?
            null : { nbDatepickerMin: { min: config.min, actual: date } };
    }
    /**
     * Validates passed value is smaller than max.
     * */
    maxValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.max || !date || this.dateService.compareDates(config.max, date) >= 0) ?
            null : { nbDatepickerMax: { max: config.max, actual: date } };
    }
    /**
     * Validates passed value satisfy the filter.
     * */
    filterValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.filter || !date || config.filter(date)) ?
            null : { nbDatepickerFilter: true };
    }
    /**
     * Chooses datepicker adapter based on passed picker component.
     * */
    chooseDatepickerAdapter() {
        this.datepickerAdapter = this.datepickerAdapters.find(({ picker }) => this.picker instanceof picker);
        if (this.noDatepickerAdapterProvided()) {
            throw new Error('No datepickerAdapter provided for picker');
        }
    }
    /**
     * Attaches picker to the host input element and subscribes on value changes.
     * */
    setupPicker() {
        this.chooseDatepickerAdapter();
        this.picker.attach(this.hostRef);
        if (this.inputValue) {
            this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        }
        // In case datepicker component placed after the input with datepicker directive,
        // we can't read `this.picker.format` on first change detection run,
        // since it's not bound yet, so we have to wait for datepicker component initialization.
        if (!this.isDatepickerReady) {
            this.picker.init
                .pipe(take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue), takeUntil(this.destroy$))
                .subscribe(() => {
                this.writeValue(this.queue);
                this.onChange(this.queue);
                this.changeDetector.detectChanges();
                this.queue = undefined;
            });
        }
        this.picker.valueChange
            .pipe(takeUntil(this.destroy$))
            .subscribe((value) => {
            this.writePicker(value);
            this.writeInput(value);
            this.onChange(value);
            if (this.picker.shouldHide()) {
                this.hidePicker();
            }
        });
        merge(this.picker.blur, fromEvent(this.input, 'blur').pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$))
            .subscribe(() => this.onTouched());
    }
    writePicker(value) {
        this.picker.value = value;
    }
    writeInput(value) {
        const stringRepresentation = this.datepickerAdapter.format(value, this.picker.format);
        this.hostRef.nativeElement.value = stringRepresentation;
    }
    /**
     * Validates if no datepicker adapter provided.
     * */
    noDatepickerAdapterProvided() {
        return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
    }
    subscribeOnInputChange() {
        fromEvent(this.input, 'input')
            .pipe(map(() => this.inputValue), takeUntil(this.destroy$))
            .subscribe((value) => this.handleInputChange(value));
    }
    /**
     * Parses input value and write if it isn't null.
     * */
    handleInputChange(value) {
        const date = this.parseInputValue(value);
        this.onChange(date);
        this.writePicker(date);
    }
    parseInputValue(value) {
        if (this.datepickerAdapter.isValid(value, this.picker.format)) {
            return this.datepickerAdapter.parse(value, this.picker.format);
        }
        return null;
    }
}
NbDatepickerDirective.ɵfac = function NbDatepickerDirective_Factory(t) { return new (t || NbDatepickerDirective)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NB_DATE_ADAPTER), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbDatepickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbDatepickerDirective, selectors: [["input", "nbDatepicker", ""]], inputs: { setPicker: ["nbDatepicker", "setPicker"] }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbDatepickerDirective),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => NbDatepickerDirective),
                multi: true
            },
        ])] });
NbDatepickerDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: Array, decorators: [{ type: Inject, args: [NB_DATE_ADAPTER,] }] },
    { type: ElementRef },
    { type: NbDateService },
    { type: ChangeDetectorRef }
];
NbDatepickerDirective.propDecorators = {
    setPicker: [{ type: Input, args: ['nbDatepicker',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDatepickerDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbDatepicker]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbDatepickerDirective),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => NbDatepickerDirective),
                        multi: true
                    },
                ]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: Array, decorators: [{
                type: Inject,
                args: [NB_DATE_ADAPTER]
            }] }, { type: ɵngcc0.ElementRef }, { type: NbDateService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { setPicker: [{
            type: Input,
            args: ['nbDatepicker']
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbBasePicker` component concentrates overlay manipulation logic.
 * */
class NbBasePicker extends NbDatepicker {
    constructor(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions) {
        super();
        this.overlay = overlay;
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.cfr = cfr;
        this.dateService = dateService;
        this.dateServiceOptions = dateServiceOptions;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        this.init$ = new ReplaySubject();
        /**
         * Stream of picker changes. Required to be the subject because picker hides and shows and picker
         * change stream becomes recreated.
         * */
        this.onChange$ = new Subject();
        this.overlayOffset = 8;
        this.destroy$ = new Subject();
        this.blur$ = new Subject();
    }
    /**
     * Returns picker instance.
     * */
    get picker() {
        return this.pickerRef && this.pickerRef.instance;
    }
    /**
     * Stream of picker value changes.
     * */
    get valueChange() {
        return this.onChange$.asObservable();
    }
    get isShown() {
        return this.ref && this.ref.hasAttached();
    }
    get init() {
        return this.init$.asObservable();
    }
    /**
     * Emits when datepicker looses focus.
     */
    get blur() {
        return this.blur$.asObservable();
    }
    /**
     * Datepicker knows nothing about host html input element.
     * So, attach method attaches datepicker to the host input element.
     * */
    attach(hostRef) {
        this.hostRef = hostRef;
        this.subscribeOnTriggers();
    }
    getValidatorConfig() {
        return { min: this.min, max: this.max, filter: this.filter };
    }
    show() {
        if (!this.ref) {
            this.createOverlay();
        }
        this.openDatepicker();
    }
    shouldHide() {
        return this.hideOnSelect && !!this.value;
    }
    hide() {
        if (this.ref) {
            this.ref.detach();
        }
        // save current value if picker was rendered
        if (this.picker) {
            this.queue = this.value;
            this.pickerRef.destroy();
            this.pickerRef = null;
            this.container = null;
        }
    }
    createOverlay() {
        this.positionStrategy = this.createPositionStrategy();
        this.ref = this.overlay.create({
            positionStrategy: this.positionStrategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.subscribeOnPositionChange();
    }
    openDatepicker() {
        this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null, this.cfr));
        this.instantiatePicker();
        this.subscribeOnValueChange();
        this.writeQueue();
        this.patchWithInputs();
        this.pickerRef.changeDetectorRef.markForCheck();
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.hostRef)
            .position(NbPosition.BOTTOM)
            .offset(this.overlayOffset)
            .adjustment(NbAdjustment.COUNTERCLOCKWISE);
    }
    subscribeOnPositionChange() {
        this.positionStrategy.positionChange
            .pipe(takeUntil(this.destroy$))
            .subscribe((position) => patch(this.container, { position }));
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.FOCUS)
            .host(this.hostRef.nativeElement)
            .container(() => this.container)
            .build();
    }
    subscribeOnTriggers() {
        this.triggerStrategy = this.createTriggerStrategy();
        this.triggerStrategy.show$.subscribe(() => this.show());
        this.triggerStrategy.hide$.subscribe(() => {
            this.blur$.next();
            this.hide();
        });
    }
    instantiatePicker() {
        this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null, this.cfr));
    }
    /**
     * Subscribes on picker value changes and emit data through this.onChange$ subject.
     * */
    subscribeOnValueChange() {
        this.pickerValueChange.subscribe(date => {
            this.onChange$.next(date);
        });
    }
    patchWithInputs() {
        this.picker.boundingMonth = this.boundingMonth;
        this.picker.startView = this.startView;
        this.picker.min = this.min;
        this.picker.max = this.max;
        this.picker.filter = this.filter;
        this.picker._cellComponent = this.dayCellComponent;
        this.picker._monthCellComponent = this.monthCellComponent;
        this.picker._yearCellComponent = this.yearCellComponent;
        this.picker.size = this.size;
        this.picker.showNavigation = this.showNavigation;
        this.picker.visibleDate = this.visibleDate;
        this.picker.showWeekNumber = this.showWeekNumber;
        this.picker.weekNumberSymbol = this.weekNumberSymbol;
    }
    checkFormat() {
        if (this.dateService.getId() === 'native' && this.format) {
            throw new Error('Can\'t format native date. To use custom formatting you have to install @nebular/moment or ' +
                '@nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.' +
                'More information at "Formatting issue" ' +
                'https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent');
        }
        const isFormatSet = this.format || (this.dateServiceOptions && this.dateServiceOptions.format);
        if (this.dateService.getId() === 'date-fns' && !isFormatSet) {
            throw new Error('format is required when using NbDateFnsDateModule');
        }
    }
}
class NbBasePickerComponent extends NbBasePicker {
    constructor(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions) {
        super(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions);
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Hide picker when a date or a range is selected, `true` by default
         * @type {boolean}
         */
        this.hideOnSelect = true;
        /**
         * Determines should we show calendars navigation or not.
         * @type {boolean}
         */
        this.showNavigation = true;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        this._showWeekNumber = false;
        /**
         * Determines picker overlay offset (in pixels).
         * */
        this.overlayOffset = 8;
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    ngOnInit() {
        this.checkFormat();
    }
    ngOnChanges(changes) {
        if (changes.format && !changes.format.isFirstChange()) {
            this.checkFormat();
        }
    }
    ngAfterViewInit() {
        this.init$.next();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.hide();
        this.init$.complete();
        if (this.ref) {
            this.ref.dispose();
        }
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    get pickerValueChange() {
        return;
    }
    get value() {
        return undefined;
    }
    set value(value) { }
    writeQueue() {
    }
}
NbBasePickerComponent.ɵfac = function NbBasePickerComponent_Factory(t) { return new (t || NbBasePickerComponent)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8)); };
NbBasePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBasePickerComponent, selectors: [["ng-component"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", size: "size", hideOnSelect: "hideOnSelect", showNavigation: "showNavigation", weekNumberSymbol: "weekNumberSymbol", overlayOffset: "overlayOffset", showWeekNumber: "showWeekNumber", format: "format", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", visibleDate: "visibleDate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function NbBasePickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
NbBasePickerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbPositionBuilderService },
    { type: NbTriggerStrategyBuilderService },
    { type: NbOverlayService },
    { type: ComponentFactoryResolver },
    { type: NbDateService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_DATE_SERVICE_OPTIONS,] }] }
];
NbBasePickerComponent.propDecorators = {
    format: [{ type: Input }],
    boundingMonth: [{ type: Input }],
    startView: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    filter: [{ type: Input }],
    dayCellComponent: [{ type: Input }],
    monthCellComponent: [{ type: Input }],
    yearCellComponent: [{ type: Input }],
    size: [{ type: Input }],
    visibleDate: [{ type: Input }],
    hideOnSelect: [{ type: Input }],
    showNavigation: [{ type: Input }],
    weekNumberSymbol: [{ type: Input }],
    showWeekNumber: [{ type: Input }],
    overlayOffset: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBasePickerComponent, [{
        type: Component,
        args: [{
                template: ''
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.ComponentFactoryResolver }, { type: NbDateService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_DATE_SERVICE_OPTIONS]
            }] }]; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], size: [{
            type: Input
        }], hideOnSelect: [{
            type: Input
        }], showNavigation: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], overlayOffset: [{
            type: Input
        }], showWeekNumber: [{
            type: Input
        }], format: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }] }); })();
/**
 * The DatePicker components itself.
 * Provides a proxy to `NbCalendar` options as well as custom picker options.
 */
class NbDatepickerComponent extends NbBasePickerComponent {
    constructor() {
        super(...arguments);
        this.pickerClass = NbCalendarComponent;
    }
    /**
     * Date which will be rendered as selected.
     * */
    set date(date) {
        this.value = date;
    }
    /**
     * Emits date when selected.
     * */
    get dateChange() {
        return this.valueChange;
    }
    get value() {
        return this.picker ? this.picker.date : undefined;
    }
    set value(date) {
        if (!this.picker) {
            this.queue = date;
            return;
        }
        if (date) {
            this.visibleDate = date;
            this.picker.visibleDate = date;
            this.picker.date = date;
        }
    }
    get pickerValueChange() {
        return this.picker.dateChange;
    }
    writeQueue() {
        if (this.queue) {
            const date = this.queue;
            this.queue = null;
            this.value = date;
        }
    }
}
NbDatepickerComponent.ɵfac = function NbDatepickerComponent_Factory(t) { return ɵNbDatepickerComponent_BaseFactory(t || NbDatepickerComponent); };
NbDatepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDatepickerComponent, selectors: [["nb-datepicker"]], inputs: { date: "date" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbDatepickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
NbDatepickerComponent.propDecorators = {
    date: [{ type: Input }],
    dateChange: [{ type: Output }]
};
const ɵNbDatepickerComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbDatepickerComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDatepickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-datepicker',
                template: ''
            }]
    }], null, { date: [{
            type: Input
        }], dateChange: [{
            type: Output
        }] }); })();
/**
 * The RangeDatePicker components itself.
 * Provides a proxy to `NbCalendarRange` options as well as custom picker options.
 */
class NbRangepickerComponent extends NbBasePickerComponent {
    constructor() {
        super(...arguments);
        this.pickerClass = NbCalendarRangeComponent;
    }
    /**
     * Range which will be rendered as selected.
     * */
    set range(range) {
        this.value = range;
    }
    /**
     * Emits range when start selected and emits again when end selected.
     * */
    get rangeChange() {
        return this.valueChange;
    }
    get value() {
        return this.picker ? this.picker.range : undefined;
    }
    set value(range) {
        if (!this.picker) {
            this.queue = range;
            return;
        }
        if (range) {
            const visibleDate = range && range.start;
            this.visibleDate = visibleDate;
            this.picker.visibleDate = visibleDate;
            this.picker.range = range;
        }
    }
    get pickerValueChange() {
        return this.picker.rangeChange;
    }
    shouldHide() {
        return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
    }
    writeQueue() {
        if (this.queue) {
            const range = this.queue;
            this.queue = null;
            this.value = range;
        }
    }
}
NbRangepickerComponent.ɵfac = function NbRangepickerComponent_Factory(t) { return ɵNbRangepickerComponent_BaseFactory(t || NbRangepickerComponent); };
NbRangepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRangepickerComponent, selectors: [["nb-rangepicker"]], inputs: { range: "range" }, outputs: { rangeChange: "rangeChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbRangepickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
NbRangepickerComponent.propDecorators = {
    range: [{ type: Input }],
    rangeChange: [{ type: Output }]
};
const ɵNbRangepickerComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbRangepickerComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRangepickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-rangepicker',
                template: ''
            }]
    }], null, { range: [{
            type: Input
        }], rangeChange: [{
            type: Output
        }] }); })();

class NbDateTimePickerComponent extends NbBasePickerComponent {
    constructor(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions, calendarWithTimeModelService) {
        super(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions);
        this.calendarWithTimeModelService = calendarWithTimeModelService;
        this.pickerClass = NbCalendarWithTimeComponent;
    }
    get value() {
        return this.picker ? this.picker.date : undefined;
    }
    set value(date) {
        if (!this.picker) {
            this.queue = date;
            return;
        }
        if (date) {
            this.visibleDate = date;
            this.picker.visibleDate = date;
            this.picker.date = date;
            this.picker.cd.markForCheck();
        }
    }
    get twelveHoursFormat() {
        return this._twelveHoursFormat;
    }
    set twelveHoursFormat(value) {
        this._twelveHoursFormat = convertToBoolProperty(value);
    }
    get withSeconds() {
        return this._withSeconds;
    }
    set withSeconds(value) {
        this._withSeconds = convertToBoolProperty(value);
    }
    get singleColumn() {
        return this._singleColumn;
    }
    set singleColumn(value) {
        this._singleColumn = convertToBoolProperty(value);
    }
    ngOnInit() {
        this.format = this.format || this.buildTimeFormat();
    }
    patchWithInputs() {
        this.picker.singleColumn = this.singleColumn;
        this.picker.twelveHoursFormat = this.twelveHoursFormat;
        this.picker.withSeconds = this.withSeconds;
        this.picker.step = this.step;
        this.picker.title = this.title;
        this.picker.applyButtonText = this.applyButtonText;
        this.picker.currentTimeButtonText = this.currentTimeButtonText;
        if (this.twelveHoursFormat) {
            this.picker.timeFormat = this.dateService.getTwelveHoursFormat();
        }
        else {
            this.picker.timeFormat = this.withSeconds ? this.dateService.getTwentyFourHoursFormatWithSeconds() :
                this.dateService.getTwentyFourHoursFormat();
        }
        super.patchWithInputs();
        this.picker.cd.markForCheck();
    }
    get pickerValueChange() {
        return this.picker.dateChange;
    }
    writeQueue() {
        if (this.queue) {
            const date = this.queue;
            this.queue = null;
            this.value = date;
        }
    }
    buildTimeFormat() {
        if (this.singleColumn) {
            return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat);
        }
        else {
            return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat, this.withSeconds);
        }
    }
}
NbDateTimePickerComponent.ɵfac = function NbDateTimePickerComponent_Factory(t) { return new (t || NbDateTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8), ɵngcc0.ɵɵdirectiveInject(NbCalendarTimeModelService)); };
NbDateTimePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDateTimePickerComponent, selectors: [["nb-date-timepicker"]], inputs: { twelveHoursFormat: "twelveHoursFormat", withSeconds: "withSeconds", singleColumn: "singleColumn", step: "step", title: "title", applyButtonText: "applyButtonText", currentTimeButtonText: "currentTimeButtonText" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbDateTimePickerComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NbDateTimePickerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbPositionBuilderService },
    { type: NbTriggerStrategyBuilderService },
    { type: NbOverlayService },
    { type: ComponentFactoryResolver },
    { type: NbDateService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_DATE_SERVICE_OPTIONS,] }] },
    { type: NbCalendarTimeModelService }
];
NbDateTimePickerComponent.propDecorators = {
    step: [{ type: Input }],
    title: [{ type: Input }],
    applyButtonText: [{ type: Input }],
    currentTimeButtonText: [{ type: Input }],
    twelveHoursFormat: [{ type: Input }],
    withSeconds: [{ type: Input }],
    singleColumn: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDateTimePickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-date-timepicker',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.ComponentFactoryResolver }, { type: NbDateService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_DATE_SERVICE_OPTIONS]
            }] }, { type: NbCalendarTimeModelService }]; }, { twelveHoursFormat: [{
            type: Input
        }], withSeconds: [{
            type: Input
        }], singleColumn: [{
            type: Input
        }], step: [{
            type: Input
        }], title: [{
            type: Input
        }], applyButtonText: [{
            type: Input
        }], currentTimeButtonText: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function isUrlPathEqual(path, link) {
    const locationPath = getPathPartOfUrl(path);
    return link === locationPath;
}
function isUrlPathContain(path, link) {
    const locationPath = getPathPartOfUrl(path);
    const endOfUrlSegmentRegExp = /\/|^$/;
    return locationPath.startsWith(link) &&
        locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
    return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
    const matched = url.match(/#(.+)/);
    return matched ? matched[1] : '';
}
function isFragmentEqual(path, fragment) {
    return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
    return getFragmentPartOfUrl(path).includes(fragment);
}

/**
 * This service determines whether we should scroll the layout back to top.
 * This occurs when the page is changed, so when current url PATH is not equal to the previous one.
 *
 *  TODO: this is most likely a temporary solutions as recently Angular introduces ViewportScroll
 *  and scroll restoration process
 */
class NbRestoreScrollTopHelper {
    constructor(router) {
        this.router = router;
    }
    shouldRestore() {
        return this.router.events
            .pipe(startWith(null), filter(event => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter(res => !!res));
    }
    pageChanged(prev, current) {
        return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
    }
}
NbRestoreScrollTopHelper.ɵfac = function NbRestoreScrollTopHelper_Factory(t) { return new (t || NbRestoreScrollTopHelper)(ɵngcc0.ɵɵinject(ɵngcc5.Router)); };
NbRestoreScrollTopHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbRestoreScrollTopHelper, factory: NbRestoreScrollTopHelper.ɵfac });
NbRestoreScrollTopHelper.ctorParameters = () => [
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRestoreScrollTopHelper, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc5.Router }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Layout container component.
 * When using with Nebular Theme System it is required that all child components should be placed inside.
 *
 * Basic example of two column layout with header:
 *
 * @stacked-example(Showcase, layout/layout-showcase.component)
 *
 * Can contain the following components inside:
 *
 * ```html
 * <nb-layout>
 *  <nb-layout-header></nb-layout-header>
 *  <nb-layout-footer></nb-layout-footer>
 *  <nb-layout-column></nb-layout-column>
 *  <nb-sidebar></nb-sidebar>
 * </nb-layout>
 * ```
 * ### Installation
 *
 * Import `NbLayoutModule` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbLayoutModule,
 *   ],
 * })
 * export class AppModule { }
 * ```
 * ### Usage
 * By default the layout fills up the whole view-port.
 * The window scrollbars are disabled on the body and moved inside of the nb-layout, so that the scrollbars
 * won't mess with the fixed nb-header.
 *
 * The child components are projected into a flexible layout structure allowing to adjust the layout behavior
 * based on the settings provided.
 *
 * The layout content (columns) becomes centered when the window width is more than
 * the value specified in the theme variable `layout-content-width`.
 *
 * The layout also contains the area on the very top (the first child of the nb-layout), which could be used
 * to dynamically append some components like modals or spinners/loaders
 * so that they are located on top of the elements hierarchy.
 * More details are under the `ThemeService` section.
 *
 * The layout component is also responsible for changing application themes.
 * It listens to the `themeChange` event and change a theme CSS class appended to body.
 * Based on the class appended, specific CSS-theme is applied to the application.
 * More details of the Theme System could be found here [Enabling Theme System](#/docs/concepts/theme-system)
 *
 * A simple layout with footer:
 *
 * @stacked-example(Layout With Footer, layout/layout-w-footer.component)
 *
 * It is possible to ask the layout to center the columns (notice: we added a `center` attribute
 * to the layout:
 *
 * ```html
 * <nb-layout center>
 *   <nb-layout-header>Awesome Company</nb-layout-header>
 *
 *   <nb-layout-column>
 *     Hello World!
 *   </nb-layout-column>
 *
 *   <nb-layout-footer>Contact us</nb-layout-footer>
 * </nb-layout>
 * ```
 *
 * @styles
 *
 * layout-background-color:
 * layout-text-color:
 * layout-text-font-family:
 * layout-text-font-size:
 * layout-text-font-weight:
 * layout-text-line-height:
 * layout-min-height:
 * layout-content-width:
 * layout-window-mode-min-width:
 * layout-window-mode-max-width:
 * layout-window-mode-background-color:
 * layout-window-mode-padding-top:
 * layout-window-shadow:
 * layout-padding:
 * layout-medium-padding:
 * layout-small-padding:
 * layout-scrollbar-background-color:
 * layout-scrollbar-color:
 * layout-scrollbar-width:
 */
class NbLayoutComponent {
    constructor(themeService, spinnerService, elementRef, renderer, window, document, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
        this.themeService = themeService;
        this.spinnerService = spinnerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.window = window;
        this.document = document;
        this.platformId = platformId;
        this.layoutDirectionService = layoutDirectionService;
        this.scrollService = scrollService;
        this.rulerService = rulerService;
        this.scrollTop = scrollTop;
        this.overlayContainer = overlayContainer;
        this.scrollBlockClass = 'nb-global-scrollblock';
        this.isScrollBlocked = false;
        this.centerValue = false;
        this.restoreScrollTopValue = true;
        this.windowModeValue = false;
        this.withScrollValue = false;
        this.withSubheader = false;
        this.afterViewInit$ = new BehaviorSubject(null);
        this.destroy$ = new Subject();
        this.registerAsOverlayContainer();
        this.themeService.onThemeChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe((theme) => {
            const body = this.document.getElementsByTagName('body')[0];
            if (theme.previous) {
                this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
            }
            this.renderer.addClass(body, `nb-theme-${theme.name}`);
        });
        this.themeService.onAppendLayoutClass()
            .pipe(takeUntil(this.destroy$))
            .subscribe((className) => {
            this.renderer.addClass(this.elementRef.nativeElement, className);
        });
        this.themeService.onRemoveLayoutClass()
            .pipe(takeUntil(this.destroy$))
            .subscribe((className) => {
            this.renderer.removeClass(this.elementRef.nativeElement, className);
        });
        this.spinnerService.registerLoader(new Promise((resolve, reject) => {
            this.afterViewInit$
                .pipe(takeUntil(this.destroy$))
                .subscribe((_) => resolve());
        }));
        this.spinnerService.load();
        this.rulerService.onGetDimensions()
            .pipe(takeUntil(this.destroy$))
            .subscribe(({ listener }) => {
            listener.next(this.getDimensions());
            listener.complete();
        });
        this.scrollService
            .onScrollableChange()
            .pipe(filter(() => this.withScrollValue))
            .subscribe((scrollable) => {
            /**
             * In case when Nebular Layout custom scroll `withScroll` mode is enabled
             * we need to disable default CDK scroll blocker (@link NbBlockScrollStrategyAdapter) on HTML element
             * so that it won't add additional positioning.
             */
            if (scrollable) {
                this.enableScroll();
            }
            else {
                this.blockScroll();
            }
        });
        if (isPlatformBrowser(this.platformId)) {
            // trigger first time so that after the change we have the initial value
            this.themeService.changeWindowWidth(this.window.innerWidth);
        }
    }
    /**
     * Defines whether the layout columns will be centered after some width
     * @param {boolean} val
     */
    set center(val) {
        this.centerValue = convertToBoolProperty(val);
    }
    /**
     * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
     * becomes centered by width with a margin from the top of the screen, like a floating window.
     * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
     * window. (TODO: check this)
     * @param {boolean} val
     */
    set windowMode(val) {
        this.windowModeValue = convertToBoolProperty(val);
        this.withScroll = this.windowModeValue;
    }
    /**
     * Defines whether to move the scrollbars to layout or leave it at the body level.
     * Automatically set to true when `windowMode` is enabled.
     * @param {boolean} val
     */
    set withScroll(val) {
        this.withScrollValue = convertToBoolProperty(val);
        // TODO: is this the best way of doing it? as we don't have access to body from theme styles
        // TODO: add e2e test
        const body = this.document.getElementsByTagName('body')[0];
        if (this.withScrollValue) {
            this.renderer.setStyle(body, 'overflow', 'hidden');
        }
        else {
            this.renderer.setStyle(body, 'overflow', 'initial');
        }
    }
    /**
     * Restores scroll to the top of the page after navigation
     * @param {boolean} val
     */
    set restoreScrollTop(val) {
        this.restoreScrollTopValue = convertToBoolProperty(val);
    }
    ngAfterViewInit() {
        this.scrollService.onGetPosition()
            .pipe(takeUntil(this.destroy$))
            .subscribe(({ listener }) => {
            listener.next(this.getScrollPosition());
            listener.complete();
        });
        this.scrollTop.shouldRestore()
            .pipe(filter(() => this.restoreScrollTopValue), takeUntil(this.destroy$))
            .subscribe(() => this.scroll(0, 0));
        this.layoutDirectionService.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe(direction => this.document.dir = direction);
        this.scrollService.onManualScroll()
            .pipe(takeUntil(this.destroy$))
            .subscribe(({ x, y }) => this.scroll(x, y));
        this.afterViewInit$.next(true);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.unregisterAsOverlayContainer();
    }
    onScroll($event) {
        this.scrollService.fireScrollChange($event);
    }
    onResize(event) {
        this.themeService.changeWindowWidth(event.target.innerWidth);
    }
    /**
     * Returns scroll and client height/width
     *
     * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
     * or from the `.scrollable-container`
     * @returns {NbLayoutDimensions}
     */
    getDimensions() {
        let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
        if (this.withScrollValue) {
            const container = this.scrollableContainerRef.nativeElement;
            clientWidth = container.clientWidth;
            clientHeight = container.clientHeight;
            scrollWidth = container.scrollWidth;
            scrollHeight = container.scrollHeight;
        }
        else {
            const { documentElement, body } = this.document;
            clientWidth = documentElement.clientWidth || body.clientWidth;
            clientHeight = documentElement.clientHeight || body.clientHeight;
            scrollWidth = documentElement.scrollWidth || body.scrollWidth;
            scrollHeight = documentElement.scrollHeight || body.scrollHeight;
        }
        return {
            clientWidth,
            clientHeight,
            scrollWidth,
            scrollHeight,
        };
    }
    /**
     * Returns scroll position of current scroll container.
     *
     * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
     * otherwise - of the scrollable element of the window (which may be different depending of a browser)
     *
     * @returns {NbScrollPosition}
     */
    getScrollPosition() {
        if (!isPlatformBrowser(this.platformId)) {
            return { x: 0, y: 0 };
        }
        if (this.withScrollValue) {
            const container = this.scrollableContainerRef.nativeElement;
            return { x: container.scrollLeft, y: container.scrollTop };
        }
        const documentRect = this.document.documentElement.getBoundingClientRect();
        const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX ||
            this.document.documentElement.scrollLeft || 0;
        const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY ||
            this.document.documentElement.scrollTop || 0;
        return { x, y };
    }
    registerAsOverlayContainer() {
        if (this.overlayContainer.setContainer) {
            this.overlayContainer.setContainer(this.elementRef.nativeElement);
        }
    }
    unregisterAsOverlayContainer() {
        if (this.overlayContainer.clearContainer) {
            this.overlayContainer.clearContainer();
        }
    }
    scroll(x = null, y = null) {
        const { x: currentX, y: currentY } = this.getScrollPosition();
        x = x == null ? currentX : x;
        y = y == null ? currentY : y;
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        if (this.withScrollValue) {
            const scrollable = this.scrollableContainerRef.nativeElement;
            if (scrollable.scrollTo) {
                scrollable.scrollTo(x, y);
            }
            else {
                scrollable.scrollLeft = x;
                scrollable.scrollTop = y;
            }
        }
        else {
            this.window.scrollTo(x, y);
        }
    }
    // TODO: Extract into block scroll strategy
    blockScroll() {
        if (this.isScrollBlocked) {
            return;
        }
        this.isScrollBlocked = true;
        this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
        const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
        const layoutElement = this.layoutContainerRef.nativeElement;
        const layoutWithScrollWidth = layoutElement.clientWidth;
        this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
        scrollableContainerElement.style.overflow = 'hidden';
        const layoutWithoutScrollWidth = layoutElement.clientWidth;
        const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
        if (!scrollWidth) {
            return;
        }
        this.layoutPaddingOldValue = {
            left: layoutElement.style.paddingLeft,
            right: layoutElement.style.paddingRight,
        };
        if (this.layoutDirectionService.isLtr()) {
            layoutElement.style.paddingRight = `${scrollWidth}px`;
        }
        else {
            layoutElement.style.paddingLeft = `${scrollWidth}px`;
        }
    }
    enableScroll() {
        if (this.isScrollBlocked) {
            this.isScrollBlocked = false;
            this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
            this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
            if (this.layoutPaddingOldValue) {
                const layoutElement = this.layoutContainerRef.nativeElement;
                layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
                layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
                this.layoutPaddingOldValue = null;
            }
        }
    }
}
NbLayoutComponent.ɵfac = function NbLayoutComponent_Factory(t) { return new (t || NbLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(NbSpinnerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbLayoutScrollService), ɵngcc0.ɵɵdirectiveInject(NbLayoutRulerService), ɵngcc0.ɵɵdirectiveInject(NbRestoreScrollTopHelper), ɵngcc0.ɵɵdirectiveInject(NbOverlayContainerAdapter)); };
NbLayoutComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutComponent, selectors: [["nb-layout"]], viewQuery: function NbLayoutComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, 1, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c10, 1, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c11, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.veryTopRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollableContainerRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.layoutContainerRef = _t.first);
    } }, hostVars: 6, hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) { return ctx.onScroll($event); }, false, ɵngcc0.ɵɵresolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
    } }, inputs: { center: "center", windowMode: "windowMode", withScroll: "withScroll", restoreScrollTop: "restoreScrollTop" }, ngContentSelectors: _c13, decls: 12, vars: 2, consts: [[1, "scrollable-container", 3, "scroll"], ["scrollableContainer", ""], [1, "layout"], ["layoutContainer", ""], [1, "layout-container"], [1, "content"], [1, "columns"]], template: function NbLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c12);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) { return ctx.onScroll($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵelementStart(7, "div", 5);
        ɵngcc0.ɵɵprojection(8, 2);
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵprojection(10, 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(11, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵclassProp("center", ctx.centerValue);
    } }, styles: ["[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}"] });
NbLayoutComponent.ctorParameters = () => [
    { type: NbThemeService },
    { type: NbSpinnerService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [NB_WINDOW,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NbLayoutDirectionService },
    { type: NbLayoutScrollService },
    { type: NbLayoutRulerService },
    { type: NbRestoreScrollTopHelper },
    { type: NbOverlayContainerAdapter }
];
NbLayoutComponent.propDecorators = {
    windowModeValue: [{ type: HostBinding, args: ['class.window-mode',] }],
    withScrollValue: [{ type: HostBinding, args: ['class.with-scroll',] }],
    withSubheader: [{ type: HostBinding, args: ['class.with-subheader',] }],
    center: [{ type: Input }],
    windowMode: [{ type: Input }],
    withScroll: [{ type: Input }],
    restoreScrollTop: [{ type: Input }],
    veryTopRef: [{ type: ViewChild, args: ['layoutTopDynamicArea', { read: ViewContainerRef },] }],
    scrollableContainerRef: [{ type: ViewChild, args: ['scrollableContainer', { read: ElementRef },] }],
    layoutContainerRef: [{ type: ViewChild, args: ['layoutContainer', { read: ElementRef },] }],
    onScroll: [{ type: HostListener, args: ['window:scroll', ['$event'],] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout',
                template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
                styles: [":host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n"]
            }]
    }], function () { return [{ type: NbThemeService }, { type: NbSpinnerService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: NbLayoutDirectionService }, { type: NbLayoutScrollService }, { type: NbLayoutRulerService }, { type: NbRestoreScrollTopHelper }, { type: NbOverlayContainerAdapter }]; }, { windowModeValue: [{
            type: HostBinding,
            args: ['class.window-mode']
        }], withScrollValue: [{
            type: HostBinding,
            args: ['class.with-scroll']
        }], withSubheader: [{
            type: HostBinding,
            args: ['class.with-subheader']
        }], center: [{
            type: Input
        }], windowMode: [{
            type: Input
        }], withScroll: [{
            type: Input
        }], restoreScrollTop: [{
            type: Input
        }], onScroll: [{
            type: HostListener,
            args: ['window:scroll', ['$event']]
        }], onResize: [{
            type: HostListener,
            args: ['window:resize', ['$event']]
        }], veryTopRef: [{
            type: ViewChild,
            args: ['layoutTopDynamicArea', { read: ViewContainerRef }]
        }], scrollableContainerRef: [{
            type: ViewChild,
            args: ['scrollableContainer', { read: ElementRef }]
        }], layoutContainerRef: [{
            type: ViewChild,
            args: ['layoutContainer', { read: ElementRef }]
        }] }); })();
/**
 * A container component which determines a content position inside of the layout.
 * The layout could contain unlimited columns (not including the sidebars).
 *
 * By default the columns are ordered from the left to the right,
 * but it's also possible to overwrite this behavior by setting a `left` attribute to the column,
 * moving it to the very first position:
 *
 * @stacked-example(Column Left, layout/layout-column-left.component)
 */
class NbLayoutColumnComponent {
    /**
     * Move the column to the very left position in the layout.
     * @param {boolean} val
     */
    set left(val) {
        this.leftValue = convertToBoolProperty(val);
        this.startValue = false;
    }
    /**
     * Make column first in the layout.
     * @param {boolean} val
     */
    set start(val) {
        this.startValue = convertToBoolProperty(val);
        this.leftValue = false;
    }
}
NbLayoutColumnComponent.ɵfac = function NbLayoutColumnComponent_Factory(t) { return new (t || NbLayoutColumnComponent)(); };
NbLayoutColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutColumnComponent, selectors: [["nb-layout-column"]], hostVars: 4, hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("left", ctx.leftValue)("start", ctx.startValue);
    } }, inputs: { left: "left", start: "start" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbLayoutColumnComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
NbLayoutColumnComponent.propDecorators = {
    leftValue: [{ type: HostBinding, args: ['class.left',] }],
    startValue: [{ type: HostBinding, args: ['class.start',] }],
    left: [{ type: Input }],
    start: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutColumnComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-column',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, { left: [{
            type: Input
        }], leftValue: [{
            type: HostBinding,
            args: ['class.left']
        }], startValue: [{
            type: HostBinding,
            args: ['class.start']
        }], start: [{
            type: Input
        }] }); })();
/**
 * Page header component.
 * Located on top of the page above the layout columns and sidebars.
 * Could be made `fixed` by setting the corresponding property. In the fixed mode the header becomes
 * sticky to the top of the nb-layout (to of the page). Here's an example:
 *
 * @stacked-example(Fixed Header, layout/layout-fixed-header.component)
 *
 * In a pair with sidebar it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * Same way you can put both `fixed` and `clipped` headers adding creating a sub-header for your app:
 *
 * @stacked-example(Subheader, layout/layout-subheader.component)
 *
 * @styles
 *
 * header-background-color:
 * header-text-color:
 * header-text-font-family:
 * header-text-font-size:
 * header-text-font-weight:
 * header-text-line-height:
 * header-height:
 * header-padding:
 * header-shadow:
 */
class NbLayoutHeaderComponent {
    constructor(layout) {
        this.layout = layout;
    }
    /**
     * Makes the header sticky to the top of the nb-layout.
     * @param {boolean} val
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
    /**
     * Places header on a side of the sidebar, and not above.
     * Disables fixed mode for this header and remove a shadow from the sidebar.
     * @param {boolean} val
     */
    set subheader(val) {
        this.subheaderValue = convertToBoolProperty(val);
        this.fixedValue = false;
        this.layout.withSubheader = this.subheaderValue;
    }
}
NbLayoutHeaderComponent.ɵfac = function NbLayoutHeaderComponent_Factory(t) { return new (t || NbLayoutHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutComponent)); };
NbLayoutHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutHeaderComponent, selectors: [["nb-layout-header"]], hostVars: 4, hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
    } }, inputs: { fixed: "fixed", subheader: "subheader" }, ngContentSelectors: _c0, decls: 2, vars: 2, template: function NbLayoutHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "nav");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, encapsulation: 2 });
NbLayoutHeaderComponent.ctorParameters = () => [
    { type: NbLayoutComponent }
];
NbLayoutHeaderComponent.propDecorators = {
    fixedValue: [{ type: HostBinding, args: ['class.fixed',] }],
    subheaderValue: [{ type: HostBinding, args: ['class.subheader',] }],
    fixed: [{ type: Input }],
    subheader: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-header',
                template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
            }]
    }], function () { return [{ type: NbLayoutComponent }]; }, { fixed: [{
            type: Input
        }], fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }], subheader: [{
            type: Input
        }], subheaderValue: [{
            type: HostBinding,
            args: ['class.subheader']
        }] }); })();
/**
 * Page footer.
 * Located under the nb-layout content (specifically, under the columns).
 * Could be made `fixed`, becoming sticky to the bottom of the view port (window).
 *
 * @styles
 *
 * footer-background-color:
 * footer-text-color:
 * footer-text-font-family:
 * footer-text-font-size:
 * footer-text-font-weight:
 * footer-text-line-height:
 * footer-text-highlight-color:
 * footer-height:
 * footer-padding:
 * footer-divider-color:
 * footer-divider-style:
 * footer-divider-width:
 * footer-shadow:
 */
class NbLayoutFooterComponent {
    /**
     * Makes the footer sticky to the bottom of the window.
     * @param {boolean} val
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
}
NbLayoutFooterComponent.ɵfac = function NbLayoutFooterComponent_Factory(t) { return new (t || NbLayoutFooterComponent)(); };
NbLayoutFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutFooterComponent, selectors: [["nb-layout-footer"]], hostVars: 2, hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, inputs: { fixed: "fixed" }, ngContentSelectors: _c0, decls: 2, vars: 2, template: function NbLayoutFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "nav");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, encapsulation: 2 });
NbLayoutFooterComponent.propDecorators = {
    fixedValue: [{ type: HostBinding, args: ['class.fixed',] }],
    fixed: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-footer',
                template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
            }]
    }], null, { fixed: [{
            type: Input
        }], fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_LAYOUT_COMPONENTS = [
    NbLayoutComponent,
    NbLayoutColumnComponent,
    NbLayoutFooterComponent,
    NbLayoutHeaderComponent,
];
class NbLayoutModule {
}
NbLayoutModule.ɵfac = function NbLayoutModule_Factory(t) { return new (t || NbLayoutModule)(); };
NbLayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbLayoutModule });
NbLayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        NbRestoreScrollTopHelper,
    ], imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbLayoutModule, { declarations: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent], imports: [NbSharedModule], exports: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbLayoutModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_LAYOUT_COMPONENTS,
                ],
                providers: [
                    NbRestoreScrollTopHelper,
                ],
                exports: [
                    ...NB_LAYOUT_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const itemClick$ = new Subject();
const addItems$ = new ReplaySubject(1);
const navigateHome$ = new ReplaySubject(1);
const getSelectedItem$ = new ReplaySubject(1);
const itemSelect$ = new ReplaySubject(1);
const itemHover$ = new ReplaySubject(1);
const submenuToggle$ = new ReplaySubject(1);
const collapseAll$ = new ReplaySubject(1);
// TODO: check if we need both URL and LINK
/**
 *
 *
 * Menu Item options example
 * @stacked-example(Menu Link Parameters, menu/menu-link-params.component)
 *
 *
 */
class NbMenuItem {
    constructor() {
        /**
         * Item is selected when partly or fully equal to the current url
         * @type {string}
         */
        this.pathMatch = 'full';
    }
    /**
     * @returns item parents in top-down order
     */
    static getParents(item) {
        const parents = [];
        let parent = item.parent;
        while (parent) {
            parents.unshift(parent);
            parent = parent.parent;
        }
        return parents;
    }
    static isParent(item, possibleChild) {
        return possibleChild.parent
            ? possibleChild.parent === item || this.isParent(item, possibleChild.parent)
            : false;
    }
}
// TODO: map select events to router change events
// TODO: review the interface
/**
 *
 *
 * Menu Service. Allows you to listen to menu events, or to interact with a menu.
 * @stacked-example(Menu Service, menu/menu-service.component)
 *
 *
 */
class NbMenuService {
    /**
     * Add items to the end of the menu items list
     * @param {List<NbMenuItem>} items
     * @param {string} tag
     */
    addItems(items, tag) {
        addItems$.next({ tag, items });
    }
    /**
     * Collapses all menu items
     * @param {string} tag
     */
    collapseAll(tag) {
        collapseAll$.next({ tag });
    }
    /**
     * Navigate to the home menu item
     * @param {string} tag
     */
    navigateHome(tag) {
        navigateHome$.next({ tag });
    }
    /**
     * Returns currently selected item. Won't subscribe to the future events.
     * @param {string} tag
     * @returns {Observable<{tag: string; item: NbMenuItem}>}
     */
    getSelectedItem(tag) {
        const listener = new BehaviorSubject(null);
        getSelectedItem$.next({ tag, listener });
        return listener.asObservable();
    }
    onItemClick() {
        return itemClick$.pipe(share());
    }
    onItemSelect() {
        return itemSelect$.pipe(share());
    }
    onItemHover() {
        return itemHover$.pipe(share());
    }
    onSubmenuToggle() {
        return submenuToggle$.pipe(share());
    }
}
NbMenuService.ɵfac = function NbMenuService_Factory(t) { return new (t || NbMenuService)(); };
NbMenuService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMenuService, factory: NbMenuService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMenuService, [{
        type: Injectable
    }], null, null); })();
class NbMenuInternalService {
    constructor(location) {
        this.location = location;
    }
    prepareItems(items) {
        const defaultItem = new NbMenuItem();
        items.forEach(i => {
            this.applyDefaults(i, defaultItem);
            this.setParent(i);
        });
    }
    selectFromUrl(items, tag, collapseOther = false) {
        const selectedItem = this.findItemByUrl(items);
        if (selectedItem) {
            this.selectItem(selectedItem, items, collapseOther, tag);
        }
    }
    selectItem(item, items, collapseOther = false, tag) {
        const unselectedItems = this.resetSelection(items);
        const collapsedItems = collapseOther ? this.collapseItems(items) : [];
        for (const parent of NbMenuItem.getParents(item)) {
            parent.selected = true;
            // emit event only for items that weren't selected before ('unselectedItems' contains items that were selected)
            if (!unselectedItems.includes(parent)) {
                this.itemSelect(parent, tag);
            }
            const wasNotExpanded = !parent.expanded;
            parent.expanded = true;
            const i = collapsedItems.indexOf(parent);
            // emit event only for items that weren't expanded before.
            // 'collapsedItems' contains items that were expanded, so no need to emit event.
            // in case 'collapseOther' is false, 'collapsedItems' will be empty,
            // so also check if item isn't expanded already ('wasNotExpanded').
            if (i === -1 && wasNotExpanded) {
                this.submenuToggle(parent, tag);
            }
            else {
                collapsedItems.splice(i, 1);
            }
        }
        item.selected = true;
        // emit event only for items that weren't selected before ('unselectedItems' contains items that were selected)
        if (!unselectedItems.includes(item)) {
            this.itemSelect(item, tag);
        }
        // remaining items which wasn't expanded back after expanding all currently selected items
        for (const collapsedItem of collapsedItems) {
            this.submenuToggle(collapsedItem, tag);
        }
    }
    collapseAll(items, tag, except) {
        const collapsedItems = this.collapseItems(items, except);
        for (const item of collapsedItems) {
            this.submenuToggle(item, tag);
        }
    }
    onAddItem() {
        return addItems$.pipe(share());
    }
    onNavigateHome() {
        return navigateHome$.pipe(share());
    }
    onCollapseAll() {
        return collapseAll$.pipe(share());
    }
    onGetSelectedItem() {
        return getSelectedItem$.pipe(share());
    }
    itemHover(item, tag) {
        itemHover$.next({ tag, item });
    }
    submenuToggle(item, tag) {
        submenuToggle$.next({ tag, item });
    }
    itemSelect(item, tag) {
        itemSelect$.next({ tag, item });
    }
    itemClick(item, tag) {
        itemClick$.next({ tag, item });
    }
    /**
     * Unselect all given items deeply.
     * @param items array of items to unselect.
     * @returns items which selected value was changed.
     */
    resetSelection(items) {
        const unselectedItems = [];
        for (const item of items) {
            if (item.selected) {
                unselectedItems.push(item);
            }
            item.selected = false;
            if (item.children) {
                unselectedItems.push(...this.resetSelection(item.children));
            }
        }
        return unselectedItems;
    }
    /**
     * Collapse all given items deeply.
     * @param items array of items to collapse.
     * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
     * @returns items which expanded value was changed.
     */
    collapseItems(items, except) {
        const collapsedItems = [];
        for (const item of items) {
            if (except && (item === except || NbMenuItem.isParent(item, except))) {
                continue;
            }
            if (item.expanded) {
                collapsedItems.push(item);
            }
            item.expanded = false;
            if (item.children) {
                collapsedItems.push(...this.collapseItems(item.children));
            }
        }
        return collapsedItems;
    }
    applyDefaults(item, defaultItem) {
        const menuItem = Object.assign({}, item);
        Object.assign(item, defaultItem, menuItem);
        item.children && item.children.forEach(child => {
            this.applyDefaults(child, defaultItem);
        });
    }
    setParent(item) {
        item.children && item.children.forEach(child => {
            child.parent = item;
            this.setParent(child);
        });
    }
    /**
     * Find deepest item which link matches current URL path.
     * @param items array of items to search in.
     * @returns found item of undefined.
     */
    findItemByUrl(items) {
        let selectedItem;
        items.some(item => {
            if (item.children) {
                selectedItem = this.findItemByUrl(item.children);
            }
            if (!selectedItem && this.isSelectedInUrl(item)) {
                selectedItem = item;
            }
            return selectedItem;
        });
        return selectedItem;
    }
    isSelectedInUrl(item) {
        const exact = item.pathMatch === 'full';
        const link = item.link;
        const isSelectedInPath = exact
            ? isUrlPathEqual(this.location.path(), link)
            : isUrlPathContain(this.location.path(), link);
        if (isSelectedInPath && item.fragment != null) {
            return exact
                ? isFragmentEqual(this.location.path(true), item.fragment)
                : isFragmentContain(this.location.path(true), item.fragment);
        }
        return isSelectedInPath;
    }
}
NbMenuInternalService.ɵfac = function NbMenuInternalService_Factory(t) { return new (t || NbMenuInternalService)(ɵngcc0.ɵɵinject(ɵngcc2.Location)); };
NbMenuInternalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMenuInternalService, factory: NbMenuInternalService.ɵfac });
NbMenuInternalService.ctorParameters = () => [
    { type: Location }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMenuInternalService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.Location }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var NbToggleStates;
(function (NbToggleStates) {
    NbToggleStates["Expanded"] = "expanded";
    NbToggleStates["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
class NbMenuItemComponent {
    constructor(menuService, directionService) {
        this.menuService = menuService;
        this.directionService = directionService;
        this.menuItem = null;
        this.hoverItem = new EventEmitter();
        this.toggleSubMenu = new EventEmitter();
        this.selectItem = new EventEmitter();
        this.itemClick = new EventEmitter();
        this.destroy$ = new Subject();
    }
    ngDoCheck() {
        this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
    }
    ngAfterViewInit() {
        this.menuService.onSubmenuToggle()
            .pipe(filter(({ item }) => item === this.menuItem), map(({ item }) => item.expanded), takeUntil(this.destroy$))
            .subscribe(isExpanded => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onToggleSubMenu(item) {
        this.toggleSubMenu.emit(item);
    }
    onHoverItem(item) {
        this.hoverItem.emit(item);
    }
    onSelectItem(item) {
        this.selectItem.emit(item);
    }
    onItemClick(item) {
        this.itemClick.emit(item);
    }
    getExpandStateIcon() {
        if (this.menuItem.expanded) {
            return 'chevron-down-outline';
        }
        return this.directionService.isLtr()
            ? 'chevron-left-outline'
            : 'chevron-right-outline';
    }
}
NbMenuItemComponent.ɵfac = function NbMenuItemComponent_Factory(t) { return new (t || NbMenuItemComponent)(ɵngcc0.ɵɵdirectiveInject(NbMenuService), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService)); };
NbMenuItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbMenuItemComponent, selectors: [["", "nbMenuItem", ""]], inputs: { menuItem: "menuItem", badge: "badge" }, outputs: { hoverItem: "hoverItem", toggleSubMenu: "toggleSubMenu", selectItem: "selectItem", itemClick: "itemClick" }, attrs: _c14, decls: 8, vars: 6, consts: [[4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["badgeTemplate", ""], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "mouseenter", "click"], [1, "menu-title"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "badge", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"], [3, "text", "dotMode", "status"]], template: function NbMenuItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_1_Template, 5, 13, "a", 1);
        ɵngcc0.ɵɵtemplate(2, NbMenuItemComponent_a_2_Template, 5, 8, "a", 2);
        ɵngcc0.ɵɵtemplate(3, NbMenuItemComponent_a_3_Template, 5, 7, "a", 2);
        ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_4_Template, 6, 8, "a", 3);
        ɵngcc0.ɵɵtemplate(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 4);
        ɵngcc0.ɵɵtemplate(6, NbMenuItemComponent_ng_template_6_Template, 1, 3, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.children);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.children);
    } }, directives: function () { return [ɵngcc2.NgIf, NbIconComponent, ɵngcc5.RouterLinkWithHref, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgForOf, NbMenuItemComponent, NbBadgeComponent]; }, encapsulation: 2, data: { animation: [
            trigger('toggle', [
                state(NbToggleStates.Collapsed, style({ height: '0', margin: '0' })),
                state(NbToggleStates.Expanded, style({ height: '*' })),
                transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300)),
            ]),
        ] } });
NbMenuItemComponent.ctorParameters = () => [
    { type: NbMenuService },
    { type: NbLayoutDirectionService }
];
NbMenuItemComponent.propDecorators = {
    menuItem: [{ type: Input }],
    badge: [{ type: Input }],
    hoverItem: [{ type: Output }],
    toggleSubMenu: [{ type: Output }],
    selectItem: [{ type: Output }],
    itemClick: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMenuItemComponent, [{
        type: Component,
        args: [{
                selector: '[nbMenuItem]',
                template: "<span *ngIf=\"menuItem.group\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a *ngIf=\"menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group\"\n   [routerLink]=\"menuItem.link\"\n   [queryParams]=\"menuItem.queryParams\"\n   [fragment]=\"menuItem.fragment\"\n   [queryParamsHandling]=\"menuItem.queryParamsHandling\"\n   [preserveFragment]=\"menuItem.preserveFragment\"\n   [skipLocationChange]=\"menuItem.skipLocationChange\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"onItemClick(menuItem);\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n  <ng-container *ngIf=\"badge\" [ngTemplateOutlet]=\"badgeTemplate\"></ng-container>\n</a>\n<a *ngIf=\"menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group\"\n   [attr.href]=\"menuItem.url\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"onSelectItem(menuItem)\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n  <ng-container *ngIf=\"badge\" [ngTemplateOutlet]=\"badgeTemplate\"></ng-container>\n</a>\n<a *ngIf=\"!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"$event.preventDefault(); onItemClick(menuItem);\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n  <ng-container *ngIf=\"badge\" [ngTemplateOutlet]=\"badgeTemplate\"></ng-container>\n</a>\n<a *ngIf=\"menuItem.children\"\n   (click)=\"$event.preventDefault(); onToggleSubMenu(menuItem);\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   href=\"#\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n  <ng-container *ngIf=\"badge\" [ngTemplateOutlet]=\"badgeTemplate\"></ng-container>\n  <nb-icon class=\"expand-state\" [icon]=\"getExpandStateIcon()\" pack=\"nebular-essentials\"></nb-icon>\n</a>\n<ul *ngIf=\"menuItem.children\"\n    [class.collapsed]=\"!(menuItem.children && menuItem.expanded)\"\n    [class.expanded]=\"menuItem.expanded\"\n    [@toggle]=\"toggleState\"\n    class=\"menu-items\">\n  <ng-container *ngFor=\"let item of menuItem.children\">\n    <li nbMenuItem *ngIf=\"!item.hidden\"\n        [menuItem]=\"item\"\n        [badge]=\"item.badge\"\n        [class.menu-group]=\"item.group\"\n        (hoverItem)=\"onHoverItem($event)\"\n        (toggleSubMenu)=\"onToggleSubMenu($event)\"\n        (selectItem)=\"onSelectItem($event)\"\n        (itemClick)=\"onItemClick($event)\"\n        class=\"menu-item\">\n    </li>\n  </ng-container>\n</ul>\n\n<ng-template #badgeTemplate>\n  <nb-badge [text]=\"badge.text\" [dotMode]=\"badge.dotMode\" [status]=\"badge.status\">\n  </nb-badge>\n</ng-template>\n",
                animations: [
                    trigger('toggle', [
                        state(NbToggleStates.Collapsed, style({ height: '0', margin: '0' })),
                        state(NbToggleStates.Expanded, style({ height: '*' })),
                        transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300)),
                    ]),
                ]
            }]
    }], function () { return [{ type: NbMenuService }, { type: NbLayoutDirectionService }]; }, { menuItem: [{
            type: Input
        }], hoverItem: [{
            type: Output
        }], toggleSubMenu: [{
            type: Output
        }], selectItem: [{
            type: Output
        }], itemClick: [{
            type: Output
        }], badge: [{
            type: Input
        }] }); })();
/**
 * Vertical menu component.
 *
 * Accepts a list of menu items and renders them accordingly. Supports multi-level menus.
 *
 * Basic example
 * @stacked-example(Showcase, menu/menu-showcase.component)
 *
 * ```ts
 * // ...
 * items: NbMenuItem[] = [
 *  {
 *    title: home,
 *    link: '/'
 *  },
 *  {
 *    title: dashboard,
 *    link: 'dashboard'
 *  }
 * ];
 * // ...
 * <nb-menu [items]="items"></nb-menu>
 * ```
 * ### Installation
 *
 * Import `NbMenuModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * and `NbMenuModule` to your feature module where the component should be shown:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Two-level menu example
 * @stacked-example(Two Levels, menu/menu-children.component)
 *
 *
 * Autocollapse menu example
 * @stacked-example(Autocollapse Menu, menu/menu-autocollapse.component)
 *
 * Menu badge
 * @stacked-example(Menu item badge, menu/menu-badge.component)
 *
 * @styles
 *
 * menu-background-color:
 * menu-text-color:
 * menu-text-font-family:
 * menu-text-font-size:
 * menu-text-font-weight:
 * menu-text-line-height:
 * menu-group-text-color:
 * menu-item-border-radius:
 * menu-item-padding:
 * menu-item-hover-background-color:
 * menu-item-hover-cursor:
 * menu-item-hover-text-color:
 * menu-item-icon-hover-color:
 * menu-item-active-background-color:
 * menu-item-active-text-color:
 * menu-item-icon-active-color:
 * menu-item-icon-color:
 * menu-item-icon-margin:
 * menu-item-icon-width:
 * menu-item-divider-color:
 * menu-item-divider-style:
 * menu-item-divider-width:
 * menu-submenu-background-color:
 * menu-submenu-text-color:
 * menu-submenu-margin:
 * menu-submenu-padding:
 * menu-submenu-item-border-color:
 * menu-submenu-item-border-style:
 * menu-submenu-item-border-width:
 * menu-submenu-item-border-radius:
 * menu-submenu-item-padding:
 * menu-submenu-item-hover-background-color:
 * menu-submenu-item-hover-border-color:
 * menu-submenu-item-hover-text-color:
 * menu-submenu-item-icon-hover-color:
 * menu-submenu-item-active-background-color:
 * menu-submenu-item-active-border-color:
 * menu-submenu-item-active-text-color:
 * menu-submenu-item-icon-active-color:
 * menu-submenu-item-active-hover-background-color:
 * menu-submenu-item-active-hover-border-color:
 * menu-submenu-item-active-hover-text-color:
 * menu-submenu-item-icon-active-hover-color:
 */
class NbMenuComponent {
    constructor(window, platformId, menuInternalService, router) {
        this.window = window;
        this.platformId = platformId;
        this.menuInternalService = menuInternalService;
        this.router = router;
        this._autoCollapse = false;
        this.destroy$ = new Subject();
    }
    /**
     * Collapse all opened submenus on the toggle event
     * Default value is "false"
     * @type boolean
     */
    get autoCollapse() {
        return this._autoCollapse;
    }
    set autoCollapse(value) {
        this._autoCollapse = convertToBoolProperty(value);
    }
    ngOnInit() {
        this.menuInternalService.prepareItems(this.items);
        this.menuInternalService
            .onAddItem()
            .pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$))
            .subscribe(data => this.onAddItem(data));
        this.menuInternalService
            .onNavigateHome()
            .pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$))
            .subscribe(() => this.navigateHome());
        this.menuInternalService
            .onGetSelectedItem()
            .pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$))
            .subscribe((data) => {
            data.listener.next({ tag: this.tag, item: this.getSelectedItem(this.items) });
        });
        this.menuInternalService
            .onCollapseAll()
            .pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$))
            .subscribe(() => this.collapseAll());
        this.router.events
            .pipe(filter(event => event instanceof NavigationEnd), takeUntil(this.destroy$))
            .subscribe(() => {
            this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
        });
    }
    ngAfterViewInit() {
        setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
    }
    onAddItem(data) {
        this.items.push(...data.items);
        this.menuInternalService.prepareItems(this.items);
        this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    }
    onHoverItem(item) {
        this.menuInternalService.itemHover(item, this.tag);
    }
    onToggleSubMenu(item) {
        if (this.autoCollapse) {
            this.menuInternalService.collapseAll(this.items, this.tag, item);
        }
        item.expanded = !item.expanded;
        this.menuInternalService.submenuToggle(item, this.tag);
    }
    // TODO: is not fired on page reload
    onSelectItem(item) {
        this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
    }
    onItemClick(item) {
        this.menuInternalService.itemClick(item, this.tag);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    navigateHome() {
        const homeItem = this.getHomeItem(this.items);
        if (homeItem) {
            if (homeItem.link) {
                const extras = {
                    queryParams: homeItem.queryParams,
                    queryParamsHandling: homeItem.queryParamsHandling,
                    fragment: homeItem.fragment,
                    preserveFragment: homeItem.preserveFragment,
                };
                this.router.navigate([homeItem.link], extras);
            }
            if (homeItem.url && isPlatformBrowser(this.platformId)) {
                this.window.location.href = homeItem.url;
            }
        }
    }
    collapseAll() {
        this.menuInternalService.collapseAll(this.items, this.tag);
    }
    getHomeItem(items) {
        for (const item of items) {
            if (item.home) {
                return item;
            }
            const homeItem = item.children && this.getHomeItem(item.children);
            if (homeItem) {
                return homeItem;
            }
        }
    }
    compareTag(tag) {
        return !tag || tag === this.tag;
    }
    getSelectedItem(items) {
        let selected = null;
        items.forEach((item) => {
            if (item.selected) {
                selected = item;
            }
            if (item.selected && item.children && item.children.length > 0) {
                selected = this.getSelectedItem(item.children);
            }
        });
        return selected;
    }
}
NbMenuComponent.ɵfac = function NbMenuComponent_Factory(t) { return new (t || NbMenuComponent)(ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NbMenuInternalService), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Router)); };
NbMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbMenuComponent, selectors: [["nb-menu"]], inputs: { autoCollapse: "autoCollapse", tag: "tag", items: "items" }, decls: 2, vars: 1, consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "badge", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"]], template: function NbMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgIf, NbMenuItemComponent], styles: ["[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-item nb-badge{position:static}[_nghost-%COMP%]     .menu-group span{display:flex}"] });
NbMenuComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_WINDOW,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NbMenuInternalService },
    { type: Router }
];
NbMenuComponent.propDecorators = {
    tag: [{ type: Input }],
    items: [{ type: Input }],
    autoCollapse: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMenuComponent, [{
        type: Component,
        args: [{
                selector: 'nb-menu',
                template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [badge]="item.badge"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
                styles: [":host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-item nb-badge{position:static}:host ::ng-deep .menu-group span{display:flex}\n"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: NbMenuInternalService }, { type: ɵngcc5.Router }]; }, { autoCollapse: [{
            type: Input
        }], tag: [{
            type: Input
        }], items: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Badge is a simple labeling component.
 * It can be used to add additional information to any content or highlight unread items.
 *
 * Element is absolute positioned, so parent should be
 * [positioned element](https://developer.mozilla.org/en-US/docs/Web/CSS/position).
 * It means parent `position` should be set to anything except `static`, e.g. `relative`,
 * `absolute`, `fixed`, or `sticky`.
 *
 * ### Installation
 *
 * Import `NbBadgeModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbBadgeModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Badge with default position and status(color):
 *
 * ```html
 * <nb-badge text="badgeText"></nb-badge>
 * ```
 *
 * For example, badge can be placed into nb-card header:
 * @stacked-example(Showcase, badge/badge-showcase.component)
 *
 * Badge located on the bottom right with warning status:
 *
 * ```html
 * <nb-badge text="badgeText" status="warning" position="bottom right">
 * </nb-badge>
 * ```
 *
 * @styles
 *
 * badge-border-radius:
 * badge-text-font-family:
 * badge-text-font-size:
 * badge-text-font-weight:
 * badge-text-line-height:
 * badge-padding:
 * badge-basic-background-color:
 * badge-basic-text-color:
 * badge-primary-background-color:
 * badge-primary-text-color:
 * badge-success-background-color:
 * badge-success-text-color:
 * badge-info-background-color:
 * badge-info-text-color:
 * badge-warning-background-color:
 * badge-warning-text-color:
 * badge-danger-background-color:
 * badge-danger-text-color:
 * badge-control-background-color:
 * badge-control-text-color:
 */
class NbBadgeComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Text to display
         * @type string
         */
        this.text = '';
        this._defaultPosition = 'top right';
        this._position = this._defaultPosition;
        /**
         * Badge status (adds specific styles):
         * 'basic', 'primary', 'info', 'success', 'warning', 'danger', 'control'
         */
        this.status = 'basic';
    }
    /**
     * Badge position
     *
     * Can be set to any class or to one of predefined positions:
     * 'top left', 'top right', 'bottom left', 'bottom right',
     * 'top start', 'top end', 'bottom start', 'bottom end'
     * @type string
     */
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value || this._defaultPosition;
    }
    /**
     * Shows badge as a dot. No text is shown.
     * @type boolean
     */
    get dotMode() {
        return this._dotMode;
    }
    set dotMode(value) {
        this._dotMode = convertToBoolProperty(value);
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get top() {
        return this.position.includes('top');
    }
    get right() {
        return this.position.includes('right');
    }
    get bottom() {
        return this.position.includes('bottom');
    }
    get left() {
        return this.position.includes('left');
    }
    get start() {
        return this.position.includes('start');
    }
    get end() {
        return this.position.includes('end');
    }
    get center() {
        return this.position.includes('center');
    }
}
NbBadgeComponent.ɵfac = function NbBadgeComponent_Factory(t) { return new (t || NbBadgeComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbBadgeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBadgeComponent, selectors: [["nb-badge"]], hostVars: 32, hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("dot-mode", ctx.dotMode)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end)("position-center", ctx.center);
    } }, inputs: { text: "text", status: "status", position: "position", dotMode: "dotMode" }, decls: 1, vars: 1, template: function NbBadgeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.dotMode ? "" : ctx.text);
    } }, styles: ["[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}.position-center[_nghost-%COMP%]{top:50%;transform:translateY(-50%)}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}"] });
NbBadgeComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbBadgeComponent.propDecorators = {
    text: [{ type: Input }],
    position: [{ type: Input }],
    dotMode: [{ type: Input }, { type: HostBinding, args: ['class.dot-mode',] }],
    status: [{ type: Input }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    top: [{ type: HostBinding, args: ['class.position-top',] }],
    right: [{ type: HostBinding, args: ['class.position-right',] }],
    bottom: [{ type: HostBinding, args: ['class.position-bottom',] }],
    left: [{ type: HostBinding, args: ['class.position-left',] }],
    start: [{ type: HostBinding, args: ['class.position-start',] }],
    end: [{ type: HostBinding, args: ['class.position-end',] }],
    center: [{ type: HostBinding, args: ['class.position-center',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBadgeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-badge',
                template: `{{dotMode ? '' : text}}`,
                styles: [":host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}:host(.position-center){top:50%;transform:translateY(-50%)}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { text: [{
            type: Input
        }], status: [{
            type: Input
        }], position: [{
            type: Input
        }], dotMode: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.dot-mode']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], top: [{
            type: HostBinding,
            args: ['class.position-top']
        }], right: [{
            type: HostBinding,
            args: ['class.position-right']
        }], bottom: [{
            type: HostBinding,
            args: ['class.position-bottom']
        }], left: [{
            type: HostBinding,
            args: ['class.position-left']
        }], start: [{
            type: HostBinding,
            args: ['class.position-start']
        }], end: [{
            type: HostBinding,
            args: ['class.position-end']
        }], center: [{
            type: HostBinding,
            args: ['class.position-center']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbBadgeModule {
}
NbBadgeModule.ɵfac = function NbBadgeModule_Factory(t) { return new (t || NbBadgeModule)(); };
NbBadgeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBadgeModule });
NbBadgeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbBadgeModule, { declarations: [NbBadgeComponent], exports: [NbBadgeComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBadgeModule, [{
        type: NgModule,
        args: [{
                exports: [NbBadgeComponent],
                declarations: [NbBadgeComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
const NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
class NbMenuModule {
    static forRoot() {
        return {
            ngModule: NbMenuModule,
            providers: [
                ...NB_MENU_PROVIDERS,
            ],
        };
    }
}
NbMenuModule.ɵfac = function NbMenuModule_Factory(t) { return new (t || NbMenuModule)(); };
NbMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbMenuModule });
NbMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
            NbBadgeModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbMenuModule, { declarations: [NbMenuComponent, NbMenuItemComponent], imports: [NbSharedModule, NbIconModule, NbBadgeModule], exports: [NbMenuComponent, NbMenuItemComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbMenuModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                    NbBadgeModule,
                ],
                declarations: [...nbMenuComponents],
                exports: [...nbMenuComponents]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Route tabset components.
 * Renders tabs inside of a router-outlet.
 *
 * ```ts
 *  tabs = [
 *  {
 *    title: 'Route tab #1',
 *    route: '/pages/description',
 *    icon: 'home',
 *    responsive: true, // hide title before `route-tabs-icon-only-max-width` value
 *  },
 *  {
 *    title: 'Route tab #2',
 *    route: '/pages/images',
 *    }
 *  ];
 *
 *  <nb-route-tabset [tabs]="tabs"></nb-route-tabset>
 * ```
 * ### Installation
 *
 * Import `NbRouteTabsetModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbRouteTabsetModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * @stacked-example(Route Tabset, tabset/route-tabset-showcase.component)
 *
 * @styles
 *
 * route-tabset-background-color:
 * route-tabset-border-radius:
 * route-tabset-shadow:
 * route-tabset-tab-background-color:
 * route-tabset-tab-padding:
 * route-tabset-tab-text-color:
 * route-tabset-tab-text-font-family:
 * route-tabset-tab-text-font-size:
 * route-tabset-tab-text-font-weight:
 * route-tabset-tab-text-line-height:
 * route-tabset-tab-text-transform:
 * route-tabset-tab-underline-width:
 * route-tabset-tab-underline-color:
 * route-tabset-tab-active-background-color:
 * route-tabset-tab-active-text-color:
 * route-tabset-tab-active-underline-color:
 * route-tabset-tab-focus-background-color:
 * route-tabset-tab-focus-text-color:
 * route-tabset-tab-focus-underline-color:
 * route-tabset-tab-hover-background-color:
 * route-tabset-tab-hover-text-color:
 * route-tabset-tab-hover-underline-color:
 * route-tabset-tab-disabled-background-color:
 * route-tabset-tab-disabled-text-color:
 * route-tabset-tab-disabled-underline-color:
 * route-tabset-divider-color:
 * route-tabset-divider-style:
 * route-tabset-divider-width:
 * route-tabset-scrollbar-color:
 * route-tabset-scrollbar-background-color:
 * route-tabset-scrollbar-width:
 * route-tabset-tab-text-hide-breakpoint:
 */
class NbRouteTabsetComponent {
    constructor() {
        this.fullWidthValue = false;
        /**
         * Options passed to `routerLinkActiveOptions` directive which set on tab links.
         * `{ exact: true }` by default.
         */
        this.activeLinkOptions = { exact: true };
        /**
         * Emits when tab is selected
         * @type {EventEmitter<any>}
         */
        this.changeTab = new EventEmitter();
    }
    /**
     * Take full width of a parent
     * @param {boolean} val
     */
    set fullWidth(val) {
        this.fullWidthValue = convertToBoolProperty(val);
    }
    selectTab(tab) {
        this.changeTab.emit(tab);
    }
}
NbRouteTabsetComponent.ɵfac = function NbRouteTabsetComponent_Factory(t) { return new (t || NbRouteTabsetComponent)(); };
NbRouteTabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRouteTabsetComponent, selectors: [["nb-route-tabset"]], hostVars: 2, hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidthValue);
    } }, inputs: { activeLinkOptions: "activeLinkOptions", fullWidth: "fullWidth", tabs: "tabs" }, outputs: { changeTab: "changeTab" }, decls: 3, vars: 1, consts: [[1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["enabled", ""], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", "tabindex", "0", 1, "route-tab", 3, "routerLink", "routerLinkActiveOptions", "click"], [3, "icon", 4, "ngIf"], [3, "icon"]], template: function NbRouteTabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "router-outlet");
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc5.RouterOutlet, ɵngcc2.NgIf, NbIconComponent, ɵngcc5.RouterLinkActive, ɵngcc5.RouterLink], styles: [".route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}"] });
NbRouteTabsetComponent.propDecorators = {
    fullWidthValue: [{ type: HostBinding, args: ['class.full-width',] }],
    tabs: [{ type: Input }],
    activeLinkOptions: [{ type: Input }],
    fullWidth: [{ type: Input }],
    changeTab: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRouteTabsetComponent, [{
        type: Component,
        args: [{
                selector: 'nb-route-tabset',
                template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li *ngIf="tab.disabled; else enabled"
            [class.responsive]="tab.responsive"
            class="route-tab disabled"
            tabindex="-1">
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li (click)="$event.preventDefault(); selectTab(tab)"
              [routerLink]="tab.route"
              routerLinkActive="active"
              [routerLinkActiveOptions]="activeLinkOptions"
              [class.responsive]="tab.responsive"
              tabindex="0"
              class="route-tab">
            <a tabindex="-1" class="tab-link">
              <nb-icon *ngIf="tab.icon" [icon]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
                styles: [".route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a::before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tab-link nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tab-link nb-icon+span{margin-right:.5rem}:host(.full-width) .route-tabset{justify-content:space-around}\n"]
            }]
    }], function () { return []; }, { fullWidthValue: [{
            type: HostBinding,
            args: ['class.full-width']
        }], activeLinkOptions: [{
            type: Input
        }], changeTab: [{
            type: Output
        }], fullWidth: [{
            type: Input
        }], tabs: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbRouteTabsetModule {
}
NbRouteTabsetModule.ɵfac = function NbRouteTabsetModule_Factory(t) { return new (t || NbRouteTabsetModule)(); };
NbRouteTabsetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbRouteTabsetModule });
NbRouteTabsetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbRouteTabsetModule, { declarations: [NbRouteTabsetComponent], imports: [NbSharedModule, NbIconModule], exports: [NbRouteTabsetComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRouteTabsetModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    NbRouteTabsetComponent,
                ],
                exports: [
                    NbRouteTabsetComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const getSidebarState$ = new Subject();
const getSidebarResponsiveState$ = new Subject();
/**
 * Sidebar service.
 *
 * Root module service to control the sidebar from any part of the app.
 *
 * Allows you to change sidebar state dynamically from any part of the app:
 * @stacked-example(Sidebar State, sidebar/sidebar-toggle.component)
 */
class NbSidebarService {
    constructor() {
        this.toggle$ = new Subject();
        this.expand$ = new Subject();
        this.collapse$ = new Subject();
        this.compact$ = new Subject();
    }
    /**
     * Subscribe to toggle events
     *
     * @returns Observable<{ compact: boolean, tag: string }>
     */
    onToggle() {
        return this.toggle$.pipe(share());
    }
    /**
     * Subscribe to expand events
     * @returns Observable<{ tag: string }>
     */
    onExpand() {
        return this.expand$.pipe(share());
    }
    /**
     * Subscribe to collapse evens
     * @returns Observable<{ tag: string }>
     */
    onCollapse() {
        return this.collapse$.pipe(share());
    }
    /**
     * Subscribe to compact evens
     * @returns Observable<{ tag: string }>
     */
    onCompact() {
        return this.compact$.pipe(share());
    }
    /**
     * Toggle a sidebar
     * @param {boolean} compact
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    toggle(compact = false, tag) {
        this.toggle$.next({ compact, tag });
    }
    /**
     * Expands a sidebar
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    expand(tag) {
        this.expand$.next({ tag });
    }
    /**
     * Collapses a sidebar
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    collapse(tag) {
        this.collapse$.next({ tag });
    }
    /**
     * Makes sidebar compact
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    compact(tag) {
        this.compact$.next({ tag });
    }
    /**
     * Returns sidebar state
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar state you need
     */
    getSidebarState(tag) {
        const observer = new Subject();
        getSidebarState$.next({ observer, tag });
        return observer.pipe(refCount());
    }
    /**
     * Returns sidebar responsive state
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar responsive state you need
     */
    getSidebarResponsiveState(tag) {
        const observer = new Subject();
        getSidebarResponsiveState$.next({ observer, tag });
        return observer.pipe(refCount());
    }
}
NbSidebarService.ɵfac = function NbSidebarService_Factory(t) { return new (t || NbSidebarService)(); };
NbSidebarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSidebarService, factory: NbSidebarService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSidebarService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Sidebar header container.
 *
 * Placeholder which contains a sidebar header content,
 * placed at the very top of the sidebar outside of the scroll area.
 */
class NbSidebarHeaderComponent {
}
NbSidebarHeaderComponent.ɵfac = function NbSidebarHeaderComponent_Factory(t) { return new (t || NbSidebarHeaderComponent)(); };
NbSidebarHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarHeaderComponent, selectors: [["nb-sidebar-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSidebarHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSidebarHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar-header',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, null); })();
/**
 * Sidebar footer container.
 *
 * Placeholder which contains a sidebar footer content,
 * placed at the very bottom of the sidebar outside of the scroll area.
 */
class NbSidebarFooterComponent {
}
NbSidebarFooterComponent.ɵfac = function NbSidebarFooterComponent_Factory(t) { return new (t || NbSidebarFooterComponent)(); };
NbSidebarFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarFooterComponent, selectors: [["nb-sidebar-footer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSidebarFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSidebarFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar-footer',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, null); })();
/**
 * Layout sidebar component.
 *
 * @stacked-example(Showcase, sidebar/sidebar-showcase.component)
 *
 * ### Installation
 *
 * Import `NbSidebarModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * and `NbSidebarModule` to your feature module where the component should be shown:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Sidebar can be placed on the left or the right side of the layout,
 * or on start/end position of layout (depends on document direction, left to right or right to left)
 * It can be fixed (shown above the content) or can push the layout when opened.
 *
 * There are three states - `expanded`, `collapsed`, `compacted`.
 * By default sidebar content is fixed and saves its position while the page is being scrolled.
 *
 * Compacted sidebar example:
 * @stacked-example(Compacted Sidebar, sidebar/sidebar-compacted.component)
 *
 * Sidebar also supports a `responsive` behavior, listening to window size change and changing its size respectably.
 *
 * In a pair with header it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * @additional-example(Right Sidebar, sidebar/sidebar-right.component)
 * @additional-example(Fixed Sidebar, sidebar/sidebar-fixed.component)
 *
 * @styles
 *
 * sidebar-background-color:
 * sidebar-text-color:
 * sidebar-text-font-family:
 * sidebar-text-font-size:
 * sidebar-text-font-weight:
 * sidebar-text-line-height:
 * sidebar-height:
 * sidebar-width:
 * sidebar-width-compact:
 * sidebar-padding:
 * sidebar-header-height:
 * sidebar-footer-height:
 * sidebar-shadow:
 * sidebar-menu-item-highlight-color:
 * sidebar-scrollbar-background-color:
 * sidebar-scrollbar-color:
 * sidebar-scrollbar-width:
 */
class NbSidebarComponent {
    constructor(sidebarService, themeService, element, cd) {
        this.sidebarService = sidebarService;
        this.themeService = themeService;
        this.element = element;
        this.cd = cd;
        this.responsiveState = 'pc';
        this.destroy$ = new Subject();
        this.containerFixedValue = true;
        this.fixedValue = false;
        this.rightValue = false;
        this.leftValue = true;
        this.startValue = false;
        this.endValue = false;
        this._responsive = false;
        // TODO: get width by the key and define only max width for the tablets and mobiles
        /**
         * Controls on which screen sizes sidebar should be switched to compacted state.
         * Works only when responsive mode is on.
         * Default values are `['xs', 'is', 'sm', 'md', 'lg']`.
         *
         * @type string[]
         */
        this.compactedBreakpoints = ['xs', 'is', 'sm', 'md', 'lg'];
        /**
         * Controls on which screen sizes sidebar should be switched to collapsed state.
         * Works only when responsive mode is on.
         * Default values are `['xs', 'is']`.
         *
         * @type string[]
         */
        this.collapsedBreakpoints = ['xs', 'is'];
        /**
         * Emits whenever sidebar state change.
         */
        this.stateChange = new EventEmitter();
        /**
         * Emits whenever sidebar responsive state change.
         */
        this.responsiveStateChange = new EventEmitter();
    }
    get expanded() {
        return this.state === 'expanded';
    }
    get collapsed() {
        return this.state === 'collapsed';
    }
    get compacted() {
        return this.state === 'compacted';
    }
    /**
     * Places sidebar on the right side
     * @type {boolean}
     */
    set right(val) {
        this.rightValue = convertToBoolProperty(val);
        this.leftValue = !this.rightValue;
        this.startValue = false;
        this.endValue = false;
    }
    /**
     * Places sidebar on the left side
     * @type {boolean}
     */
    set left(val) {
        this.leftValue = convertToBoolProperty(val);
        this.rightValue = !this.leftValue;
        this.startValue = false;
        this.endValue = false;
    }
    /**
     * Places sidebar on the start edge of layout
     * @type {boolean}
     */
    set start(val) {
        this.startValue = convertToBoolProperty(val);
        this.endValue = !this.startValue;
        this.leftValue = false;
        this.rightValue = false;
    }
    /**
     * Places sidebar on the end edge of layout
     * @type {boolean}
     */
    set end(val) {
        this.endValue = convertToBoolProperty(val);
        this.startValue = !this.endValue;
        this.leftValue = false;
        this.rightValue = false;
    }
    /**
     * Makes sidebar fixed (shown above the layout content)
     * @type {boolean}
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
    /**
     * Makes sidebar container fixed
     * @type {boolean}
     */
    set containerFixed(val) {
        this.containerFixedValue = convertToBoolProperty(val);
    }
    /**
     * Initial sidebar state, `expanded`|`collapsed`|`compacted`
     * @type {string}
     */
    get state() {
        return this._state;
    }
    set state(value) {
        this._state = value;
    }
    /**
     * Makes sidebar listen to media query events and change its behaviour
     * @type {boolean}
     */
    get responsive() {
        return this._responsive;
    }
    set responsive(value) {
        this._responsive = convertToBoolProperty(value);
    }
    ngOnInit() {
        this.sidebarService.onToggle()
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag), takeUntil(this.destroy$))
            .subscribe(({ compact }) => this.toggle(compact));
        this.sidebarService.onExpand()
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag), takeUntil(this.destroy$))
            .subscribe(() => this.expand());
        this.sidebarService.onCollapse()
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag), takeUntil(this.destroy$))
            .subscribe(() => this.collapse());
        this.sidebarService.onCompact()
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag), takeUntil(this.destroy$))
            .subscribe(() => this.compact());
        getSidebarState$
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag))
            .subscribe(({ observer }) => observer.next(this.state));
        getSidebarResponsiveState$
            .pipe(filter(({ tag }) => !this.tag || this.tag === tag))
            .subscribe(({ observer }) => observer.next(this.responsiveState));
        this.subscribeToMediaQueryChange();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    // TODO: this is more of a workaround, should be a better way to make components communicate to each other
    onClick(event) {
        const menu = this.element.nativeElement.querySelector('nb-menu');
        if (menu && menu.contains(event.target)) {
            const link = this.getMenuLink(event.target);
            if (link && link.nextElementSibling && link.nextElementSibling.classList.contains('menu-items')) {
                this.sidebarService.expand(this.tag);
            }
        }
    }
    /**
     * Collapses the sidebar
     */
    collapse() {
        this.state = 'collapsed';
        this.stateChange.emit(this.state);
        this.cd.markForCheck();
    }
    /**
     * Expands the sidebar
     */
    expand() {
        this.state = 'expanded';
        this.stateChange.emit(this.state);
        this.cd.markForCheck();
    }
    /**
     * Compacts the sidebar (minimizes)
     */
    compact() {
        this.state = 'compacted';
        this.stateChange.emit(this.state);
        this.cd.markForCheck();
    }
    /**
     * Toggles sidebar state (expanded|collapsed|compacted)
     * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
     * otherwise - between expanded & collapsed. False by default.
     *
     * Toggle sidebar state
     *
     * ```ts
     * this.sidebar.toggle(true);
     * ```
     */
    toggle(compact = false) {
        if (this.responsive) {
            if (this.responsiveState === 'mobile') {
                compact = false;
            }
        }
        if (this.state === 'compacted' || this.state === 'collapsed') {
            this.state = 'expanded';
        }
        else {
            this.state = compact ? 'compacted' : 'collapsed';
        }
        this.stateChange.emit(this.state);
        this.cd.markForCheck();
    }
    subscribeToMediaQueryChange() {
        this.themeService.onMediaQueryChange()
            .pipe(filter(() => this.responsive), takeUntil(this.destroy$))
            .subscribe(([prev, current]) => {
            const isCollapsed = this.collapsedBreakpoints.includes(current.name);
            const isCompacted = this.compactedBreakpoints.includes(current.name);
            let newResponsiveState;
            if (isCompacted) {
                this.fixed = this.containerFixedValue;
                this.compact();
                newResponsiveState = 'tablet';
            }
            if (isCollapsed) {
                this.fixed = true;
                this.collapse();
                newResponsiveState = 'mobile';
            }
            if (!isCollapsed && !isCompacted && prev.width < current.width) {
                this.expand();
                this.fixed = false;
                newResponsiveState = 'pc';
            }
            if (newResponsiveState && newResponsiveState !== this.responsiveState) {
                this.responsiveState = newResponsiveState;
                this.responsiveStateChange.emit(this.responsiveState);
                this.cd.markForCheck();
            }
        });
    }
    getMenuLink(element) {
        if (!element || element.tagName.toLowerCase() === 'nb-menu') {
            return;
        }
        if (element.tagName.toLowerCase() === 'a') {
            return element;
        }
        return this.getMenuLink(element.parentElement);
    }
    /**
     * @deprecated Use `responsive` property instead
     * @breaking-change Remove @8.0.0
     */
    toggleResponsive(enabled) {
        this.responsive = enabled;
    }
}
NbSidebarComponent.ɵfac = function NbSidebarComponent_Factory(t) { return new (t || NbSidebarComponent)(ɵngcc0.ɵɵdirectiveInject(NbSidebarService), ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbSidebarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarComponent, selectors: [["nb-sidebar"]], hostVars: 16, hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
    } }, inputs: { compactedBreakpoints: "compactedBreakpoints", collapsedBreakpoints: "collapsedBreakpoints", right: "right", left: "left", start: "start", end: "end", fixed: "fixed", containerFixed: "containerFixed", state: "state", responsive: "responsive", tag: "tag" }, outputs: { stateChange: "stateChange", responsiveStateChange: "responsiveStateChange" }, ngContentSelectors: _c16, decls: 5, vars: 2, consts: [[1, "main-container"], [1, "scrollable", 3, "click"]], template: function NbSidebarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c15);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵlistener("click", function NbSidebarComponent_Template_div_click_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("main-container-fixed", ctx.containerFixedValue);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}"], changeDetection: 0 });
/**
 * @deprecated Use NbSidebarState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.STATE_EXPANDED = 'expanded';
/**
 * @deprecated Use NbSidebarState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.STATE_COLLAPSED = 'collapsed';
/**
 * @deprecated Use NbSidebarState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.STATE_COMPACTED = 'compacted';
/**
 * @deprecated Use NbSidebarResponsiveState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.RESPONSIVE_STATE_MOBILE = 'mobile';
/**
 * @deprecated Use NbSidebarResponsiveState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.RESPONSIVE_STATE_TABLET = 'tablet';
/**
 * @deprecated Use NbSidebarResponsiveState type instead
 * @breaking-change Remove @8.0.0
 */
NbSidebarComponent.RESPONSIVE_STATE_PC = 'pc';
NbSidebarComponent.ctorParameters = () => [
    { type: NbSidebarService },
    { type: NbThemeService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
NbSidebarComponent.propDecorators = {
    fixedValue: [{ type: HostBinding, args: ['class.fixed',] }],
    rightValue: [{ type: HostBinding, args: ['class.right',] }],
    leftValue: [{ type: HostBinding, args: ['class.left',] }],
    startValue: [{ type: HostBinding, args: ['class.start',] }],
    endValue: [{ type: HostBinding, args: ['class.end',] }],
    expanded: [{ type: HostBinding, args: ['class.expanded',] }],
    collapsed: [{ type: HostBinding, args: ['class.collapsed',] }],
    compacted: [{ type: HostBinding, args: ['class.compacted',] }],
    right: [{ type: Input }],
    left: [{ type: Input }],
    start: [{ type: Input }],
    end: [{ type: Input }],
    fixed: [{ type: Input }],
    containerFixed: [{ type: Input }],
    state: [{ type: Input }],
    responsive: [{ type: Input }],
    tag: [{ type: Input }],
    compactedBreakpoints: [{ type: Input }],
    collapsedBreakpoints: [{ type: Input }],
    stateChange: [{ type: Output }],
    responsiveStateChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSidebarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar',
                template: `
    <div class="main-container"
         [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translate3d(0, 0, 0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n"]
            }]
    }], function () { return [{ type: NbSidebarService }, { type: NbThemeService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }], rightValue: [{
            type: HostBinding,
            args: ['class.right']
        }], leftValue: [{
            type: HostBinding,
            args: ['class.left']
        }], startValue: [{
            type: HostBinding,
            args: ['class.start']
        }], endValue: [{
            type: HostBinding,
            args: ['class.end']
        }], compactedBreakpoints: [{
            type: Input
        }], collapsedBreakpoints: [{
            type: Input
        }], stateChange: [{
            type: Output
        }], responsiveStateChange: [{
            type: Output
        }], expanded: [{
            type: HostBinding,
            args: ['class.expanded']
        }], collapsed: [{
            type: HostBinding,
            args: ['class.collapsed']
        }], compacted: [{
            type: HostBinding,
            args: ['class.compacted']
        }], right: [{
            type: Input
        }], left: [{
            type: Input
        }], start: [{
            type: Input
        }], end: [{
            type: Input
        }], fixed: [{
            type: Input
        }], containerFixed: [{
            type: Input
        }], state: [{
            type: Input
        }], responsive: [{
            type: Input
        }], tag: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_SIDEBAR_COMPONENTS = [
    NbSidebarComponent,
    NbSidebarFooterComponent,
    NbSidebarHeaderComponent,
];
const NB_SIDEBAR_PROVIDERS = [
    NbSidebarService,
];
class NbSidebarModule {
    static forRoot() {
        return {
            ngModule: NbSidebarModule,
            providers: [
                ...NB_SIDEBAR_PROVIDERS,
            ],
        };
    }
}
NbSidebarModule.ɵfac = function NbSidebarModule_Factory(t) { return new (t || NbSidebarModule)(); };
NbSidebarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSidebarModule });
NbSidebarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSidebarModule, { declarations: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent], imports: [NbSharedModule], exports: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSidebarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_SIDEBAR_COMPONENTS,
                ],
                exports: [
                    ...NB_SIDEBAR_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Specific tab container.
 *
 * ```ts
 * <nb-tab tabTitle="Users"
 *   badgeText="99+"
 *   badgeStatus="danger">
 *   <p>List of <strong>users</strong>.</p>
 * </nb-tab>
 ```
 */
class NbTabComponent {
    constructor() {
        this.activeValue = false;
        this.responsiveValue = false;
        this.disabledValue = false;
        /**
         * Badge status (adds specific styles):
         * 'primary', 'info', 'success', 'warning', 'danger'
         * @param {string} val
         */
        this.badgeStatus = 'basic';
        this.init = false;
    }
    /**
     * Use badge dot mode
     * @type {boolean}
     */
    get badgeDot() {
        return this._badgeDot;
    }
    set badgeDot(val) {
        this._badgeDot = convertToBoolProperty(val);
    }
    /**
     * Item is disabled and cannot be opened.
     * @type {boolean}
     */
    get disabled() {
        return this.disabledValue;
    }
    set disabled(val) {
        this.disabledValue = convertToBoolProperty(val);
    }
    /**
     * Show only icons when width is smaller than `tabs-icon-only-max-width`
     * @type {boolean}
     */
    set responsive(val) {
        this.responsiveValue = convertToBoolProperty(val);
    }
    get responsive() {
        return this.responsiveValue;
    }
    /**
     * Specifies active tab
     * @returns {boolean}
     */
    get active() {
        return this.activeValue;
    }
    set active(val) {
        this.activeValue = convertToBoolProperty(val);
        if (this.activeValue) {
            this.init = true;
        }
    }
    /**
     * Lazy load content before tab selection
     * TODO: rename, as lazy is by default, and this is more `instant load`
     * @param {boolean} val
     */
    set lazyLoad(val) {
        this.init = convertToBoolProperty(val);
    }
}
NbTabComponent.ɵfac = function NbTabComponent_Factory(t) { return new (t || NbTabComponent)(); };
NbTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTabComponent, selectors: [["nb-tab"]], hostVars: 4, hostBindings: function NbTabComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("content-active", ctx.activeValue)("disabled", ctx.disabled);
    } }, inputs: { badgeStatus: "badgeStatus", badgeDot: "badgeDot", disabled: "disabled", responsive: "responsive", active: "active", lazyLoad: "lazyLoad", tabTitle: "tabTitle", tabId: "tabId", tabIcon: "tabIcon", route: "route", badgeText: "badgeText", badgePosition: "badgePosition" }, ngContentSelectors: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function NbTabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbTabComponent_ng_container_0_Template, 2, 0, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.init);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
NbTabComponent.propDecorators = {
    tabTitle: [{ type: Input }],
    tabId: [{ type: Input }],
    badgeDot: [{ type: Input }],
    tabIcon: [{ type: Input }],
    disabled: [{ type: Input, args: ['disabled',] }, { type: HostBinding, args: ['class.disabled',] }],
    responsive: [{ type: Input }],
    route: [{ type: Input }],
    activeValue: [{ type: HostBinding, args: ['class.content-active',] }],
    active: [{ type: Input }],
    lazyLoad: [{ type: Input }],
    badgeText: [{ type: Input }],
    badgeStatus: [{ type: Input }],
    badgePosition: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTabComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tab',
                template: `
    <ng-container *ngIf="init">
      <ng-content></ng-content>
    </ng-container>
  `
            }]
    }], function () { return []; }, { activeValue: [{
            type: HostBinding,
            args: ['class.content-active']
        }], badgeStatus: [{
            type: Input
        }], badgeDot: [{
            type: Input
        }], disabled: [{
            type: Input,
            args: ['disabled']
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], responsive: [{
            type: Input
        }], active: [{
            type: Input
        }], lazyLoad: [{
            type: Input
        }], tabTitle: [{
            type: Input
        }], tabId: [{
            type: Input
        }], tabIcon: [{
            type: Input
        }], route: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();
// TODO: Combine tabset with route-tabset, so that we can:
// - have similar interface
// - easy to migrate from one to another
// - can mix them both (route/content tab)
/**
 *
 * Dynamic tabset component.
 * @stacked-example(Showcase, tabset/tabset-showcase.component)
 *
 * Basic tabset example
 *
 * ```html
 * <nb-tabset>
 *  <nb-tab tabTitle="Simple Tab #1">
 *    Tab content 1
 *  </nb-tab>
 *  <nb-tab tabTitle="Simple Tab #2">
 *    Tab content 2
 *  </nb-tab>
 * </nb-tabset>
 * ```
 *
 * ### Installation
 *
 * Import `NbTabsetModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTabsetModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * It is also possible to set a badge to a particular tab:
 * @stacked-example(Tab With Badge, tabset/tabset-badge.component)
 *
 * and we can set it to full a width of a parent component
 * @stacked-example(Full Width, tabset/tabset-width.component)
 *
 * `tabIcon` should be used to add an icon to the tab. Icon can also be combined with title.
 * `responsive` tab property if set allows you to hide the title on smaller screens
 * (`tabs-icon-only-max-width` property) for better responsive behaviour. You can open the following example and make
 * your screen smaller - titles will be hidden in the last tabset in the list:
 *
 * @stacked-example(Icon, tabset/tabset-icon.component)
 *
 * It is also possible to disable a tab using `disabled` property:
 * @stacked-example(Disabled Tab, tabset/tabset-disabled.component)
 *
 * @styles
 *
 * tabset-background-color:
 * tabset-border-radius:
 * tabset-shadow:
 * tabset-tab-background-color:
 * tabset-tab-padding:
 * tabset-tab-text-color:
 * tabset-tab-text-font-family:
 * tabset-tab-text-font-size:
 * tabset-tab-text-font-weight:
 * tabset-tab-text-line-height:
 * tabset-tab-text-transform:
 * tabset-tab-underline-width:
 * tabset-tab-underline-color:
 * tabset-tab-active-background-color:
 * tabset-tab-active-text-color:
 * tabset-tab-active-underline-color:
 * tabset-tab-focus-background-color:
 * tabset-tab-focus-text-color:
 * tabset-tab-focus-underline-color:
 * tabset-tab-hover-background-color:
 * tabset-tab-hover-text-color:
 * tabset-tab-hover-underline-color:
 * tabset-tab-disabled-background-color:
 * tabset-tab-disabled-text-color:
 * tabset-tab-disabled-underline-color:
 * tabset-divider-color:
 * tabset-divider-style:
 * tabset-divider-width:
 * tabset-content-background-color:
 * tabset-content-padding:
 * tabset-content-text-color:
 * tabset-content-text-font-family:
 * tabset-content-text-font-size:
 * tabset-content-text-font-weight:
 * tabset-content-text-line-height:
 * tabset-scrollbar-color:
 * tabset-scrollbar-background-color:
 * tabset-scrollbar-width:
 * tabset-tab-text-hide-breakpoint:
 */
class NbTabsetComponent {
    constructor(route, changeDetectorRef) {
        this.route = route;
        this.changeDetectorRef = changeDetectorRef;
        this.fullWidthValue = false;
        /**
         * Emits when tab is selected
         * @type EventEmitter<any>
         */
        this.changeTab = new EventEmitter();
    }
    /**
     * Take full width of a parent
     * @param {boolean} val
     */
    set fullWidth(val) {
        this.fullWidthValue = convertToBoolProperty(val);
    }
    // TODO: refactoring this component, avoid change detection loop
    ngAfterContentInit() {
        this.route.params
            .pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab))
            .subscribe((tabToSelect) => {
            this.selectTab(tabToSelect);
            this.changeDetectorRef.markForCheck();
        });
    }
    // TODO: navigate to routeParam
    selectTab(selectedTab) {
        if (!selectedTab.disabled) {
            this.tabs.forEach(tab => tab.active = tab === selectedTab);
            this.changeTab.emit(selectedTab);
        }
    }
}
NbTabsetComponent.ɵfac = function NbTabsetComponent_Factory(t) { return new (t || NbTabsetComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTabsetComponent, selectors: [["nb-tabset"]], contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbTabComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, hostVars: 2, hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidthValue);
    } }, inputs: { fullWidth: "fullWidth", routeParam: "routeParam" }, outputs: { changeTab: "changeTab" }, ngContentSelectors: _c18, decls: 3, vars: 1, consts: [[1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "config"], [1, "tab-text"], [3, "text", "dotMode", "status", "position"]], template: function NbTabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c17);
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbTabsetComponent_li_1_Template, 5, 10, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgIf, NbIconComponent, NbBadgeComponent], styles: ["[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}"] });
NbTabsetComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: ChangeDetectorRef }
];
NbTabsetComponent.propDecorators = {
    tabs: [{ type: ContentChildren, args: [NbTabComponent,] }],
    fullWidthValue: [{ type: HostBinding, args: ['class.full-width',] }],
    fullWidth: [{ type: Input }],
    routeParam: [{ type: Input }],
    changeTab: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTabsetComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tabset',
                template: `
    <ul class="tabset">
      <li *ngFor="let tab of tabs"
          (click)="selectTab(tab)"
          (keyup.space)="selectTab(tab)"
          (keyup.enter)="selectTab(tab)"
          [class.responsive]="tab.responsive"
          [class.active]="tab.active"
          [class.disabled]="tab.disabled"
          [attr.tabindex]="tab.disabled ? -1 : 0"
          class="tab">
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <span *ngIf="tab.tabTitle" class="tab-text">{{ tab.tabTitle }}</span>
        </a>
        <nb-badge *ngIf="tab.badgeText || tab.badgeDot"
          [text]="tab.badgeText"
          [dotMode]="tab.badgeDot"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition">
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
                styles: [":host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a::before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc5.ActivatedRoute }, { type: ɵngcc0.ChangeDetectorRef }]; }, { fullWidthValue: [{
            type: HostBinding,
            args: ['class.full-width']
        }], changeTab: [{
            type: Output
        }], fullWidth: [{
            type: Input
        }], tabs: [{
            type: ContentChildren,
            args: [NbTabComponent]
        }], routeParam: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TABSET_COMPONENTS = [
    NbTabsetComponent,
    NbTabComponent,
];
class NbTabsetModule {
}
NbTabsetModule.ɵfac = function NbTabsetModule_Factory(t) { return new (t || NbTabsetModule)(); };
NbTabsetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTabsetModule });
NbTabsetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbBadgeModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTabsetModule, { declarations: [NbTabsetComponent, NbTabComponent], imports: [NbSharedModule, NbBadgeModule, NbIconModule], exports: [NbTabsetComponent, NbTabComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTabsetModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_TABSET_COMPONENTS,
                ],
                exports: [
                    ...NB_TABSET_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Represents a component showing a user avatar (picture) with a user name on the right.
 * @stacked-example(Showcase, user/user-showcase.component)
 *
 * ```ts
 *   <nb-user name="John Doe" title="Engineer"></nb-user>
 * ```
 *
 * ### Installation
 *
 * Import `NbUserModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbUserModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Available in multiple sizes:
 * @stacked-example(Multiple Sizes, user/user-sizes.component)
 *
 *
 * You can hide unnecessary captions (name, title or both):
 * @stacked-example(Hide captions in user component, user/user-hide-captions.component)
 *
 *
 * You can set custom avatar background-color, user image (as link or BASE64 string) and disable user initials:
 * @stacked-example(Avatar image settings, user/user-avatar-settings.component)
 *
 * Component shape could be controlled with `shape` input.
 * @stacked-example(Shapes, user/user-shape.component)
 *
 * @styles
 *
 * user-picture-box-background-color:
 * user-picture-box-border-color:
 * user-picture-box-border-width:
 * user-initials-text-color:
 * user-initials-text-font-family:
 * user-initials-text-font-weight:
 * user-name-text-color:
 * user-name-text-font-family:
 * user-name-text-font-weight:
 * user-title-text-color:
 * user-title-text-font-family:
 * user-title-text-font-weight:
 * user-rectangle-border-radius:
 * user-semi-round-border-radius:
 * user-round-border-radius:
 * user-tiny-height:
 * user-tiny-width:
 * user-tiny-initials-text-font-size:
 * user-tiny-initials-text-line-height:
 * user-tiny-name-text-font-size:
 * user-tiny-name-text-line-height:
 * user-tiny-title-text-font-size:
 * user-tiny-title-text-line-height:
 * user-small-height:
 * user-small-width:
 * user-small-initials-text-font-size:
 * user-small-initials-text-line-height:
 * user-small-name-text-font-size:
 * user-small-name-text-line-height:
 * user-small-title-text-font-size:
 * user-small-title-text-line-height:
 * user-medium-height:
 * user-medium-width:
 * user-medium-initials-text-font-size:
 * user-medium-initials-text-line-height:
 * user-medium-name-text-font-size:
 * user-medium-name-text-line-height:
 * user-medium-title-text-font-size:
 * user-medium-title-text-line-height:
 * user-large-height:
 * user-large-width:
 * user-large-initials-text-font-size:
 * user-large-initials-text-line-height:
 * user-large-name-text-font-size:
 * user-large-name-text-line-height:
 * user-large-title-text-font-size:
 * user-large-title-text-line-height:
 * user-giant-height:
 * user-giant-width:
 * user-giant-initials-text-font-size:
 * user-giant-initials-text-line-height:
 * user-giant-name-text-font-size:
 * user-giant-name-text-line-height:
 * user-giant-title-text-font-size:
 * user-giant-title-text-line-height:
 */
class NbUserComponent {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
        /**
         * Specifies a name to be shown on the right of a user picture
         * @type string
         */
        this.name = 'Anonymous';
        /**
         * Size of the component.
         * Possible values: `tiny`, `small`, `medium` (default), `large`, 'giant'.
         */
        this.size = 'medium';
        /**
         * Shape of the picture box.
         * Possible values: `rectangle`, `semi-round`, `round`.
         */
        this.shape = 'round';
        this._showName = true;
        this._showTitle = true;
        this._showInitials = true;
        /**
         * Badge status (adds specific styles):
         * `primary`, `info`, `success`, `warning`, `danger`
         * @param {string} val
         */
        this.badgeStatus = 'basic';
    }
    /**
     * Absolute path to a user picture or base64 image.
     * User name initials will be shown if no picture specified (JD for John Doe).
     * @type string
     */
    set picture(value) {
        this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
    }
    /**
     * Whether to show a user name or not
     */
    get showName() {
        return this._showName;
    }
    set showName(val) {
        this._showName = convertToBoolProperty(val);
    }
    /**
     * Whether to show a user title or not
     * @type boolean
     */
    get showTitle() {
        return this._showTitle;
    }
    set showTitle(val) {
        this._showTitle = convertToBoolProperty(val);
    }
    /**
     * Whether to show a user initials (if no picture specified) or not
     * @type boolean
     */
    get showInitials() {
        return this._showInitials;
    }
    set showInitials(val) {
        this._showInitials = convertToBoolProperty(val);
    }
    /**
     * Whether to show only a picture or also show the name and title
     * @type boolean
     */
    get onlyPicture() {
        return !this.showName && !this.showTitle;
    }
    set onlyPicture(val) {
        this.showName = this.showTitle = !convertToBoolProperty(val);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get round() {
        return this.shape === 'round';
    }
    getInitials() {
        if (this.name) {
            const names = this.name.split(' ');
            return names.map(n => n.charAt(0)).splice(0, 2).join('').toUpperCase();
        }
        return '';
    }
}
NbUserComponent.ɵfac = function NbUserComponent_Factory(t) { return new (t || NbUserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbUserComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbUserComponent, selectors: [["nb-user"]], hostVars: 16, hostBindings: function NbUserComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    } }, inputs: { name: "name", size: "size", shape: "shape", badgeStatus: "badgeStatus", picture: "picture", showName: "showName", showTitle: "showTitle", showInitials: "showInitials", onlyPicture: "onlyPicture", title: "title", color: "color", badgeText: "badgeText", badgePosition: "badgePosition" }, decls: 6, vars: 4, consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]], template: function NbUserComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_1_Template, 2, 3, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NbUserComponent_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵtemplate(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageBackgroundStyle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.imageBackgroundStyle);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showName && ctx.name);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTitle && ctx.title);
    } }, directives: [ɵngcc2.NgIf, NbBadgeComponent], styles: ["[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}"] });
NbUserComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
NbUserComponent.propDecorators = {
    name: [{ type: Input }],
    title: [{ type: Input }],
    picture: [{ type: Input }],
    color: [{ type: Input }],
    size: [{ type: Input }],
    shape: [{ type: Input }],
    showName: [{ type: Input }],
    showTitle: [{ type: Input }],
    showInitials: [{ type: Input }],
    onlyPicture: [{ type: Input }],
    badgeText: [{ type: Input }],
    badgeStatus: [{ type: Input }],
    badgePosition: [{ type: Input }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    rectangle: [{ type: HostBinding, args: ['class.shape-rectangle',] }],
    semiRound: [{ type: HostBinding, args: ['class.shape-semi-round',] }],
    round: [{ type: HostBinding, args: ['class.shape-round',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbUserComponent, [{
        type: Component,
        args: [{
                selector: 'nb-user',
                template: "<div class=\"user-container\">\n  <div *ngIf=\"imageBackgroundStyle\" class=\"user-picture image\" [style.background-image]=\"imageBackgroundStyle\">\n    <nb-badge *ngIf=\"badgeText\" [text]=\"badgeText\" [status]=\"badgeStatus\" [position]=\"badgePosition\"></nb-badge>\n  </div>\n  <div *ngIf=\"!imageBackgroundStyle\" class=\"user-picture initials\" [style.background-color]=\"color\">\n    <ng-container *ngIf=\"showInitials\">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf=\"badgeText\" [text]=\"badgeText\" [status]=\"badgeStatus\" [position]=\"badgePosition\"></nb-badge>\n  </div>\n\n  <div class=\"info-container\">\n    <div *ngIf=\"showName && name\" class=\"user-name\">{{ name }}</div>\n    <div *ngIf=\"showTitle && title\" class=\"user-title\">{{ title }}</div>\n  </div>\n</div>\n",
                styles: [":host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }]; }, { name: [{
            type: Input
        }], size: [{
            type: Input
        }], shape: [{
            type: Input
        }], badgeStatus: [{
            type: Input
        }], picture: [{
            type: Input
        }], showName: [{
            type: Input
        }], showTitle: [{
            type: Input
        }], showInitials: [{
            type: Input
        }], onlyPicture: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], title: [{
            type: Input
        }], color: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_USER_COMPONENTS = [
    NbUserComponent,
];
class NbUserModule {
}
NbUserModule.ɵfac = function NbUserModule_Factory(t) { return new (t || NbUserModule)(); };
NbUserModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbUserModule });
NbUserModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbBadgeModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbUserModule, { declarations: [NbUserComponent], imports: [NbSharedModule, NbBadgeModule], exports: [NbUserComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbUserModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                ],
                declarations: [
                    ...NB_USER_COMPONENTS,
                ],
                exports: [
                    ...NB_USER_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Action item, display a link with an icon, or any other content provided instead.
 */
class NbActionComponent {
    constructor() {
        /**
         * Optional title for mouseover
         * @type string
         */
        this.title = '';
        this._disabled = false;
        /**
         * Badge status (adds specific styles):
         * 'basic', 'primary', 'info', 'success', 'warning', 'danger', 'control'
         * @param {string} val
         */
        this.badgeStatus = 'basic';
    }
    /**
     * Visually disables the item
     * @type boolean
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * Use badge dot mode
     * @type boolean
     */
    get badgeDot() {
        return this._badgeDot;
    }
    set badgeDot(value) {
        this._badgeDot = convertToBoolProperty(value);
    }
}
NbActionComponent.ɵfac = function NbActionComponent_Factory(t) { return new (t || NbActionComponent)(); };
NbActionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbActionComponent, selectors: [["nb-action"]], hostVars: 2, hostBindings: function NbActionComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    } }, inputs: { title: "title", badgeStatus: "badgeStatus", disabled: "disabled", badgeDot: "badgeDot", link: "link", href: "href", icon: "icon", badgeText: "badgeText", badgePosition: "badgePosition" }, ngContentSelectors: _c0, decls: 5, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["projectedContent", ""], ["badgeTemplate", ""], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [3, "ngTemplateOutlet"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "title", "click"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "text", "dotMode", "status", "position"]], template: function NbActionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, NbActionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, NbActionComponent_ng_template_3_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon)("ngIfElse", _r1);
    } }, directives: [ɵngcc2.NgIf, ɵngcc5.RouterLinkWithHref, NbIconComponent, ɵngcc2.NgTemplateOutlet, NbBadgeComponent], styles: ["[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]{position:relative}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}"] });
NbActionComponent.propDecorators = {
    link: [{ type: Input }],
    href: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.disabled',] }],
    badgeDot: [{ type: Input }],
    badgeText: [{ type: Input }],
    badgeStatus: [{ type: Input }],
    badgePosition: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbActionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-action',
                template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
      <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
    </ng-template>
    <ng-template #badgeTemplate>
      <nb-badge *ngIf="badgeText || badgeDot"
                [text]="badgeText"
                [dotMode]="badgeDot"
                [status]="badgeStatus"
                [position]="badgePosition">
      </nb-badge>
    </ng-template>
  `,
                styles: [":host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container{position:relative}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n"]
            }]
    }], function () { return []; }, { title: [{
            type: Input
        }], badgeStatus: [{
            type: Input
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], badgeDot: [{
            type: Input
        }], link: [{
            type: Input
        }], href: [{
            type: Input
        }], icon: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();
/**
 * Shows a horizontal list of actions, available in multiple sizes.
 * Aligns items vertically.
 *
 * @stacked-example(Showcase, action/action-showcase.component)
 *
 * Basic actions setup:
 * ```html
 * <nb-actions size="small">
 *   <nb-action icon="nb-search"></nb-action>
 *   <nb-action icon="nb-power-circled"></nb-action>
 *   <nb-action icon="nb-person"></nb-action>
 * </nb-actions>
 * ```
 * ### Installation
 *
 * Import `NbActionsModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbActionsModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Multiple sizes example:
 * @stacked-example(Multiple Sizes, action/action-sizes.component)
 *
 * It is also possible to specify a `badge` value:
 *
 * @stacked-example(Action Badge, action/action-badge.component)
 *
 * and we can set it to full a width of a parent component
 * @stacked-example(Full Width, action/action-width.component)
 *
 * Action dot mode
 * @stacked-example(Action badge in dot mode, action/action-dot-mode.component)
 *
 * @styles
 *
 * actions-background-color:
 * actions-divider-color:
 * actions-divider-style:
 * actions-divider-width:
 * actions-icon-color:
 * actions-text-color:
 * actions-text-font-family:
 * actions-text-font-weight:
 * actions-text-line-height:
 * actions-disabled-icon-color:
 * actions-disabled-text-color:
 * actions-tiny-height:
 * actions-tiny-icon-height:
 * actions-tiny-padding:
 * actions-tiny-text-font-size:
 * actions-small-height:
 * actions-small-icon-height:
 * actions-small-padding:
 * actions-small-text-font-size:
 * actions-medium-height:
 * actions-medium-icon-height:
 * actions-medium-padding:
 * actions-medium-text-font-size:
 * actions-large-height:
 * actions-large-icon-height:
 * actions-large-padding:
 * actions-large-text-font-size:
 * actions-giant-height:
 * actions-giant-icon-height:
 * actions-giant-padding:
 * actions-giant-text-font-size:
 */
class NbActionsComponent {
    constructor() {
        this._size = 'small';
        this._fullWidth = false;
    }
    /**
     * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
    }
    /**
     * Component will fill full width of the container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
}
NbActionsComponent.ɵfac = function NbActionsComponent_Factory(t) { return new (t || NbActionsComponent)(); };
NbActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbActionsComponent, selectors: [["nb-actions"]], hostVars: 12, hostBindings: function NbActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    } }, inputs: { size: "size", fullWidth: "fullWidth" }, ngContentSelectors: _c20, decls: 1, vars: 0, template: function NbActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c19);
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:center}"] });
NbActionsComponent.propDecorators = {
    size: [{ type: Input }],
    fullWidth: [{ type: Input }, { type: HostBinding, args: ['class.full-width',] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbActionsComponent, [{
        type: Component,
        args: [{
                selector: 'nb-actions',
                template: `
    <ng-content select="nb-action"></ng-content>
  `,
                styles: [":host{display:flex;align-items:center}\n"]
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_ACTIONS_COMPONENTS = [
    NbActionComponent,
    NbActionsComponent,
];
class NbActionsModule {
}
NbActionsModule.ɵfac = function NbActionsModule_Factory(t) { return new (t || NbActionsModule)(); };
NbActionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbActionsModule });
NbActionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbBadgeModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbActionsModule, { declarations: [NbActionComponent, NbActionsComponent], imports: [NbSharedModule, NbBadgeModule, NbIconModule], exports: [NbActionComponent, NbActionsComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbActionsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_ACTIONS_COMPONENTS,
                ],
                exports: [
                    ...NB_ACTIONS_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Search component service, connects your code to a page-level search component.
 */
class NbSearchService {
    constructor() {
        this.searchSubmittings$ = new Subject();
        this.searchActivations$ = new Subject();
        this.searchDeactivations$ = new Subject();
        this.searchInput$ = new Subject();
    }
    /***
     * Activate (open) search component
     * @param {string} searchType
     * @param {string} tag
     */
    activateSearch(searchType, tag) {
        this.searchActivations$.next({ searchType, tag });
    }
    /**
     * Deactibate (close) search component
     * @param {string} searchType
     * @param {string} tag
     */
    deactivateSearch(searchType, tag) {
        this.searchDeactivations$.next({ searchType, tag });
    }
    /**
     * Trigger search submit
     * @param {string} term
     * @param {string} tag
     */
    submitSearch(term, tag) {
        this.searchSubmittings$.next({ term, tag });
    }
    /**
     * Trigger search submit by input event
     * @param {string} term
     * @param {string} tag
     */
    searchInput(term, tag) {
        this.searchInput$.next({ term, tag });
    }
    /**
     * Subscribe to 'activate' event
     * @returns Observable<{searchType: string; tag?: string}>
     */
    onSearchActivate() {
        return this.searchActivations$.pipe(share());
    }
    /**
     * Subscribe to 'deactivate' event
     * @returns Observable<{searchType: string; tag?: string}>
     */
    onSearchDeactivate() {
        return this.searchDeactivations$.pipe(share());
    }
    /**
     * Subscribe to 'submit' event (when submit button clicked)
     * @returns Observable<{term: string; tag?: string}>
     */
    onSearchSubmit() {
        return this.searchSubmittings$.pipe(share());
    }
    /**
     * Subscribe to input event
     * @returns Observable<{term: string; tag?: string}>
     */
    onSearchInput() {
        return this.searchInput$.pipe(share());
    }
}
NbSearchService.ɵfac = function NbSearchService_Factory(t) { return new (t || NbSearchService)(); };
NbSearchService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSearchService, factory: NbSearchService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSearchService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * search-field-component is used under the hood by nb-search component
 * can't be used itself
 */
class NbSearchFieldComponent {
    constructor() {
        this.show = false;
        this.close = new EventEmitter();
        this.search = new EventEmitter();
        this.searchInput = new EventEmitter();
    }
    get showClass() {
        return this.show;
    }
    get modalZoomin() {
        return this.type === NbSearchFieldComponent.TYPE_MODAL_ZOOMIN;
    }
    get rotateLayout() {
        return this.type === NbSearchFieldComponent.TYPE_ROTATE_LAYOUT;
    }
    get modalMove() {
        return this.type === NbSearchFieldComponent.TYPE_MODAL_MOVE;
    }
    get curtain() {
        return this.type === NbSearchFieldComponent.TYPE_CURTAIN;
    }
    get columnCurtain() {
        return this.type === NbSearchFieldComponent.TYPE_COLUMN_CURTAIN;
    }
    get modalDrop() {
        return this.type === NbSearchFieldComponent.TYPE_MODAL_DROP;
    }
    get modalHalf() {
        return this.type === NbSearchFieldComponent.TYPE_MODAL_HALF;
    }
    ngOnChanges({ show }) {
        const becameHidden = !show.isFirstChange() && show.currentValue === false;
        if (becameHidden && this.inputElement) {
            this.inputElement.nativeElement.value = '';
        }
        this.focusInput();
    }
    ngAfterViewInit() {
        this.focusInput();
    }
    emitClose() {
        this.close.emit();
    }
    submitSearch(term) {
        if (term) {
            this.search.emit(term);
        }
    }
    emitSearchInput(term) {
        this.searchInput.emit(term);
    }
    focusInput() {
        if (this.show && this.inputElement) {
            this.inputElement.nativeElement.focus();
        }
    }
}
NbSearchFieldComponent.ɵfac = function NbSearchFieldComponent_Factory(t) { return new (t || NbSearchFieldComponent)(); };
NbSearchFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSearchFieldComponent, selectors: [["nb-search-field"]], viewQuery: function NbSearchFieldComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c21, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostVars: 16, hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
    } }, inputs: { show: "show", type: "type", placeholder: "placeholder", hint: "hint" }, outputs: { close: "close", search: "search", searchInput: "searchInput" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 10, vars: 2, consts: [[1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], ["searchInput", ""], [1, "info"]], template: function NbSearchFieldComponent_Template(rf, ctx) { if (rf & 1) {
        const _r1 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() { return ctx.emitClose(); });
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NbSearchFieldComponent_Template_button_click_1_listener() { return ctx.emitClose(); });
        ɵngcc0.ɵɵelement(2, "nb-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "form", 4);
        ɵngcc0.ɵɵlistener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() { ɵngcc0.ɵɵrestoreView(_r1); const _r0 = ɵngcc0.ɵɵreference(7); return ctx.submitSearch(_r0.value); });
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵelementStart(6, "input", 6, 7);
        ɵngcc0.ɵɵlistener("input", function NbSearchFieldComponent_Template_input_input_6_listener() { ɵngcc0.ɵɵrestoreView(_r1); const _r0 = ɵngcc0.ɵɵreference(7); return ctx.emitSearchInput(_r0.value); })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() { return ctx.focusInput(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 8);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.hint);
    } }, directives: [NbButtonComponent, NbIconComponent, ɵngcc6.ɵangular_packages_forms_forms_ba, ɵngcc6.NgControlStatusGroup, ɵngcc6.NgForm], styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:0.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:0.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:bold;display:block;width:75%;margin:0 auto;padding:0.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{content:'';position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px, -15px, 0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px, 15px, 0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{transform:translate3d(0, 0, 0);transition:transform 0.5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", "nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0, 50vh, 0) rotate3d(1, 0, 0, 30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:0.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(0.7, 0.7, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}", "nb-layout.modal-move .layout{transition:transform 0.5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scale3d(1, 1, 1);transition-duration:0.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", ".curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform 0.3s;transition-delay:0.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transition:transform 0.3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity 0.1s;transition-delay:0.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%, 0, 0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{transform:translate3d(100%, 0, 0);transition-delay:0.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}", "nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%, 0, 0);transition:transform 0.3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]::before{transform:scale3d(1, 1, 1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);transition-delay:0.15s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}", "nb-layout.modal-drop .layout{position:relative;transition:transform 0.4s, opacity 0.4s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(0.9, 0.9, 1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{content:'';position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity 0.4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:0.25rem;text-align:center;opacity:0;transition:opacity 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:0.85rem 0;opacity:0;transform:translate3d(0, -50px, 0);transition:opacity 0.4s, transform 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0, -50px, 0);transition:transform 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]::after{content:'';position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]::after{animation:scaleUpDown 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s 0.4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translate3d(0, 0, 0);transition-delay:0.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1, 0, 1)}50%{transform:scale3d(1, 1, 1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}100%{opacity:1;transform:scale3d(1, 0, 1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}", "nb-layout.modal-half .layout{transition:transform 0.6s, opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.6s, transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1);transform:translate3d(0, -100%, 0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0)}"], changeDetection: 0 });
NbSearchFieldComponent.TYPE_MODAL_ZOOMIN = 'modal-zoomin';
NbSearchFieldComponent.TYPE_ROTATE_LAYOUT = 'rotate-layout';
NbSearchFieldComponent.TYPE_MODAL_MOVE = 'modal-move';
NbSearchFieldComponent.TYPE_CURTAIN = 'curtain';
NbSearchFieldComponent.TYPE_COLUMN_CURTAIN = 'column-curtain';
NbSearchFieldComponent.TYPE_MODAL_DROP = 'modal-drop';
NbSearchFieldComponent.TYPE_MODAL_HALF = 'modal-half';
NbSearchFieldComponent.propDecorators = {
    type: [{ type: Input }],
    placeholder: [{ type: Input }],
    hint: [{ type: Input }],
    show: [{ type: Input }],
    close: [{ type: Output }],
    search: [{ type: Output }],
    searchInput: [{ type: Output }],
    inputElement: [{ type: ViewChild, args: ['searchInput',] }],
    showClass: [{ type: HostBinding, args: ['class.show',] }],
    modalZoomin: [{ type: HostBinding, args: ['class.modal-zoomin',] }],
    rotateLayout: [{ type: HostBinding, args: ['class.rotate-layout',] }],
    modalMove: [{ type: HostBinding, args: ['class.modal-move',] }],
    curtain: [{ type: HostBinding, args: ['class.curtain',] }],
    columnCurtain: [{ type: HostBinding, args: ['class.column-curtain',] }],
    modalDrop: [{ type: HostBinding, args: ['class.modal-drop',] }],
    modalHalf: [{ type: HostBinding, args: ['class.modal-half',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSearchFieldComponent, [{
        type: Component,
        args: [{
                selector: 'nb-search-field',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
                styles: [":host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:0.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:0.3}:host span{font-size:90%;font-weight:bold;display:block;width:75%;margin:0 auto;padding:0.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}:host.modal-zoomin .search::before,:host.modal-zoomin .search::after{content:'';position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search::before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px, -15px, 0)}:host.modal-zoomin .search::after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px, 15px, 0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search::before,:host.modal-zoomin.show .search::after{transform:translate3d(0, 0, 0);transition:transform 0.5s}:host.modal-zoomin.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-zoomin.show .search form{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n", "::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0, 50vh, 0) rotate3d(1, 0, 0, 30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:0.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(0.7, 0.7, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.rotate-layout.show .search form{opacity:1;transform:scale3d(1, 1, 1)}\n", "::ng-deep nb-layout.modal-move .layout{transition:transform 0.5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-move.show .search input{transform:scale3d(1, 1, 1);transition-duration:0.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n", ":host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform 0.3s;transition-delay:0.4s;transition-timing-function:ease-out}:host.curtain .search::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transition:transform 0.3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity 0.1s;transition-delay:0.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%, 0, 0);transition-delay:0s}:host.curtain.show .search::after{transform:translate3d(100%, 0, 0);transition-delay:0.4s}:host.curtain.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.curtain.show .search form{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n", "::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%, 0, 0);transition:transform 0.3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show::before{transform:scale3d(1, 1, 1)}:host.column-curtain.show .search form{transform:translate3d(0, 0, 0);transition-delay:0.15s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n", "::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform 0.4s, opacity 0.4s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(0.9, 0.9, 1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search::before{content:'';position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity 0.4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity 0.4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:0.25rem;text-align:center;opacity:0;transition:opacity 0.4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:0.85rem 0;opacity:0;transform:translate3d(0, -50px, 0);transition:opacity 0.4s, transform 0.4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0, -50px, 0);transition:transform 0.4s}:host.modal-drop .search .form-content::after{content:'';position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search::before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translate3d(0, 0, 0);transition:none}:host.modal-drop.show .search .form-content::after{animation:scaleUpDown 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s 0.4s}:host.modal-drop.show .search span{opacity:1;transform:translate3d(0, 0, 0);transition-delay:0.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1, 0, 1)}50%{transform:scale3d(1, 1, 1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}100%{opacity:1;transform:scale3d(1, 0, 1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n", "::ng-deep nb-layout.modal-half .layout{transition:transform 0.6s, opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.6s, transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1);transform:translate3d(0, -100%, 0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search::before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-half.show .search .form-wrapper{transform:translate3d(0, 0, 0)}\n"]
            }]
    }], function () { return []; }, { show: [{
            type: Input
        }], close: [{
            type: Output
        }], search: [{
            type: Output
        }], searchInput: [{
            type: Output
        }], showClass: [{
            type: HostBinding,
            args: ['class.show']
        }], modalZoomin: [{
            type: HostBinding,
            args: ['class.modal-zoomin']
        }], rotateLayout: [{
            type: HostBinding,
            args: ['class.rotate-layout']
        }], modalMove: [{
            type: HostBinding,
            args: ['class.modal-move']
        }], curtain: [{
            type: HostBinding,
            args: ['class.curtain']
        }], columnCurtain: [{
            type: HostBinding,
            args: ['class.column-curtain']
        }], modalDrop: [{
            type: HostBinding,
            args: ['class.modal-drop']
        }], modalHalf: [{
            type: HostBinding,
            args: ['class.modal-half']
        }], type: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], hint: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['searchInput']
        }] }); })();
/**
 * Beautiful full-page search control.
 *
 * @stacked-example(Showcase, search/search-showcase.component)
 *
 * Basic setup:
 *
 * ```ts
 *  <nb-search type="rotate-layout"></nb-search>
 * ```
 * ### Installation
 *
 * Import `NbSearchModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSearchModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Several animation types are available:
 * modal-zoomin, rotate-layout, modal-move, curtain, column-curtain, modal-drop, modal-half
 *
 * It is also possible to handle search event using `NbSearchService`:
 *
 * @stacked-example(Search Event, search/search-event.component)
 *
 * @styles
 *
 * search-background-color:
 * search-divider-color:
 * search-divider-style:
 * search-divider-width:
 * search-extra-background-color:
 * search-text-color:
 * search-text-font-family:
 * search-text-font-size:
 * search-text-font-weight:
 * search-text-line-height:
 * search-placeholder-text-color:
 * search-info-text-color:
 * search-info-text-font-family:
 * search-info-text-font-size:
 * search-info-text-font-weight:
 * search-info-text-line-height:
 */
class NbSearchComponent {
    constructor(searchService, themeService, router, overlayService, changeDetector) {
        this.searchService = searchService;
        this.themeService = themeService;
        this.router = router;
        this.overlayService = overlayService;
        this.changeDetector = changeDetector;
        this.destroy$ = new Subject();
        this.showSearchField = false;
        /**
         * Search input placeholder
         * @type {string}
         */
        this.placeholder = 'Search...';
        /**
         * Hint showing under the input field to improve user experience
         *
         * @type {string}
         */
        this.hint = 'Hit enter to search';
    }
    ngOnInit() {
        this.router.events
            .pipe(filter(event => event instanceof NavigationEnd), takeUntil(this.destroy$))
            .subscribe(() => this.hideSearch());
        this.searchService.onSearchActivate()
            .pipe(filter(data => !this.tag || data.tag === this.tag), takeUntil(this.destroy$))
            .subscribe(() => this.openSearch());
        this.searchService.onSearchDeactivate()
            .pipe(filter(data => !this.tag || data.tag === this.tag), takeUntil(this.destroy$))
            .subscribe(() => this.hideSearch());
    }
    ngOnDestroy() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.removeLayoutClasses();
            this.overlayRef.detach();
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    openSearch() {
        if (!this.overlayRef) {
            this.overlayRef = this.overlayService.create();
            this.overlayRef.attach(this.searchFieldPortal);
        }
        this.themeService.appendLayoutClass(this.type);
        of(null).pipe(delay(0)).subscribe(() => {
            this.themeService.appendLayoutClass('with-search');
            this.showSearchField = true;
            this.changeDetector.detectChanges();
        });
    }
    hideSearch() {
        this.removeLayoutClasses();
        this.showSearchField = false;
        this.changeDetector.detectChanges();
        this.searchButton.nativeElement.focus();
    }
    search(term) {
        this.searchService.submitSearch(term, this.tag);
        this.hideSearch();
    }
    emitInput(term) {
        this.searchService.searchInput(term, this.tag);
    }
    emitActivate() {
        this.searchService.activateSearch(this.type, this.tag);
    }
    emitDeactivate() {
        this.searchService.deactivateSearch(this.type, this.tag);
    }
    removeLayoutClasses() {
        this.themeService.removeLayoutClass('with-search');
        of(null).pipe(delay(500)).subscribe(() => {
            this.themeService.removeLayoutClass(this.type);
        });
    }
}
NbSearchComponent.ɵfac = function NbSearchComponent_Factory(t) { return new (t || NbSearchComponent)(ɵngcc0.ɵɵdirectiveInject(NbSearchService), ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Router), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbSearchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSearchComponent, selectors: [["nb-search"]], viewQuery: function NbSearchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, 1);
        ɵngcc0.ɵɵviewQuery(_c22, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchFieldPortal = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchButton = _t.first);
    } }, inputs: { placeholder: "placeholder", hint: "hint", tag: "tag", type: "type" }, decls: 4, vars: 0, consts: [["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["searchButton", ""], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close"]], template: function NbSearchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("click", function NbSearchComponent_Template_button_click_0_listener() { return ctx.emitActivate(); });
        ɵngcc0.ɵɵelement(2, "nb-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
    } }, directives: [NbButtonComponent, NbIconComponent, NbPortalDirective, NbSearchFieldComponent], styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}"], changeDetection: 0 });
NbSearchComponent.ctorParameters = () => [
    { type: NbSearchService },
    { type: NbThemeService },
    { type: Router },
    { type: NbOverlayService },
    { type: ChangeDetectorRef }
];
NbSearchComponent.propDecorators = {
    tag: [{ type: Input }],
    placeholder: [{ type: Input }],
    hint: [{ type: Input }],
    type: [{ type: Input }],
    searchFieldPortal: [{ type: ViewChild, args: [NbPortalDirective,] }],
    searchButton: [{ type: ViewChild, args: ['searchButton', { read: ElementRef },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSearchComponent, [{
        type: Component,
        args: [{
                selector: 'nb-search',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
                styles: [":host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n"]
            }]
    }], function () { return [{ type: NbSearchService }, { type: NbThemeService }, { type: ɵngcc5.Router }, { type: NbOverlayService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { placeholder: [{
            type: Input
        }], hint: [{
            type: Input
        }], tag: [{
            type: Input
        }], type: [{
            type: Input
        }], searchFieldPortal: [{
            type: ViewChild,
            args: [NbPortalDirective]
        }], searchButton: [{
            type: ViewChild,
            args: ['searchButton', { read: ElementRef }]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbSearchModule {
}
NbSearchModule.ɵfac = function NbSearchModule_Factory(t) { return new (t || NbSearchModule)(); };
NbSearchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSearchModule });
NbSearchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        NbSearchService,
    ], imports: [[
            NbSharedModule,
            NbOverlayModule,
            NbIconModule,
            NbButtonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSearchModule, { declarations: [NbSearchComponent, NbSearchFieldComponent], imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule], exports: [NbSearchComponent, NbSearchFieldComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSearchModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbOverlayModule,
                    NbIconModule,
                    NbButtonModule,
                ],
                declarations: [
                    NbSearchComponent,
                    NbSearchFieldComponent,
                ],
                exports: [
                    NbSearchComponent,
                    NbSearchFieldComponent,
                ],
                providers: [
                    NbSearchService,
                ],
                entryComponents: [
                    NbSearchFieldComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Styled checkbox component
 *
 * @stacked-example(Showcase, checkbox/checkbox-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCheckboxComponent` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCheckboxModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Checkbox is available in multiple colors using `status` property:
 * @stacked-example(Colored Checkboxes, checkbox/checkbox-status.component)
 *
 * Indeterminate state is also supported:
 * @stacked-example(Indeterminate Checkbox, checkbox/checkbox-indeterminate.component)
 *
 * Checkbox can be disabled via `disabled` attribute.
 * @stacked-example(Disabled Checkbox, checkbox/checkbox-disabled.component)
 *
 * @styles
 *
 * checkbox-height:
 * checkbox-width:
 * checkbox-border-style:
 * checkbox-border-width:
 * checkbox-border-radius:
 * checkbox-outline-width:
 * checkbox-outline-color:
 * checkbox-text-font-family:
 * checkbox-text-font-size:
 * checkbox-text-font-weight:
 * checkbox-text-line-height:
 * checkbox-text-space:
 * checkbox-padding:
 * checkbox-focus-inset-shadow-length:
 * checkbox-basic-text-color:
 * checkbox-basic-background-color:
 * checkbox-basic-border-color:
 * checkbox-basic-checked-background-color:
 * checkbox-basic-checked-border-color:
 * checkbox-basic-checked-checkmark-color:
 * checkbox-basic-indeterminate-background-color:
 * checkbox-basic-indeterminate-border-color:
 * checkbox-basic-indeterminate-checkmark-color:
 * checkbox-basic-focus-background-color:
 * checkbox-basic-focus-border-color:
 * checkbox-basic-focus-checked-background-color:
 * checkbox-basic-focus-checked-border-color:
 * checkbox-basic-hover-background-color:
 * checkbox-basic-hover-border-color:
 * checkbox-basic-hover-checked-background-color:
 * checkbox-basic-hover-checked-border-color:
 * checkbox-basic-active-background-color:
 * checkbox-basic-active-border-color:
 * checkbox-basic-active-checked-background-color:
 * checkbox-basic-active-checked-border-color:
 * checkbox-basic-disabled-background-color:
 * checkbox-basic-disabled-border-color:
 * checkbox-basic-disabled-checkmark-color:
 * checkbox-basic-disabled-text-color:
 * checkbox-basic-disabled-checked-background-color:
 * checkbox-primary-text-color:
 * checkbox-primary-background-color:
 * checkbox-primary-border-color:
 * checkbox-primary-checked-background-color:
 * checkbox-primary-checked-border-color:
 * checkbox-primary-checked-checkmark-color:
 * checkbox-primary-indeterminate-background-color:
 * checkbox-primary-indeterminate-border-color:
 * checkbox-primary-indeterminate-checkmark-color:
 * checkbox-primary-focus-background-color:
 * checkbox-primary-focus-border-color:
 * checkbox-primary-focus-checked-background-color:
 * checkbox-primary-focus-checked-border-color:
 * checkbox-primary-hover-background-color:
 * checkbox-primary-hover-border-color:
 * checkbox-primary-hover-checked-background-color:
 * checkbox-primary-hover-checked-border-color:
 * checkbox-primary-active-background-color:
 * checkbox-primary-active-border-color:
 * checkbox-primary-active-checked-background-color:
 * checkbox-primary-active-checked-border-color:
 * checkbox-primary-disabled-background-color:
 * checkbox-primary-disabled-border-color:
 * checkbox-primary-disabled-checkmark-color:
 * checkbox-primary-disabled-text-color:
 * checkbox-primary-disabled-checked-background-color:
 * checkbox-success-text-color:
 * checkbox-success-background-color:
 * checkbox-success-border-color:
 * checkbox-success-checked-background-color:
 * checkbox-success-checked-border-color:
 * checkbox-success-checked-checkmark-color:
 * checkbox-success-indeterminate-background-color:
 * checkbox-success-indeterminate-border-color:
 * checkbox-success-indeterminate-checkmark-color:
 * checkbox-success-focus-background-color:
 * checkbox-success-focus-border-color:
 * checkbox-success-focus-checked-background-color:
 * checkbox-success-focus-checked-border-color:
 * checkbox-success-hover-background-color:
 * checkbox-success-hover-border-color:
 * checkbox-success-hover-checked-background-color:
 * checkbox-success-hover-checked-border-color:
 * checkbox-success-active-background-color:
 * checkbox-success-active-border-color:
 * checkbox-success-active-checked-background-color:
 * checkbox-success-active-checked-border-color:
 * checkbox-success-disabled-background-color:
 * checkbox-success-disabled-border-color:
 * checkbox-success-disabled-checkmark-color:
 * checkbox-success-disabled-text-color:
 * checkbox-success-disabled-checked-background-color:
 * checkbox-info-text-color:
 * checkbox-info-background-color:
 * checkbox-info-border-color:
 * checkbox-info-checked-background-color:
 * checkbox-info-checked-border-color:
 * checkbox-info-checked-checkmark-color:
 * checkbox-info-indeterminate-background-color:
 * checkbox-info-indeterminate-border-color:
 * checkbox-info-indeterminate-checkmark-color:
 * checkbox-info-focus-background-color:
 * checkbox-info-focus-border-color:
 * checkbox-info-focus-checked-background-color:
 * checkbox-info-focus-checked-border-color:
 * checkbox-info-hover-background-color:
 * checkbox-info-hover-border-color:
 * checkbox-info-hover-checked-background-color:
 * checkbox-info-hover-checked-border-color:
 * checkbox-info-active-background-color:
 * checkbox-info-active-border-color:
 * checkbox-info-active-checked-background-color:
 * checkbox-info-active-checked-border-color:
 * checkbox-info-disabled-background-color:
 * checkbox-info-disabled-border-color:
 * checkbox-info-disabled-checkmark-color:
 * checkbox-info-disabled-text-color:
 * checkbox-info-disabled-checked-background-color:
 * checkbox-warning-text-color:
 * checkbox-warning-background-color:
 * checkbox-warning-border-color:
 * checkbox-warning-checked-background-color:
 * checkbox-warning-checked-border-color:
 * checkbox-warning-checked-checkmark-color:
 * checkbox-warning-indeterminate-background-color:
 * checkbox-warning-indeterminate-border-color:
 * checkbox-warning-indeterminate-checkmark-color:
 * checkbox-warning-focus-background-color:
 * checkbox-warning-focus-border-color:
 * checkbox-warning-focus-checked-background-color:
 * checkbox-warning-focus-checked-border-color:
 * checkbox-warning-hover-background-color:
 * checkbox-warning-hover-border-color:
 * checkbox-warning-hover-checked-background-color:
 * checkbox-warning-hover-checked-border-color:
 * checkbox-warning-active-background-color:
 * checkbox-warning-active-border-color:
 * checkbox-warning-active-checked-background-color:
 * checkbox-warning-active-checked-border-color:
 * checkbox-warning-disabled-background-color:
 * checkbox-warning-disabled-border-color:
 * checkbox-warning-disabled-checkmark-color:
 * checkbox-warning-disabled-text-color:
 * checkbox-warning-disabled-checked-background-color:
 * checkbox-danger-text-color:
 * checkbox-danger-background-color:
 * checkbox-danger-border-color:
 * checkbox-danger-checked-background-color:
 * checkbox-danger-checked-border-color:
 * checkbox-danger-checked-checkmark-color:
 * checkbox-danger-indeterminate-background-color:
 * checkbox-danger-indeterminate-border-color:
 * checkbox-danger-indeterminate-checkmark-color:
 * checkbox-danger-focus-background-color:
 * checkbox-danger-focus-border-color:
 * checkbox-danger-focus-checked-background-color:
 * checkbox-danger-focus-checked-border-color:
 * checkbox-danger-hover-background-color:
 * checkbox-danger-hover-border-color:
 * checkbox-danger-hover-checked-background-color:
 * checkbox-danger-hover-checked-border-color:
 * checkbox-danger-active-background-color:
 * checkbox-danger-active-border-color:
 * checkbox-danger-active-checked-background-color:
 * checkbox-danger-active-checked-border-color:
 * checkbox-danger-disabled-background-color:
 * checkbox-danger-disabled-border-color:
 * checkbox-danger-disabled-checkmark-color:
 * checkbox-danger-disabled-text-color:
 * checkbox-danger-disabled-checked-background-color:
 * checkbox-control-text-color:
 * checkbox-control-background-color:
 * checkbox-control-border-color:
 * checkbox-control-checked-background-color:
 * checkbox-control-checked-border-color:
 * checkbox-control-checked-checkmark-color:
 * checkbox-control-indeterminate-background-color:
 * checkbox-control-indeterminate-border-color:
 * checkbox-control-indeterminate-checkmark-color:
 * checkbox-control-focus-background-color:
 * checkbox-control-focus-border-color:
 * checkbox-control-focus-checked-background-color:
 * checkbox-control-focus-checked-border-color:
 * checkbox-control-hover-background-color:
 * checkbox-control-hover-border-color:
 * checkbox-control-hover-checked-background-color:
 * checkbox-control-hover-checked-border-color:
 * checkbox-control-active-background-color:
 * checkbox-control-active-border-color:
 * checkbox-control-active-checked-background-color:
 * checkbox-control-active-checked-border-color:
 * checkbox-control-disabled-background-color:
 * checkbox-control-disabled-border-color:
 * checkbox-control-disabled-checkmark-color:
 * checkbox-control-disabled-text-color:
 * checkbox-control-disabled-checked-background-color:
 */
class NbCheckboxComponent {
    constructor(changeDetector, renderer, hostElement, zone, statusService) {
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.zone = zone;
        this.statusService = statusService;
        this.onChange = () => { };
        this.onTouched = () => { };
        this._checked = false;
        this._disabled = false;
        /**
         * Checkbox status.
         * Possible values are: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`.
         */
        this.status = 'basic';
        this._indeterminate = false;
        /**
         * Output when checked state is changed by a user
         * @type EventEmitter<boolean>
         */
        this.checkedChange = new EventEmitter();
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        this._checked = convertToBoolProperty(value);
    }
    /**
     * Controls input disabled state
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * Controls checkbox indeterminate state
     */
    get indeterminate() {
        return this._indeterminate;
    }
    set indeterminate(value) {
        this._indeterminate = convertToBoolProperty(value);
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get info() {
        return this.status === 'info';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.hostElement.nativeElement, 'nb-transition');
        }));
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(val) {
        this._checked = val;
        this.changeDetector.markForCheck();
    }
    setDisabledState(val) {
        this.disabled = convertToBoolProperty(val);
        this.changeDetector.markForCheck();
    }
    setTouched() {
        this.onTouched();
    }
    updateValueAndIndeterminate(event) {
        const input = event.target;
        this.checked = input.checked;
        this.checkedChange.emit(this.checked);
        this.onChange(this.checked);
        this.indeterminate = input.indeterminate;
    }
}
NbCheckboxComponent.ɵfac = function NbCheckboxComponent_Factory(t) { return new (t || NbCheckboxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCheckboxComponent, selectors: [["nb-checkbox"]], hostVars: 16, hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { status: "status", checked: "checked", disabled: "disabled", indeterminate: "indeterminate" }, outputs: { checkedChange: "checkedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbCheckboxComponent),
                multi: true
            }])], ngContentSelectors: _c0, decls: 7, vars: 9, consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "indeterminate", "change", "blur", "click"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]], template: function NbCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) { return ctx.updateValueAndIndeterminate($event); })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() { return ctx.setTouched(); })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) { return $event.stopPropagation(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtemplate(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3);
        ɵngcc0.ɵɵtemplate(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.indeterminate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0}.nb-transition[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.nb-transition[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition-duration:0.15s;transition-property:color;transition-timing-function:ease-in}"], changeDetection: 0 });
NbCheckboxComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: NbStatusService }
];
NbCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    status: [{ type: Input }],
    indeterminate: [{ type: Input }],
    checkedChange: [{ type: Output }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'nb-checkbox',
                template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbCheckboxComponent),
                        multi: true
                    }],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0}:host(.nb-transition) .custom-checkbox{transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host(.nb-transition) .text{transition-duration:0.15s;transition-property:color;transition-timing-function:ease-in}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { status: [{
            type: Input
        }], checkedChange: [{
            type: Output
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], indeterminate: [{
            type: Input
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbCheckboxModule {
}
NbCheckboxModule.ɵfac = function NbCheckboxModule_Factory(t) { return new (t || NbCheckboxModule)(); };
NbCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCheckboxModule });
NbCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCheckboxModule, { declarations: [NbCheckboxComponent], imports: [NbSharedModule, NbIconModule], exports: [NbCheckboxComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCheckboxModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [NbCheckboxComponent],
                exports: [NbCheckboxComponent]
            }]
    }], null, null); })();

class NbDynamicOverlay {
    constructor(overlay, componentFactoryResolver, zone, overlayContainer) {
        this.overlay = overlay;
        this.componentFactoryResolver = componentFactoryResolver;
        this.zone = zone;
        this.overlayContainer = overlayContainer;
        this.context = {};
        this.overlayConfig = {};
        this.positionStrategyChange$ = new Subject();
        this.isShown$ = new BehaviorSubject(false);
        this.destroy$ = new Subject();
        this.overlayDestroy$ = new Subject();
    }
    get isAttached() {
        return this.ref && this.ref.hasAttached();
    }
    get isShown() {
        return this.isShown$.pipe(distinctUntilChanged());
    }
    create(componentType, content, context, positionStrategy, overlayConfig = {}) {
        this.setContentAndContext(content, context);
        this.setComponent(componentType);
        this.setPositionStrategy(positionStrategy);
        this.setOverlayConfig(overlayConfig);
        return this;
    }
    setContent(content) {
        this.content = content;
        if (this.container) {
            this.updateContext();
        }
        this.updatePosition();
    }
    setContext(context) {
        this.context = context;
        if (this.container) {
            this.updateContext();
        }
        this.updatePosition();
    }
    setContentAndContext(content, context) {
        this.content = content;
        this.context = context;
        if (this.container) {
            this.updateContext();
        }
        this.updatePosition();
    }
    setComponent(componentType) {
        this.componentType = componentType;
        // in case the component is shown we recreate it and show it back
        const wasAttached = this.isAttached;
        this.disposeOverlayRef();
        if (wasAttached) {
            this.show();
        }
    }
    setPositionStrategy(positionStrategy) {
        this.positionStrategyChange$.next();
        this.positionStrategy = positionStrategy;
        this.positionStrategy.positionChange
            .pipe(filter(() => !!this.container), takeUntil(merge(this.positionStrategyChange$, this.destroy$)))
            .subscribe((position) => {
            this.lastAppliedPosition = position;
            patch(this.container, { position });
        });
        if (this.ref) {
            this.ref.updatePositionStrategy(this.positionStrategy);
        }
    }
    setOverlayConfig(overlayConfig) {
        this.overlayConfig = overlayConfig;
        const wasAttached = this.isAttached;
        this.disposeOverlayRef();
        if (wasAttached) {
            this.show();
        }
    }
    show() {
        if (!this.ref) {
            this.createOverlay();
        }
        this.renderContainer();
        if (!this.hasOverlayInContainer()) {
            // Dispose overlay ref as it refers to the old overlay container and create new by calling `show`
            this.disposeOverlayRef();
            return this.show();
        }
        this.isShown$.next(true);
    }
    hide() {
        if (!this.ref) {
            return;
        }
        this.ref.detach();
        this.container = null;
        this.isShown$.next(false);
    }
    toggle() {
        if (this.isAttached) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    dispose() {
        this.destroy$.next();
        this.destroy$.complete();
        this.hide();
        this.disposeOverlayRef();
        this.isShown$.complete();
        this.positionStrategyChange$.complete();
        this.overlayDestroy$.complete();
    }
    getContainer() {
        return this.container;
    }
    createOverlay() {
        this.ref = this.overlay.create(Object.assign({ positionStrategy: this.positionStrategy, scrollStrategy: this.overlay.scrollStrategies.reposition() }, this.overlayConfig));
        this.updatePositionWhenStable(this.ref);
    }
    renderContainer() {
        const containerContext = this.createContainerContext();
        if (!this.container) {
            this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);
        }
        this.container.instance.renderContent();
    }
    updateContext() {
        const containerContext = this.createContainerContext();
        Object.assign(this.container.instance, containerContext);
        this.container.instance.renderContent();
        this.container.changeDetectorRef.detectChanges();
    }
    createContainerContext() {
        return {
            content: this.content,
            context: this.context,
            cfr: this.componentFactoryResolver,
            position: this.lastAppliedPosition,
        };
    }
    /**
     * Dimensions of the container may change after content update. So we listen to zone.stable event to
     * reposition the container.
     */
    updatePositionWhenStable(overlay) {
        const overlayDestroy$ = this.overlayDestroy$.pipe(filter((destroyedOverlay) => destroyedOverlay === overlay));
        this.zone.onStable
            .pipe(takeUntil(merge(this.destroy$, overlayDestroy$)))
            .subscribe(() => this.updatePosition());
    }
    updatePosition() {
        if (this.ref) {
            this.ref.updatePosition();
        }
    }
    hasOverlayInContainer() {
        return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
    }
    disposeOverlayRef() {
        if (this.ref) {
            this.ref.dispose();
            this.overlayDestroy$.next(this.ref);
            this.ref = null;
            this.container = null;
        }
    }
}
NbDynamicOverlay.ɵfac = function NbDynamicOverlay_Factory(t) { return new (t || NbDynamicOverlay)(ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbOverlayContainer)); };
NbDynamicOverlay.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDynamicOverlay, factory: NbDynamicOverlay.ɵfac });
NbDynamicOverlay.ctorParameters = () => [
    { type: NbOverlayService },
    { type: ComponentFactoryResolver },
    { type: NgZone },
    { type: NbOverlayContainer }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDynamicOverlay, [{
        type: Injectable
    }], function () { return [{ type: NbOverlayService }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.NgZone }, { type: NbOverlayContainer }]; }, null); })();

class NbDynamicOverlayChange extends SimpleChange {
    constructor(previousValue, currentValue, firstChange = false) {
        super(previousValue, currentValue, firstChange);
    }
    isChanged() {
        return this.currentValue !== this.previousValue;
    }
}
class NbDynamicOverlayHandler {
    constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService) {
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.dynamicOverlayService = dynamicOverlayService;
        this._context = {};
        this._trigger = NbTrigger.NOOP;
        this._position = NbPosition.TOP;
        this._adjustment = NbAdjustment.NOOP;
        this._offset = 15;
        this._overlayConfig = {};
        this.changes = {};
    }
    host(host) {
        this.changes.host = new NbDynamicOverlayChange(this._host, host);
        this._host = host;
        return this;
    }
    trigger(trigger$$1) {
        this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger$$1);
        this._trigger = trigger$$1;
        return this;
    }
    position(position) {
        this.changes.position = new NbDynamicOverlayChange(this._position, position);
        this._position = position;
        return this;
    }
    adjustment(adjustment) {
        this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
        this._adjustment = adjustment;
        return this;
    }
    componentType(componentType) {
        this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
        this._componentType = componentType;
        return this;
    }
    content(content) {
        this.changes.content = new NbDynamicOverlayChange(this._content, content);
        this._content = content;
        return this;
    }
    context(context) {
        this.changes.context = new NbDynamicOverlayChange(this._context, context);
        this._context = context;
        return this;
    }
    offset(offset) {
        this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
        this._offset = offset;
        return this;
    }
    overlayConfig(overlayConfig) {
        this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
        this._overlayConfig = overlayConfig;
        return this;
    }
    build() {
        if (!this._componentType || !this._host) {
            throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
        }
        this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig);
        this.connect();
        this.clearChanges();
        return this.dynamicOverlay;
    }
    rebuild() {
        /**
         * we should not throw here
         * as we use rebuilt in lifecycle hooks
         * which it could be called before the build
         * so we just ignore this call
         */
        if (!this.dynamicOverlay) {
            return;
        }
        if (this.isPositionStrategyUpdateRequired()) {
            this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
        }
        if (this.isTriggerStrategyUpdateRequired()) {
            this.connect();
        }
        if (this.isContainerRerenderRequired()) {
            this.dynamicOverlay.setContentAndContext(this._content, this._context);
        }
        if (this.isComponentTypeUpdateRequired()) {
            this.dynamicOverlay.setComponent(this._componentType);
        }
        if (this.isOverlayConfigUpdateRequired()) {
            this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
        }
        this.clearChanges();
        return this.dynamicOverlay;
    }
    connect() {
        if (!this.dynamicOverlay) {
            throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
        }
        this.disconnect();
        this.subscribeOnTriggers(this.dynamicOverlay);
    }
    disconnect() {
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    destroy() {
        this.disconnect();
        this.clearChanges();
        if (this.dynamicOverlay) {
            this.dynamicOverlay.dispose();
        }
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this._host)
            .position(this._position)
            .adjustment(this._adjustment)
            .offset(this._offset);
    }
    subscribeOnTriggers(dynamicOverlay) {
        this.triggerStrategy = this.triggerStrategyBuilder
            .trigger(this._trigger)
            .host(this._host.nativeElement)
            .container(() => dynamicOverlay.getContainer())
            .build();
        this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
        this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
    }
    isContainerRerenderRequired() {
        return this.isContentUpdated()
            || this.isContextUpdated()
            || this.isPositionStrategyUpdateRequired();
    }
    isPositionStrategyUpdateRequired() {
        return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
    }
    isTriggerStrategyUpdateRequired() {
        return this.isTriggerUpdated() || this.isHostUpdated();
    }
    isComponentTypeUpdateRequired() {
        return this.isComponentTypeUpdated();
    }
    isOverlayConfigUpdateRequired() {
        return this.isOverlayConfigUpdated();
    }
    isComponentTypeUpdated() {
        return this.changes.componentType && this.changes.componentType.isChanged();
    }
    isContentUpdated() {
        return this.changes.content && this.changes.content.isChanged();
    }
    isContextUpdated() {
        return this.changes.context && this.changes.context.isChanged();
    }
    isAdjustmentUpdated() {
        return this.changes.adjustment && this.changes.adjustment.isChanged();
    }
    isPositionUpdated() {
        return this.changes.position && this.changes.position.isChanged();
    }
    isHostUpdated() {
        return this.changes.host && this.changes.host.isChanged();
    }
    isTriggerUpdated() {
        return this.changes.trigger && this.changes.trigger.isChanged();
    }
    isOffsetUpdated() {
        return this.changes.offset && this.changes.offset.isChanged();
    }
    isOverlayConfigUpdated() {
        return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
    }
    clearChanges() {
        this.changes = {};
    }
}
NbDynamicOverlayHandler.ɵfac = function NbDynamicOverlayHandler_Factory(t) { return new (t || NbDynamicOverlayHandler)(ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵinject(NbDynamicOverlay)); };
NbDynamicOverlayHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDynamicOverlayHandler, factory: NbDynamicOverlayHandler.ɵfac });
NbDynamicOverlayHandler.ctorParameters = () => [
    { type: NbPositionBuilderService },
    { type: NbTriggerStrategyBuilderService },
    { type: NbDynamicOverlay }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDynamicOverlayHandler, [{
        type: Injectable
    }], function () { return [{ type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: NbDynamicOverlay }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Overlay container.
 * Renders provided content inside.
 *
 * @styles
 *
 * popover-text-color:
 * popover-text-font-family:
 * popover-text-font-size:
 * popover-text-font-weight:
 * popover-text-line-height:
 * popover-background-color:
 * popover-border-width:
 * popover-border-color:
 * popover-border-radius:
 * popover-shadow:
 * popover-arrow-size:
 * popover-padding:
 * */
class NbPopoverComponent extends NbPositionedContainerComponent {
    renderContent() {
        this.detachContent();
        this.attachContent();
    }
    detachContent() {
        this.overlayContainer.detach();
    }
    attachContent() {
        if (this.content instanceof TemplateRef) {
            this.attachTemplate();
        }
        else if (this.content instanceof Type) {
            this.attachComponent();
        }
        else {
            this.attachString();
        }
    }
    attachTemplate() {
        this.overlayContainer
            .attachTemplatePortal(new NbTemplatePortal(this.content, null, { $implicit: this.context }));
    }
    attachComponent() {
        const portal = new NbComponentPortal(this.content, null, null, this.cfr);
        const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
        ref.changeDetectorRef.detectChanges();
    }
    attachString() {
        this.overlayContainer.attachStringContent(this.content);
    }
}
NbPopoverComponent.ɵfac = function NbPopoverComponent_Factory(t) { return ɵNbPopoverComponent_BaseFactory(t || NbPopoverComponent); };
NbPopoverComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbPopoverComponent, selectors: [["nb-popover"]], viewQuery: function NbPopoverComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbOverlayContainerComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, inputs: { content: "content", context: "context", cfr: "cfr" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 0, consts: [[1, "arrow"]], template: function NbPopoverComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelement(1, "nb-overlay-container");
    } }, directives: [NbOverlayContainerComponent], styles: ["[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}"] });
NbPopoverComponent.propDecorators = {
    overlayContainer: [{ type: ViewChild, args: [NbOverlayContainerComponent,] }],
    content: [{ type: Input }],
    context: [{ type: Input }],
    cfr: [{ type: Input }]
};
const ɵNbPopoverComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbPopoverComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPopoverComponent, [{
        type: Component,
        args: [{
                selector: 'nb-popover',
                template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
                styles: [":host .arrow{position:absolute;width:0;height:0}\n"]
            }]
    }], null, { overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent]
        }], content: [{
            type: Input
        }], context: [{
            type: Input
        }], cfr: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Powerful popover directive, which provides the best UX for your users.
 *
 * @stacked-example(Showcase, popover/popover-showcase.component)
 *
 * Popover can accept different content such as:
 * TemplateRef
 *
 * ```html
 * <button [nbPopover]="templateRef"></button>
 * <ng-template #templateRef>
 *   <span>Hello, Popover!</span>
 * </ng-template>
 * ```
 * ### Installation
 *
 * Import `NbPopoverModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbPopoverModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Custom components
 *
 * ```html
 * <button [nbPopover]="MyPopoverComponent"></button>
 * ```
 *
 * Both custom components and templateRef popovers can receive *contentContext* property
 * that will be passed to the content props.
 *
 * Primitive types
 *
 * ```html
 * <button nbPopover="Hello, Popover!"></button>
 * ```
 *
 * Popover has different placements, such as: top, bottom, left, right, start and end
 * which can be used as following:
 *
 * @stacked-example(Placements, popover/popover-placements.component)
 *
 * By default popover will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the popover container.
 * If you want to disable this behaviour set it `noop`.
 *
 * ```html
 * <button nbPopover="Hello, Popover!" nbPopoverAdjustment="noop"></button>
 * ```
 *
 * Popover has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, popover/popover-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, popover/popover-noop.component)
 *
 * Below are examples for manual popover settings control, both via template binding and code.
 * @stacked-example(Popover Settings, popover/popover-dynamic.component)
 *
 * Please note, while manipulating Popover setting via code, you need to call `rebuild()` method to apply the settings
 * changed.
 * @stacked-example(Popover Settings Code, popover/popover-dynamic-code.component)
 *
 * @additional-example(Template Ref, popover/popover-template-ref.component)
 * @additional-example(Custom Component, popover/popover-custom-component.component)
 * */
class NbPopoverDirective {
    constructor(hostRef, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.popoverComponent = NbPopoverComponent;
        this.destroy$ = new Subject();
        /**
         * Container content context. Will be applied to the rendered component.
         * */
        this.context = {};
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom, left, start or end.
         * */
        this.position = NbPosition.TOP;
        this._adjustment = NbAdjustment.CLOCKWISE;
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.CLICK;
        /**
         * Sets popover offset
         * */
        this.offset = 15;
        this._popoverClass = '';
        this.nbPopoverShowStateChange = new EventEmitter();
        this.overlayConfig = { panelClass: this.popoverClass };
    }
    /**
     * Container position will be changes automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatically adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     * */
    get adjustment() {
        return this._adjustment;
    }
    set adjustment(value) {
        this._adjustment = value;
    }
    get popoverClass() {
        return this._popoverClass;
    }
    set popoverClass(value) {
        if (value !== this.popoverClass) {
            this._popoverClass = value;
            this.overlayConfig = { panelClass: this.popoverClass };
        }
    }
    get isShown() {
        return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
    }
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(this.popoverComponent);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.dynamicOverlay.isShown
            .pipe(skip(1), takeUntil(this.destroy$))
            .subscribe((isShown) => this.nbPopoverShowStateChange.emit({ isShown }));
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .offset(this.offset)
            .adjustment(this.adjustment)
            .content(this.content)
            .context(this.context)
            .overlayConfig(this.overlayConfig);
    }
}
NbPopoverDirective.ɵfac = function NbPopoverDirective_Factory(t) { return new (t || NbPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbPopoverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPopoverDirective, selectors: [["", "nbPopover", ""]], inputs: { context: ["nbPopoverContext", "context"], position: ["nbPopoverPlacement", "position"], trigger: ["nbPopoverTrigger", "trigger"], offset: ["nbPopoverOffset", "offset"], adjustment: ["nbPopoverAdjustment", "adjustment"], popoverClass: ["nbPopoverClass", "popoverClass"], content: ["nbPopover", "content"] }, outputs: { nbPopoverShowStateChange: "nbPopoverShowStateChange" }, exportAs: ["nbPopover"], features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature] });
NbPopoverDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbDynamicOverlayHandler }
];
NbPopoverDirective.propDecorators = {
    content: [{ type: Input, args: ['nbPopover',] }],
    context: [{ type: Input, args: ['nbPopoverContext',] }],
    position: [{ type: Input, args: ['nbPopoverPlacement',] }],
    adjustment: [{ type: Input, args: ['nbPopoverAdjustment',] }],
    trigger: [{ type: Input, args: ['nbPopoverTrigger',] }],
    offset: [{ type: Input, args: ['nbPopoverOffset',] }],
    popoverClass: [{ type: Input, args: ['nbPopoverClass',] }],
    nbPopoverShowStateChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[nbPopover]',
                exportAs: 'nbPopover',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbDynamicOverlayHandler }]; }, { context: [{
            type: Input,
            args: ['nbPopoverContext']
        }], position: [{
            type: Input,
            args: ['nbPopoverPlacement']
        }], trigger: [{
            type: Input,
            args: ['nbPopoverTrigger']
        }], offset: [{
            type: Input,
            args: ['nbPopoverOffset']
        }], nbPopoverShowStateChange: [{
            type: Output
        }], adjustment: [{
            type: Input,
            args: ['nbPopoverAdjustment']
        }], popoverClass: [{
            type: Input,
            args: ['nbPopoverClass']
        }], content: [{
            type: Input,
            args: ['nbPopover']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbPopoverModule {
}
NbPopoverModule.ɵfac = function NbPopoverModule_Factory(t) { return new (t || NbPopoverModule)(); };
NbPopoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbPopoverModule });
NbPopoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbOverlayModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbPopoverModule, { declarations: [NbPopoverDirective, NbPopoverComponent], imports: [NbOverlayModule], exports: [NbPopoverDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPopoverModule, [{
        type: NgModule,
        args: [{
                imports: [NbOverlayModule],
                declarations: [NbPopoverDirective, NbPopoverComponent],
                exports: [NbPopoverDirective],
                entryComponents: [NbPopoverComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Context menu component used as content within NbContextMenuDirective.
 *
 * @styles
 *
 * context-menu-background-color:
 * context-menu-border-color:
 * context-menu-border-style:
 * context-menu-border-width:
 * context-menu-border-radius:
 * context-menu-text-align:
 * context-menu-min-width:
 * context-menu-max-width:
 * context-menu-shadow:
 * */
class NbContextMenuComponent extends NbPositionedContainerComponent {
    constructor() {
        super(...arguments);
        this.items = [];
        this.context = { items: [] };
    }
    /**
     * The method is empty since we don't need to do anything additionally
     * render is handled by change detection
     */
    renderContent() { }
}
NbContextMenuComponent.ɵfac = function NbContextMenuComponent_Factory(t) { return ɵNbContextMenuComponent_BaseFactory(t || NbContextMenuComponent); };
NbContextMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbContextMenuComponent, selectors: [["nb-context-menu"]], inputs: { items: "items", context: "context", tag: "tag" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 2, consts: [[1, "context-menu", 3, "items", "tag"]], template: function NbContextMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "nb-menu", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("items", ctx.context.items)("tag", ctx.context.tag);
    } }, directives: [NbMenuComponent], encapsulation: 2 });
NbContextMenuComponent.propDecorators = {
    items: [{ type: Input }],
    tag: [{ type: Input }],
    context: [{ type: Input }]
};
const ɵNbContextMenuComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbContextMenuComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbContextMenuComponent, [{
        type: Component,
        args: [{
                selector: 'nb-context-menu',
                template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `
            }]
    }], null, { items: [{
            type: Input
        }], context: [{
            type: Input
        }], tag: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Full featured context menu directive.
 *
 * @stacked-example(Showcase, context-menu/context-menu-showcase.component)
 *
 * Just pass menu items array:
 *
 * ```html
 * <button [nbContextMenu]="items"></button>
 * ...
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * ### Installation
 *
 * Import `NbContextMenuModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbContextMenuModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * Also make sure `NbMenuModule` is imported to your `app.module`.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * If you want to handle context menu clicks you have to pass `nbContextMenuTag`
 * param and register to events using NbMenuService.
 * `NbContextMenu` renders plain `NbMenu` inside, so
 * you have to work with it just like with `NbMenu` component:
 *
 * @stacked-example(Menu item click, context-menu/context-menu-click.component)
 *
 * Context menu has different placements, such as: top, bottom, left and right
 * which can be used as following:
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuPlacement="right"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 *
 * By default context menu will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the context menu.
 * If you wanna disable this behaviour just set it falsy value.
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuAdjustment="counterclockwise"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * Context menu has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, context-menu/context-menu-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, context-menu/context-menu-noop.component)
 *
 * @stacked-example(Manual Control, context-menu/context-menu-right-click.component)
 * */
class NbContextMenuDirective {
    constructor(hostRef, menuService, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.menuService = menuService;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.contextMenuHost = true;
        this._position = NbPosition.BOTTOM;
        /**
         * Container position will be changes automatically based on this strategy if container can't fit view port.
         * Set this property to any falsy value if you want to disable automatically adjustment.
         * Available values: clockwise, counterclockwise.
         * */
        this.adjustment = NbAdjustment.CLOCKWISE;
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.CLICK;
        this._contextMenuClass = '';
        this.overlayConfig = { panelClass: this.contextMenuClass };
        this.overlayContext = { items: this.items, tag: this.tag, position: this.position };
        this.destroy$ = new Subject();
        this._items = [];
    }
    /**
     * Position will be calculated relatively host element based on the position.
     * Can be top, right, bottom and left.
     * */
    get position() {
        return this._position;
    }
    set position(value) {
        if (value !== this.position) {
            this._position = value;
            this.updateOverlayContext();
        }
    }
    /**
     * Set NbMenu tag, which helps identify menu when working with NbMenuService.
     * */
    get tag() {
        return this._tag;
    }
    set tag(value) {
        if (value !== this.tag) {
            this._tag = value;
            this.updateOverlayContext();
        }
    }
    /**
     * Basic menu items, will be passed to the internal NbMenuComponent.
     * */
    get items() {
        return this._items;
    }
    set items(items) {
        this.validateItems(items);
        this._items = items;
        this.updateOverlayContext();
    }
    ;
    get contextMenuClass() {
        return this._contextMenuClass;
    }
    set contextMenuClass(value) {
        if (value !== this.contextMenuClass) {
            this._contextMenuClass = value;
            this.overlayConfig = { panelClass: this.contextMenuClass };
        }
    }
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(NbContextMenuComponent);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.subscribeOnItemClick();
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .adjustment(this.adjustment)
            .context(this.overlayContext)
            .overlayConfig(this.overlayConfig);
    }
    /*
     * NbMenuComponent will crash if don't pass menu items to it.
     * So, we just validating them and throw custom obvious error.
     * */
    validateItems(items) {
        if (!items || !items.length) {
            throw Error(`List of menu items expected, but given: ${items}`);
        }
    }
    subscribeOnItemClick() {
        this.menuService.onItemClick()
            .pipe(filter(({ tag }) => tag === this.tag), takeUntil(this.destroy$))
            .subscribe(() => this.hide());
    }
    updateOverlayContext() {
        this.overlayContext = { items: this.items, position: this.position, tag: this.tag };
    }
}
NbContextMenuDirective.ɵfac = function NbContextMenuDirective_Factory(t) { return new (t || NbContextMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbMenuService), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbContextMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbContextMenuDirective, selectors: [["", "nbContextMenu", ""]], hostVars: 2, hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("context-menu-host", ctx.contextMenuHost);
    } }, inputs: { adjustment: ["nbContextMenuAdjustment", "adjustment"], trigger: ["nbContextMenuTrigger", "trigger"], position: ["nbContextMenuPlacement", "position"], tag: ["nbContextMenuTag", "tag"], items: ["nbContextMenu", "items"], contextMenuClass: ["nbContextMenuClass", "contextMenuClass"] }, features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature] });
NbContextMenuDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbMenuService },
    { type: NbDynamicOverlayHandler }
];
NbContextMenuDirective.propDecorators = {
    contextMenuHost: [{ type: HostBinding, args: ['class.context-menu-host',] }],
    position: [{ type: Input, args: ['nbContextMenuPlacement',] }],
    adjustment: [{ type: Input, args: ['nbContextMenuAdjustment',] }],
    tag: [{ type: Input, args: ['nbContextMenuTag',] }],
    items: [{ type: Input, args: ['nbContextMenu',] }],
    trigger: [{ type: Input, args: ['nbContextMenuTrigger',] }],
    contextMenuClass: [{ type: Input, args: ['nbContextMenuClass',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbContextMenuDirective, [{
        type: Directive,
        args: [{
                selector: '[nbContextMenu]',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbMenuService }, { type: NbDynamicOverlayHandler }]; }, { contextMenuHost: [{
            type: HostBinding,
            args: ['class.context-menu-host']
        }], adjustment: [{
            type: Input,
            args: ['nbContextMenuAdjustment']
        }], trigger: [{
            type: Input,
            args: ['nbContextMenuTrigger']
        }], position: [{
            type: Input,
            args: ['nbContextMenuPlacement']
        }], tag: [{
            type: Input,
            args: ['nbContextMenuTag']
        }], items: [{
            type: Input,
            args: ['nbContextMenu']
        }], contextMenuClass: [{
            type: Input,
            args: ['nbContextMenuClass']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbContextMenuModule {
}
NbContextMenuModule.ɵfac = function NbContextMenuModule_Factory(t) { return new (t || NbContextMenuModule)(); };
NbContextMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbContextMenuModule });
NbContextMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NbOverlayModule, NbMenuModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbContextMenuModule, { declarations: function () { return [NbContextMenuDirective, NbContextMenuComponent]; }, imports: function () { return [CommonModule, NbOverlayModule, NbMenuModule]; }, exports: function () { return [NbContextMenuDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbContextMenuModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbOverlayModule, NbMenuModule],
                exports: [NbContextMenuDirective],
                declarations: [NbContextMenuDirective, NbContextMenuComponent],
                entryComponents: [NbContextMenuComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Progress Bar is a component for indicating progress.
 *
 * Simple usage:
 *
 * ```html
 * <nb-progress-bar [value]="50"></nb-progress-bar>
 * ```
 * ### Installation
 *
 * Import `NbProgressBarModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbProgressBarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Progress bar accepts property `value` in range 0-100
 * @stacked-example(Progress bar, progress-bar/progress-bar-showcase.component)
 *
 * Progress bar background could be configured by providing a `status` property:
 * @stacked-example(Progress bar status, progress-bar/progress-bar-status.component)
 *
 * Progress bar size (height and font-size) could be configured by providing a `size` property:
 * @stacked-example(Progress bar size, progress-bar/progress-bar-size.component)
 *
 * `displayValue` property shows current value inside progress bar. It's also possible to add custom text inside:
 * @stacked-example(Progress bar value, progress-bar/progress-bar-value.component)
 *
 * Progress bar supports `width` and `background-color` transition:
 * @stacked-example(Progress bar interactive, progress-bar/progress-bar-interactive.component)
 *
 * @styles
 *
 * progress-bar-animation-duration:
 * progress-bar-border-radius:
 * progress-bar-text-font-family:
 * progress-bar-tiny-height:
 * progress-bar-tiny-text-font-size:
 * progress-bar-tiny-text-font-weight:
 * progress-bar-tiny-text-line-height:
 * progress-bar-small-height:
 * progress-bar-small-text-font-size:
 * progress-bar-small-text-font-weight:
 * progress-bar-small-text-line-height:
 * progress-bar-medium-height:
 * progress-bar-medium-text-font-size:
 * progress-bar-medium-text-font-weight:
 * progress-bar-medium-text-line-height:
 * progress-bar-large-height:
 * progress-bar-large-text-font-size:
 * progress-bar-large-text-font-weight:
 * progress-bar-large-text-line-height:
 * progress-bar-giant-height:
 * progress-bar-giant-text-font-size:
 * progress-bar-giant-text-font-weight:
 * progress-bar-giant-text-line-height:
 * progress-bar-basic-background-color:
 * progress-bar-basic-filled-background-color:
 * progress-bar-basic-text-color:
 * progress-bar-primary-background-color:
 * progress-bar-primary-filled-background-color:
 * progress-bar-primary-text-color:
 * progress-bar-success-background-color:
 * progress-bar-success-filled-background-color:
 * progress-bar-success-text-color:
 * progress-bar-info-background-color:
 * progress-bar-info-filled-background-color:
 * progress-bar-info-text-color:
 * progress-bar-warning-background-color:
 * progress-bar-warning-filled-background-color:
 * progress-bar-warning-text-color:
 * progress-bar-danger-background-color:
 * progress-bar-danger-filled-background-color:
 * progress-bar-danger-text-color:
 * progress-bar-control-background-color:
 * progress-bar-control-filled-background-color:
 * progress-bar-control-text-color:
 */
class NbProgressBarComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Progress bar value in percent (0 - 100)
         */
        this.value = 0;
        /**
         * Progress bar background (`basic` (default), `primary`, `info`, `success`, `warning`, `danger`, `control`)
         */
        this.status = 'basic';
        /**
         * Progress bar size (`tiny`, `small`, `medium` (default), `large`, `giant`)
         */
        this.size = 'medium';
        /**
         * Displays value inside progress bar
         */
        this.displayValue = false;
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
}
NbProgressBarComponent.ɵfac = function NbProgressBarComponent_Factory(t) { return new (t || NbProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbProgressBarComponent, selectors: [["nb-progress-bar"]], hostVars: 26, hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { value: "value", status: "status", size: "size", displayValue: "displayValue" }, ngContentSelectors: _c0, decls: 4, vars: 3, consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]], template: function NbProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.value, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.displayValue);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}"] });
NbProgressBarComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbProgressBarComponent.propDecorators = {
    value: [{ type: Input }],
    status: [{ type: Input }],
    size: [{ type: Input }],
    displayValue: [{ type: Input }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-progress-bar',
                template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
                styles: [":host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { value: [{
            type: Input
        }], status: [{
            type: Input
        }], size: [{
            type: Input
        }], displayValue: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbProgressBarModule {
}
NbProgressBarModule.ɵfac = function NbProgressBarModule_Factory(t) { return new (t || NbProgressBarModule)(); };
NbProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbProgressBarModule });
NbProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbProgressBarModule, { declarations: [NbProgressBarComponent], imports: [NbSharedModule], exports: [NbProgressBarComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbProgressBarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [NbProgressBarComponent],
                exports: [NbProgressBarComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Alert component.
 *
 * Basic alert example:
 * @stacked-example(Showcase, alert/alert-showcase.component)
 *
 * Alert configuration:
 *
 * ```html
 * <nb-alert status="success">
 *   You have been successfully authenticated!
 * </nb-alert>
 * ```
 * ### Installation
 *
 * Import `NbAlertModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbAlertModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Alert could additionally have a `close` button when `closable` property is set:
 * ```html
 * <nb-alert status="success" closable (close)="onClose()">
 *   You have been successfully authenticated!
 * </nb-alert>
 * ```
 *
 * Colored alerts could be simply configured by providing a `status` property:
 * @stacked-example(Alert status, alert/alert-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight alert highlight
 * as well as combine it with `status`:
 * @stacked-example(Alert accent, alert/alert-accents.component)
 *
 * And `outline` property:
 * @stacked-example(Outline Alert, alert/alert-outline.component)
 *
 * @additional-example(Multiple Sizes, alert/alert-sizes.component)
 *
 * @styles
 *
 * alert-border-radius:
 * alert-bottom-margin:
 * alert-padding:
 * alert-scrollbar-color:
 * alert-scrollbar-background-color:
 * alert-scrollbar-width:
 * alert-shadow:
 * alert-text-font-family:
 * alert-text-font-size:
 * alert-text-font-weight:
 * alert-text-line-height:
 * alert-closable-start-padding:
 * alert-tiny-height:
 * alert-small-height:
 * alert-medium-height:
 * alert-medium-padding:
 * alert-large-height:
 * alert-giant-height:
 * alert-basic-background-color:
 * alert-basic-text-color:
 * alert-primary-background-color:
 * alert-primary-text-color:
 * alert-success-background-color:
 * alert-success-text-color:
 * alert-info-background-color:
 * alert-info-text-color:
 * alert-warning-background-color:
 * alert-warning-text-color:
 * alert-danger-background-color:
 * alert-danger-text-color:
 * alert-control-background-color:
 * alert-control-text-color:
 * alert-accent-basic-color:
 * alert-accent-primary-color:
 * alert-accent-info-color:
 * alert-accent-success-color:
 * alert-accent-warning-color:
 * alert-accent-danger-color:
 * alert-accent-control-color:
 * alert-outline-width:
 * alert-outline-basic-color:
 * alert-outline-primary-color:
 * alert-outline-info-color:
 * alert-outline-success-color:
 * alert-outline-warning-color:
 * alert-outline-danger-color:
 * alert-outline-control-color:
 */
class NbAlertComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Alert size, available sizes:
         * `tiny`, `small`, `medium`, `large`, `giant`
         * Unset by default.
         */
        this.size = '';
        /**
         * Alert status (adds specific styles):
         * `basic` (default), `primary`, `success`, `info`, `warning`, `danger`, `control`.
         */
        this.status = 'basic';
        /**
         * Alert accent (color of the top border):
         * `basic`, `primary`, `success`, `info`, `warning`, `danger`, `control`.
         * Unset by default.
         */
        this.accent = '';
        /**
         * Alert outline (color of the border):
         * `basic`, `primary`, `success`, `info`, `warning`, `danger`, `control`.
         * Unset by default.
         */
        this.outline = '';
        this._closable = false;
        /**
         * Emits when chip is removed
         * @type EventEmitter<any>
         */
        this.close = new EventEmitter();
    }
    /**
     * Shows `close` icon
     */
    get closable() {
        return this._closable;
    }
    set closable(value) {
        this._closable = convertToBoolProperty(value);
    }
    /**
     * Emits the removed chip event
     */
    onClose() {
        this.close.emit();
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get primaryAccent() {
        return this.accent === 'primary';
    }
    get successAccent() {
        return this.accent === 'success';
    }
    get infoAccent() {
        return this.accent === 'info';
    }
    get warningAccent() {
        return this.accent === 'warning';
    }
    get dangerAccent() {
        return this.accent === 'danger';
    }
    get basicAccent() {
        return this.accent === 'basic';
    }
    get controlAccent() {
        return this.accent === 'control';
    }
    get primaryOutline() {
        return this.outline === 'primary';
    }
    get successOutline() {
        return this.outline === 'success';
    }
    get infoOutline() {
        return this.outline === 'info';
    }
    get warningOutline() {
        return this.outline === 'warning';
    }
    get dangerOutline() {
        return this.outline === 'danger';
    }
    get basicOutline() {
        return this.outline === 'basic';
    }
    get controlOutline() {
        return this.outline === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
}
NbAlertComponent.ɵfac = function NbAlertComponent_Factory(t) { return new (t || NbAlertComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbAlertComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAlertComponent, selectors: [["nb-alert"]], hostVars: 56, hostBindings: function NbAlertComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
    } }, inputs: { size: "size", status: "status", accent: "accent", outline: "outline", closable: "closable" }, outputs: { close: "close" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]], template: function NbAlertComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.closable);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}"] });
NbAlertComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbAlertComponent.propDecorators = {
    size: [{ type: Input }],
    status: [{ type: Input }],
    accent: [{ type: Input }],
    outline: [{ type: Input }],
    closable: [{ type: Input }, { type: HostBinding, args: ['class.closable',] }],
    close: [{ type: Output }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    primaryAccent: [{ type: HostBinding, args: ['class.accent-primary',] }],
    successAccent: [{ type: HostBinding, args: ['class.accent-success',] }],
    infoAccent: [{ type: HostBinding, args: ['class.accent-info',] }],
    warningAccent: [{ type: HostBinding, args: ['class.accent-warning',] }],
    dangerAccent: [{ type: HostBinding, args: ['class.accent-danger',] }],
    basicAccent: [{ type: HostBinding, args: ['class.accent-basic',] }],
    controlAccent: [{ type: HostBinding, args: ['class.accent-control',] }],
    primaryOutline: [{ type: HostBinding, args: ['class.outline-primary',] }],
    successOutline: [{ type: HostBinding, args: ['class.outline-success',] }],
    infoOutline: [{ type: HostBinding, args: ['class.outline-info',] }],
    warningOutline: [{ type: HostBinding, args: ['class.outline-warning',] }],
    dangerOutline: [{ type: HostBinding, args: ['class.outline-danger',] }],
    basicOutline: [{ type: HostBinding, args: ['class.outline-basic',] }],
    controlOutline: [{ type: HostBinding, args: ['class.outline-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAlertComponent, [{
        type: Component,
        args: [{
                selector: 'nb-alert',
                template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
                styles: [":host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], accent: [{
            type: Input
        }], outline: [{
            type: Input
        }], close: [{
            type: Output
        }], closable: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.closable']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], primaryAccent: [{
            type: HostBinding,
            args: ['class.accent-primary']
        }], successAccent: [{
            type: HostBinding,
            args: ['class.accent-success']
        }], infoAccent: [{
            type: HostBinding,
            args: ['class.accent-info']
        }], warningAccent: [{
            type: HostBinding,
            args: ['class.accent-warning']
        }], dangerAccent: [{
            type: HostBinding,
            args: ['class.accent-danger']
        }], basicAccent: [{
            type: HostBinding,
            args: ['class.accent-basic']
        }], controlAccent: [{
            type: HostBinding,
            args: ['class.accent-control']
        }], primaryOutline: [{
            type: HostBinding,
            args: ['class.outline-primary']
        }], successOutline: [{
            type: HostBinding,
            args: ['class.outline-success']
        }], infoOutline: [{
            type: HostBinding,
            args: ['class.outline-info']
        }], warningOutline: [{
            type: HostBinding,
            args: ['class.outline-warning']
        }], dangerOutline: [{
            type: HostBinding,
            args: ['class.outline-danger']
        }], basicOutline: [{
            type: HostBinding,
            args: ['class.outline-basic']
        }], controlOutline: [{
            type: HostBinding,
            args: ['class.outline-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbAlertModule {
}
NbAlertModule.ɵfac = function NbAlertModule_Factory(t) { return new (t || NbAlertModule)(); };
NbAlertModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbAlertModule });
NbAlertModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbAlertModule, { declarations: [NbAlertComponent], imports: [NbSharedModule], exports: [NbAlertComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAlertModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    NbAlertComponent,
                ],
                exports: [
                    NbAlertComponent,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat form component.
 *
 * Show a message form with a send message button.
 *
 * ```ts
 * <nb-chat-form showButton="true" buttonIcon="nb-send">
 * </nb-chat-form>
 * ```
 *
 * When `[dropFiles]="true"` handles files drag&drop with a file preview.
 *
 * Drag & drop available for files and images:
 * @stacked-example(Drag & Drop Chat, chat/chat-drop.component)
 *
 * New message could be tracked outside by using `(send)` output.
 *
 * ```ts
 * <nb-chat-form (send)="onNewMessage($event)">
 * </nb-chat-form>
 *
 * // ...
 *
 * onNewMessage({ message: string, files: any[] }) {
 *   this.service.sendToServer(message, files);
 * }
 * ```
 */
class NbChatFormComponent {
    constructor(cd, domSanitizer) {
        this.cd = cd;
        this.domSanitizer = domSanitizer;
        this.status = 'basic';
        this.inputFocus = false;
        this.inputHover = false;
        this.droppedFiles = [];
        this.imgDropTypes = ['image/png', 'image/jpeg', 'image/gif'];
        /**
         * Predefined message text
         * @type {string}
         */
        this.message = '';
        /**
         * Message placeholder text
         * @type {string}
         */
        this.messagePlaceholder = 'Type a message';
        /**
         * Send button title
         * @type {string}
         */
        this.buttonTitle = '';
        /**
         * Send button icon, shown if `buttonTitle` is empty
         * @type {string}
         */
        this.buttonIcon = 'paper-plane-outline';
        /**
         * Show send button
         * @type {boolean}
         */
        this.showButton = true;
        /**
         * Show send button
         * @type {boolean}
         */
        this.dropFiles = false;
        /**
         * File drop placeholder text
         * @type {string}
         */
        this.dropFilePlaceholder = 'Drop file to send';
        /**
         *
         * @type {EventEmitter<{ message: string, files: File[] }>}
         */
        this.send = new EventEmitter();
        this.fileOver = false;
    }
    onDrop(event) {
        if (this.dropFiles) {
            event.preventDefault();
            event.stopPropagation();
            this.fileOver = false;
            if (event.dataTransfer && event.dataTransfer.files) {
                for (const file of event.dataTransfer.files) {
                    const res = file;
                    if (this.imgDropTypes.includes(file.type)) {
                        const fr = new FileReader();
                        fr.onload = (e) => {
                            res.src = e.target.result;
                            res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
                            this.cd.detectChanges();
                        };
                        fr.readAsDataURL(file);
                    }
                    this.droppedFiles.push(res);
                }
            }
        }
    }
    removeFile(file) {
        const index = this.droppedFiles.indexOf(file);
        if (index >= 0) {
            this.droppedFiles.splice(index, 1);
        }
    }
    onDragOver() {
        if (this.dropFiles) {
            this.fileOver = true;
        }
    }
    onDragLeave() {
        if (this.dropFiles) {
            this.fileOver = false;
        }
    }
    sendMessage() {
        if (this.droppedFiles.length || String(this.message).trim().length) {
            this.send.emit({ message: this.message, files: this.droppedFiles });
            this.message = '';
            this.droppedFiles = [];
        }
    }
    setStatus(status) {
        if (this.status !== status) {
            this.status = status;
            this.cd.detectChanges();
        }
    }
    getInputStatus() {
        if (this.fileOver) {
            return this.getHighlightStatus();
        }
        if (this.inputFocus || this.inputHover) {
            return this.status;
        }
        return 'basic';
    }
    getButtonStatus() {
        return this.getHighlightStatus();
    }
    getHighlightStatus() {
        if (this.status === 'basic' || this.status === 'control') {
            return 'primary';
        }
        return this.status;
    }
}
NbChatFormComponent.ɵfac = function NbChatFormComponent_Factory(t) { return new (t || NbChatFormComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatFormComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatFormComponent, selectors: [["nb-chat-form"]], hostVars: 2, hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) { return ctx.onDrop($event); })("dragover", function NbChatFormComponent_dragover_HostBindingHandler() { return ctx.onDragOver(); })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler() { return ctx.onDragLeave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("file-over", ctx.fileOver);
    } }, inputs: { message: "message", messagePlaceholder: "messagePlaceholder", buttonTitle: "buttonTitle", buttonIcon: "buttonIcon", showButton: "showButton", dropFiles: "dropFiles", dropFilePlaceholder: "dropFilePlaceholder" }, outputs: { send: "send" }, decls: 4, vars: 7, consts: [["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "status", "ngModel", "placeholder", "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], ["icon", "file-text-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "status", "click"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["title", ""], ["pack", "nebular-essentials", 3, "icon"]], template: function NbChatFormComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "input", 2);
        ɵngcc0.ɵɵlistener("focus", function NbChatFormComponent_Template_input_focus_2_listener() { return ctx.inputFocus = true; })("blur", function NbChatFormComponent_Template_input_blur_2_listener() { return ctx.inputFocus = false; })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() { return ctx.inputHover = true; })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() { return ctx.inputHover = false; })("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) { return ctx.message = $event; })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() { return ctx.sendMessage(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("with-button", ctx.showButton);
        ɵngcc0.ɵɵpropertyInterpolate("placeholder", ctx.fileOver ? ctx.dropFilePlaceholder : ctx.messagePlaceholder);
        ɵngcc0.ɵɵproperty("status", ctx.getInputStatus())("ngModel", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButton);
    } }, directives: function () { return [ɵngcc2.NgIf, NbInputDirective, ɵngcc6.DefaultValueAccessor, ɵngcc6.NgControlStatus, ɵngcc6.NgModel, ɵngcc2.NgForOf, NbIconComponent, NbButtonComponent]; }, encapsulation: 2, changeDetection: 0 });
NbChatFormComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DomSanitizer }
];
NbChatFormComponent.propDecorators = {
    message: [{ type: Input }],
    messagePlaceholder: [{ type: Input }],
    buttonTitle: [{ type: Input }],
    buttonIcon: [{ type: Input }],
    showButton: [{ type: Input }],
    dropFiles: [{ type: Input }],
    dropFilePlaceholder: [{ type: Input }],
    send: [{ type: Output }],
    fileOver: [{ type: HostBinding, args: ['class.file-over',] }],
    onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }],
    onDragOver: [{ type: HostListener, args: ['dragover',] }],
    onDragLeave: [{ type: HostListener, args: ['dragleave',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatFormComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-form',
                template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div>
          <nb-icon *ngIf="!file.urlStyle" icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input nbInput
             fullWidth
             [status]="getInputStatus()"
             (focus)="inputFocus = true"
             (blur)="inputFocus = false"
             (mouseenter)="inputHover = true"
             (mouseleave)="inputHover = false"
             [(ngModel)]="message"
             [class.with-button]="showButton"
             type="text"
             placeholder="{{ fileOver ? dropFilePlaceholder : messagePlaceholder }}"
             (keyup.enter)="sendMessage()">
      <button nbButton
              [status]="getButtonStatus()"
              *ngIf="showButton"
              [class.with-icon]="!buttonTitle"
              (click)="sendMessage()"
              class="send-button">
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.DomSanitizer }]; }, { message: [{
            type: Input
        }], messagePlaceholder: [{
            type: Input
        }], buttonTitle: [{
            type: Input
        }], buttonIcon: [{
            type: Input
        }], showButton: [{
            type: Input
        }], dropFiles: [{
            type: Input
        }], dropFilePlaceholder: [{
            type: Input
        }], send: [{
            type: Output
        }], fileOver: [{
            type: HostBinding,
            args: ['class.file-over']
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], onDragOver: [{
            type: HostListener,
            args: ['dragover']
        }], onDragLeave: [{
            type: HostListener,
            args: ['dragleave']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat message component.
 *
 * Multiple message types are available through a `type` property, such as
 * - text - simple text message
 * - file - could be a file preview or a file icon
 * if multiple files are provided grouped files are shown
 * - quote - quotes a message with specific quote styles
 * - map - shows a google map picture by provided [latitude] and [longitude] properties
 *
 * @stacked-example(Available Types, chat/chat-message-types-showcase.component)
 *
 * Message with attached files:
 * ```html
 * <nb-chat-message
 *   type="file"
 *   [files]="[ { url: '...' } ]"
 *   message="Hello world!">
 * </nb-chat-message>
 * ```
 *
 * Map message:
 * ```html
 * <nb-chat-message
 *   type="map"
 *   [latitude]="53.914"
 *   [longitude]="27.59"
 *   message="Here I am">
 * </nb-chat-message>
 * ```
 *
 * @styles
 *
 * chat-message-background:
 * chat-message-text-color:
 * chat-message-reply-background-color:
 * chat-message-reply-text-color:
 * chat-message-avatar-background-color:
 * chat-message-sender-text-color:
 * chat-message-quote-background-color:
 * chat-message-quote-text-color:
 * chat-message-file-text-color:
 * chat-message-file-background-color:
 */
class NbChatMessageComponent {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
        this._reply = false;
    }
    get flyInOut() {
        return true;
    }
    get notReply() {
        return !this.reply;
    }
    /**
     * Determines if a message is a reply
     */
    get reply() {
        return this._reply;
    }
    set reply(value) {
        this._reply = convertToBoolProperty(value);
    }
    /**
     * Message send avatar
     * @type {string}
     */
    set avatar(value) {
        this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
    }
    getInitials() {
        if (this.sender) {
            const names = this.sender.split(' ');
            return names.map(n => n.charAt(0)).splice(0, 2).join('').toUpperCase();
        }
        return '';
    }
}
NbChatMessageComponent.ɵfac = function NbChatMessageComponent_Factory(t) { return new (t || NbChatMessageComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatMessageComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageComponent, selectors: [["nb-chat-message"]], hostVars: 5, hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@flyInOut", ctx.flyInOut);
        ɵngcc0.ɵɵclassProp("not-reply", ctx.notReply)("reply", ctx.reply);
    } }, inputs: { reply: "reply", avatar: "avatar", message: "message", sender: "sender", date: "date", dateFormat: "dateFormat", files: "files", quote: "quote", latitude: "latitude", longitude: "longitude", type: "type" }, decls: 7, vars: 5, consts: [["class", "avatar", 3, "background-image", 4, "ngIf"], [1, "message"], [3, "ngSwitch"], [3, "sender", "date", "dateFormat", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", 4, "ngSwitchDefault"], [1, "avatar"], [4, "ngIf"], [3, "sender", "date", "dateFormat", "message", "files"], [3, "sender", "date", "dateFormat", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "dateFormat", "message"]], template: function NbChatMessageComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageComponent_div_0_Template, 2, 3, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵtemplate(3, NbChatMessageComponent_nb_chat_message_file_3_Template, 1, 5, "nb-chat-message-file", 3);
        ɵngcc0.ɵɵtemplate(4, NbChatMessageComponent_nb_chat_message_quote_4_Template, 1, 5, "nb-chat-message-quote", 4);
        ɵngcc0.ɵɵtemplate(5, NbChatMessageComponent_nb_chat_message_map_5_Template, 1, 5, "nb-chat-message-map", 5);
        ɵngcc0.ɵɵtemplate(6, NbChatMessageComponent_nb_chat_message_text_6_Template, 1, 4, "nb-chat-message-text", 6);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.reply);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.type);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "file");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "quote");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "map");
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatMessageTextComponent]; }, encapsulation: 2, data: { animation: [
            trigger('flyInOut', [
                state('in', style({ transform: 'translateX(0)' })),
                transition('void => *', [
                    style({ transform: 'translateX(-100%)' }),
                    animate(80),
                ]),
                transition('* => void', [
                    animate(80, style({ transform: 'translateX(100%)' })),
                ]),
            ]),
        ] }, changeDetection: 0 });
NbChatMessageComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
NbChatMessageComponent.propDecorators = {
    flyInOut: [{ type: HostBinding, args: ['@flyInOut',] }],
    notReply: [{ type: HostBinding, args: ['class.not-reply',] }],
    reply: [{ type: Input }, { type: HostBinding, args: ['class.reply',] }],
    message: [{ type: Input }],
    sender: [{ type: Input }],
    date: [{ type: Input }],
    dateFormat: [{ type: Input }],
    files: [{ type: Input }],
    quote: [{ type: Input }],
    latitude: [{ type: Input }],
    longitude: [{ type: Input }],
    avatar: [{ type: Input }],
    type: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatMessageComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message',
                template: `
    <div class="avatar" [style.background-image]="avatarStyle" *ngIf="!reply">
      <ng-container *ngIf="!avatarStyle">
        {{ getInitials() }}
      </ng-container>
    </div>
    <div class="message">
      <ng-container [ngSwitch]="type">

        <nb-chat-message-file *ngSwitchCase="'file'"
                              [sender]="sender" [date]="date" [dateFormat]="dateFormat"
                              [message]="message" [files]="files">
        </nb-chat-message-file>

        <nb-chat-message-quote *ngSwitchCase="'quote'"
                              [sender]="sender" [date]="date" [dateFormat]="dateFormat"
                              [message]="message" [quote]="quote">
        </nb-chat-message-quote>

        <nb-chat-message-map *ngSwitchCase="'map'"
                              [sender]="sender" [date]="date"
                              [message]="message" [latitude]="latitude" [longitude]="longitude">
        </nb-chat-message-map>

        <nb-chat-message-text *ngSwitchDefault
                              [sender]="sender" [date]="date" [dateFormat]="dateFormat"
                              [message]="message">
        </nb-chat-message-text>
      </ng-container>
    </div>
  `,
                animations: [
                    trigger('flyInOut', [
                        state('in', style({ transform: 'translateX(0)' })),
                        transition('void => *', [
                            style({ transform: 'translateX(-100%)' }),
                            animate(80),
                        ]),
                        transition('* => void', [
                            animate(80, style({ transform: 'translateX(100%)' })),
                        ]),
                    ]),
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }]; }, { flyInOut: [{
            type: HostBinding,
            args: ['@flyInOut']
        }], notReply: [{
            type: HostBinding,
            args: ['class.not-reply']
        }], reply: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.reply']
        }], avatar: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], dateFormat: [{
            type: Input
        }], files: [{
            type: Input
        }], quote: [{
            type: Input
        }], latitude: [{
            type: Input
        }], longitude: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Conversational UI collection - a set of components for chat-like UI construction.
 *
 * Main features:
 * - different message types support (text, image, file, file group, map, etc)
 * - drag & drop for images and files with preview
 * - different UI styles
 * - custom action buttons (coming soon)
 *
 * Here's a complete example build in a bot-like app. Type `help` to be able to receive different message types.
 * Enjoy the conversation and the beautiful UI.
 * @stacked-example(Showcase, chat/chat-showcase.component)
 *
 * Basic chat configuration and usage:
 * ```ts
 * <nb-chat title="Nebular Conversational UI">
 *       <nb-chat-message *ngFor="let msg of messages"
 *                        [type]="msg.type"
 *                        [message]="msg.text"
 *                        [reply]="msg.reply"
 *                        [sender]="msg.user.name"
 *                        [date]="msg.date"
 *                        [files]="msg.files"
 *                        [quote]="msg.quote"
 *                        [latitude]="msg.latitude"
 *                        [longitude]="msg.longitude"
 *                        [avatar]="msg.user.avatar">
 *   </nb-chat-message>
 *
 *   <nb-chat-form (send)="sendMessage($event)" [dropFiles]="true">
 *   </nb-chat-form>
 * </nb-chat>
 * ```
 * ### Installation
 *
 * Import `NbChatModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbChatModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * If you need to provide an API key for a `map` message type (which is required by Google Maps)
 * you may use `NbChatModule.forRoot({ ... })` call if this is a global app configuration
 * or `NbChatModule.forChild({ ... })` for a feature module configuration:
 *
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbChatModule.forRoot({ messageGoogleMapKey: 'MAP_KEY' }),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * There are three main components:
 * ```ts
 * <nb-chat>
 * </nb-chat> // chat container
 *
 * <nb-chat-form>
 * </nb-chat-form> // chat form with drag&drop files feature
 *
 * <nb-chat-message>
 * </nb-chat-message> // chat message, available multiple types
 * ```
 *
 * Two users conversation showcase:
 * @stacked-example(Conversation, chat/chat-conversation-showcase.component)
 *
 * Chat UI is also available in different colors by specifying a `[status]` input:
 *
 * @stacked-example(Colored Chat, chat/chat-colors.component)
 *
 * Also it is possible to configure sizes through `[size]` input:
 *
 * @stacked-example(Chat Sizes, chat/chat-sizes.component)
 *
 * @styles
 *
 * chat-background-color:
 * chat-border:
 * chat-border-radius:
 * chat-shadow:
 * chat-padding:
 * chat-scrollbar-color:
 * chat-scrollbar-background-color:
 * chat-scrollbar-width:
 * chat-text-color:
 * chat-text-font-family:
 * chat-text-font-size:
 * chat-text-font-weight:
 * chat-text-line-height:
 * chat-header-text-font-family:
 * chat-header-text-font-size:
 * chat-header-text-font-weight:
 * chat-header-text-line-height:
 * chat-tiny-height:
 * chat-small-height:
 * chat-medium-height:
 * chat-large-height:
 * chat-giant-height:
 * chat-basic-background-color:
 * chat-basic-text-color:
 * chat-primary-background-color:
 * chat-primary-text-color:
 * chat-success-background-color:
 * chat-success-text-color:
 * chat-info-background-color:
 * chat-info-text-color:
 * chat-warning-background-color:
 * chat-warning-text-color:
 * chat-danger-background-color:
 * chat-danger-text-color:
 * chat-control-background-color:
 * chat-control-text-color:
 * chat-divider-color:
 * chat-divider-style:
 * chat-divider-width:
 * chat-message-background:
 * chat-message-text-color:
 * chat-message-reply-background-color:
 * chat-message-reply-text-color:
 * chat-message-avatar-background-color:
 * chat-message-sender-text-color:
 * chat-message-quote-background-color:
 * chat-message-quote-text-color:
 * chat-message-file-text-color:
 * chat-message-file-background-color:
 */
class NbChatComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Chat status color (adds specific styles):
         * `basic` (default), `primary`, `success`, `info`, `warning`, `danger`, `control`.
         */
        this.status = 'basic';
        this.noMessagesPlaceholder = 'No messages yet.';
        this._scrollBottom = true;
    }
    /**
     * Scroll chat to the bottom of the list when a new message arrives
     */
    get scrollBottom() {
        return this._scrollBottom;
    }
    set scrollBottom(value) {
        this._scrollBottom = convertToBoolProperty(value);
    }
    ngOnChanges(changes) {
        if ('status' in changes) {
            this.updateFormStatus();
        }
    }
    ngAfterContentInit() {
        this.updateFormStatus();
    }
    ngAfterViewInit() {
        this.messages.changes
            .subscribe((messages) => {
            this.messages = messages;
            this.updateView();
        });
        this.updateView();
    }
    updateView() {
        if (this.scrollBottom) {
            this.scrollListBottom();
        }
    }
    scrollListBottom() {
        this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
    }
    updateFormStatus() {
        if (this.chatForm) {
            this.chatForm.setStatus(this.status);
        }
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
}
NbChatComponent.ɵfac = function NbChatComponent_Factory(t) { return new (t || NbChatComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbChatComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatComponent, selectors: [["nb-chat"]], contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbChatFormComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbChatMessageComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chatForm = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.messages = _t);
    } }, viewQuery: function NbChatComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c23, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollable = _t.first);
    } }, hostVars: 26, hostBindings: function NbChatComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { status: "status", noMessagesPlaceholder: "noMessagesPlaceholder", scrollBottom: "scrollBottom", title: "title", size: "size" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c25, decls: 9, vars: 2, consts: [[1, "header"], [1, "scrollable"], ["scrollable", ""], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [1, "no-messages"]], template: function NbChatComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c24);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵtemplate(6, NbChatComponent_p_6_Template, 2, 1, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 5);
        ɵngcc0.ɵɵprojection(8, 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}"] });
NbChatComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbChatComponent.propDecorators = {
    title: [{ type: Input }],
    size: [{ type: Input }],
    status: [{ type: Input }],
    noMessagesPlaceholder: [{ type: Input }],
    scrollBottom: [{ type: Input }],
    scrollable: [{ type: ViewChild, args: ['scrollable',] }],
    messages: [{ type: ContentChildren, args: [NbChatMessageComponent,] }],
    chatForm: [{ type: ContentChild, args: [NbChatFormComponent,] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat',
                template: `
    <div class="header">{{ title }}</div>
    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">{{ noMessagesPlaceholder }}</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
                styles: [":host{display:flex;flex-direction:column;position:relative;height:100%}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { status: [{
            type: Input
        }], noMessagesPlaceholder: [{
            type: Input
        }], scrollBottom: [{
            type: Input
        }], messages: [{
            type: ContentChildren,
            args: [NbChatMessageComponent]
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], title: [{
            type: Input
        }], size: [{
            type: Input
        }], scrollable: [{
            type: ViewChild,
            args: ['scrollable']
        }], chatForm: [{
            type: ContentChild,
            args: [NbChatFormComponent]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbChatOptions {
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat message component.
 */
class NbChatMessageMapComponent {
    constructor(options) {
        /**
         * Message send date format, default 'shortTime'
         * @type {string}
         */
        this.dateFormat = 'shortTime';
        this.mapKey = options.messageGoogleMapKey;
    }
    get file() {
        return {
            // tslint:disable-next-line:max-line-length
            url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
            type: 'image/png',
            icon: 'location',
        };
    }
}
NbChatMessageMapComponent.ɵfac = function NbChatMessageMapComponent_Factory(t) { return new (t || NbChatMessageMapComponent)(ɵngcc0.ɵɵdirectiveInject(NbChatOptions)); };
NbChatMessageMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageMapComponent, selectors: [["nb-chat-message-map"]], inputs: { dateFormat: "dateFormat", message: "message", sender: "sender", date: "date", latitude: "latitude", longitude: "longitude" }, decls: 1, vars: 7, consts: [[3, "files", "message", "sender", "date", "dateFormat"]], template: function NbChatMessageMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "nb-chat-message-file", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("files", ɵngcc0.ɵɵpureFunction1(5, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat);
    } }, directives: function () { return [NbChatMessageFileComponent]; }, encapsulation: 2, changeDetection: 0 });
NbChatMessageMapComponent.ctorParameters = () => [
    { type: NbChatOptions }
];
NbChatMessageMapComponent.propDecorators = {
    message: [{ type: Input }],
    sender: [{ type: Input }],
    date: [{ type: Input }],
    dateFormat: [{ type: Input }],
    latitude: [{ type: Input }],
    longitude: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatMessageMapComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-map',
                template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"
     [dateFormat]="dateFormat"></nb-chat-message-file>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbChatOptions }]; }, { dateFormat: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], latitude: [{
            type: Input
        }], longitude: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat message component.
 */
class NbChatMessageFileComponent {
    constructor(cd, domSanitizer) {
        this.cd = cd;
        this.domSanitizer = domSanitizer;
        /**
         * Message send date format, default 'shortTime'
         * @type {string}
         */
        this.dateFormat = 'shortTime';
    }
    /**
     * Message file path
     * @type {Date}
     */
    set files(files) {
        this.readyFiles = (files || []).map((file) => {
            const isImage = this.isImage(file);
            return Object.assign(Object.assign({}, file), { urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`), isImage: isImage });
        });
        this.cd.detectChanges();
    }
    isImage(file) {
        const type = file.type;
        if (type) {
            return ['image/png', 'image/jpeg', 'image/gif'].includes(type);
        }
        return false;
    }
}
NbChatMessageFileComponent.ɵfac = function NbChatMessageFileComponent_Factory(t) { return new (t || NbChatMessageFileComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatMessageFileComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageFileComponent, selectors: [["nb-chat-message-file"]], inputs: { dateFormat: "dateFormat", files: "files", message: "message", sender: "sender", date: "date" }, decls: 4, vars: 7, consts: [[3, "sender", "date", "dateFormat", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]], template: function NbChatMessageFileComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-chat-message-text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat)("message", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.message, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
    } }, directives: function () { return [NbChatMessageTextComponent, ɵngcc2.NgIf, ɵngcc2.NgForOf, NbIconComponent]; }, encapsulation: 2, changeDetection: 0 });
NbChatMessageFileComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DomSanitizer }
];
NbChatMessageFileComponent.propDecorators = {
    message: [{ type: Input }],
    sender: [{ type: Input }],
    date: [{ type: Input }],
    dateFormat: [{ type: Input }],
    files: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatMessageFileComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-file',
                template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.DomSanitizer }]; }, { dateFormat: [{
            type: Input
        }], files: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat message component.
 */
class NbChatMessageQuoteComponent {
    constructor() {
        /**
          * Message send date format, default 'shortTime'
          * @type {string}
          */
        this.dateFormat = 'shortTime';
    }
}
NbChatMessageQuoteComponent.ɵfac = function NbChatMessageQuoteComponent_Factory(t) { return new (t || NbChatMessageQuoteComponent)(); };
NbChatMessageQuoteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageQuoteComponent, selectors: [["nb-chat-message-quote"]], inputs: { dateFormat: "dateFormat", message: "message", sender: "sender", date: "date", quote: "quote" }, decls: 5, vars: 4, consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]], template: function NbChatMessageQuoteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
        ɵngcc0.ɵɵelementStart(1, "p", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "nb-chat-message-text", 2);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.sender || ctx.date);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.quote, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("message", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.message, " ");
    } }, directives: function () { return [ɵngcc2.NgIf, NbChatMessageTextComponent]; }, pipes: function () { return [ɵngcc2.DatePipe]; }, encapsulation: 2, changeDetection: 0 });
NbChatMessageQuoteComponent.propDecorators = {
    message: [{ type: Input }],
    sender: [{ type: Input }],
    date: [{ type: Input }],
    dateFormat: [{ type: Input }],
    quote: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatMessageQuoteComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-quote',
                template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date | date: dateFormat }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { dateFormat: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], quote: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Chat message component.
 */
class NbChatMessageTextComponent {
    constructor() {
        /**
         * Message send date format, default 'shortTime'
         * @type {string}
         */
        this.dateFormat = 'shortTime';
    }
}
NbChatMessageTextComponent.ɵfac = function NbChatMessageTextComponent_Factory(t) { return new (t || NbChatMessageTextComponent)(); };
NbChatMessageTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageTextComponent, selectors: [["nb-chat-message-text"]], inputs: { dateFormat: "dateFormat", sender: "sender", message: "message", date: "date" }, decls: 2, vars: 2, consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]], template: function NbChatMessageTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0);
        ɵngcc0.ɵɵtemplate(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.sender || ctx.date);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
    } }, directives: [ɵngcc2.NgIf], pipes: [ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
NbChatMessageTextComponent.propDecorators = {
    sender: [{ type: Input }],
    message: [{ type: Input }],
    date: [{ type: Input }],
    dateFormat: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatMessageTextComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-text',
                template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date: dateFormat }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { dateFormat: [{
            type: Input
        }], sender: [{
            type: Input
        }], message: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/*
 * Class used as injection token to provide form element.
 **/
class NbFormFieldControl {
}
NbFormFieldControl.ɵfac = function NbFormFieldControl_Factory(t) { return new (t || NbFormFieldControl)(); };
NbFormFieldControl.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbFormFieldControl, factory: NbFormFieldControl.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFormFieldControl, [{
        type: Injectable
    }], null, null); })();
/*
 * Optional config to be provided on NbFormFieldControl to alter default settings.
 **/
class NbFormFieldControlConfig {
    constructor() {
        this.supportsPrefix = true;
        this.supportsSuffix = true;
    }
}
NbFormFieldControlConfig.ɵfac = function NbFormFieldControlConfig_Factory(t) { return new (t || NbFormFieldControlConfig)(); };
NbFormFieldControlConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbFormFieldControlConfig, factory: NbFormFieldControlConfig.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFormFieldControlConfig, [{
        type: Injectable
    }], function () { return []; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Basic input directive.
 *
 * ```html
 * <input nbInput></input>
 * ```
 *
 * ### Installation
 *
 * Import `NbInputModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbInputModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Default input size is `medium`:
 * @stacked-example(Showcase, input/input-showcase.component)
 *
 * Inputs are available in multiple colors using `status` property:
 * @stacked-example(Input Colors, input/input-colors.component)
 *
 * There are three input sizes:
 *
 * @stacked-example(Input Sizes, input/input-sizes.component)
 *
 * Inputs available in different shapes, which could be combined with the other properties:
 * @stacked-example(Input Shapes, input/input-shapes.component)
 *
 * `nbInput` could be applied to the following selectors - `input`, `textarea`:
 * @stacked-example(Input Elements, input/input-types.component)
 *
 * You can add `fullWidth` attribute to make element fill container:
 * @stacked-example(Full width inputs, input/input-full-width.component)
 *
 * Or you can bind control with form controls or ngModel:
 * @stacked-example(Input form binding, input/input-form.component)
 *
 * Use `<nb-form-field>` to add custom content to the input field.
 * First import `NbFormFieldModule`. Then put the input field and custom content into
 * `<nb-form-field>` and add `nbPrefix` or `nbSuffix` directive to the custom content.
 * `nbPrefix` puts content before input and `nbSuffix` after.
 *
 * @stacked-example(Input with icon, form-field/form-field-input.component)
 * @stacked-example(Input with button, form-field/form-field-password.component)
 *
 * @styles
 *
 * input-border-style:
 * input-border-width:
 * input-outline-color:
 * input-outline-width:
 * input-placeholder-text-font-family:
 * input-text-font-family:
 * input-basic-text-color:
 * input-basic-placeholder-text-color:
 * input-basic-background-color:
 * input-basic-border-color:
 * input-basic-focus-background-color:
 * input-basic-focus-border-color:
 * input-basic-hover-background-color:
 * input-basic-hover-border-color:
 * input-basic-disabled-background-color:
 * input-basic-disabled-border-color:
 * input-basic-disabled-text-color:
 * input-basic-disabled-placeholder-text-color:
 * input-primary-text-color:
 * input-primary-placeholder-text-color:
 * input-primary-background-color:
 * input-primary-border-color:
 * input-primary-focus-background-color:
 * input-primary-focus-border-color:
 * input-primary-hover-background-color:
 * input-primary-hover-border-color:
 * input-primary-disabled-background-color:
 * input-primary-disabled-border-color:
 * input-primary-disabled-text-color:
 * input-primary-disabled-placeholder-text-color:
 * input-success-text-color:
 * input-success-placeholder-text-color:
 * input-success-background-color:
 * input-success-border-color:
 * input-success-focus-background-color:
 * input-success-focus-border-color:
 * input-success-hover-background-color:
 * input-success-hover-border-color:
 * input-success-disabled-background-color:
 * input-success-disabled-border-color:
 * input-success-disabled-text-color:
 * input-success-disabled-placeholder-text-color:
 * input-info-text-color:
 * input-info-placeholder-text-color:
 * input-info-background-color:
 * input-info-border-color:
 * input-info-focus-background-color:
 * input-info-focus-border-color:
 * input-info-hover-background-color:
 * input-info-hover-border-color:
 * input-info-disabled-background-color:
 * input-info-disabled-border-color:
 * input-info-disabled-text-color:
 * input-info-disabled-placeholder-text-color:
 * input-warning-text-color:
 * input-warning-placeholder-text-color:
 * input-warning-background-color:
 * input-warning-border-color:
 * input-warning-focus-background-color:
 * input-warning-focus-border-color:
 * input-warning-hover-background-color:
 * input-warning-hover-border-color:
 * input-warning-disabled-background-color:
 * input-warning-disabled-border-color:
 * input-warning-disabled-text-color:
 * input-warning-disabled-placeholder-text-color:
 * input-danger-text-color:
 * input-danger-placeholder-text-color:
 * input-danger-background-color:
 * input-danger-border-color:
 * input-danger-focus-background-color:
 * input-danger-focus-border-color:
 * input-danger-hover-background-color:
 * input-danger-hover-border-color:
 * input-danger-disabled-background-color:
 * input-danger-disabled-border-color:
 * input-danger-disabled-text-color:
 * input-danger-disabled-placeholder-text-color:
 * input-control-text-color:
 * input-control-placeholder-text-color:
 * input-control-background-color:
 * input-control-border-color:
 * input-control-focus-background-color:
 * input-control-focus-border-color:
 * input-control-hover-background-color:
 * input-control-hover-border-color:
 * input-control-disabled-background-color:
 * input-control-disabled-border-color:
 * input-control-disabled-text-color:
 * input-control-disabled-placeholder-text-color:
 * input-rectangle-border-radius:
 * input-semi-round-border-radius:
 * input-round-border-radius:
 * input-tiny-text-font-size:
 * input-tiny-text-font-weight:
 * input-tiny-text-line-height:
 * input-tiny-placeholder-text-font-size:
 * input-tiny-placeholder-text-font-weight:
 * input-tiny-placeholder-text-line-height:
 * input-tiny-padding:
 * input-tiny-max-width:
 * input-small-text-font-size:
 * input-small-text-font-weight:
 * input-small-text-line-height:
 * input-small-placeholder-text-font-size:
 * input-small-placeholder-text-font-weight:
 * input-small-placeholder-text-line-height:
 * input-small-padding:
 * input-small-max-width:
 * input-medium-text-font-size:
 * input-medium-text-font-weight:
 * input-medium-text-line-height:
 * input-medium-placeholder-text-font-size:
 * input-medium-placeholder-text-font-weight:
 * input-medium-placeholder-text-line-height:
 * input-medium-padding:
 * input-medium-max-width:
 * input-large-text-font-size:
 * input-large-text-font-weight:
 * input-large-text-line-height:
 * input-large-placeholder-text-font-size:
 * input-large-placeholder-text-font-weight:
 * input-large-placeholder-text-line-height:
 * input-large-padding:
 * input-large-max-width:
 * input-giant-text-font-size:
 * input-giant-text-font-weight:
 * input-giant-text-line-height:
 * input-giant-placeholder-text-font-size:
 * input-giant-placeholder-text-font-weight:
 * input-giant-placeholder-text-line-height:
 * input-giant-padding:
 * input-giant-max-width:
 */
class NbInputDirective {
    constructor(elementRef, focusMonitor, renderer, zone, statusService) {
        this.elementRef = elementRef;
        this.focusMonitor = focusMonitor;
        this.renderer = renderer;
        this.zone = zone;
        this.statusService = statusService;
        this.destroy$ = new Subject();
        /**
         * Field size modifications. Possible values: `small`, `medium` (default), `large`.
         */
        this.fieldSize = 'medium';
        /**
         * Field status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = 'basic';
        /**
         * Field shapes modifications. Possible values: `rectangle` (default), `round`, `semi-round`.
         */
        this.shape = 'rectangle';
        this._fullWidth = false;
        /*
         * @docs-private
         **/
        this.status$ = new BehaviorSubject(this.status);
        /*
         * @docs-private
         **/
        this.size$ = new BehaviorSubject(this.fieldSize);
        /*
         * @docs-private
         **/
        this.focused$ = new BehaviorSubject(false);
        /*
         * @docs-private
         **/
        this.disabled$ = new BehaviorSubject(false);
        /*
         * @docs-private
         **/
        this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    }
    /**
     * If set element will fill container. `false` by default.
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    ngDoCheck() {
        const isDisabled = this.elementRef.nativeElement.disabled;
        if (isDisabled !== this.disabled$.value) {
            this.disabled$.next(isDisabled);
        }
    }
    ngOnChanges({ status, fieldSize, fullWidth }) {
        if (status) {
            this.status$.next(this.status);
        }
        if (fieldSize) {
            this.size$.next(this.fieldSize);
        }
        if (fullWidth) {
            this.fullWidth$.next(this.fullWidth);
        }
    }
    ngOnInit() {
        this.focusMonitor.monitor(this.elementRef)
            .pipe(map(origin => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.elementRef)), takeUntil(this.destroy$))
            .subscribe(this.focused$);
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.elementRef.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    get tiny() {
        return this.fieldSize === 'tiny';
    }
    get small() {
        return this.fieldSize === 'small';
    }
    get medium() {
        return this.fieldSize === 'medium';
    }
    get large() {
        return this.fieldSize === 'large';
    }
    get giant() {
        return this.fieldSize === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get round() {
        return this.shape === 'round';
    }
}
NbInputDirective.ɵfac = function NbInputDirective_Factory(t) { return new (t || NbInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbFocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbInputDirective, selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]], hostVars: 34, hostBindings: function NbInputDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    } }, inputs: { fieldSize: "fieldSize", status: "status", shape: "shape", fullWidth: "fullWidth" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbFormFieldControl, useExisting: NbInputDirective },
        ]), ɵngcc0.ɵɵNgOnChangesFeature] });
NbInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbFocusMonitor },
    { type: Renderer2 },
    { type: NgZone },
    { type: NbStatusService }
];
NbInputDirective.propDecorators = {
    fieldSize: [{ type: Input }],
    status: [{ type: Input }],
    shape: [{ type: Input }],
    fullWidth: [{ type: Input }, { type: HostBinding, args: ['class.input-full-width',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    rectangle: [{ type: HostBinding, args: ['class.shape-rectangle',] }],
    semiRound: [{ type: HostBinding, args: ['class.shape-semi-round',] }],
    round: [{ type: HostBinding, args: ['class.shape-round',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbInput],textarea[nbInput]',
                providers: [
                    { provide: NbFormFieldControl, useExisting: NbInputDirective },
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbFocusMonitor }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { fieldSize: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.input-full-width']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_INPUT_COMPONENTS = [
    NbInputDirective,
];
class NbInputModule {
}
NbInputModule.ɵfac = function NbInputModule_Factory(t) { return new (t || NbInputModule)(); };
NbInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbInputModule });
NbInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbSharedModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbInputModule, { declarations: [NbInputDirective], imports: [NbSharedModule], exports: [NbInputDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbInputModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule],
                declarations: NB_INPUT_COMPONENTS,
                exports: NB_INPUT_COMPONENTS
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_CHAT_COMPONENTS = [
    NbChatComponent,
    NbChatMessageComponent,
    NbChatFormComponent,
    NbChatMessageTextComponent,
    NbChatMessageFileComponent,
    NbChatMessageQuoteComponent,
    NbChatMessageMapComponent,
];
class NbChatModule {
    static forRoot(options) {
        return {
            ngModule: NbChatModule,
            providers: [
                { provide: NbChatOptions, useValue: options || {} },
            ],
        };
    }
    static forChild(options) {
        return {
            ngModule: NbChatModule,
            providers: [
                { provide: NbChatOptions, useValue: options || {} },
            ],
        };
    }
}
NbChatModule.ɵfac = function NbChatModule_Factory(t) { return new (t || NbChatModule)(); };
NbChatModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbChatModule });
NbChatModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
            NbInputModule,
            NbButtonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbChatModule, { declarations: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent], imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule], exports: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbChatModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                    NbInputModule,
                    NbButtonModule,
                ],
                declarations: [
                    ...NB_CHAT_COMPONENTS,
                ],
                exports: [
                    ...NB_CHAT_COMPONENTS,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Styled spinner component
 *
 * @styles
 *
 * spinner-text-color:
 * spinner-text-font-family:
 * spinner-text-font-size:
 * spinner-text-font-weight:
 * spinner-text-line-height:
 * spinner-basic-background-color:
 * spinner-basic-circle-filled-color:
 * spinner-basic-circle-empty-color:
 * spinner-primary-background-color:
 * spinner-primary-circle-filled-color:
 * spinner-primary-circle-empty-color:
 * spinner-info-background-color:
 * spinner-info-circle-filled-color:
 * spinner-info-circle-empty-color:
 * spinner-success-background-color:
 * spinner-success-circle-filled-color:
 * spinner-success-circle-empty-color:
 * spinner-warning-background-color:
 * spinner-warning-circle-filled-color:
 * spinner-warning-circle-empty-color:
 * spinner-danger-background-color:
 * spinner-danger-circle-filled-color:
 * spinner-danger-circle-empty-color:
 * spinner-control-background-color:
 * spinner-control-circle-filled-color:
 * spinner-control-circle-empty-color:
 * spinner-height-tiny:
 * spinner-height-small:
 * spinner-height-medium:
 * spinner-height-large:
 * spinner-height-giant:
 */
class NbSpinnerComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Loading text that is shown near the icon
         * @type string
         */
        this.message = 'Loading...';
        /**
         * Spinner size, available sizes:
         * tiny, small, medium, large, giant
         * @param {string} value
         */
        this.size = 'medium';
        /**
         * Spinner status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
         */
        this.status = 'basic';
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
}
NbSpinnerComponent.ɵfac = function NbSpinnerComponent_Factory(t) { return new (t || NbSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSpinnerComponent, selectors: [["nb-spinner"]], hostVars: 26, hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { message: "message", size: "size", status: "status" }, decls: 2, vars: 1, consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]], template: function NbSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;top:0;right:0;left:0;bottom:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin 0.8s infinite linear;border-radius:50%;border-style:solid;border-width:0.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:0.5rem}"] });
NbSpinnerComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbSpinnerComponent.propDecorators = {
    message: [{ type: Input }],
    size: [{ type: Input }],
    status: [{ type: Input }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-spinner',
                template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
                styles: [":host{opacity:1;position:absolute;border-radius:inherit;top:0;right:0;left:0;bottom:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin 0.8s infinite linear;border-radius:50%;border-style:solid;border-width:0.125em;width:1em;height:1em}:host .message{margin-left:0.5rem}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { message: [{
            type: Input
        }], size: [{
            type: Input
        }], status: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Styled spinner directive
 *
 * @stacked-example(Spinner Showcase, spinner/spinner-card.component)
 *
 *
 * ```ts
 * <nb-card [nbSpinner]="loading" nbSpinnerStatus="danger">
 *   <nb-card-body>Card Content</nb-card-body>
 * </nb-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbSpinnerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSpinnerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Could be colored using `status` property
 *
 * @stacked-example(Spinner Colors, spinner/spinner-colors.component)
 *
 * Available in different sizes with `size` property:
 *
 * @stacked-example(Spinner Sizes, spinner/spinner-sizes.component)
 *
 * It is also possible to place it into the button:
 * @stacked-example(Buttons with spinner, spinner/spinner-button.component)
 *
 * Or tabs:
 * @stacked-example(Spinner in tabs, spinner/spinner-tabs.component)
 */
class NbSpinnerDirective {
    constructor(directiveView, componentFactoryResolver, renderer, directiveElement) {
        this.directiveView = directiveView;
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        this.directiveElement = directiveElement;
        this.shouldShow = false;
        /**
         * Spinner status color
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
         */
        this.spinnerStatus = 'basic';
        /**
         * Spinner size. Possible values: `tiny`, `small`, `medium` (default), `large`, `giant`
         */
        this.spinnerSize = 'medium';
        this.isSpinnerExist = false;
    }
    /**
     * Directive value - show or hide spinner
     * @param {boolean} val
     */
    set nbSpinner(val) {
        if (this.componentFactory) {
            if (val) {
                this.show();
            }
            else {
                this.hide();
            }
        }
        else {
            this.shouldShow = val;
        }
    }
    ngOnInit() {
        this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(NbSpinnerComponent);
        if (this.shouldShow) {
            this.show();
        }
    }
    hide() {
        if (this.isSpinnerExist) {
            this.directiveView.remove();
            this.isSpinnerExist = false;
        }
    }
    show() {
        if (!this.isSpinnerExist) {
            this.spinner = this.directiveView.createComponent(this.componentFactory);
            this.setInstanceInputs(this.spinner.instance);
            this.spinner.changeDetectorRef.detectChanges();
            this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
            this.isSpinnerExist = true;
        }
    }
    setInstanceInputs(instance) {
        instance.message = this.spinnerMessage;
        typeof this.spinnerStatus !== 'undefined' && (instance.status = this.spinnerStatus);
        typeof this.spinnerSize !== 'undefined' && (instance.size = this.spinnerSize);
    }
}
NbSpinnerDirective.ɵfac = function NbSpinnerDirective_Factory(t) { return new (t || NbSpinnerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbSpinnerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSpinnerDirective, selectors: [["", "nbSpinner", ""]], hostVars: 2, hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-spinner-container", ctx.isSpinnerExist);
    } }, inputs: { spinnerStatus: ["nbSpinnerStatus", "spinnerStatus"], spinnerSize: ["nbSpinnerSize", "spinnerSize"], nbSpinner: "nbSpinner", spinnerMessage: ["nbSpinnerMessage", "spinnerMessage"] } });
NbSpinnerDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: ElementRef }
];
NbSpinnerDirective.propDecorators = {
    spinnerMessage: [{ type: Input, args: ['nbSpinnerMessage',] }],
    spinnerStatus: [{ type: Input, args: ['nbSpinnerStatus',] }],
    spinnerSize: [{ type: Input, args: ['nbSpinnerSize',] }],
    nbSpinner: [{ type: Input, args: ['nbSpinner',] }],
    isSpinnerExist: [{ type: HostBinding, args: ['class.nb-spinner-container',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSpinnerDirective, [{
        type: Directive,
        args: [{ selector: '[nbSpinner]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { spinnerStatus: [{
            type: Input,
            args: ['nbSpinnerStatus']
        }], spinnerSize: [{
            type: Input,
            args: ['nbSpinnerSize']
        }], isSpinnerExist: [{
            type: HostBinding,
            args: ['class.nb-spinner-container']
        }], nbSpinner: [{
            type: Input,
            args: ['nbSpinner']
        }], spinnerMessage: [{
            type: Input,
            args: ['nbSpinnerMessage']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbSpinnerModule {
}
NbSpinnerModule.ɵfac = function NbSpinnerModule_Factory(t) { return new (t || NbSpinnerModule)(); };
NbSpinnerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSpinnerModule });
NbSpinnerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSpinnerModule, { declarations: [NbSpinnerComponent, NbSpinnerDirective], imports: [NbSharedModule], exports: [NbSpinnerComponent, NbSpinnerDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSpinnerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                exports: [NbSpinnerComponent, NbSpinnerDirective],
                declarations: [NbSpinnerComponent, NbSpinnerDirective],
                entryComponents: [NbSpinnerComponent]
            }]
    }], null, null); })();

const NB_STEPPER = new InjectionToken('Nebular Stepper Component');

/**
 * Component intended to be used within  the `<nb-stepper>` component.
 * Container for a step
 */
class NbStepComponent {
    constructor(stepper) {
        this._hidden = false;
        this._completed = false;
        this.interacted = false;
        this.stepper = stepper;
    }
    /**
     * Whether step will be displayed in wizard
     *
     * @type {boolean}
     */
    get hidden() {
        return this._hidden;
    }
    set hidden(value) {
        this._hidden = convertToBoolProperty(value);
    }
    /**
     * Check that label is a TemplateRef.
     *
     * @return boolean
     * */
    get isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    /**
     * Whether step is marked as completed.
     *
     * @type {boolean}
     */
    get completed() {
        return this._completed || this.isCompleted;
    }
    set completed(value) {
        this._completed = convertToBoolProperty(value);
    }
    get isCompleted() {
        return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
    }
    /**
     * Mark step as selected
     * */
    select() {
        this.stepper.selected = this;
    }
    /**
     * Reset step and stepControl state
     * */
    reset() {
        this.interacted = false;
        if (this.stepControl) {
            this.stepControl.reset();
        }
    }
}
NbStepComponent.ɵfac = function NbStepComponent_Factory(t) { return new (t || NbStepComponent)(ɵngcc0.ɵɵdirectiveInject(NB_STEPPER)); };
NbStepComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbStepComponent, selectors: [["nb-step"]], viewQuery: function NbStepComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(TemplateRef, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, inputs: { hidden: "hidden", completed: "completed", stepControl: "stepControl", label: "label" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbStepComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
    } }, encapsulation: 2 });
NbStepComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_STEPPER,] }] }
];
NbStepComponent.propDecorators = {
    content: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],
    stepControl: [{ type: Input }],
    label: [{ type: Input }],
    hidden: [{ type: Input }],
    completed: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStepComponent, [{
        type: Component,
        args: [{
                selector: 'nb-step',
                template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_STEPPER]
            }] }]; }, { hidden: [{
            type: Input
        }], completed: [{
            type: Input
        }], content: [{
            type: ViewChild,
            args: [TemplateRef, { static: true }]
        }], stepControl: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Stepper component
 *
 * @stacked-example(Showcase, stepper/stepper-showcase.component)
 *
 * ### Installation
 *
 * Import `NbStepperModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbStepperModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If step label is string you can pass it as `label` attribute. Otherwise ng-template should be used:
 * ```html
 * // ...
 * <nb-stepper orientation="horizontal">
 *   <nb-step label="step number one">
 *       // ... step content here
 *   </nb-step>
 *   <nb-step label="stepLabel">
 *       <ng-template #stepLabel>
 *           <div>
 *               step number two
 *           </div>
 *       </ng-template>
 *       // ... step content here
 *   </nb-step>
 * </nb-stepper>
 * ```
 *
 * When linear mode enabled user can't move forward unless current step is complete.
 * @stacked-example(Linear, stepper/stepper-linear.component)
 *
 * Specify `[stepControl]="form"` and stepper allow go to the next step only if form is valid.
 * You can disable it via `linear` mode setting.
 * ```html
 * // ...
 * <nb-stepper  orientation="horizontal">
 *   <nb-step label="step number one" [stepControl]="form">
 *     <form [formGroup]="form">
 *       // ...
 *     </form>
 *   </nb-step>
 *    // ...
 * </nb-stepper>
 * ```
 *
 * @stacked-example(Validation, stepper/stepper-validation.component)
 *
 * Stepper component has two layout options - `vertical` & `horizontal`
 * @stacked-example(Vertical, stepper/stepper-vertical.component)
 *
 * `disableStepNavigation` disables navigation by clicking on steps, so user can navigate only using
 * 'nbStepperPrevious' and 'nbStepperNext' buttons.
 * @stacked-example(Disabled steps navigation, stepper/stepper-disabled-step-nav.component)
 *
 * @styles
 *
 * stepper-step-text-color:
 * stepper-step-text-font-family:
 * stepper-step-text-font-size:
 * stepper-step-text-font-weight:
 * stepper-step-text-line-height:
 * stepper-step-active-text-color:
 * stepper-step-completed-text-color:
 * stepper-step-index-border-color:
 * stepper-step-index-border-style:
 * stepper-step-index-border-width:
 * stepper-step-index-border-radius:
 * stepper-step-index-width:
 * stepper-step-index-active-border-color:
 * stepper-step-index-completed-background-color:
 * stepper-step-index-completed-border-color:
 * stepper-step-index-completed-text-color:
 * stepper-connector-background-color:
 * stepper-connector-completed-background-color:
 * stepper-horizontal-connector-margin:
 * stepper-vertical-connector-margin:
 * stepper-step-content-padding:
 */
class NbStepperComponent {
    constructor() {
        this._selectedIndex = 0;
        this._disableStepNavigation = false;
        /**
         * Stepper orientation - `horizontal`|`vertical`
         */
        this.orientation = 'horizontal';
        this._linear = true;
    }
    /**
     * Selected step index
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        if (!this.steps) {
            this._selectedIndex = index;
            return;
        }
        this.markCurrentStepInteracted();
        if (this.canBeSelected(index)) {
            this._selectedIndex = index;
        }
    }
    /**
     * Disables navigation by clicking on steps. False by default
     * @param {boolean} value
     */
    set disableStepNavigation(value) {
        this._disableStepNavigation = convertToBoolProperty(value);
    }
    get disableStepNavigation() {
        return this._disableStepNavigation;
    }
    /**
     * Selected step component
     */
    get selected() {
        return this.steps ? this.steps.toArray()[this.selectedIndex] : undefined;
    }
    set selected(step) {
        if (!this.steps) {
            return;
        }
        this.selectedIndex = this.steps.toArray().indexOf(step);
    }
    /**
     * Allow moving forward only if the current step is complete
     * @default true
     */
    set linear(value) {
        this._linear = convertToBoolProperty(value);
    }
    get linear() {
        return this._linear;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * Navigate to next step
     * */
    next() {
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
    }
    /**
     * Navigate to previous step
     * */
    previous() {
        this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
    }
    /**
     * Reset stepper and stepControls to initial state
     * */
    reset() {
        this._selectedIndex = 0;
        this.steps.forEach(step => step.reset());
    }
    isStepSelected(step) {
        return this.selected === step;
    }
    /*
     * @docs-private
     **/
    getStepTemplate(step) {
        if (step.isLabelTemplate) {
            return step.label;
        }
        return null;
    }
    isStepValid(index) {
        return this.steps.toArray()[index].completed;
    }
    canBeSelected(indexToCheck) {
        const noSteps = !this.steps || this.steps.length === 0;
        if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length) {
            return false;
        }
        if (indexToCheck <= this.selectedIndex || !this.linear) {
            return true;
        }
        let isAllStepsValid = true;
        for (let i = this.selectedIndex; i < indexToCheck; i++) {
            if (!this.isStepValid(i)) {
                isAllStepsValid = false;
                break;
            }
        }
        return isAllStepsValid;
    }
    markCurrentStepInteracted() {
        if (this.selected) {
            this.selected.interacted = true;
        }
    }
}
NbStepperComponent.ɵfac = function NbStepperComponent_Factory(t) { return new (t || NbStepperComponent)(); };
NbStepperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbStepperComponent, selectors: [["nb-stepper"]], contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbStepComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.steps = _t);
    } }, hostVars: 4, hostBindings: function NbStepperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
    } }, inputs: { orientation: "orientation", selectedIndex: "selectedIndex", disableStepNavigation: "disableStepNavigation", selected: "selected", linear: "linear" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NB_STEPPER, useExisting: NbStepperComponent }])], ngContentSelectors: _c28, decls: 5, vars: 2, consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]], template: function NbStepperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c27);
        ɵngcc0.ɵɵtemplate(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementContainer(4, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, NbIconComponent], styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"] });
NbStepperComponent.propDecorators = {
    selectedIndex: [{ type: Input }],
    disableStepNavigation: [{ type: Input }],
    selected: [{ type: Input }],
    orientation: [{ type: Input }],
    linear: [{ type: Input }],
    vertical: [{ type: HostBinding, args: ['class.vertical',] }],
    horizontal: [{ type: HostBinding, args: ['class.horizontal',] }],
    steps: [{ type: ContentChildren, args: [NbStepComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStepperComponent, [{
        type: Component,
        args: [{
                selector: 'nb-stepper',
                template: "<ng-template><ng-content select=\"nb-step\"></ng-content></ng-template>\n<div class=\"header\">\n  <ng-container *ngFor=\"let step of steps; let index = index; let first = first\">\n\n    <div *ngIf=\"!first && !step.hidden\"\n         [class.connector-past]=\"index <= selectedIndex\"\n         class=\"connector\"></div>\n\n    <div *ngIf=\"!step.hidden\" class=\"step\"\n         [class.selected]=\"isStepSelected(step)\"\n         [class.completed]=\"!isStepSelected(step) && step.completed\"\n         [class.noninteractive]=\"disableStepNavigation\"\n         (click)=\"!disableStepNavigation && step.select()\">\n      <div class=\"label-index\">\n        <span *ngIf=\"!step.completed || isStepSelected(step)\">{{ index + 1 }}</span>\n        <nb-icon *ngIf=\"!isStepSelected(step) && step.completed\" icon=\"checkmark-outline\" pack=\"nebular-essentials\">\n        </nb-icon>\n      </div>\n      <div class=\"label\">\n        <ng-container *ngIf=\"step.isLabelTemplate\">\n          <ng-container *ngTemplateOutlet=\"getStepTemplate(step)\"></ng-container>\n        </ng-container>\n        <span *ngIf=\"!step.isLabelTemplate\">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class=\"step-content\">\n  <ng-container [ngTemplateOutlet]=\"selected?.content\"></ng-container>\n</div>\n",
                providers: [{ provide: NB_STEPPER, useExisting: NbStepperComponent }],
                styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], disableStepNavigation: [{
            type: Input
        }], selected: [{
            type: Input
        }], linear: [{
            type: Input
        }], vertical: [{
            type: HostBinding,
            args: ['class.vertical']
        }], horizontal: [{
            type: HostBinding,
            args: ['class.horizontal']
        }], steps: [{
            type: ContentChildren,
            args: [NbStepComponent]
        }] }); })();

class NbStepperNextDirective {
    constructor(stepper) {
        this.stepper = stepper;
        this.type = 'submit';
    }
    onClick() {
        this.stepper.next();
    }
}
NbStepperNextDirective.ɵfac = function NbStepperNextDirective_Factory(t) { return new (t || NbStepperNextDirective)(ɵngcc0.ɵɵdirectiveInject(NbStepperComponent)); };
NbStepperNextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbStepperNextDirective, selectors: [["button", "nbStepperNext", ""]], hostVars: 1, hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbStepperNextDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { type: "type" } });
NbStepperNextDirective.ctorParameters = () => [
    { type: NbStepperComponent }
];
NbStepperNextDirective.propDecorators = {
    type: [{ type: Input }, { type: HostBinding, args: ['attr.type',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStepperNextDirective, [{
        type: Directive,
        args: [{
                selector: 'button[nbStepperNext]'
            }]
    }], function () { return [{ type: NbStepperComponent }]; }, { type: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.type']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();
class NbStepperPreviousDirective {
    constructor(stepper) {
        this.stepper = stepper;
        this.type = 'button';
    }
    onClick() {
        this.stepper.previous();
    }
}
NbStepperPreviousDirective.ɵfac = function NbStepperPreviousDirective_Factory(t) { return new (t || NbStepperPreviousDirective)(ɵngcc0.ɵɵdirectiveInject(NbStepperComponent)); };
NbStepperPreviousDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbStepperPreviousDirective, selectors: [["button", "nbStepperPrevious", ""]], hostVars: 1, hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbStepperPreviousDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { type: "type" } });
NbStepperPreviousDirective.ctorParameters = () => [
    { type: NbStepperComponent }
];
NbStepperPreviousDirective.propDecorators = {
    type: [{ type: Input }, { type: HostBinding, args: ['attr.type',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStepperPreviousDirective, [{
        type: Directive,
        args: [{
                selector: 'button[nbStepperPrevious]'
            }]
    }], function () { return [{ type: NbStepperComponent }]; }, { type: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.type']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbStepperModule {
}
NbStepperModule.ɵfac = function NbStepperModule_Factory(t) { return new (t || NbStepperModule)(); };
NbStepperModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbStepperModule });
NbStepperModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbStepperModule, { declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective], imports: [NbSharedModule, NbIconModule], exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbStepperModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    NbStepperComponent,
                    NbStepComponent,
                    NbStepperNextDirective,
                    NbStepperPreviousDirective,
                ],
                exports: [
                    NbStepperComponent,
                    NbStepComponent,
                    NbStepperNextDirective,
                    NbStepperPreviousDirective,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * An accordion allows to toggle the display of sections of content
 *
 * Basic example
 * @stacked-example(Showcase, accordion/accordion-showcase.component)
 *
 * ```ts
 * <nb-accordion>
 *  <nb-accordion-item>
 *   <nb-accordion-item-header>Product Details</nb-accordion-item-header>
 *   <nb-accordion-item-body>
 *     Item Content
 *   </nb-accordion-item-body>
 *  </nb-accordion-item>
 * </nb-accordion>
 * ```
 * ### Installation
 *
 * Import `NbAccordionModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbAccordionModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * With `multi` mode accordion can have multiple items expanded:
 * @stacked-example(Multiple expanded items, accordion/accordion-multi.component)
 *
 * `NbAccordionItemComponent` has several methods, for example it is possible to trigger item click/toggle:
 * @stacked-example(Expand API, accordion/accordion-toggle.component)
 *
 * @styles
 *
 * accordion-border-radius:
 * accordion-padding:
 * accordion-shadow:
 * accordion-header-text-color:
 * accordion-header-text-font-family:
 * accordion-header-text-font-size:
 * accordion-header-text-font-weight:
 * accordion-header-text-line-height:
 * accordion-header-disabled-text-color:
 * accordion-header-border-color:
 * accordion-header-border-style:
 * accordion-header-border-width:
 * accordion-item-background-color:
 * accordion-item-text-color:
 * accordion-item-text-font-family:
 * accordion-item-text-font-size:
 * accordion-item-text-font-weight:
 * accordion-item-text-line-height:
 */
class NbAccordionComponent {
    constructor() {
        this.openCloseItems = new Subject();
        this.multiValue = false;
    }
    /**
     *  Allow multiple items to be expanded at the same time.
     * @type {boolean}
     */
    get multi() {
        return this.multiValue;
    }
    set multi(val) {
        this.multiValue = convertToBoolProperty(val);
    }
    /**
     * Opens all enabled accordion items.
     */
    openAll() {
        if (this.multi) {
            this.openCloseItems.next(false);
        }
    }
    /**
     * Closes all enabled accordion items.
     */
    closeAll() {
        this.openCloseItems.next(true);
    }
}
NbAccordionComponent.ɵfac = function NbAccordionComponent_Factory(t) { return new (t || NbAccordionComponent)(); };
NbAccordionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionComponent, selectors: [["nb-accordion"]], inputs: { multi: "multi" }, ngContentSelectors: _c30, decls: 1, vars: 0, template: function NbAccordionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c29);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
NbAccordionComponent.propDecorators = {
    multi: [{ type: Input, args: ['multi',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAccordionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion',
                template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { multi: [{
            type: Input,
            args: ['multi']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Component intended to be used within `<nb-accordion>` component
 */
class NbAccordionItemComponent {
    constructor(accordion, cd) {
        this.accordion = accordion;
        this.cd = cd;
        /**
         * Emits whenever the expanded state of the accordion changes.
         * Primarily used to facilitate two-way binding.
         */
        this.collapsedChange = new EventEmitter();
        this.accordionItemInvalidate = new Subject();
        this.collapsedValue = true;
        this.disabledValue = false;
        this.destroy$ = new Subject();
    }
    /**
     * Item is collapse (`true` by default)
     * @type {boolean}
     */
    get collapsed() {
        return this.collapsedValue;
    }
    set collapsed(val) {
        this.collapsedValue = convertToBoolProperty(val);
        this.collapsedChange.emit(this.collapsedValue);
        this.invalidate();
    }
    /**
     * Item is expanded (`false` by default)
     * @type {boolean}
     */
    get expanded() {
        return !this.collapsed;
    }
    set expanded(val) {
        this.collapsedValue = !convertToBoolProperty(val);
    }
    /**
     * Item is disabled and cannot be opened.
     * @type {boolean}
     */
    get disabled() {
        return this.disabledValue;
    }
    set disabled(val) {
        this.disabledValue = convertToBoolProperty(val);
        this.invalidate();
    }
    /**
     * Open/close the item
     */
    toggle() {
        if (!this.disabled) {
            // we need this temporary variable as `openCloseItems.next` will change current value we need to save
            const willSet = !this.collapsed;
            if (!this.accordion.multi) {
                this.accordion.openCloseItems.next(true);
            }
            this.collapsed = willSet;
        }
    }
    /**
     * Open the item.
     */
    open() {
        !this.disabled && (this.collapsed = false);
    }
    /**
     * Collapse the item.
     */
    close() {
        !this.disabled && (this.collapsed = true);
    }
    ngOnInit() {
        this.accordion.openCloseItems
            .pipe(takeUntil(this.destroy$))
            .subscribe(collapsed => {
            !this.disabled && (this.collapsed = collapsed);
        });
    }
    ngOnChanges(changes) {
        this.accordionItemInvalidate.next(true);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.accordionItemInvalidate.complete();
    }
    invalidate() {
        this.accordionItemInvalidate.next(true);
        this.cd.markForCheck();
    }
}
NbAccordionItemComponent.ɵfac = function NbAccordionItemComponent_Factory(t) { return new (t || NbAccordionItemComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemComponent, selectors: [["nb-accordion-item"]], hostVars: 6, hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
    } }, inputs: { collapsed: "collapsed", expanded: "expanded", disabled: "disabled" }, outputs: { collapsedChange: "collapsedChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c32, decls: 2, vars: 0, template: function NbAccordionItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c31);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
    } }, styles: [_c8], changeDetection: 0 });
NbAccordionItemComponent.ctorParameters = () => [
    { type: NbAccordionComponent, decorators: [{ type: Host }] },
    { type: ChangeDetectorRef }
];
NbAccordionItemComponent.propDecorators = {
    collapsed: [{ type: Input, args: ['collapsed',] }, { type: HostBinding, args: ['class.collapsed',] }],
    expanded: [{ type: Input, args: ['expanded',] }, { type: HostBinding, args: ['class.expanded',] }],
    disabled: [{ type: Input, args: ['disabled',] }, { type: HostBinding, args: ['class.disabled',] }],
    collapsedChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAccordionItemComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item',
                template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbAccordionComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { collapsedChange: [{
            type: Output
        }], collapsed: [{
            type: Input,
            args: ['collapsed']
        }, {
            type: HostBinding,
            args: ['class.collapsed']
        }], expanded: [{
            type: Input,
            args: ['expanded']
        }, {
            type: HostBinding,
            args: ['class.expanded']
        }], disabled: [{
            type: Input,
            args: ['disabled']
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const accordionItemBodyTrigger = trigger('accordionItemBody', [
    state('collapsed', style({
        overflow: 'hidden',
        visibility: 'hidden',
        height: 0,
    })),
    state('expanded', style({
        overflow: 'hidden',
        visibility: 'visible',
    })),
    transition('collapsed => expanded', animate('100ms ease-in')),
    transition('expanded => collapsed', animate('100ms ease-out')),
]);
/**
 * Component intended to be used within `<nb-accordion-item>` component
 */
class NbAccordionItemBodyComponent {
    constructor(accordionItem, cd) {
        this.accordionItem = accordionItem;
        this.cd = cd;
        this.destroy$ = new Subject();
    }
    get state() {
        return this.accordionItem.collapsed ? 'collapsed' : 'expanded';
    }
    ngOnInit() {
        this.accordionItem.accordionItemInvalidate
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.cd.markForCheck());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NbAccordionItemBodyComponent.ɵfac = function NbAccordionItemBodyComponent_Factory(t) { return new (t || NbAccordionItemBodyComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemBodyComponent, selectors: [["nb-accordion-item-body"]], ngContentSelectors: _c0, decls: 3, vars: 3, consts: [[1, "item-body"]], template: function NbAccordionItemBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@accordionItemBody", ɵngcc0.ɵɵpureFunction1(1, _c33, ctx.state));
    } }, encapsulation: 2, data: { animation: [accordionItemBodyTrigger] }, changeDetection: 0 });
NbAccordionItemBodyComponent.ctorParameters = () => [
    { type: NbAccordionItemComponent, decorators: [{ type: Host }] },
    { type: ChangeDetectorRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAccordionItemBodyComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item-body',
                template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
                animations: [accordionItemBodyTrigger],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbAccordionItemComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Component intended to be used within `<nb-accordion-item>` component
 */
class NbAccordionItemHeaderComponent {
    constructor(accordionItem, cd) {
        this.accordionItem = accordionItem;
        this.cd = cd;
        this.destroy$ = new Subject();
    }
    get isCollapsed() {
        return this.accordionItem.collapsed;
    }
    get expanded() {
        return !this.accordionItem.collapsed;
    }
    // issue #794
    get tabbable() {
        return this.accordionItem.disabled ? '-1' : '0';
    }
    get disabled() {
        return this.accordionItem.disabled;
    }
    toggle() {
        this.accordionItem.toggle();
    }
    get state() {
        if (this.isCollapsed) {
            return 'collapsed';
        }
        if (this.expanded) {
            return 'expanded';
        }
    }
    ngOnInit() {
        this.accordionItem.accordionItemInvalidate
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.cd.markForCheck());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NbAccordionItemHeaderComponent.ɵfac = function NbAccordionItemHeaderComponent_Factory(t) { return new (t || NbAccordionItemHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemHeaderComponent, selectors: [["nb-accordion-item-header"]], hostVars: 7, hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() { return ctx.toggle(); })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() { return ctx.toggle(); })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() { return ctx.toggle(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
        ɵngcc0.ɵɵclassProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
    } }, ngContentSelectors: _c35, decls: 4, vars: 1, consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]], template: function NbAccordionItemHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c34);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵprojection(2, 2);
        ɵngcc0.ɵɵtemplate(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabled);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}"], data: { animation: [
            trigger('expansionIndicator', [
                state('expanded', style({
                    transform: 'rotate(180deg)'
                })),
                transition('collapsed => expanded', animate('100ms ease-in')),
                transition('expanded => collapsed', animate('100ms ease-out')),
            ]),
        ] }, changeDetection: 0 });
NbAccordionItemHeaderComponent.ctorParameters = () => [
    { type: NbAccordionItemComponent, decorators: [{ type: Host }] },
    { type: ChangeDetectorRef }
];
NbAccordionItemHeaderComponent.propDecorators = {
    isCollapsed: [{ type: HostBinding, args: ['class.accordion-item-header-collapsed',] }],
    expanded: [{ type: HostBinding, args: ['class.accordion-item-header-expanded',] }, { type: HostBinding, args: ['attr.aria-expanded',] }],
    tabbable: [{ type: HostBinding, args: ['attr.tabindex',] }],
    disabled: [{ type: HostBinding, args: ['attr.aria-disabled',] }],
    toggle: [{ type: HostListener, args: ['click',] }, { type: HostListener, args: ['keydown.space',] }, { type: HostListener, args: ['keydown.enter',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAccordionItemHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item-header',
                template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
                animations: [
                    trigger('expansionIndicator', [
                        state('expanded', style({
                            transform: 'rotate(180deg)'
                        })),
                        transition('collapsed => expanded', animate('100ms ease-in')),
                        transition('expanded => collapsed', animate('100ms ease-out')),
                    ]),
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n"]
            }]
    }], function () { return [{ type: NbAccordionItemComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isCollapsed: [{
            type: HostBinding,
            args: ['class.accordion-item-header-collapsed']
        }], expanded: [{
            type: HostBinding,
            args: ['class.accordion-item-header-expanded']
        }, {
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], tabbable: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], toggle: [{
            type: HostListener,
            args: ['click']
        }, {
            type: HostListener,
            args: ['keydown.space']
        }, {
            type: HostListener,
            args: ['keydown.enter']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_ACCORDION_COMPONENTS = [
    NbAccordionComponent,
    NbAccordionItemComponent,
    NbAccordionItemHeaderComponent,
    NbAccordionItemBodyComponent,
];
class NbAccordionModule {
}
NbAccordionModule.ɵfac = function NbAccordionModule_Factory(t) { return new (t || NbAccordionModule)(); };
NbAccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbAccordionModule });
NbAccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [], imports: [[CommonModule, NbIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbAccordionModule, { declarations: function () { return [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]; }, imports: function () { return [CommonModule, NbIconModule]; }, exports: function () { return [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAccordionModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbIconModule],
                exports: [...NB_ACCORDION_COMPONENTS],
                declarations: [...NB_ACCORDION_COMPONENTS],
                providers: []
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * `[nbButtonToggle]` is a directive to add a `pressed` state to a button.
 */
class NbButtonToggleDirective extends NbButton {
    constructor(renderer, hostElement, cd, zone, statusService) {
        super(renderer, hostElement, cd, zone, statusService);
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cd = cd;
        this.zone = zone;
        this.statusService = statusService;
        this._pressedChange$ = new Subject();
        this.appearance = 'filled';
        this._pressed = false;
        /**
         * Emits whenever button pressed state change
         **/
        this.pressedChange = new EventEmitter();
    }
    get pressedChange$() {
        return this._pressedChange$.asObservable();
    }
    /**
     * Controls button pressed state
     **/
    get pressed() {
        return this._pressed;
    }
    set pressed(value) {
        if (this.pressed !== convertToBoolProperty(value)) {
            this._pressed = !this.pressed;
            this.pressedChange.emit(this.pressed);
            this._pressedChange$.next({ source: this, pressed: this.pressed });
        }
    }
    get basic() {
        // By design, all toggle buttons should have a `basic` status when not pressed.
        return !this.pressed;
    }
    get primary() {
        return this.pressed && (this.status === 'basic' || this.status === 'primary');
    }
    get success() {
        return this.pressed && this.status === 'success';
    }
    get info() {
        return this.pressed && this.status === 'info';
    }
    get warning() {
        return this.pressed && this.status === 'warning';
    }
    get danger() {
        return this.pressed && this.status === 'danger';
    }
    get control() {
        return this.pressed && this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    onClick() {
        this.pressed = !this.pressed;
    }
    /**
     * @docs-private
     */
    _updatePressed(value) {
        this.pressed = value;
        this.cd.markForCheck();
    }
}
NbButtonToggleDirective.ɵfac = function NbButtonToggleDirective_Factory(t) { return new (t || NbButtonToggleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbButtonToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbButtonToggleDirective, selectors: [["button", "nbButtonToggle", ""]], hostVars: 17, hostBindings: function NbButtonToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbButtonToggleDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-pressed", ctx.pressed);
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control);
    } }, inputs: { appearance: "appearance", pressed: "pressed" }, outputs: { pressedChange: "pressedChange" }, exportAs: ["nbButtonToggle"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbButton, useExisting: NbButtonToggleDirective },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbButtonToggleDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: NbStatusService }
];
NbButtonToggleDirective.propDecorators = {
    appearance: [{ type: Input }],
    pressed: [{ type: Input }, { type: HostBinding, args: ['attr.aria-pressed',] }],
    pressedChange: [{ type: Output }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButtonToggleDirective, [{
        type: Directive,
        args: [{
                selector: 'button[nbButtonToggle]',
                providers: [
                    { provide: NbButton, useExisting: NbButtonToggleDirective },
                ],
                exportAs: 'nbButtonToggle'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { appearance: [{
            type: Input
        }], pressedChange: [{
            type: Output
        }], pressed: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-pressed']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * `<nb-button-group>` visually groups buttons together and allow to control buttons properties and the state as a
 * group.
 * @stacked-example(Button Group Showcase, button-group/button-group-showcase.component)
 *
 * ### Installation
 *
 * Import `NbButtonGroupModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbButtonGroupModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * You can use `<nb-button-group>` to group a series of `[nbButton]` or `[nbButtonToggle]` components.
 * @stacked-example(Button and Button Toggle Groups, button-group/button-and-button-toggle-groups.component)
 *
 * For a group of multiple `[nbButtonToggle]` you also can control multi-selection behavior. By default, the group
 * component allows only one pressed button toggle at a time (similar to the radio group). To be able to keep multiple
 * toggles pressed, you need to add `multiple` attributes to the `<nb-button-toggle>`.
 * @stacked-example(Button Group Multiple, button-group/button-group-multiple.component)
 *
 * To disable a group of buttons, add a `disabled` attribute to the `<nb-button-group>`.
 * @stacked-example(Button Group Disabled, button-group/button-group-disabled.component)
 *
 * The group component controls all visual attributes of buttons such as `appearance`, `status`, `size`, `shape`.
 * You can change it via the appropriate attributes.
 *
 * Button group appearances:
 * @stacked-example(Button Group Appearances, button-group/button-group-appearances.component)
 *
 * Button group statuses:
 * @stacked-example(Button Group Statuses, button-group/button-group-statuses.component)
 *
 * Button group sizes:
 * @stacked-example(Button Group Sizes, button-group/button-group-sizes.component)
 *
 * Buttons group shapes:
 * @additional-example(Button Group Shapes, button-group/button-group-shapes.component)
 *
 * @styles
 *
 * button-group-filled-button-basic-text-color:
 * button-group-filled-button-primary-text-color:
 * button-group-filled-button-success-text-color:
 * button-group-filled-button-info-text-color:
 * button-group-filled-button-warning-text-color:
 * button-group-filled-button-danger-text-color:
 * button-group-filled-button-control-text-color:
 * button-group-filled-basic-divider-color:
 * button-group-filled-primary-divider-color:
 * button-group-filled-success-divider-color:
 * button-group-filled-info-divider-color:
 * button-group-filled-warning-divider-color:
 * button-group-filled-danger-divider-color:
 * button-group-filled-control-divider-color:
 * button-group-ghost-divider-color:
 **/
class NbButtonGroupComponent {
    constructor(cd, statusService) {
        this.cd = cd;
        this.statusService = statusService;
        this.destroy$ = new Subject();
        this.buttonsChange$ = new Subject();
        /**
         * Button group size, available sizes:
         * `tiny`, `small`, `medium`, `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Button group status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = 'basic';
        /**
         * Button group shapes: `rectangle`, `round`, `semi-round`
         */
        this.shape = 'rectangle';
        /**
         * Button group appearance: `filled`, `outline`, `ghost`
         */
        this.appearance = 'filled';
        this._disabled = false;
        this._multiple = false;
        this.role = 'group';
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this.disabled !== convertToBoolProperty(value)) {
            this._disabled = !this.disabled;
        }
    }
    /**
     * Allows to keep multiple button toggles pressed. Off by default.
     */
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = convertToBoolProperty(value);
    }
    /**
     * Sets `filled` appearance
     */
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    /**
     * Sets `outline` appearance
     */
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    /**
     * Sets `ghost` appearance
     */
    get ghost() {
        return this.appearance === 'ghost';
    }
    set ghost(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'ghost';
        }
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    ngOnChanges({ size, status, shape, multiple, filled, outline, ghost, disabled }) {
        var _a;
        if (size || status || shape || multiple || filled || outline || ghost || disabled) {
            this.syncButtonsProperties(((_a = this.buttons) === null || _a === void 0 ? void 0 : _a.toArray()) || []);
        }
    }
    ngAfterContentInit() {
        this.buttonsChange$
            .pipe(takeUntil(this.destroy$))
            .subscribe((buttons) => {
            this.listenButtonPressedState(buttons);
            this.syncButtonsProperties(buttons);
        });
        this.buttons.changes
            .pipe(
        // `buttons.changes` emit during change detection run after projected content already was initialized.
        // So at this time, it's too late to update projected buttons properties as updating bindings after
        // initialization doesn't make sense. Changes won't be picked up and should cause an "expression changed" error.
        // Instead, we wrap the new buttons list into a promise to defer update to the following microtask and also to
        // trigger change detection one more time.
        switchMap((buttons) => from(Promise.resolve(buttons.toArray()))), takeUntil(this.destroy$))
            .subscribe(this.buttonsChange$);
        this.buttonsChange$.next(this.buttons.toArray());
    }
    listenButtonPressedState(buttons) {
        const toggleButtons = buttons.filter((button) => {
            return button instanceof NbButtonToggleDirective;
        });
        if (!toggleButtons.length) {
            return;
        }
        const buttonsPressedChange$ = toggleButtons
            .map((button) => button.pressedChange$);
        merge(...buttonsPressedChange$)
            .pipe(filter(({ pressed }) => !this.multiple && pressed), takeUntil(merge(this.buttonsChange$, this.destroy$)))
            .subscribe(({ source }) => {
            toggleButtons
                .filter((button) => button !== source)
                .forEach((button) => button._updatePressed(false));
        });
    }
    syncButtonsProperties(buttons) {
        buttons.forEach((button) => {
            button.updateProperties({
                appearance: this.appearance,
                size: this.size,
                status: this.status,
                shape: this.shape,
                disabled: this.disabled,
            });
        });
    }
}
NbButtonGroupComponent.ɵfac = function NbButtonGroupComponent_Factory(t) { return new (t || NbButtonGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbButtonGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbButtonGroupComponent, selectors: [["nb-button-group"]], contentQueries: function NbButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbButton, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.buttons = _t);
    } }, hostVars: 3, hostBindings: function NbButtonGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
    } }, inputs: { size: "size", status: "status", shape: "shape", appearance: "appearance", disabled: "disabled", multiple: "multiple", filled: "filled", outline: "outline", ghost: "ghost" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbButtonGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
NbButtonGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NbStatusService }
];
NbButtonGroupComponent.propDecorators = {
    buttons: [{ type: ContentChildren, args: [NbButton,] }],
    size: [{ type: Input }],
    status: [{ type: Input }],
    shape: [{ type: Input }],
    appearance: [{ type: Input }],
    disabled: [{ type: Input }],
    multiple: [{ type: Input }],
    filled: [{ type: Input }],
    outline: [{ type: Input }],
    ghost: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButtonGroupComponent, [{
        type: Component,
        args: [{
                selector: 'nb-button-group',
                template: `
    <ng-content></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: NbStatusService }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], appearance: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], disabled: [{
            type: Input
        }], multiple: [{
            type: Input
        }], filled: [{
            type: Input
        }], outline: [{
            type: Input
        }], ghost: [{
            type: Input
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], buttons: [{
            type: ContentChildren,
            args: [NbButton]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbButtonGroupModule {
}
NbButtonGroupModule.ɵfac = function NbButtonGroupModule_Factory(t) { return new (t || NbButtonGroupModule)(); };
NbButtonGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbButtonGroupModule });
NbButtonGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbButtonGroupModule, { declarations: [NbButtonGroupComponent, NbButtonToggleDirective], exports: [NbButtonGroupComponent, NbButtonToggleDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbButtonGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
                exports: [NbButtonGroupComponent, NbButtonToggleDirective]
            }]
    }], null, null); })();

/**
 * List is a container component that wraps `nb-list-item` component.
 *
 * Basic example:
 * @stacked-example(Simple list, list/simple-list-showcase.component)
 *
 * `nb-list-item` accepts arbitrary content, so you can create a list of any components.
 *
 * ### Installation
 *
 * Import `NbListModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbListModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * List of users:
 * @stacked-example(Users list, list/users-list-showcase.component)
 *
 * @styles
 *
 * list-item-divider-color:
 * list-item-divider-style:
 * list-item-divider-width:
 * list-item-padding:
 * list-item-text-color:
 * list-item-font-family:
 * list-item-font-size:
 * list-item-font-weight:
 * list-item-line-height:
 */
class NbListComponent {
    constructor() {
        /**
         * Role attribute value
         *
         * @type {string}
         */
        this.role = 'list';
    }
}
NbListComponent.ɵfac = function NbListComponent_Factory(t) { return new (t || NbListComponent)(); };
NbListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbListComponent, selectors: [["nb-list"]], hostVars: 1, hostBindings: function NbListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" }, ngContentSelectors: _c37, decls: 1, vars: 0, template: function NbListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c36);
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"] });
NbListComponent.propDecorators = {
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbListComponent, [{
        type: Component,
        args: [{
                selector: 'nb-list',
                template: `<ng-content select="nb-list-item"></ng-content>`,
                styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
            }]
    }], function () { return []; }, { role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }] }); })();
/**
 * List item component is a grouping component that accepts arbitrary content.
 * It should be direct child of `nb-list` componet.
 */
class NbListItemComponent {
    constructor() {
        /**
         * Role attribute value
         *
         * @type {string}
         */
        this.role = 'listitem';
    }
}
NbListItemComponent.ɵfac = function NbListItemComponent_Factory(t) { return new (t || NbListItemComponent)(); };
NbListItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbListItemComponent, selectors: [["nb-list-item"]], hostVars: 1, hostBindings: function NbListItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbListItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"] });
NbListItemComponent.propDecorators = {
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbListItemComponent, [{
        type: Component,
        args: [{
                selector: 'nb-list-item',
                template: `<ng-content></ng-content>`,
                styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
            }]
    }], function () { return []; }, { role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }] }); })();

/**
 * List pager directive
 *
 * Directive allows you to determine page of currently viewing items.
 *
 */
class NbListPageTrackerDirective {
    constructor() {
        this.destroy$ = new Subject();
        /**
         * Page to start counting with.
         */
        this.startPage = 1;
        /**
         * Emits when another page become visible.
         */
        this.pageChange = new EventEmitter();
        this.observer = new IntersectionObserver(entries => this.checkForPageChange(entries), { threshold: 0.5 });
    }
    ngAfterViewInit() {
        if (this.listItems && this.listItems.length) {
            this.observeItems();
        }
        this.listItems.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.observeItems());
    }
    ngOnDestroy() {
        this.observer.disconnect && this.observer.disconnect();
    }
    observeItems() {
        this.listItems.forEach(i => this.observer.observe(i.nativeElement));
    }
    checkForPageChange(entries) {
        const mostVisiblePage = this.findMostVisiblePage(entries);
        if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
            this.currentPage = mostVisiblePage;
            this.pageChange.emit(this.currentPage);
        }
    }
    findMostVisiblePage(entries) {
        const intersectionRatioByPage = new Map();
        for (const entry of entries) {
            if (entry.intersectionRatio < 0.5) {
                continue;
            }
            const elementIndex = this.elementIndex(entry.target);
            if (elementIndex === -1) {
                continue;
            }
            const page = this.startPage + Math.floor(elementIndex / this.pageSize);
            let ratio = entry.intersectionRatio;
            if (intersectionRatioByPage.has(page)) {
                ratio += intersectionRatioByPage.get(page);
            }
            intersectionRatioByPage.set(page, ratio);
        }
        let maxRatio = 0;
        let mostVisiblePage;
        intersectionRatioByPage.forEach((ratio, page) => {
            if (ratio > maxRatio) {
                maxRatio = ratio;
                mostVisiblePage = page;
            }
        });
        return mostVisiblePage;
    }
    elementIndex(element) {
        return element.parentElement && element.parentElement.children
            ? Array.from(element.parentElement.children).indexOf(element)
            : -1;
    }
}
NbListPageTrackerDirective.ɵfac = function NbListPageTrackerDirective_Factory(t) { return new (t || NbListPageTrackerDirective)(); };
NbListPageTrackerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbListPageTrackerDirective, selectors: [["", "nbListPageTracker", ""]], contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbListItemComponent, 0, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItems = _t);
    } }, inputs: { startPage: "startPage", pageSize: "pageSize" }, outputs: { pageChange: "pageChange" } });
NbListPageTrackerDirective.ctorParameters = () => [];
NbListPageTrackerDirective.propDecorators = {
    pageSize: [{ type: Input }],
    startPage: [{ type: Input }],
    pageChange: [{ type: Output }],
    listItems: [{ type: ContentChildren, args: [NbListItemComponent, { read: ElementRef },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbListPageTrackerDirective, [{
        type: Directive,
        args: [{
                selector: '[nbListPageTracker]'
            }]
    }], function () { return []; }, { startPage: [{
            type: Input
        }], pageChange: [{
            type: Output
        }], pageSize: [{
            type: Input
        }], listItems: [{
            type: ContentChildren,
            args: [NbListItemComponent, { read: ElementRef }]
        }] }); })();

class NbScrollableContainerDimentions {
}
/**
 * Infinite List Directive
 *
 * ```html
 *  <nb-list nbInfiniteList [threshold]="500" (bottomThreshold)="loadNext()">
 *    <nb-list-item *ngFor="let item of items"></nb-list-item>
 *  </nb-list>
 * ```
 *
 * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)
 *
 * Directive will notify when list scrolled up or down to a given threshold.
 * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.
 *
 * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)
 *
 * To improve UX of infinite lists, it's better to keep current page in url,
 * so user able to return to the last viewed page or to share a link to this page.
 * `nbListPageTracker` directive will help you to know, what page user currently viewing.
 * Just put it on a list, set page size and it will calculate page that currently in viewport.
 * You can [open the example](example/infinite-list/infinite-news-list.component)
 * in a new tab to check out this feature.
 *
 * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)
 *
 * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)
 *
 */
class NbInfiniteListDirective {
    constructor(elementRef, scrollService, dimensionsService) {
        this.elementRef = elementRef;
        this.scrollService = scrollService;
        this.dimensionsService = dimensionsService;
        this.destroy$ = new Subject();
        this.windowScroll = false;
        /**
         * Emits when distance between list bottom and current scroll position is less than threshold.
         */
        this.bottomThreshold = new EventEmitter(true);
        /**
         * Emits when distance between list top and current scroll position is less than threshold.
         */
        this.topThreshold = new EventEmitter(true);
    }
    get elementScroll() {
        return !this.windowScroll;
    }
    /**
     * By default component observes list scroll position.
     * If set to `true`, component will observe position of page scroll instead.
     */
    set listenWindowScroll(value) {
        this.windowScroll = convertToBoolProperty(value);
    }
    onElementScroll() {
        if (this.elementScroll) {
            this.checkPosition(this.elementRef.nativeElement);
        }
    }
    ngAfterViewInit() {
        this.scrollService.onScroll()
            .pipe(filter(() => this.windowScroll), switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$))
            .subscribe(dimentions => this.checkPosition(dimentions));
        this.listItems.changes
            .pipe(
        // For some reason, changes are emitted before list item removed from dom,
        // so dimensions will be incorrect.
        // Check every 50ms for a second if dom and query are in sync.
        // Once they synchronized, we can get proper dimensions.
        switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1000)))), switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$))
            .subscribe(dimentions => this.checkPosition(dimentions));
        this.getContainerDimensions().subscribe(dimentions => this.checkPosition(dimentions));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkPosition({ scrollHeight, scrollTop, clientHeight }) {
        const initialCheck = this.lastScrollPosition == null;
        const manualCheck = this.lastScrollPosition === scrollTop;
        const scrollUp = scrollTop < this.lastScrollPosition;
        const scrollDown = scrollTop > this.lastScrollPosition;
        const distanceToBottom = scrollHeight - scrollTop - clientHeight;
        if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
            this.bottomThreshold.emit();
        }
        if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
            this.topThreshold.emit();
        }
        this.lastScrollPosition = scrollTop;
    }
    getContainerDimensions() {
        if (this.elementScroll) {
            const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;
            return of({ scrollTop, scrollHeight, clientHeight });
        }
        return forkJoin(this.scrollService.getPosition(), this.dimensionsService.getDimensions())
            .pipe(map(([scrollPosition, dimensions]) => ({
            scrollTop: scrollPosition.y,
            scrollHeight: dimensions.scrollHeight,
            clientHeight: dimensions.clientHeight,
        })));
    }
    inSyncWithDom() {
        return this.elementRef.nativeElement.children.length === this.listItems.length;
    }
}
NbInfiniteListDirective.ɵfac = function NbInfiniteListDirective_Factory(t) { return new (t || NbInfiniteListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbLayoutScrollService), ɵngcc0.ɵɵdirectiveInject(NbLayoutRulerService)); };
NbInfiniteListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbInfiniteListDirective, selectors: [["", "nbInfiniteList", ""]], contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbListItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItems = _t);
    } }, hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() { return ctx.onElementScroll(); });
    } }, inputs: { listenWindowScroll: "listenWindowScroll", threshold: "threshold" }, outputs: { bottomThreshold: "bottomThreshold", topThreshold: "topThreshold" } });
NbInfiniteListDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbLayoutScrollService },
    { type: NbLayoutRulerService }
];
NbInfiniteListDirective.propDecorators = {
    threshold: [{ type: Input }],
    listenWindowScroll: [{ type: Input }],
    bottomThreshold: [{ type: Output }],
    topThreshold: [{ type: Output }],
    onElementScroll: [{ type: HostListener, args: ['scroll',] }],
    listItems: [{ type: ContentChildren, args: [NbListItemComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbInfiniteListDirective, [{
        type: Directive,
        args: [{
                selector: '[nbInfiniteList]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbLayoutScrollService }, { type: NbLayoutRulerService }]; }, { bottomThreshold: [{
            type: Output
        }], topThreshold: [{
            type: Output
        }], listenWindowScroll: [{
            type: Input
        }], onElementScroll: [{
            type: HostListener,
            args: ['scroll']
        }], threshold: [{
            type: Input
        }], listItems: [{
            type: ContentChildren,
            args: [NbListItemComponent]
        }] }); })();

const components = [
    NbListComponent,
    NbListItemComponent,
    NbListPageTrackerDirective,
    NbInfiniteListDirective,
];
class NbListModule {
}
NbListModule.ɵfac = function NbListModule_Factory(t) { return new (t || NbListModule)(); };
NbListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbListModule });
NbListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbListModule, { declarations: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective], exports: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbListModule, [{
        type: NgModule,
        args: [{
                declarations: components,
                exports: components
            }]
    }], null, null); })();

class NbDirectionality extends Directionality {
}
NbDirectionality.ɵfac = function NbDirectionality_Factory(t) { return ɵNbDirectionality_BaseFactory(t || NbDirectionality); };
NbDirectionality.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDirectionality, factory: NbDirectionality.ɵfac });
const ɵNbDirectionality_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbDirectionality);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDirectionality, [{
        type: Injectable
    }], null, null); })();

class NbBidiModule extends BidiModule {
}
NbBidiModule.ɵfac = function NbBidiModule_Factory(t) { return ɵNbBidiModule_BaseFactory(t || NbBidiModule); };
NbBidiModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBidiModule });
NbBidiModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        { provide: NbDirectionality, useExisting: Directionality },
    ] });
const ɵNbBidiModule_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbBidiModule);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbBidiModule, [{
        type: NgModule,
        args: [{
                providers: [
                    { provide: NbDirectionality, useExisting: Directionality },
                ]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license infornbion.
 */
/**
 * Cell definition for the nb-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
class NbCellDefDirective extends CdkCellDef {
}
NbCellDefDirective.ɵfac = function NbCellDefDirective_Factory(t) { return ɵNbCellDefDirective_BaseFactory(t || NbCellDefDirective); };
NbCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellDefDirective, selectors: [["", "nbCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkCellDef, useExisting: NbCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbCellDef]',
                providers: [{ provide: CdkCellDef, useExisting: NbCellDefDirective }]
            }]
    }], null, null); })();
/**
 * Header cell definition for the nb-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
class NbHeaderCellDefDirective extends CdkHeaderCellDef {
}
NbHeaderCellDefDirective.ɵfac = function NbHeaderCellDefDirective_Factory(t) { return ɵNbHeaderCellDefDirective_BaseFactory(t || NbHeaderCellDefDirective); };
NbHeaderCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderCellDefDirective, selectors: [["", "nbHeaderCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderCellDef, useExisting: NbHeaderCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbHeaderCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbHeaderCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbHeaderCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderCellDef]',
                providers: [{ provide: CdkHeaderCellDef, useExisting: NbHeaderCellDefDirective }]
            }]
    }], null, null); })();
/**
 * Footer cell definition for the nb-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
class NbFooterCellDefDirective extends CdkFooterCellDef {
}
NbFooterCellDefDirective.ɵfac = function NbFooterCellDefDirective_Factory(t) { return ɵNbFooterCellDefDirective_BaseFactory(t || NbFooterCellDefDirective); };
NbFooterCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterCellDefDirective, selectors: [["", "nbFooterCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterCellDef, useExisting: NbFooterCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbFooterCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFooterCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFooterCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterCellDef]',
                providers: [{ provide: CdkFooterCellDef, useExisting: NbFooterCellDefDirective }]
            }]
    }], null, null); })();
const NB_SORT_HEADER_COLUMN_DEF = new InjectionToken('NB_SORT_HEADER_COLUMN_DEF');
/**
 * Column definition for the nb-table.
 * Defines a set of cells available for a table column.
 */
class NbColumnDefDirective extends CdkColumnDef {
    /** Unique name for this column. */
    get name() {
        return this._name;
    }
    set name(value) {
        this._setNameInput(value);
    }
    /** Whether this column should be sticky positioned on the end of the row */
    get stickyEnd() {
        return this._stickyEnd;
    }
    set stickyEnd(value) {
        const prevValue = this._stickyEnd;
        this._stickyEnd = coerceBooleanProperty(value);
        this._hasStickyChanged = prevValue !== this._stickyEnd;
    }
}
NbColumnDefDirective.ɵfac = function NbColumnDefDirective_Factory(t) { return ɵNbColumnDefDirective_BaseFactory(t || NbColumnDefDirective); };
NbColumnDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbColumnDefDirective, selectors: [["", "nbColumnDef", ""]], inputs: { name: ["nbColumnDef", "name"], stickyEnd: "stickyEnd", sticky: "sticky" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: CdkColumnDef, useExisting: NbColumnDefDirective },
            { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbColumnDefDirective },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbColumnDefDirective.propDecorators = {
    name: [{ type: Input, args: ['nbColumnDef',] }],
    sticky: [{ type: Input }],
    stickyEnd: [{ type: Input }]
};
const ɵNbColumnDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbColumnDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbColumnDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbColumnDef]',
                providers: [
                    { provide: CdkColumnDef, useExisting: NbColumnDefDirective },
                    { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbColumnDefDirective },
                ]
            }]
    }], null, { name: [{
            type: Input,
            args: ['nbColumnDef']
        }], stickyEnd: [{
            type: Input
        }], sticky: [{
            type: Input
        }] }); })();
/** Header cell template container that adds the right classes and role. */
class NbHeaderCellDirective extends CdkHeaderCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
}
NbHeaderCellDirective.ɵfac = function NbHeaderCellDirective_Factory(t) { return new (t || NbHeaderCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbHeaderCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderCellDirective, selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]], hostAttrs: ["role", "columnheader", 1, "nb-header-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbHeaderCellDirective.ctorParameters = () => [
    { type: NbColumnDefDirective },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbHeaderCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-header-cell, th[nbHeaderCell]',
                host: {
                    'class': 'nb-header-cell',
                    'role': 'columnheader'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();
/** Footer cell template container that adds the right classes and role. */
class NbFooterCellDirective extends CdkFooterCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
}
NbFooterCellDirective.ɵfac = function NbFooterCellDirective_Factory(t) { return new (t || NbFooterCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbFooterCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterCellDirective, selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbFooterCellDirective.ctorParameters = () => [
    { type: NbColumnDefDirective },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFooterCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-footer-cell, td[nbFooterCell]',
                host: {
                    'class': 'nb-footer-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();
/** Cell template container that adds the right classes and role. */
class NbCellDirective extends CdkCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
}
NbCellDirective.ɵfac = function NbCellDirective_Factory(t) { return new (t || NbCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellDirective, selectors: [["nb-cell"], ["td", "nbCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbCellDirective.ctorParameters = () => [
    { type: NbColumnDefDirective },
    { type: ElementRef }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-cell, td[nbCell]',
                host: {
                    'class': 'nb-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();

class NbDataSource extends DataSource {
}

class NbDataRowOutletDirective extends DataRowOutlet {
}
NbDataRowOutletDirective.ɵfac = function NbDataRowOutletDirective_Factory(t) { return ɵNbDataRowOutletDirective_BaseFactory(t || NbDataRowOutletDirective); };
NbDataRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbDataRowOutletDirective, selectors: [["", "nbRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: DataRowOutlet, useExisting: NbDataRowOutletDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbDataRowOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbDataRowOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDataRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbRowOutlet]',
                providers: [{ provide: DataRowOutlet, useExisting: NbDataRowOutletDirective }]
            }]
    }], null, null); })();
class NbHeaderRowOutletDirective extends HeaderRowOutlet {
}
NbHeaderRowOutletDirective.ɵfac = function NbHeaderRowOutletDirective_Factory(t) { return ɵNbHeaderRowOutletDirective_BaseFactory(t || NbHeaderRowOutletDirective); };
NbHeaderRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderRowOutletDirective, selectors: [["", "nbHeaderRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: HeaderRowOutlet, useExisting: NbHeaderRowOutletDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbHeaderRowOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbHeaderRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderRowOutlet]',
                providers: [{ provide: HeaderRowOutlet, useExisting: NbHeaderRowOutletDirective }]
            }]
    }], null, null); })();
class NbFooterRowOutletDirective extends FooterRowOutlet {
}
NbFooterRowOutletDirective.ɵfac = function NbFooterRowOutletDirective_Factory(t) { return ɵNbFooterRowOutletDirective_BaseFactory(t || NbFooterRowOutletDirective); };
NbFooterRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterRowOutletDirective, selectors: [["", "nbFooterRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: FooterRowOutlet, useExisting: NbFooterRowOutletDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbFooterRowOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFooterRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterRowOutlet]',
                providers: [{ provide: FooterRowOutlet, useExisting: NbFooterRowOutletDirective }]
            }]
    }], null, null); })();
class NbNoDataRowOutletDirective extends NoDataRowOutlet {
}
NbNoDataRowOutletDirective.ɵfac = function NbNoDataRowOutletDirective_Factory(t) { return ɵNbNoDataRowOutletDirective_BaseFactory(t || NbNoDataRowOutletDirective); };
NbNoDataRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbNoDataRowOutletDirective, selectors: [["", "nbNoDataRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NoDataRowOutlet, useExisting: NbNoDataRowOutletDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbNoDataRowOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbNoDataRowOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbNoDataRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbNoDataRowOutlet]',
                providers: [{ provide: NoDataRowOutlet, useExisting: NbNoDataRowOutletDirective }]
            }]
    }], null, null); })();
class NbCellOutletDirective extends CdkCellOutlet {
}
NbCellOutletDirective.ɵfac = function NbCellOutletDirective_Factory(t) { return ɵNbCellOutletDirective_BaseFactory(t || NbCellOutletDirective); };
NbCellOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellOutletDirective, selectors: [["", "nbCellOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkCellOutlet, useExisting: NbCellOutletDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbCellOutletDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbCellOutletDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbCellOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbCellOutlet]',
                providers: [{ provide: CdkCellOutlet, useExisting: NbCellOutletDirective }]
            }]
    }], null, null); })();
/**
 * Header row definition for the nb-table.
 * Captures the header row's template and other header properties such as the columns to display.
 */
class NbHeaderRowDefDirective extends CdkHeaderRowDef {
}
NbHeaderRowDefDirective.ɵfac = function NbHeaderRowDefDirective_Factory(t) { return ɵNbHeaderRowDefDirective_BaseFactory(t || NbHeaderRowDefDirective); };
NbHeaderRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderRowDefDirective, selectors: [["", "nbHeaderRowDef", ""]], inputs: { columns: ["nbHeaderRowDef", "columns"], sticky: ["nbHeaderRowDefSticky", "sticky"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderRowDef, useExisting: NbHeaderRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbHeaderRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbHeaderRowDef',] }],
    sticky: [{ type: Input, args: ['nbHeaderRowDefSticky',] }]
};
const ɵNbHeaderRowDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbHeaderRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderRowDef]',
                providers: [{ provide: CdkHeaderRowDef, useExisting: NbHeaderRowDefDirective }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbHeaderRowDef']
        }], sticky: [{
            type: Input,
            args: ['nbHeaderRowDefSticky']
        }] }); })();
/**
 * Footer row definition for the nb-table.
 * Captures the footer row's template and other footer properties such as the columns to display.
 */
class NbFooterRowDefDirective extends CdkFooterRowDef {
}
NbFooterRowDefDirective.ɵfac = function NbFooterRowDefDirective_Factory(t) { return ɵNbFooterRowDefDirective_BaseFactory(t || NbFooterRowDefDirective); };
NbFooterRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterRowDefDirective, selectors: [["", "nbFooterRowDef", ""]], inputs: { columns: ["nbFooterRowDef", "columns"], sticky: ["nbFooterRowDefSticky", "sticky"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterRowDef, useExisting: NbFooterRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbFooterRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbFooterRowDef',] }],
    sticky: [{ type: Input, args: ['nbFooterRowDefSticky',] }]
};
const ɵNbFooterRowDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFooterRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterRowDef]',
                providers: [{ provide: CdkFooterRowDef, useExisting: NbFooterRowDefDirective }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbFooterRowDef']
        }], sticky: [{
            type: Input,
            args: ['nbFooterRowDefSticky']
        }] }); })();
/**
 * Data row definition for the nb-table.
 * Captures the data row's template and other properties such as the columns to display and
 * a when predicate that describes when this row should be used.
 */
class NbRowDefDirective extends CdkRowDef {
}
NbRowDefDirective.ɵfac = function NbRowDefDirective_Factory(t) { return ɵNbRowDefDirective_BaseFactory(t || NbRowDefDirective); };
NbRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbRowDefDirective, selectors: [["", "nbRowDef", ""]], inputs: { columns: ["nbRowDefColumns", "columns"], when: ["nbRowDefWhen", "when"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRowDef, useExisting: NbRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbRowDefColumns',] }],
    when: [{ type: Input, args: ['nbRowDefWhen',] }]
};
const ɵNbRowDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbRowDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbRowDef]',
                providers: [{ provide: CdkRowDef, useExisting: NbRowDefDirective }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbRowDefColumns']
        }], when: [{
            type: Input,
            args: ['nbRowDefWhen']
        }] }); })();
/** Footer template container that contains the cell outlet. Adds the right class and role. */
class NbHeaderRowComponent extends CdkHeaderRow {
}
NbHeaderRowComponent.ɵfac = function NbHeaderRowComponent_Factory(t) { return ɵNbHeaderRowComponent_BaseFactory(t || NbHeaderRowComponent); };
NbHeaderRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbHeaderRowComponent, selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]], hostAttrs: ["role", "row", 1, "nb-header-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderRow, useExisting: NbHeaderRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbHeaderRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
const ɵNbHeaderRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbHeaderRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-header-row, tr[nbHeaderRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-header-row',
                    'role': 'row'
                },
                providers: [{ provide: CdkHeaderRow, useExisting: NbHeaderRowComponent }]
            }]
    }], null, null); })();
/** Footer template container that contains the cell outlet. Adds the right class and role. */
class NbFooterRowComponent extends CdkFooterRow {
}
NbFooterRowComponent.ɵfac = function NbFooterRowComponent_Factory(t) { return ɵNbFooterRowComponent_BaseFactory(t || NbFooterRowComponent); };
NbFooterRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbFooterRowComponent, selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]], hostAttrs: ["role", "row", 1, "nb-footer-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterRow, useExisting: NbFooterRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbFooterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
const ɵNbFooterRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFooterRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-footer-row, tr[nbFooterRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-footer-row',
                    'role': 'row'
                },
                providers: [{ provide: CdkFooterRow, useExisting: NbFooterRowComponent }]
            }]
    }], null, null); })();
/** Data row template container that contains the cell outlet. Adds the right class and role. */
class NbRowComponent extends CdkRow {
}
NbRowComponent.ɵfac = function NbRowComponent_Factory(t) { return ɵNbRowComponent_BaseFactory(t || NbRowComponent); };
NbRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRowComponent, selectors: [["nb-row"], ["tr", "nbRow", ""]], hostAttrs: ["role", "row", 1, "nb-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRow, useExisting: NbRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
const ɵNbRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbRowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-row, tr[nbRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-row',
                    'role': 'row'
                },
                providers: [{ provide: CdkRow, useExisting: NbRowComponent }]
            }]
    }], null, null); })();

const NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbNoDataRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>
`;
const NB_VIEW_REPEATER_STRATEGY = _VIEW_REPEATER_STRATEGY;
const NB_COALESCED_STYLE_SCHEDULER = _COALESCED_STYLE_SCHEDULER;
const NB_TABLE_PROVIDERS = [
    { provide: NB_VIEW_REPEATER_STRATEGY, useClass: _DisposeViewRepeaterStrategy },
    { provide: NB_COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },
];
// tslint:disable-next-line:component-class-suffix
class NbTable extends CdkTable {
    constructor(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler) {
        super(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler);
        this._viewRepeater = _viewRepeater;
        this._coalescedStyleScheduler = _coalescedStyleScheduler;
    }
}
NbTable.ɵfac = function NbTable_Factory(t) { return new (t || NbTable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NbDirectionality), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPlatform), ɵngcc0.ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER, 8)); };
NbTable.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTable, selectors: [["nb-table-not-implemented"]], features: [ɵngcc0.ɵɵProvidersFeature(NB_TABLE_PROVIDERS), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbTable_Template(rf, ctx) { }, encapsulation: 2 });
NbTable.ctorParameters = () => [
    { type: IterableDiffers },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
    { type: NbDirectionality },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbPlatform },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [_VIEW_REPEATER_STRATEGY,] }] },
    { type: _CoalescedStyleScheduler, decorators: [{ type: Optional }, { type: Inject, args: [_COALESCED_STYLE_SCHEDULER,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTable, [{
        type: Component,
        args: [{
                selector: 'nb-table-not-implemented',
                template: ``,
                providers: NB_TABLE_PROVIDERS
            }]
    }], function () { return [{ type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NbDirectionality }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPlatform }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [_VIEW_REPEATER_STRATEGY]
            }] }, { type: ɵngcc7._CoalescedStyleScheduler, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [_COALESCED_STYLE_SCHEDULER]
            }] }]; }, null); })();
const COMPONENTS$1 = [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent,
];
class NbTableModule extends CdkTableModule {
}
NbTableModule.ɵfac = function NbTableModule_Factory(t) { return ɵNbTableModule_BaseFactory(t || NbTableModule); };
NbTableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTableModule });
NbTableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbBidiModule]] });
const ɵNbTableModule_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTableModule);
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTableModule, { declarations: [NbTable, NbHeaderCellDefDirective, NbHeaderRowDefDirective, NbColumnDefDirective, NbCellDefDirective, NbRowDefDirective, NbFooterCellDefDirective, NbFooterRowDefDirective, NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective, NbCellOutletDirective, NbHeaderCellDirective, NbCellDirective, NbFooterCellDirective, NbHeaderRowComponent, NbRowComponent, NbFooterRowComponent], imports: [NbBidiModule], exports: [NbTable, NbHeaderCellDefDirective, NbHeaderRowDefDirective, NbColumnDefDirective, NbCellDefDirective, NbRowDefDirective, NbFooterCellDefDirective, NbFooterRowDefDirective, NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective, NbCellOutletDirective, NbHeaderCellDirective, NbCellDirective, NbFooterCellDirective, NbHeaderRowComponent, NbRowComponent, NbFooterRowComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTableModule, [{
        type: NgModule,
        args: [{
                imports: [NbBidiModule],
                declarations: [...COMPONENTS$1],
                exports: [...COMPONENTS$1]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_DIALOG_CONFIG = new InjectionToken('Default dialog options');
/**
 * Describes all available options that may be passed to the NbDialogService.
 * */
class NbDialogConfig {
    constructor(config) {
        /**
         * If true than overlay will render backdrop under a dialog.
         * */
        this.hasBackdrop = true;
        /**
         * Class that'll be assigned to the backdrop element.
         * */
        this.backdropClass = 'overlay-backdrop';
        /**
         * Class that'll be assigned to the dialog overlay.
         * */
        this.dialogClass = '';
        /**
         * If true then mouse clicks by backdrop will close a dialog.
         * */
        this.closeOnBackdropClick = true;
        /**
         * If true then escape press will close a dialog.
         * */
        this.closeOnEsc = true;
        /**
         * Disables scroll on content under dialog if true and does nothing otherwise.
         * */
        this.hasScroll = false;
        /**
         * Focuses dialog automatically after open if true.
         * */
        this.autoFocus = true;
        Object.assign(this, config);
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbDialogRef` helps to manipulate dialog after it was created.
 * The dialog can be dismissed by using `close` method of the dialogRef.
 * You can access rendered component as `content` property of the dialogRef.
 * `onBackdropClick` streams click events on the backdrop of the dialog.
 * */
class NbDialogRef {
    constructor(overlayRef) {
        this.overlayRef = overlayRef;
        this.onClose$ = new Subject();
        this.onClose = this.onClose$.asObservable();
        this.onBackdropClick = this.overlayRef.backdropClick();
    }
    /**
     * Hides dialog.
     * */
    close(res) {
        this.overlayRef.detach();
        this.overlayRef.dispose();
        this.onClose$.next(res);
        this.onClose$.complete();
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Container component for each dialog.
 * All the dialogs will be attached to it.
 * // TODO add animations
 * */
class NbDialogContainerComponent {
    constructor(config, elementRef, focusTrapFactory) {
        this.config = config;
        this.elementRef = elementRef;
        this.focusTrapFactory = focusTrapFactory;
    }
    ngOnInit() {
        if (this.config.autoFocus) {
            this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
            this.focusTrap.blurPreviouslyFocusedElement();
            this.focusTrap.focusInitialElement();
        }
    }
    ngOnDestroy() {
        if (this.config.autoFocus && this.focusTrap) {
            this.focusTrap.restoreFocus();
        }
    }
    attachComponentPortal(portal) {
        return this.portalOutlet.attachComponentPortal(portal);
    }
    attachTemplatePortal(portal) {
        return this.portalOutlet.attachTemplatePortal(portal);
    }
}
NbDialogContainerComponent.ɵfac = function NbDialogContainerComponent_Factory(t) { return new (t || NbDialogContainerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDialogConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbFocusTrapFactoryService)); };
NbDialogContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDialogContainerComponent, selectors: [["nb-dialog-container"]], viewQuery: function NbDialogContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalOutletDirective, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, decls: 1, vars: 0, consts: [["nbPortalOutlet", ""]], template: function NbDialogContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [NbPortalOutletDirective], encapsulation: 2 });
NbDialogContainerComponent.ctorParameters = () => [
    { type: NbDialogConfig },
    { type: ElementRef },
    { type: NbFocusTrapFactoryService }
];
NbDialogContainerComponent.propDecorators = {
    portalOutlet: [{ type: ViewChild, args: [NbPortalOutletDirective, { static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDialogContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-dialog-container',
                template: '<ng-template nbPortalOutlet></ng-template>'
            }]
    }], function () { return [{ type: NbDialogConfig }, { type: ɵngcc0.ElementRef }, { type: NbFocusTrapFactoryService }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [NbPortalOutletDirective, { static: true }]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbDialogService` helps to open dialogs.
 *
 * @stacked-example(Showcase, dialog/dialog-showcase.component)
 *
 * A new dialog is opened by calling the `open` method with a component to be loaded and an optional configuration.
 * `open` method will return `NbDialogRef` that can be used for the further manipulations.
 *
 * ### Installation
 *
 * Import `NbDialogModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDialogModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * If you are using it in a lazy loaded module than you have to install it with `NbDialogModule.forChild()`:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDialogModule.forChild(config),
 *   ],
 * })
 * export class LazyLoadedModule { }
 * ```
 *
 * ### Usage
 *
 * ```ts
 * const dialogRef = this.dialogService.open(MyDialogComponent, { ... });
 * ```
 *
 * `NbDialogRef` gives capability access reference to the rendered dialog component,
 * destroy dialog and some other options described below.
 *
 * Also, you can inject `NbDialogRef` in dialog component.
 *
 * ```ts
 * this.dialogService.open(MyDialogComponent, { ... });
 *
 * // my-dialog.component.ts
 * constructor(protected dialogRef: NbDialogRef) {
 * }
 *
 * close() {
 *   this.dialogRef.close();
 * }
 * ```
 *
 * Instead of component you can create dialog from TemplateRef:
 *
 * @stacked-example(Template ref, dialog/dialog-template.component)
 *
 * The dialog may return result through `NbDialogRef`. Calling component can receive this result with `onClose`
 * stream of `NbDialogRef`.
 *
 * @stacked-example(Result, dialog/dialog-result.component)
 *
 * ### Configuration
 *
 * As we mentioned above, `open` method of the `NbDialogService` may receive optional configuration options.
 * Also, you can provide global dialogs configuration through `NbDialogModule.forRoot({ ... })`.
 *
 * This config may contain the following:
 *
 * `context` - both, template and component may receive data through `config.context` property.
 * For components, this data will be assigned through inputs.
 * For templates, you can access it inside template as $implicit.
 *
 * ```ts
 * this.dialogService.open(template, { context: 'pass data in template' });
 * ```
 *
 * ```html
 * <ng-template let-some-additional-data>
 *   {{ some-additional-data }}
 * <ng-template/>
 * ```
 *
 * `hasBackdrop` - determines is service have to render backdrop under the dialog.
 * Default is true.
 * @stacked-example(Backdrop, dialog/dialog-has-backdrop.component)
 *
 * `closeOnBackdropClick` - close dialog on backdrop click if true.
 * Default is true.
 * @stacked-example(Backdrop click, dialog/dialog-backdrop-click.component)
 *
 * `closeOnEsc` - close dialog on escape button on the keyboard.
 * Default is true.
 * @stacked-example(Escape hit, dialog/dialog-esc.component)
 *
 * `hasScroll` - Disables scroll on content under dialog if true and does nothing otherwise.
 * Default is false.
 * Please, open dialogs in the separate window and try to scroll.
 * @stacked-example(Scroll, dialog/dialog-scroll.component)
 *
 * `autoFocus` - Focuses dialog automatically after open if true. It's useful to prevent misclicks on
 * trigger elements and opening multiple dialogs.
 * Default is true.
 *
 * As you can see, if you open dialog with auto focus dialog will focus first focusable element
 * or just blur previously focused automatically.
 * Otherwise, without auto focus, the focus will stay on the previously focused element.
 * Please, open dialogs in the separate window and try to click on the button without focus
 * and then hit space any times. Multiple same dialogs will be opened.
 * @stacked-example(Auto focus, dialog/dialog-auto-focus.component)
 * */
class NbDialogService {
    constructor(document, globalConfig, positionBuilder, overlay, injector, cfr) {
        this.document = document;
        this.globalConfig = globalConfig;
        this.positionBuilder = positionBuilder;
        this.overlay = overlay;
        this.injector = injector;
        this.cfr = cfr;
    }
    /**
     * Opens new instance of the dialog, may receive optional config.
     * */
    open(content, userConfig = {}) {
        const config = new NbDialogConfig(Object.assign(Object.assign({}, this.globalConfig), userConfig));
        const overlayRef = this.createOverlay(config);
        const dialogRef = new NbDialogRef(overlayRef);
        const container = this.createContainer(config, overlayRef);
        this.createContent(config, content, container, dialogRef);
        this.registerCloseListeners(config, overlayRef, dialogRef);
        return dialogRef;
    }
    createOverlay(config) {
        const positionStrategy = this.createPositionStrategy();
        const scrollStrategy = this.createScrollStrategy(config.hasScroll);
        return this.overlay.create({
            positionStrategy,
            scrollStrategy,
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.dialogClass,
        });
    }
    createPositionStrategy() {
        return this.positionBuilder
            .global()
            .centerVertically()
            .centerHorizontally();
    }
    createScrollStrategy(hasScroll) {
        if (hasScroll) {
            return this.overlay.scrollStrategies.noop();
        }
        else {
            return this.overlay.scrollStrategies.block();
        }
    }
    createContainer(config, overlayRef) {
        const injector = new NbPortalInjector(this.createInjector(config), new WeakMap([[NbDialogConfig, config]]));
        const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector, this.cfr);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    createContent(config, content, container, dialogRef) {
        if (content instanceof TemplateRef) {
            const portal = this.createTemplatePortal(config, content, dialogRef);
            container.attachTemplatePortal(portal);
        }
        else {
            const portal = this.createComponentPortal(config, content, dialogRef);
            dialogRef.componentRef = container.attachComponentPortal(portal);
            if (config.context) {
                Object.assign(dialogRef.componentRef.instance, Object.assign({}, config.context));
            }
        }
    }
    createTemplatePortal(config, content, dialogRef) {
        return new NbTemplatePortal(content, null, { $implicit: config.context, dialogRef });
    }
    /**
     * We're creating portal with custom injector provided through config or using global injector.
     * This approach provides us capability inject `NbDialogRef` in dialog component.
     * */
    createComponentPortal(config, content, dialogRef) {
        const injector = this.createInjector(config);
        const portalInjector = new NbPortalInjector(injector, new WeakMap([[NbDialogRef, dialogRef]]));
        return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
    }
    createInjector(config) {
        return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
    }
    registerCloseListeners(config, overlayRef, dialogRef) {
        if (config.closeOnBackdropClick) {
            overlayRef.backdropClick().subscribe(() => dialogRef.close());
        }
        if (config.closeOnEsc) {
            fromEvent(this.document, 'keyup')
                .pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose))
                .subscribe(() => dialogRef.close());
        }
    }
}
NbDialogService.ɵfac = function NbDialogService_Factory(t) { return new (t || NbDialogService)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NB_DIALOG_CONFIG), ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
NbDialogService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDialogService, factory: NbDialogService.ɵfac });
NbDialogService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DIALOG_CONFIG,] }] },
    { type: NbPositionBuilderService },
    { type: NbOverlayService },
    { type: Injector },
    { type: ComponentFactoryResolver }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDialogService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DIALOG_CONFIG]
            }] }, { type: NbPositionBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDialogModule {
    static forRoot(dialogConfig = {}) {
        return {
            ngModule: NbDialogModule,
            providers: [
                NbDialogService,
                { provide: NB_DIALOG_CONFIG, useValue: dialogConfig },
            ],
        };
    }
    static forChild(dialogConfig = {}) {
        return {
            ngModule: NbDialogModule,
            providers: [
                NbDialogService,
                { provide: NB_DIALOG_CONFIG, useValue: dialogConfig },
            ],
        };
    }
}
NbDialogModule.ɵfac = function NbDialogModule_Factory(t) { return new (t || NbDialogModule)(); };
NbDialogModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbDialogModule });
NbDialogModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbSharedModule, NbOverlayModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbDialogModule, { declarations: [NbDialogContainerComponent], imports: [NbSharedModule, NbOverlayModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDialogModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule],
                declarations: [NbDialogContainerComponent],
                entryComponents: [NbDialogContainerComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbToast {
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbToastComponent` is responsible for rendering each toast with appropriate styles.
 *
 * @styles
 *
 * toastr-border-style:
 * toastr-border-width:
 * toastr-border-radius:
 * toastr-padding:
 * toastr-shadow:
 * toastr-text-font-family:
 * toastr-text-font-size:
 * toastr-text-font-weight:
 * toastr-text-line-height:
 * toastr-title-text-font-family:
 * toastr-title-text-font-size:
 * toastr-title-text-font-weight:
 * toastr-title-text-line-height:
 * toastr-basic-background-color:
 * toastr-basic-border-color:
 * toastr-basic-text-color:
 * toastr-icon-basic-background-color:
 * toastr-icon-basic-color:
 * toastr-destroyable-basic-hover-background-color:
 * toastr-destroyable-basic-hover-border-color:
 * toastr-primary-background-color:
 * toastr-primary-border-color:
 * toastr-primary-text-color:
 * toastr-icon-primary-background-color:
 * toastr-icon-primary-color:
 * toastr-destroyable-primary-hover-background-color:
 * toastr-destroyable-primary-hover-border-color:
 * toastr-success-background-color:
 * toastr-success-border-color:
 * toastr-success-text-color:
 * toastr-icon-success-background-color:
 * toastr-icon-success-color:
 * toastr-destroyable-success-hover-background-color:
 * toastr-destroyable-success-hover-border-color:
 * toastr-info-background-color:
 * toastr-info-border-color:
 * toastr-info-text-color:
 * toastr-icon-info-background-color:
 * toastr-icon-info-color:
 * toastr-destroyable-info-hover-background-color:
 * toastr-destroyable-info-hover-border-color:
 * toastr-warning-background-color:
 * toastr-warning-border-color:
 * toastr-warning-text-color:
 * toastr-icon-warning-background-color:
 * toastr-icon-warning-color:
 * toastr-destroyable-warning-hover-background-color:
 * toastr-destroyable-warning-hover-border-color:
 * toastr-danger-background-color:
 * toastr-danger-border-color:
 * toastr-danger-text-color:
 * toastr-icon-danger-background-color:
 * toastr-icon-danger-color:
 * toastr-destroyable-danger-hover-background-color:
 * toastr-destroyable-danger-hover-border-color:
 * toastr-control-background-color:
 * toastr-control-border-color:
 * toastr-control-text-color:
 * toastr-icon-control-background-color:
 * toastr-icon-control-color:
 * toastr-destroyable-control-hover-background-color:
 * toastr-destroyable-control-hover-border-color:
 * */
class NbToastComponent {
    constructor(renderer, elementRef, statusService) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.statusService = statusService;
        this.destroy = new EventEmitter();
    }
    get success() {
        return this.toast.config.status === 'success';
    }
    get info() {
        return this.toast.config.status === 'info';
    }
    get warning() {
        return this.toast.config.status === 'warning';
    }
    get primary() {
        return this.toast.config.status === 'primary';
    }
    get danger() {
        return this.toast.config.status === 'danger';
    }
    get basic() {
        return this.toast.config.status === 'basic';
    }
    get control() {
        return this.toast.config.status === 'control';
    }
    get destroyByClick() {
        return this.toast.config.destroyByClick;
    }
    get hasIcon() {
        const { icon } = this.toast.config;
        if (typeof icon === 'string') {
            return true;
        }
        return !!(icon && icon.icon);
    }
    get customIcon() {
        return !!this.icon;
    }
    get icon() {
        return this.toast.config.icon;
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.toast.config.status)) {
            return [this.statusService.getStatusClass(this.toast.config.status)];
        }
        return [];
    }
    onClick() {
        this.destroy.emit();
    }
    ngOnInit() {
        if (this.toast.config.toastClass) {
            this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
        }
    }
}
NbToastComponent.ɵfac = function NbToastComponent_Factory(t) { return new (t || NbToastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToastComponent, selectors: [["nb-toast"]], hostVars: 22, hostBindings: function NbToastComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbToastComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
    } }, inputs: { toast: "toast" }, outputs: { destroy: "destroy" }, decls: 6, vars: 3, consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]], template: function NbToastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasIcon && ctx.icon);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.toast.title);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.toast.message);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:0.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:0.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}"] });
NbToastComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NbStatusService }
];
NbToastComponent.propDecorators = {
    toast: [{ type: Input }],
    destroy: [{ type: Output }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    destroyByClick: [{ type: HostBinding, args: ['class.destroy-by-click',] }],
    hasIcon: [{ type: HostBinding, args: ['class.has-icon',] }],
    customIcon: [{ type: HostBinding, args: ['class.custom-icon',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToastComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toast',
                template: "<div class=\"icon-container\" *ngIf=\"hasIcon && icon\">\n  <nb-icon [config]=\"icon\"></nb-icon>\n</div>\n<div class=\"content-container\">\n  <span class=\"title subtitle\">{{ toast.title }}</span>\n  <div class=\"message\">{{ toast.message }}</div>\n</div>\n",
                styles: [":host{display:flex;align-items:center;width:25rem;margin:0.5rem}:host .title{margin-right:0.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: NbStatusService }]; }, { destroy: [{
            type: Output
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], destroyByClick: [{
            type: HostBinding,
            args: ['class.destroy-by-click']
        }], hasIcon: [{
            type: HostBinding,
            args: ['class.has-icon']
        }], customIcon: [{
            type: HostBinding,
            args: ['class.custom-icon']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], toast: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const voidState = style({
    transform: 'translateX({{ direction }}110%)',
    height: 0,
    marginLeft: '0',
    marginRight: '0',
    marginTop: '0',
    marginBottom: '0',
});
const defaultOptions = { params: { direction: '' } };
class NbToastrContainerComponent {
    constructor(layoutDirection, positionHelper) {
        this.layoutDirection = layoutDirection;
        this.positionHelper = positionHelper;
        this.destroy$ = new Subject();
        this.content = [];
    }
    ngOnInit() {
        this.layoutDirection.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.onDirectionChange());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onDirectionChange() {
        const direction = this.positionHelper.isRightPosition(this.position) ? '' : '-';
        this.fadeIn = { value: '', params: { direction } };
    }
}
NbToastrContainerComponent.ɵfac = function NbToastrContainerComponent_Factory(t) { return new (t || NbToastrContainerComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbPositionHelper)); };
NbToastrContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToastrContainerComponent, selectors: [["nb-toastr-container"]], viewQuery: function NbToastrContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbToastComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toasts = _t);
    } }, inputs: { content: "content", context: "context", position: "position" }, decls: 1, vars: 1, consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]], template: function NbToastrContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.content);
    } }, directives: [ɵngcc2.NgForOf, NbToastComponent], encapsulation: 2, data: { animation: [
            trigger('fadeIn', [
                transition(':enter', [voidState, animate(100)], defaultOptions),
                transition(':leave', [animate(100, voidState)], defaultOptions),
            ]),
        ] } });
NbToastrContainerComponent.ctorParameters = () => [
    { type: NbLayoutDirectionService },
    { type: NbPositionHelper }
];
NbToastrContainerComponent.propDecorators = {
    content: [{ type: Input }],
    context: [{ type: Input }],
    position: [{ type: Input }],
    toasts: [{ type: ViewChildren, args: [NbToastComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToastrContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toastr-container',
                template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
                animations: [
                    trigger('fadeIn', [
                        transition(':enter', [voidState, animate(100)], defaultOptions),
                        transition(':leave', [animate(100, voidState)], defaultOptions),
                    ]),
                ]
            }]
    }], function () { return [{ type: NbLayoutDirectionService }, { type: NbPositionHelper }]; }, { content: [{
            type: Input
        }], context: [{
            type: Input
        }], position: [{
            type: Input
        }], toasts: [{
            type: ViewChildren,
            args: [NbToastComponent]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TOASTR_CONFIG = new InjectionToken('Default toastr options');
/**
 * The `NbToastrConfig` class describes configuration of the `NbToastrService.show` and global toastr configuration.
 * */
class NbToastrConfig {
    constructor(config) {
        /**
         * Determines where on the screen toast have to be rendered.
         * */
        this.position = NbGlobalLogicalPosition.TOP_END;
        /**
         * Status chooses color scheme for the toast.
         * */
        this.status = 'basic';
        /**
         * Duration is timeout between toast appears and disappears.
         * */
        this.duration = 3000;
        /**
         * Destroy by click means you can hide the toast by clicking it.
         * */
        this.destroyByClick = true;
        /**
         * If preventDuplicates is true then the toast with the same title, message and status will not be rendered.
         * Find duplicates behaviour determined by `preventDuplicates`.
         * The default `previous` duplicate behaviour is used.
         * */
        this.preventDuplicates = false;
        /**
         * Determines the how to treat duplicates.
         * */
        this.duplicatesBehaviour = 'previous';
        /*
        * The number of visible toasts. If the limit exceeded the oldest toast will be removed.
        * */
        this.limit = null;
        /**
         * Class to be applied to the toast.
         */
        this.toastClass = '';
        /**
         * Determines render icon or not.
         * */
        this.hasIcon = true;
        /**
         * Icon name or icon config object that can be provided to render custom icon.
         * */
        this.icon = 'email';
        /**
         * Toast status icon-class mapping.
         * */
        this.icons = {
            danger: 'flash-outline',
            success: 'checkmark-outline',
            info: 'question-mark-outline',
            warning: 'alert-triangle-outline',
            primary: 'email-outline',
            control: 'email-outline',
            basic: 'email-outline',
        };
        this.patchIcon(config);
        Object.assign(this, config);
    }
    patchIcon(config) {
        if (!('icon' in config)) {
            config.icon = {
                icon: this.icons[config.status] || this.icons.basic,
                pack: 'nebular-essentials',
            };
        }
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbToastRef {
    constructor(toastContainer, toast) {
        this.toastContainer = toastContainer;
        this.toast = toast;
    }
    close() {
        this.toastContainer.destroy(this.toast);
    }
}
class NbToastContainer {
    constructor(position, containerRef, positionHelper) {
        this.position = position;
        this.containerRef = containerRef;
        this.positionHelper = positionHelper;
        this.toasts = [];
        this.toastDuplicateCompareFunc = (t1, t2) => {
            return t1.message === t2.message
                && t1.title === t2.title
                && t1.config.status === t2.config.status;
        };
    }
    get nativeElement() {
        return this.containerRef.location.nativeElement;
    }
    attach(toast) {
        if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
            return;
        }
        this.removeToastIfLimitReached(toast);
        const toastComponent = this.attachToast(toast);
        if (toast.config.destroyByClick) {
            this.subscribeOnClick(toastComponent, toast);
        }
        if (toast.config.duration) {
            this.setDestroyTimeout(toast);
        }
        this.prevToast = toast;
        return new NbToastRef(this, toast);
    }
    destroy(toast) {
        if (this.prevToast === toast) {
            this.prevToast = null;
        }
        this.toasts = this.toasts.filter(t => t !== toast);
        this.updateContainer();
    }
    isDuplicate(toast) {
        return toast.config.duplicatesBehaviour === 'previous'
            ? this.isDuplicatePrevious(toast)
            : this.isDuplicateAmongAll(toast);
    }
    isDuplicatePrevious(toast) {
        return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
    }
    isDuplicateAmongAll(toast) {
        return this.toasts.some(t => this.toastDuplicateCompareFunc(t, toast));
    }
    removeToastIfLimitReached(toast) {
        if (!toast.config.limit || this.toasts.length < toast.config.limit) {
            return;
        }
        if (this.positionHelper.isTopPosition(toast.config.position)) {
            this.toasts.pop();
        }
        else {
            this.toasts.shift();
        }
    }
    attachToast(toast) {
        if (this.positionHelper.isTopPosition(toast.config.position)) {
            return this.attachToTop(toast);
        }
        else {
            return this.attachToBottom(toast);
        }
    }
    attachToTop(toast) {
        this.toasts.unshift(toast);
        this.updateContainer();
        return this.containerRef.instance.toasts.first;
    }
    attachToBottom(toast) {
        this.toasts.push(toast);
        this.updateContainer();
        return this.containerRef.instance.toasts.last;
    }
    setDestroyTimeout(toast) {
        setTimeout(() => this.destroy(toast), toast.config.duration);
    }
    subscribeOnClick(toastComponent, toast) {
        toastComponent.destroy.subscribe(() => this.destroy(toast));
    }
    updateContainer() {
        patch(this.containerRef, { content: this.toasts, position: this.position });
    }
}
class NbToastrContainerRegistry {
    constructor(overlay, positionBuilder, positionHelper, cfr, document) {
        this.overlay = overlay;
        this.positionBuilder = positionBuilder;
        this.positionHelper = positionHelper;
        this.cfr = cfr;
        this.document = document;
        this.overlays = new Map();
    }
    get(position) {
        const logicalPosition = this.positionHelper.toLogicalPosition(position);
        const overlayWithContainer = this.overlays.get(logicalPosition);
        if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
            if (overlayWithContainer) {
                overlayWithContainer.overlayRef.dispose();
            }
            this.instantiateContainer(logicalPosition);
        }
        return this.overlays.get(logicalPosition).toastrContainer;
    }
    instantiateContainer(position) {
        const toastrOverlayWithContainer = this.createContainer(position);
        this.overlays.set(position, toastrOverlayWithContainer);
    }
    createContainer(position) {
        const positionStrategy = this.positionBuilder.global().position(position);
        const ref = this.overlay.create({ positionStrategy });
        this.addClassToOverlayHost(ref);
        const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null, this.cfr));
        return {
            overlayRef: ref,
            toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper),
        };
    }
    addClassToOverlayHost(overlayRef) {
        overlayRef.hostElement.classList.add('toastr-overlay-container');
    }
    existsInDom(toastContainer) {
        return this.document.body.contains(toastContainer.nativeElement);
    }
}
NbToastrContainerRegistry.ɵfac = function NbToastrContainerRegistry_Factory(t) { return new (t || NbToastrContainerRegistry)(ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbPositionHelper), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbToastrContainerRegistry.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbToastrContainerRegistry, factory: NbToastrContainerRegistry.ɵfac });
NbToastrContainerRegistry.ctorParameters = () => [
    { type: NbOverlayService },
    { type: NbPositionBuilderService },
    { type: NbPositionHelper },
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToastrContainerRegistry, [{
        type: Injectable
    }], function () { return [{ type: NbOverlayService }, { type: NbPositionBuilderService }, { type: NbPositionHelper }, { type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
/**
 * The `NbToastrService` provides a capability to build toast notifications.
 *
 * @stacked-example(Showcase, toastr/toastr-showcase.component)
 *
 * `NbToastrService.show(message, title, config)` accepts three params, title and config are optional.
 *
 * ### Installation
 *
 * Import `NbToastrModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbToastrModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * Calling `NbToastrService.show(...)` will render new toast and return `NbToastrRef` with
 * help of which you may close newly created toast by calling `close` method.
 *
 * ```ts
 * const toastRef: NbToastRef = this.toastrService.show(...);
 * toastRef.close();
 * ```
 *
 * Config accepts following options:
 *
 * `position` - determines where on the screen toast will be rendered.
 * Default is `top-end`.
 *
 * @stacked-example(Position, toastr/toastr-positions.component)
 *
 * `status` - coloring and icon of the toast.
 * Default is `basic`.
 *
 * @stacked-example(Status, toastr/toastr-statuses.component)
 *
 * `duration` - the time after which the toast will be destroyed.
 * `0` means endless toast, that may be destroyed by click only.
 * Default is 3000 ms.
 *
 * @stacked-example(Duration, toastr/toastr-duration.component)
 *
 * `destroyByClick` - provides a capability to destroy toast by click.
 * Default is true.
 *
 * @stacked-example(Destroy by click, toastr/toastr-destroy-by-click.component)
 *
 * `preventDuplicates` - don't create new toast if it has the same title, message and status.
 * Default is false.
 *
 * @stacked-example(Prevent duplicates, toastr/toastr-prevent-duplicates.component)
 *
 * `duplicatesBehaviour` - determines how to treat the toasts duplication.
 * Compare with the previous message `previous`
 * or with all visible messages `all`.
 *
 * @stacked-example(Prevent duplicates behaviour , toastr/toastr-prevent-duplicates-behaviour.component)
 *
 * `limit` - the number of visible toasts in the toast container. The number of toasts is unlimited by default.
 *
 * @stacked-example(Prevent duplicates behaviour , toastr/toastr-limit.component)
 *
 * `hasIcon` - if true then render toast icon.
 * `icon` - you can pass icon class that will be applied into the toast.
 *
 * @stacked-example(Has icon, toastr/toastr-icon.component)
 * */
class NbToastrService {
    constructor(globalConfig, containerRegistry) {
        this.globalConfig = globalConfig;
        this.containerRegistry = containerRegistry;
    }
    /**
     * Shows toast with message, title and user config.
     * */
    show(message, title, userConfig) {
        const config = new NbToastrConfig(Object.assign(Object.assign({}, this.globalConfig), userConfig));
        const container = this.containerRegistry.get(config.position);
        const toast = { message, title, config };
        return container.attach(toast);
    }
    /**
     * Shows success toast with message, title and user config.
     * */
    success(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'success' }));
    }
    /**
     * Shows info toast with message, title and user config.
     * */
    info(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'info' }));
    }
    /**
     * Shows warning toast with message, title and user config.
     * */
    warning(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'warning' }));
    }
    /**
     * Shows primary toast with message, title and user config.
     * */
    primary(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'primary' }));
    }
    /**
     * Shows danger toast with message, title and user config.
     * */
    danger(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'danger' }));
    }
    /**
     * Shows default toast with message, title and user config.
     * */
    default(message, title, config) {
        return this.show(message, title, Object.assign(Object.assign({}, config), { status: 'basic' }));
    }
    /**
     * Shows control toast with message, title and user config.
     * */
    control(message, title, config) {
        return this.default(message, title, Object.assign(Object.assign({}, config), { status: 'control' }));
    }
}
NbToastrService.ɵfac = function NbToastrService_Factory(t) { return new (t || NbToastrService)(ɵngcc0.ɵɵinject(NB_TOASTR_CONFIG), ɵngcc0.ɵɵinject(NbToastrContainerRegistry)); };
NbToastrService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbToastrService, factory: NbToastrService.ɵfac });
NbToastrService.ctorParameters = () => [
    { type: NbToastrConfig, decorators: [{ type: Inject, args: [NB_TOASTR_CONFIG,] }] },
    { type: NbToastrContainerRegistry }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToastrService, [{
        type: Injectable
    }], function () { return [{ type: NbToastrConfig, decorators: [{
                type: Inject,
                args: [NB_TOASTR_CONFIG]
            }] }, { type: NbToastrContainerRegistry }]; }, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbToastrModule {
    static forRoot(toastrConfig = {}) {
        return {
            ngModule: NbToastrModule,
            providers: [
                NbToastrService,
                NbToastrContainerRegistry,
                { provide: NB_TOASTR_CONFIG, useValue: toastrConfig },
            ],
        };
    }
}
NbToastrModule.ɵfac = function NbToastrModule_Factory(t) { return new (t || NbToastrModule)(); };
NbToastrModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbToastrModule });
NbToastrModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbSharedModule, NbOverlayModule, NbIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbToastrModule, { declarations: [NbToastrContainerComponent, NbToastComponent], imports: [NbSharedModule, NbOverlayModule, NbIconModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToastrModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule, NbIconModule],
                declarations: [NbToastrContainerComponent, NbToastComponent],
                entryComponents: [NbToastrContainerComponent, NbToastComponent]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Tooltip container.
 * Renders provided tooltip inside.
 *
 * @styles
 *
 * tooltip-background-color:
 * tooltip-border-color:
 * tooltip-border-style:
 * tooltip-border-width:
 * tooltip-border-radius:
 * tooltip-padding:
 * tooltip-text-color:
 * tooltip-text-font-family:
 * tooltip-text-font-size:
 * tooltip-text-font-weight:
 * tooltip-text-line-height:
 * tooltip-icon-height:
 * tooltip-icon-width:
 * tooltip-max-width:
 * tooltip-basic-background-color:
 * tooltip-basic-border-color:
 * tooltip-basic-text-color:
 * tooltip-primary-background-color:
 * tooltip-primary-border-color:
 * tooltip-primary-text-color:
 * tooltip-info-background-color:
 * tooltip-info-border-color:
 * tooltip-info-text-color:
 * tooltip-success-background-color:
 * tooltip-success-border-color:
 * tooltip-success-text-color:
 * tooltip-warning-background-color:
 * tooltip-warning-border-color:
 * tooltip-warning-text-color:
 * tooltip-danger-background-color:
 * tooltip-danger-border-color:
 * tooltip-danger-text-color:
 * tooltip-control-background-color:
 * tooltip-control-border-color:
 * tooltip-control-text-color:
 * tooltip-shadow:
 */
class NbTooltipComponent {
    constructor(statusService) {
        this.statusService = statusService;
        /**
         * Popover position relatively host element.
         * */
        this.position = NbPosition.TOP;
        this.context = {};
    }
    get binding() {
        return `${this.position} ${this.statusClass}`;
    }
    get show() {
        return true;
    }
    get statusClass() {
        if (this.context.status) {
            return this.statusService.getStatusClass(this.context.status);
        }
        return '';
    }
    /**
     * The method is empty since we don't need to do anything additionally
     * render is handled by change detection
     */
    renderContent() { }
}
NbTooltipComponent.ɵfac = function NbTooltipComponent_Factory(t) { return new (t || NbTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTooltipComponent, selectors: [["nb-tooltip"]], hostVars: 3, hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵsyntheticHostProperty("@showTooltip", ctx.show);
        ɵngcc0.ɵɵclassMap(ctx.binding);
    } }, inputs: { position: "position", context: "context", content: "content" }, decls: 4, vars: 2, consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]], template: function NbTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2);
        ɵngcc0.ɵɵtemplate(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context == null ? null : ctx.context.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.content);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:0.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:0.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:calc(-1 * 6px + 1px);transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:calc(-6px + 1px);transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:calc(-6px - 6px / 2.5);bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:calc(-6px - 6px / 2.5);top:6px;transform:rotate(270deg)}"], data: { animation: [
            trigger('showTooltip', [
                state('in', style({ opacity: 1 })),
                transition('void => *', [
                    style({ opacity: 0 }),
                    animate(100),
                ]),
                transition('* => void', [
                    animate(100, style({ opacity: 0 })),
                ]),
            ]),
        ] } });
NbTooltipComponent.ctorParameters = () => [
    { type: NbStatusService }
];
NbTooltipComponent.propDecorators = {
    content: [{ type: Input }],
    position: [{ type: Input }],
    binding: [{ type: HostBinding, args: ['class',] }],
    show: [{ type: HostBinding, args: ['@showTooltip',] }],
    context: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTooltipComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tooltip',
                template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
                animations: [
                    trigger('showTooltip', [
                        state('in', style({ opacity: 1 })),
                        transition('void => *', [
                            style({ opacity: 0 }),
                            animate(100),
                        ]),
                        transition('* => void', [
                            animate(100, style({ opacity: 0 })),
                        ]),
                    ]),
                ],
                styles: [":host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:0.5rem}:host.right nb-icon+span{margin-right:0.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:calc(-1 * 6px + 1px);transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:calc(-6px + 1px);transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:calc(-6px - 6px / 2.5);bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:calc(-6px - 6px / 2.5);top:6px;transform:rotate(270deg)}\n"]
            }]
    }], function () { return [{ type: NbStatusService }]; }, { position: [{
            type: Input
        }], context: [{
            type: Input
        }], binding: [{
            type: HostBinding,
            args: ['class']
        }], show: [{
            type: HostBinding,
            args: ['@showTooltip']
        }], content: [{
            type: Input
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 *
 * Tooltip directive for small text/icon hints.
 *
 * ### Installation
 *
 * Import `NbTooltipModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTooltipModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * @stacked-example(Showcase, tooltip/tooltip-showcase.component)
 *
 * Tooltip can accept a hint text and/or an icon:
 * @stacked-example(With Icon, tooltip/tooltip-with-icon.component)
 *
 * Same way as Popover, tooltip can accept placement position with `nbTooltipPlacement` property:
 * @stacked-example(Placements, tooltip/tooltip-placements.component)
 *
 * It is also possible to specify tooltip color using `nbTooltipStatus` property:
 * @stacked-example(Colored Tooltips, tooltip/tooltip-colors.component)
 *
 * Tooltip has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 */
class NbTooltipDirective {
    constructor(hostRef, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.destroy$ = new Subject();
        this.tooltipComponent = NbTooltipComponent;
        this.context = {};
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom, left, start or end.
         */
        this.position = NbPosition.TOP;
        this._adjustment = NbAdjustment.CLOCKWISE;
        this._tooltipClass = '';
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.HINT;
        /**
         * Determines tooltip overlay offset (in pixels).
         **/
        this.offset = 8;
        this.nbTooltipShowStateChange = new EventEmitter();
        this.overlayConfig = { panelClass: this.tooltipClass };
    }
    /**
     * Container position will change automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatic adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     */
    get adjustment() {
        return this._adjustment;
    }
    set adjustment(value) {
        this._adjustment = value;
    }
    get tooltipClass() {
        return this._tooltipClass;
    }
    set tooltipClass(value) {
        if (value !== this.tooltipClass) {
            this._tooltipClass = value;
            this.overlayConfig = { panelClass: this.tooltipClass };
        }
    }
    /**
     * Accepts icon name or icon config object
     * @param {string | NbIconConfig} icon name or config object
     */
    set icon(icon) {
        this.context = Object.assign(this.context, { icon });
    }
    /**
     *
     * @param {string} status
     */
    set status(status) {
        this.context = Object.assign(this.context, { status });
    }
    get isShown() {
        return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
    }
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(this.tooltipComponent)
            .offset(this.offset);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.dynamicOverlay.isShown
            .pipe(skip(1), takeUntil(this.destroy$))
            .subscribe((isShown) => this.nbTooltipShowStateChange.emit({ isShown }));
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .adjustment(this.adjustment)
            .content(this.content)
            .context(this.context)
            .overlayConfig(this.overlayConfig);
    }
}
NbTooltipDirective.ɵfac = function NbTooltipDirective_Factory(t) { return new (t || NbTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbTooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTooltipDirective, selectors: [["", "nbTooltip", ""]], inputs: { position: ["nbTooltipPlacement", "position"], trigger: ["nbTooltipTrigger", "trigger"], offset: ["nbTooltipOffset", "offset"], adjustment: ["nbTooltipAdjustment", "adjustment"], tooltipClass: ["nbTooltipClass", "tooltipClass"], icon: ["nbTooltipIcon", "icon"], status: ["nbTooltipStatus", "status"], content: ["nbTooltip", "content"] }, outputs: { nbTooltipShowStateChange: "nbTooltipShowStateChange" }, exportAs: ["nbTooltip"], features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature] });
NbTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbDynamicOverlayHandler }
];
NbTooltipDirective.propDecorators = {
    content: [{ type: Input, args: ['nbTooltip',] }],
    position: [{ type: Input, args: ['nbTooltipPlacement',] }],
    adjustment: [{ type: Input, args: ['nbTooltipAdjustment',] }],
    tooltipClass: [{ type: Input, args: ['nbTooltipClass',] }],
    icon: [{ type: Input, args: ['nbTooltipIcon',] }],
    status: [{ type: Input, args: ['nbTooltipStatus',] }],
    trigger: [{ type: Input, args: ['nbTooltipTrigger',] }],
    offset: [{ type: Input, args: ['nbTooltipOffset',] }],
    nbTooltipShowStateChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTooltip]',
                exportAs: 'nbTooltip',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbDynamicOverlayHandler }]; }, { position: [{
            type: Input,
            args: ['nbTooltipPlacement']
        }], trigger: [{
            type: Input,
            args: ['nbTooltipTrigger']
        }], offset: [{
            type: Input,
            args: ['nbTooltipOffset']
        }], nbTooltipShowStateChange: [{
            type: Output
        }], adjustment: [{
            type: Input,
            args: ['nbTooltipAdjustment']
        }], tooltipClass: [{
            type: Input,
            args: ['nbTooltipClass']
        }], icon: [{
            type: Input,
            args: ['nbTooltipIcon']
        }], status: [{
            type: Input,
            args: ['nbTooltipStatus']
        }], content: [{
            type: Input,
            args: ['nbTooltip']
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTooltipModule {
}
NbTooltipModule.ɵfac = function NbTooltipModule_Factory(t) { return new (t || NbTooltipModule)(); };
NbTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTooltipModule });
NbTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[NbSharedModule, NbOverlayModule, NbIconModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTooltipModule, { declarations: [NbTooltipComponent, NbTooltipDirective], imports: [NbSharedModule, NbOverlayModule, NbIconModule], exports: [NbTooltipDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTooltipModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule, NbIconModule],
                declarations: [NbTooltipComponent, NbTooltipDirective],
                exports: [NbTooltipDirective],
                entryComponents: [NbTooltipComponent]
            }]
    }], null, null); })();

const NB_SELECT_INJECTION_TOKEN = new InjectionToken('NB_SELECT_INJECTION_TOKEN');

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
// Component class scoped counter for aria attributes.
let lastOptionId = 0;
/**
 * NbOptionComponent
 *
 * @styles
 *
 * option-background-color:
 * option-text-color:
 * option-text-font-family:
 * option-hover-background-color:
 * option-hover-text-color:
 * option-active-background-color:
 * option-active-text-color:
 * option-focus-background-color:
 * option-focus-text-color:
 * option-selected-background-color:
 * option-selected-text-color:
 * option-selected-hover-background-color:
 * option-selected-hover-text-color:
 * option-selected-active-background-color:
 * option-selected-active-text-color:
 * option-selected-focus-background-color:
 * option-selected-focus-text-color:
 * option-disabled-background-color:
 * option-disabled-text-color:
 * option-tiny-text-font-size:
 * option-tiny-text-font-weight:
 * option-tiny-text-line-height:
 * option-tiny-padding:
 * option-small-text-font-size:
 * option-small-text-font-weight:
 * option-small-text-line-height:
 * option-small-padding:
 * option-medium-text-font-size:
 * option-medium-text-font-weight:
 * option-medium-text-line-height:
 * option-medium-padding:
 * option-large-text-font-size:
 * option-large-text-font-weight:
 * option-large-text-line-height:
 * option-large-padding:
 * option-giant-text-font-size:
 * option-giant-text-font-weight:
 * option-giant-text-line-height:
 * option-giant-padding:
 **/
class NbOptionComponent {
    constructor(parent, elementRef, cd, zone, renderer) {
        this.elementRef = elementRef;
        this.cd = cd;
        this.zone = zone;
        this.renderer = renderer;
        this.disabledByGroup = false;
        this._disabled = false;
        /**
         * Fires value when option selection change.
         * */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when option clicked
         */
        this.click$ = new Subject();
        this.selected = false;
        this.alive = true;
        /**
         * Component scoped id for aria attributes.
         * */
        this.id = `nb-option-${lastOptionId++}`;
        this._active = false;
        this.parent = parent;
    }
    get disabled() {
        return this._disabled || this.disabledByGroup;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    get click() {
        return this.click$.asObservable();
    }
    ngOnDestroy() {
        this.alive = false;
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.elementRef.nativeElement, 'nb-transition');
        }));
    }
    /**
     * Determines should we render checkbox.
     * */
    get withCheckbox() {
        return this.multiple && this.value != null;
    }
    get content() {
        return this.elementRef.nativeElement.textContent;
    }
    // TODO: replace with isShowCheckbox property to control this behaviour outside, issues/1965
    get multiple() {
        // We check parent existing because parent can be NbSelectComponent or
        // NbAutocomplete and `miltiple` property exists only in NbSelectComponent
        return this.parent ? this.parent.multiple : false;
    }
    get selectedClass() {
        return this.selected;
    }
    get disabledAttribute() {
        return this.disabled ? '' : null;
    }
    get tabindex() {
        return '-1';
    }
    get activeClass() {
        return this._active;
    }
    ;
    onClick(event) {
        this.click$.next(this);
        // Prevent scroll on space click, etc.
        event.preventDefault();
    }
    select() {
        this.setSelection(true);
    }
    deselect() {
        this.setSelection(false);
    }
    /**
     * Sets disabled by group state and marks component for check.
     */
    setDisabledByGroupState(disabled) {
        // Check if the component still alive as the option group defer method call so the component may become destroyed.
        if (this.disabledByGroup !== disabled && this.alive) {
            this.disabledByGroup = disabled;
            this.cd.markForCheck();
        }
    }
    setSelection(selected) {
        /**
         * In case of changing options in runtime the reference to the selected option will be kept in select component.
         * This may lead to exceptions with detecting changes in destroyed component.
         *
         * Also Angular can call writeValue on destroyed view (select implements ControlValueAccessor).
         * angular/angular#27803
         * */
        if (this.alive && this.selected !== selected) {
            this.selected = selected;
            this.selectionChange.emit(this);
            this.cd.markForCheck();
        }
    }
    focus() {
        this.elementRef.nativeElement.focus();
    }
    getLabel() {
        return this.content;
    }
    setActiveStyles() {
        this._active = true;
        this.cd.markForCheck();
    }
    setInactiveStyles() {
        this._active = false;
        this.cd.markForCheck();
    }
}
NbOptionComponent.ɵfac = function NbOptionComponent_Factory(t) { return new (t || NbOptionComponent)(ɵngcc0.ɵɵdirectiveInject(NB_SELECT_INJECTION_TOKEN, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbOptionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOptionComponent, selectors: [["nb-option"]], hostVars: 9, hostBindings: function NbOptionComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbOptionComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) { return ctx.onClick($event); })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabindex);
        ɵngcc0.ɵɵattribute("id", ctx.id)("disabled", ctx.disabledAttribute);
        ɵngcc0.ɵɵclassProp("multiple", ctx.multiple)("selected", ctx.selectedClass)("active", ctx.activeClass);
    } }, inputs: { disabled: "disabled", value: "value" }, outputs: { selectionChange: "selectionChange" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]], template: function NbOptionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.withCheckbox);
    } }, directives: [ɵngcc2.NgIf, NbCheckboxComponent], styles: ["[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}.nb-transition[_nghost-%COMP%]{transition-duration:0.15s;transition-property:background-color,color;transition-timing-function:ease-in}"], changeDetection: 0 });
NbOptionComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_SELECT_INJECTION_TOKEN,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
NbOptionComponent.propDecorators = {
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    selectionChange: [{ type: Output }],
    id: [{ type: HostBinding, args: ['attr.id',] }],
    multiple: [{ type: HostBinding, args: ['class.multiple',] }],
    selectedClass: [{ type: HostBinding, args: ['class.selected',] }],
    disabledAttribute: [{ type: HostBinding, args: ['attr.disabled',] }],
    tabindex: [{ type: HostBinding, args: ['tabIndex',] }],
    activeClass: [{ type: HostBinding, args: ['class.active',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }, { type: HostListener, args: ['keydown.enter', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOptionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-option',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <nb-checkbox *ngIf="withCheckbox"
                 [checked]="selected"
                 [disabled]="disabled"
                 aria-hidden="true">
    </nb-checkbox>
    <ng-content></ng-content>
  `,
                styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}:host(.nb-transition){transition-duration:0.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_SELECT_INJECTION_TOKEN]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { selectionChange: [{
            type: Output
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }], disabled: [{
            type: Input
        }], multiple: [{
            type: HostBinding,
            args: ['class.multiple']
        }], selectedClass: [{
            type: HostBinding,
            args: ['class.selected']
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], tabindex: [{
            type: HostBinding,
            args: ['tabIndex']
        }], activeClass: [{
            type: HostBinding,
            args: ['class.active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], value: [{
            type: Input
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbSelectLabelComponent {
}
NbSelectLabelComponent.ɵfac = function NbSelectLabelComponent_Factory(t) { return new (t || NbSelectLabelComponent)(); };
NbSelectLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSelectLabelComponent, selectors: [["nb-select-label"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSelectLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSelectLabelComponent, [{
        type: Component,
        args: [{
                selector: 'nb-select-label',
                template: '<ng-content></ng-content>'
            }]
    }], null, null); })();
function nbSelectFormFieldControlConfigFactory() {
    const config = new NbFormFieldControlConfig();
    config.supportsSuffix = false;
    return config;
}
/**
 * The `NbSelectComponent` provides a capability to select one of the passed items.
 *
 * @stacked-example(Showcase, select/select-showcase.component)
 *
 * ### Installation
 *
 * Import `NbSelectModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSelectModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use it as the multi-select control you have to mark it as `multiple`.
 * In this case, `nb-select` will work only with arrays - accept arrays and propagate arrays.
 *
 * @stacked-example(Multiple, select/select-multiple.component)
 *
 * Items without values will clean the selection. Both `null` and `undefined` values will also clean the selection.
 *
 * @stacked-example(Clean selection, select/select-clean.component)
 *
 * Select may be bounded using `selected` input:
 *
 * ```html
 * <nb-select [(selected)]="selected"></nb-selected>
 * ```
 *
 * Or you can bind control with form controls or ngModel:
 *
 * @stacked-example(Select form binding, select/select-form.component)
 *
 * Options in the select may be grouped using `nb-option-group` component.
 *
 * @stacked-example(Grouping, select/select-groups.component)
 *
 * Select may have a placeholder that will be shown when nothing selected:
 *
 * @stacked-example(Placeholder, select/select-placeholder.component)
 *
 * You can disable select, options and whole groups.
 *
 * @stacked-example(Disabled select, select/select-disabled.component)
 *
 * Also, the custom label may be provided in select.
 * This custom label will be used for instead placeholder when something selected.
 *
 * @stacked-example(Custom label, select/select-label.component)
 *
 * Default `nb-select` size is `medium` and status is `basic`.
 * Select is available in multiple colors using `status` property:
 *
 * @stacked-example(Select statuses, select/select-status.component)
 *
 * There are five select sizes:
 *
 * @stacked-example(Select sizes, select/select-sizes.component)
 *
 * And two additional style types - `filled`:
 *
 * @stacked-example(Filled select, select/select-filled.component)
 *
 * and `hero`:
 *
 * @stacked-example(Select colors, select/select-hero.component)
 *
 * Select is available in different shapes, that could be combined with the other properties:
 *
 * @stacked-example(Select shapes, select/select-shapes.component)
 *
 * By default, the component selects options whose values are strictly equal (`===`) with the select value.
 * To change such behavior, pass a custom comparator function to the `compareWith` attribute.
 *
 * @stacked-example(Select custom comparator, select/select-compare-with.component)
 *
 * @additional-example(Interactive, select/select-interactive.component)
 *
 * @styles
 *
 * select-cursor:
 * select-disabled-cursor:
 * select-min-width:
 * select-outline-width:
 * select-outline-color:
 * select-icon-offset:
 * select-text-font-family:
 * select-placeholder-text-font-family:
 * select-tiny-text-font-size:
 * select-tiny-text-font-weight:
 * select-tiny-text-line-height:
 * select-tiny-placeholder-text-font-size:
 * select-tiny-placeholder-text-font-weight:
 * select-tiny-max-width:
 * select-small-text-font-size:
 * select-small-text-font-weight:
 * select-small-text-line-height:
 * select-small-placeholder-text-font-size:
 * select-small-placeholder-text-font-weight:
 * select-small-max-width:
 * select-medium-text-font-size:
 * select-medium-text-font-weight:
 * select-medium-text-line-height:
 * select-medium-placeholder-text-font-size:
 * select-medium-placeholder-text-font-weight:
 * select-medium-max-width:
 * select-large-text-font-size:
 * select-large-text-font-weight:
 * select-large-text-line-height:
 * select-large-placeholder-text-font-size:
 * select-large-placeholder-text-font-weight:
 * select-large-max-width:
 * select-giant-text-font-size:
 * select-giant-text-font-weight:
 * select-giant-text-line-height:
 * select-giant-placeholder-text-font-size:
 * select-giant-placeholder-text-font-weight:
 * select-giant-max-width:
 * select-rectangle-border-radius:
 * select-semi-round-border-radius:
 * select-round-border-radius:
 * select-outline-border-style:
 * select-outline-border-width:
 * select-outline-tiny-padding:
 * select-outline-small-padding:
 * select-outline-medium-padding:
 * select-outline-large-padding:
 * select-outline-giant-padding:
 * select-outline-basic-icon-color:
 * select-outline-basic-text-color:
 * select-outline-basic-placeholder-text-color:
 * select-outline-basic-background-color:
 * select-outline-basic-border-color:
 * select-outline-basic-focus-background-color:
 * select-outline-basic-focus-border-color:
 * select-outline-basic-hover-background-color:
 * select-outline-basic-hover-border-color:
 * select-outline-basic-disabled-background-color:
 * select-outline-basic-disabled-border-color:
 * select-outline-basic-disabled-icon-color:
 * select-outline-basic-disabled-text-color:
 * select-outline-primary-icon-color:
 * select-outline-primary-text-color:
 * select-outline-primary-placeholder-text-color:
 * select-outline-primary-background-color:
 * select-outline-primary-border-color:
 * select-outline-primary-focus-background-color:
 * select-outline-primary-focus-border-color:
 * select-outline-primary-hover-background-color:
 * select-outline-primary-hover-border-color:
 * select-outline-primary-disabled-background-color:
 * select-outline-primary-disabled-border-color:
 * select-outline-primary-disabled-icon-color:
 * select-outline-primary-disabled-text-color:
 * select-outline-success-icon-color:
 * select-outline-success-text-color:
 * select-outline-success-placeholder-text-color:
 * select-outline-success-background-color:
 * select-outline-success-border-color:
 * select-outline-success-focus-background-color:
 * select-outline-success-focus-border-color:
 * select-outline-success-hover-background-color:
 * select-outline-success-hover-border-color:
 * select-outline-success-disabled-background-color:
 * select-outline-success-disabled-border-color:
 * select-outline-success-disabled-icon-color:
 * select-outline-success-disabled-text-color:
 * select-outline-info-icon-color:
 * select-outline-info-text-color:
 * select-outline-info-placeholder-text-color:
 * select-outline-info-background-color:
 * select-outline-info-border-color:
 * select-outline-info-focus-background-color:
 * select-outline-info-focus-border-color:
 * select-outline-info-hover-background-color:
 * select-outline-info-hover-border-color:
 * select-outline-info-disabled-background-color:
 * select-outline-info-disabled-border-color:
 * select-outline-info-disabled-icon-color:
 * select-outline-info-disabled-text-color:
 * select-outline-warning-icon-color:
 * select-outline-warning-text-color:
 * select-outline-warning-placeholder-text-color:
 * select-outline-warning-background-color:
 * select-outline-warning-border-color:
 * select-outline-warning-focus-background-color:
 * select-outline-warning-focus-border-color:
 * select-outline-warning-hover-background-color:
 * select-outline-warning-hover-border-color:
 * select-outline-warning-disabled-background-color:
 * select-outline-warning-disabled-border-color:
 * select-outline-warning-disabled-icon-color:
 * select-outline-warning-disabled-text-color:
 * select-outline-danger-icon-color:
 * select-outline-danger-text-color:
 * select-outline-danger-placeholder-text-color:
 * select-outline-danger-background-color:
 * select-outline-danger-border-color:
 * select-outline-danger-focus-background-color:
 * select-outline-danger-focus-border-color:
 * select-outline-danger-hover-background-color:
 * select-outline-danger-hover-border-color:
 * select-outline-danger-disabled-background-color:
 * select-outline-danger-disabled-border-color:
 * select-outline-danger-disabled-icon-color:
 * select-outline-danger-disabled-text-color:
 * select-outline-control-icon-color:
 * select-outline-control-text-color:
 * select-outline-control-placeholder-text-color:
 * select-outline-control-background-color:
 * select-outline-control-border-color:
 * select-outline-control-focus-background-color:
 * select-outline-control-focus-border-color:
 * select-outline-control-hover-background-color:
 * select-outline-control-hover-border-color:
 * select-outline-control-disabled-background-color:
 * select-outline-control-disabled-border-color:
 * select-outline-control-disabled-icon-color:
 * select-outline-control-disabled-text-color:
 * select-outline-adjacent-border-style:
 * select-outline-adjacent-border-width:
 * select-outline-basic-open-border-color:
 * select-outline-basic-adjacent-border-color:
 * select-outline-primary-open-border-color:
 * select-outline-primary-adjacent-border-color:
 * select-outline-success-open-border-color:
 * select-outline-success-adjacent-border-color:
 * select-outline-info-open-border-color:
 * select-outline-info-adjacent-border-color:
 * select-outline-warning-open-border-color:
 * select-outline-warning-adjacent-border-color:
 * select-outline-danger-open-border-color:
 * select-outline-danger-adjacent-border-color:
 * select-outline-control-open-border-color:
 * select-outline-control-adjacent-border-color:
 * select-filled-border-style:
 * select-filled-border-width:
 * select-filled-tiny-padding:
 * select-filled-small-padding:
 * select-filled-medium-padding:
 * select-filled-large-padding:
 * select-filled-giant-padding:
 * select-filled-basic-background-color:
 * select-filled-basic-border-color:
 * select-filled-basic-icon-color:
 * select-filled-basic-text-color:
 * select-filled-basic-placeholder-text-color:
 * select-filled-basic-focus-background-color:
 * select-filled-basic-focus-border-color:
 * select-filled-basic-hover-background-color:
 * select-filled-basic-hover-border-color:
 * select-filled-basic-disabled-background-color:
 * select-filled-basic-disabled-border-color:
 * select-filled-basic-disabled-icon-color:
 * select-filled-basic-disabled-text-color:
 * select-filled-primary-background-color:
 * select-filled-primary-border-color:
 * select-filled-primary-icon-color:
 * select-filled-primary-text-color:
 * select-filled-primary-placeholder-text-color:
 * select-filled-primary-focus-background-color:
 * select-filled-primary-focus-border-color:
 * select-filled-primary-hover-background-color:
 * select-filled-primary-hover-border-color:
 * select-filled-primary-disabled-background-color:
 * select-filled-primary-disabled-border-color:
 * select-filled-primary-disabled-icon-color:
 * select-filled-primary-disabled-text-color:
 * select-filled-success-background-color:
 * select-filled-success-border-color:
 * select-filled-success-icon-color:
 * select-filled-success-text-color:
 * select-filled-success-placeholder-text-color:
 * select-filled-success-focus-background-color:
 * select-filled-success-focus-border-color:
 * select-filled-success-hover-background-color:
 * select-filled-success-hover-border-color:
 * select-filled-success-disabled-background-color:
 * select-filled-success-disabled-border-color:
 * select-filled-success-disabled-icon-color:
 * select-filled-success-disabled-text-color:
 * select-filled-info-background-color:
 * select-filled-info-border-color:
 * select-filled-info-icon-color:
 * select-filled-info-text-color:
 * select-filled-info-placeholder-text-color:
 * select-filled-info-focus-background-color:
 * select-filled-info-focus-border-color:
 * select-filled-info-hover-background-color:
 * select-filled-info-hover-border-color:
 * select-filled-info-disabled-background-color:
 * select-filled-info-disabled-border-color:
 * select-filled-info-disabled-icon-color:
 * select-filled-info-disabled-text-color:
 * select-filled-warning-background-color:
 * select-filled-warning-border-color:
 * select-filled-warning-icon-color:
 * select-filled-warning-text-color:
 * select-filled-warning-placeholder-text-color:
 * select-filled-warning-focus-background-color:
 * select-filled-warning-focus-border-color:
 * select-filled-warning-hover-background-color:
 * select-filled-warning-hover-border-color:
 * select-filled-warning-disabled-background-color:
 * select-filled-warning-disabled-border-color:
 * select-filled-warning-disabled-icon-color:
 * select-filled-warning-disabled-text-color:
 * select-filled-danger-background-color:
 * select-filled-danger-border-color:
 * select-filled-danger-icon-color:
 * select-filled-danger-text-color:
 * select-filled-danger-placeholder-text-color:
 * select-filled-danger-focus-background-color:
 * select-filled-danger-focus-border-color:
 * select-filled-danger-hover-background-color:
 * select-filled-danger-hover-border-color:
 * select-filled-danger-disabled-background-color:
 * select-filled-danger-disabled-border-color:
 * select-filled-danger-disabled-icon-color:
 * select-filled-danger-disabled-text-color:
 * select-filled-control-background-color:
 * select-filled-control-border-color:
 * select-filled-control-icon-color:
 * select-filled-control-text-color:
 * select-filled-control-placeholder-text-color:
 * select-filled-control-focus-background-color:
 * select-filled-control-focus-border-color:
 * select-filled-control-hover-background-color:
 * select-filled-control-hover-border-color:
 * select-filled-control-disabled-background-color:
 * select-filled-control-disabled-border-color:
 * select-filled-control-disabled-icon-color:
 * select-filled-control-disabled-text-color:
 * select-hero-tiny-padding:
 * select-hero-small-padding:
 * select-hero-medium-padding:
 * select-hero-large-padding:
 * select-hero-giant-padding:
 * select-hero-basic-left-background-color:
 * select-hero-basic-right-background-color:
 * select-hero-basic-icon-color:
 * select-hero-basic-text-color:
 * select-hero-basic-placeholder-text-color:
 * select-hero-basic-focus-left-background-color:
 * select-hero-basic-focus-right-background-color:
 * select-hero-basic-hover-left-background-color:
 * select-hero-basic-hover-right-background-color:
 * select-hero-basic-disabled-background-color:
 * select-hero-basic-disabled-icon-color:
 * select-hero-basic-disabled-text-color:
 * select-hero-primary-left-background-color:
 * select-hero-primary-right-background-color:
 * select-hero-primary-icon-color:
 * select-hero-primary-text-color:
 * select-hero-primary-placeholder-text-color:
 * select-hero-primary-focus-left-background-color:
 * select-hero-primary-focus-right-background-color:
 * select-hero-primary-hover-left-background-color:
 * select-hero-primary-hover-right-background-color:
 * select-hero-primary-disabled-background-color:
 * select-hero-primary-disabled-icon-color:
 * select-hero-primary-disabled-text-color:
 * select-hero-success-left-background-color:
 * select-hero-success-right-background-color:
 * select-hero-success-icon-color:
 * select-hero-success-text-color:
 * select-hero-success-placeholder-text-color:
 * select-hero-success-focus-left-background-color:
 * select-hero-success-focus-right-background-color:
 * select-hero-success-hover-left-background-color:
 * select-hero-success-hover-right-background-color:
 * select-hero-success-disabled-background-color:
 * select-hero-success-disabled-icon-color:
 * select-hero-success-disabled-text-color:
 * select-hero-info-left-background-color:
 * select-hero-info-right-background-color:
 * select-hero-info-icon-color:
 * select-hero-info-text-color:
 * select-hero-info-placeholder-text-color:
 * select-hero-info-focus-left-background-color:
 * select-hero-info-focus-right-background-color:
 * select-hero-info-hover-left-background-color:
 * select-hero-info-hover-right-background-color:
 * select-hero-info-disabled-background-color:
 * select-hero-info-disabled-icon-color:
 * select-hero-info-disabled-text-color:
 * select-hero-warning-left-background-color:
 * select-hero-warning-right-background-color:
 * select-hero-warning-icon-color:
 * select-hero-warning-text-color:
 * select-hero-warning-placeholder-text-color:
 * select-hero-warning-focus-left-background-color:
 * select-hero-warning-focus-right-background-color:
 * select-hero-warning-hover-left-background-color:
 * select-hero-warning-hover-right-background-color:
 * select-hero-warning-disabled-background-color:
 * select-hero-warning-disabled-icon-color:
 * select-hero-warning-disabled-text-color:
 * select-hero-danger-left-background-color:
 * select-hero-danger-right-background-color:
 * select-hero-danger-icon-color:
 * select-hero-danger-text-color:
 * select-hero-danger-placeholder-text-color:
 * select-hero-danger-focus-left-background-color:
 * select-hero-danger-focus-right-background-color:
 * select-hero-danger-hover-left-background-color:
 * select-hero-danger-hover-right-background-color:
 * select-hero-danger-disabled-background-color:
 * select-hero-danger-disabled-icon-color:
 * select-hero-danger-disabled-text-color:
 * select-hero-control-left-background-color:
 * select-hero-control-right-background-color:
 * select-hero-control-icon-color:
 * select-hero-control-text-color:
 * select-hero-control-placeholder-text-color:
 * select-hero-control-focus-left-background-color:
 * select-hero-control-focus-right-background-color:
 * select-hero-control-hover-left-background-color:
 * select-hero-control-hover-right-background-color:
 * select-hero-control-disabled-background-color:
 * select-hero-control-disabled-icon-color:
 * select-hero-control-disabled-text-color:
 * */
class NbSelectComponent {
    constructor(document, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService) {
        this.document = document;
        this.overlay = overlay;
        this.hostRef = hostRef;
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.cd = cd;
        this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
        this.focusMonitor = focusMonitor;
        this.renderer = renderer;
        this.zone = zone;
        this.statusService = statusService;
        /**
         * Select size, available sizes:
         * `tiny`, `small`, `medium` (default), `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Select status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = 'basic';
        /**
         * Select shapes: `rectangle` (default), `round`, `semi-round`
         */
        this.shape = 'rectangle';
        /**
         * Select appearances: `outline` (default), `filled`, `hero`
         */
        this.appearance = 'outline';
        this._fullWidth = false;
        /**
         * Renders select placeholder if nothing selected.
         * */
        this.placeholder = '';
        this._compareWith = (v1, v2) => v1 === v2;
        this._multiple = false;
        /**
         * Determines options overlay offset (in pixels).
         **/
        this.optionsOverlayOffset = 8;
        /**
         * Determines options overlay scroll strategy.
         **/
        this.scrollStrategy = 'block';
        /**
         * Will be emitted when selected value changes.
         * */
        this.selectedChange = new EventEmitter();
        /**
         * List of selected options.
         * */
        this.selectionModel = [];
        /**
         * Current overlay position because of we have to toggle overlayPosition
         * in [ngClass] direction and this directive can use only string.
         */
        this.overlayPosition = '';
        this.alive = true;
        this.destroy$ = new Subject();
        /**
         * Function passed through control value accessor to propagate changes.
         * */
        this.onChange = () => { };
        this.onTouched = () => { };
        /*
         * @docs-private
         **/
        this.status$ = new BehaviorSubject(this.status);
        /*
         * @docs-private
         **/
        this.size$ = new BehaviorSubject(this.size);
        /*
         * @docs-private
         **/
        this.focused$ = new BehaviorSubject(false);
        /*
         * @docs-private
         **/
        this.disabled$ = new BehaviorSubject(this.disabled);
        /*
         * @docs-private
         **/
        this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    }
    /**
     * Adds `outline` styles
     */
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    /**
     * Adds `filled` styles
     */
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    /**
     * Adds `hero` styles
     */
    get hero() {
        return this.appearance === 'hero';
    }
    set hero(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'hero';
        }
    }
    /**
     * Disables the select
     */
    get disabled() {
        return !!this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * If set element will fill its container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    /**
     * A function to compare option value with selected value.
     * By default, values are compared with strict equality (`===`).
     */
    get compareWith() {
        return this._compareWith;
    }
    set compareWith(fn) {
        if (typeof fn !== 'function') {
            return;
        }
        this._compareWith = fn;
        if (this.selectionModel.length && this.canSelectValue()) {
            this.setSelection(this.selected);
        }
    }
    /**
     * Accepts selected item or array of selected items.
     * */
    set selected(value) {
        this.writeValue(value);
    }
    get selected() {
        return this.multiple
            ? this.selectionModel.map(o => o.value)
            : this.selectionModel[0].value;
    }
    /**
     * Gives capability just write `multiple` over the element.
     * */
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = convertToBoolProperty(value);
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    /**
     * Determines is select opened.
     * */
    get isOpen() {
        return this.ref && this.ref.hasAttached();
    }
    /**
     * Determines is select hidden.
     * */
    get isHidden() {
        return !this.isOpen;
    }
    /**
     * Returns width of the select button.
     * */
    get hostWidth() {
        return this.button.nativeElement.getBoundingClientRect().width;
    }
    get selectButtonClasses() {
        const classes = [];
        if (!this.selectionModel.length) {
            classes.push('placeholder');
        }
        if (!this.selectionModel.length && !this.placeholder) {
            classes.push('empty');
        }
        if (this.isOpen) {
            classes.push(this.overlayPosition);
        }
        return classes;
    }
    /**
     * Content rendered in the label.
     * */
    get selectionView() {
        if (this.selectionModel.length > 1) {
            return this.selectionModel.map((option) => option.content).join(', ');
        }
        return this.selectionModel[0].content;
    }
    ngOnChanges({ disabled, status, size, fullWidth }) {
        if (disabled) {
            this.disabled$.next(disabled.currentValue);
        }
        if (status) {
            this.status$.next(status.currentValue);
        }
        if (size) {
            this.size$.next(size.currentValue);
        }
        if (fullWidth) {
            this.fullWidth$.next(this.fullWidth);
        }
    }
    ngAfterContentInit() {
        this.options.changes
            .pipe(startWith(this.options), filter(() => this.queue != null && this.canSelectValue()), 
        // Call 'writeValue' when current change detection run is finished.
        // When writing is finished, change detection starts again, since
        // microtasks queue is empty.
        // Prevents ExpressionChangedAfterItHasBeenCheckedError.
        switchMap((options) => from(Promise.resolve(options))), takeUntil(this.destroy$))
            .subscribe(() => this.writeValue(this.queue));
    }
    ngAfterViewInit() {
        this.triggerStrategy = this.createTriggerStrategy();
        this.subscribeOnButtonFocus();
        this.subscribeOnTriggers();
        this.subscribeOnOptionClick();
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.hostRef.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this.alive = false;
        this.destroy$.next();
        this.destroy$.complete();
        if (this.ref) {
            this.ref.dispose();
        }
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    show() {
        if (this.isHidden) {
            this.attachToOverlay();
            this.setActiveOption();
            this.cd.markForCheck();
        }
    }
    hide() {
        if (this.isOpen) {
            this.ref.detach();
            this.cd.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cd.markForCheck();
    }
    writeValue(value) {
        if (!this.alive) {
            return;
        }
        if (this.canSelectValue()) {
            this.setSelection(value);
            if (this.selectionModel.length) {
                this.queue = null;
            }
        }
        else {
            this.queue = value;
        }
    }
    /**
     * Selects option or clear all selected options if value is null.
     * */
    handleOptionClick(option) {
        this.queue = null;
        if (option.value == null) {
            this.reset();
        }
        else {
            this.selectOption(option);
        }
        this.cd.markForCheck();
    }
    /**
     * Deselect all selected options.
     * */
    reset() {
        this.selectionModel.forEach((option) => option.deselect());
        this.selectionModel = [];
        this.hide();
        this.button.nativeElement.focus();
        this.emitSelected(this.multiple ? [] : null);
    }
    /**
     * Determines how to select option as multiple or single.
     * */
    selectOption(option) {
        if (this.multiple) {
            this.handleMultipleSelect(option);
        }
        else {
            this.handleSingleSelect(option);
        }
    }
    /**
     * Select single option.
     * */
    handleSingleSelect(option) {
        const selected = this.selectionModel.pop();
        if (selected && !this._compareWith(selected.value, option.value)) {
            selected.deselect();
        }
        this.selectionModel = [option];
        option.select();
        this.hide();
        this.button.nativeElement.focus();
        this.emitSelected(option.value);
    }
    /**
     * Select for multiple options.
     * */
    handleMultipleSelect(option) {
        if (option.selected) {
            this.selectionModel = this.selectionModel.filter(s => !this._compareWith(s.value, option.value));
            option.deselect();
        }
        else {
            this.selectionModel.push(option);
            option.select();
        }
        this.emitSelected(this.selectionModel.map((opt) => opt.value));
    }
    attachToOverlay() {
        if (!this.ref) {
            this.createOverlay();
            this.subscribeOnPositionChange();
            this.createKeyManager();
            this.subscribeOnOverlayKeys();
        }
        this.ref.attach(this.portal);
    }
    setActiveOption() {
        if (this.selectionModel.length) {
            this.keyManager.setActiveItem(this.selectionModel[0]);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
    }
    createOverlay() {
        const scrollStrategy = this.createScrollStrategy();
        this.positionStrategy = this.createPositionStrategy();
        this.ref = this.overlay.create({
            positionStrategy: this.positionStrategy,
            scrollStrategy,
            panelClass: this.optionsPanelClass,
        });
    }
    createKeyManager() {
        this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.button)
            .position(NbPosition.BOTTOM)
            .offset(this.optionsOverlayOffset)
            .adjustment(NbAdjustment.VERTICAL);
    }
    createScrollStrategy() {
        return this.overlay.scrollStrategies[this.scrollStrategy]();
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.CLICK)
            .host(this.hostRef.nativeElement)
            .container(() => this.getContainer())
            .build();
    }
    subscribeOnTriggers() {
        this.triggerStrategy.show$.subscribe(() => this.show());
        this.triggerStrategy.hide$
            .pipe(filter(() => this.isOpen))
            .subscribe(($event) => {
            this.hide();
            if (!this.isClickedWithinComponent($event)) {
                this.onTouched();
            }
        });
    }
    subscribeOnPositionChange() {
        this.positionStrategy.positionChange
            .pipe(takeUntil(this.destroy$))
            .subscribe((position) => {
            this.overlayPosition = position;
            this.cd.detectChanges();
        });
    }
    subscribeOnOptionClick() {
        /**
         * If the user changes provided options list in the runtime we have to handle this
         * and resubscribe on options selection changes event.
         * Otherwise, the user will not be able to select new options.
         * */
        this.options.changes
            .pipe(startWith(this.options), switchMap((options) => {
            return merge(...options.map(option => option.click));
        }), takeUntil(this.destroy$))
            .subscribe((clickedOption) => this.handleOptionClick(clickedOption));
    }
    subscribeOnOverlayKeys() {
        this.ref.keydownEvents()
            .pipe(filter(() => this.isOpen), takeUntil(this.destroy$))
            .subscribe((event) => {
            if (event.keyCode === ESCAPE) {
                this.button.nativeElement.focus();
                this.hide();
            }
            else {
                this.keyManager.onKeydown(event);
            }
        });
        this.keyManager.tabOut
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            this.hide();
            this.onTouched();
        });
    }
    subscribeOnButtonFocus() {
        this.focusMonitor.monitor(this.button)
            .pipe(map(origin => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.button)), takeUntil(this.destroy$))
            .subscribe(this.focused$);
    }
    getContainer() {
        return this.ref && this.ref.hasAttached() && {
            location: {
                nativeElement: this.ref.overlayElement,
            },
        };
    }
    /**
     * Propagate selected value.
     * */
    emitSelected(selected) {
        this.onChange(selected);
        this.selectedChange.emit(selected);
    }
    /**
     * Set selected value in model.
     * */
    setSelection(value) {
        const isArray = Array.isArray(value);
        if (this.multiple && !isArray) {
            throw new Error('Can\'t assign single value if select is marked as multiple');
        }
        if (!this.multiple && isArray) {
            throw new Error('Can\'t assign array if select is not marked as multiple');
        }
        const previouslySelectedOptions = this.selectionModel;
        this.selectionModel = [];
        if (isArray) {
            value.forEach(option => this.selectValue(option));
        }
        else {
            this.selectValue(value);
        }
        // find options which were selected before and trigger deselect
        previouslySelectedOptions
            .filter((option) => !this.selectionModel.includes(option))
            .forEach((option) => option.deselect());
        this.cd.markForCheck();
    }
    /**
     * Selects value.
     * */
    selectValue(value) {
        const corresponding = this.options.find((option) => this._compareWith(option.value, value));
        if (corresponding) {
            corresponding.select();
            this.selectionModel.push(corresponding);
        }
    }
    /**
     * Sets touched if focus moved outside of button and overlay,
     * ignoring the case when focus moved to options overlay.
     */
    trySetTouched() {
        if (this.isHidden) {
            this.onTouched();
        }
    }
    isClickedWithinComponent($event) {
        return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
    }
    canSelectValue() {
        return !!(this.options && this.options.length);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get round() {
        return this.shape === 'round';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
}
NbSelectComponent.ɵfac = function NbSelectComponent_Factory(t) { return new (t || NbSelectComponent)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵngcc0.ɵɵdirectiveInject(NbFocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSelectComponent, selectors: [["nb-select"]], contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbOptionComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, viewQuery: function NbSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, 1);
        ɵngcc0.ɵɵviewQuery(_c38, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portal = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.button = _t.first);
    } }, hostVars: 42, hostBindings: function NbSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    } }, inputs: { size: "size", status: "status", shape: "shape", appearance: "appearance", placeholder: "placeholder", optionsOverlayOffset: "optionsOverlayOffset", scrollStrategy: "scrollStrategy", outline: "outline", filled: "filled", hero: "hero", disabled: "disabled", fullWidth: "fullWidth", compareWith: "compareWith", selected: "selected", multiple: "multiple", optionsListClass: "optionsListClass", optionsPanelClass: "optionsPanelClass" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbSelectComponent),
                multi: true
            },
            { provide: NB_SELECT_INJECTION_TOKEN, useExisting: NbSelectComponent },
            { provide: NbFormFieldControl, useExisting: NbSelectComponent },
            { provide: NbFormFieldControlConfig, useFactory: nbSelectFormFieldControlConfigFactory },
        ]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c40, decls: 7, vars: 4, consts: [["type", "button", 1, "select-button", 3, "disabled", "ngClass", "blur", "keydown.arrowDown", "keydown.arrowUp"], ["selectButton", ""], [4, "ngIf", "ngIfElse"], ["placeholderTemplate", ""], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], ["defaultSelectionTemplate", ""], [3, "size", "position", "ngClass"]], template: function NbSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c39);
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("blur", function NbSelectComponent_Template_button_blur_0_listener() { return ctx.trySetTouched(); })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() { return ctx.show(); })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() { return ctx.show(); });
        ɵngcc0.ɵɵtemplate(2, NbSelectComponent_ng_container_2_Template, 4, 2, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(3, NbSelectComponent_ng_template_3_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(5, "nb-icon", 4);
        ɵngcc0.ɵɵlistener("click", function NbSelectComponent_Template_nb_icon_click_5_listener($event) { return ctx.disabled && $event.stopPropagation(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, NbSelectComponent_nb_option_list_6_Template, 2, 5, "nb-option-list", 5);
    } if (rf & 2) {
        const _r2 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", _r2);
    } }, directives: function () { return [ɵngcc2.NgClass, ɵngcc2.NgIf, NbIconComponent, NbPortalDirective, NbOptionListComponent]; }, styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:0.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:0.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:0.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:0.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}"], changeDetection: 0 });
NbSelectComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbOverlayService },
    { type: ElementRef },
    { type: NbPositionBuilderService },
    { type: NbTriggerStrategyBuilderService },
    { type: ChangeDetectorRef },
    { type: NbFocusKeyManagerFactoryService },
    { type: NbFocusMonitor },
    { type: Renderer2 },
    { type: NgZone },
    { type: NbStatusService }
];
NbSelectComponent.propDecorators = {
    size: [{ type: Input }],
    status: [{ type: Input }],
    shape: [{ type: Input }],
    appearance: [{ type: Input }],
    optionsListClass: [{ type: Input }],
    optionsPanelClass: [{ type: Input }],
    outline: [{ type: Input }, { type: HostBinding, args: ['class.appearance-outline',] }],
    filled: [{ type: Input }, { type: HostBinding, args: ['class.appearance-filled',] }],
    hero: [{ type: Input }, { type: HostBinding, args: ['class.appearance-hero',] }],
    disabled: [{ type: Input }],
    fullWidth: [{ type: Input }, { type: HostBinding, args: ['class.full-width',] }],
    placeholder: [{ type: Input }],
    compareWith: [{ type: Input }],
    selected: [{ type: Input }],
    multiple: [{ type: Input }],
    optionsOverlayOffset: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    selectedChange: [{ type: Output }],
    options: [{ type: ContentChildren, args: [NbOptionComponent, { descendants: true },] }],
    customLabel: [{ type: ContentChild, args: [NbSelectLabelComponent,] }],
    portal: [{ type: ViewChild, args: [NbPortalDirective,] }],
    button: [{ type: ViewChild, args: ['selectButton', { read: ElementRef },] }],
    isOpen: [{ type: HostBinding, args: ['class.open',] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    rectangle: [{ type: HostBinding, args: ['class.shape-rectangle',] }],
    round: [{ type: HostBinding, args: ['class.shape-round',] }],
    semiRound: [{ type: HostBinding, args: ['class.shape-semi-round',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSelectComponent, [{
        type: Component,
        args: [{
                selector: 'nb-select',
                template: "<button [disabled]=\"disabled\"\n        [ngClass]=\"selectButtonClasses\"\n        (blur)=\"trySetTouched()\"\n        (keydown.arrowDown)=\"show()\"\n        (keydown.arrowUp)=\"show()\"\n        class=\"select-button\"\n        type=\"button\"\n        #selectButton>\n\n    <ng-container *ngIf=\"selectionModel.length; else placeholderTemplate\">\n      <ng-container *ngIf=\"customLabel; else defaultSelectionTemplate\">\n        <ng-content select=\"nb-select-label\"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n\n    <nb-icon icon=\"chevron-down-outline\" pack=\"nebular-essentials\" (click)=\"disabled && $event.stopPropagation()\" aria-hidden=\"true\">\n    </nb-icon>\n</button>\n\n<nb-option-list *nbPortal [size]=\"size\" [position]=\"overlayPosition\" [style.width.px]=\"hostWidth\" [ngClass]=\"optionsListClass\">\n  <ng-content select=\"nb-option, nb-option-group\"></ng-content>\n</nb-option-list>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbSelectComponent),
                        multi: true
                    },
                    { provide: NB_SELECT_INJECTION_TOKEN, useExisting: NbSelectComponent },
                    { provide: NbFormFieldControl, useExisting: NbSelectComponent },
                    { provide: NbFormFieldControlConfig, useFactory: nbSelectFormFieldControlConfigFactory },
                ],
                styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:0.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:0.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:0.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:0.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbOverlayService }, { type: ɵngcc0.ElementRef }, { type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbFocusKeyManagerFactoryService }, { type: NbFocusMonitor }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], appearance: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], optionsOverlayOffset: [{
            type: Input
        }], scrollStrategy: [{
            type: Input
        }], selectedChange: [{
            type: Output
        }], outline: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-outline']
        }], filled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-filled']
        }], hero: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-hero']
        }], disabled: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], compareWith: [{
            type: Input
        }], selected: [{
            type: Input
        }], multiple: [{
            type: Input
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], isOpen: [{
            type: HostBinding,
            args: ['class.open']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], optionsListClass: [{
            type: Input
        }], optionsPanelClass: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NbOptionComponent, { descendants: true }]
        }], customLabel: [{
            type: ContentChild,
            args: [NbSelectLabelComponent]
        }], portal: [{
            type: ViewChild,
            args: [NbPortalDirective]
        }], button: [{
            type: ViewChild,
            args: ['selectButton', { read: ElementRef }]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * NbOptionGroupComponent
 *
 * @styles
 *
 * option-group-text-color:
 * option-group-tiny-start-padding:
 * option-group-small-start-padding:
 * option-group-medium-start-padding:
 * option-group-large-start-padding:
 * option-group-giant-start-padding:
 **/
class NbOptionGroupComponent {
    constructor() {
        this.destroy$ = new Subject();
        this._disabled = false;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
        if (this.options) {
            this.updateOptionsDisabledState();
        }
    }
    get disabledAttribute() {
        return this.disabled ? '' : null;
    }
    ngAfterContentInit() {
        if (this.options.length) {
            this.asyncUpdateOptionsDisabledState();
        }
        this.options.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.asyncUpdateOptionsDisabledState());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Sets disabled state for each option to current group disabled state.
     */
    updateOptionsDisabledState() {
        this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
    }
    /**
     * Updates options disabled state after promise resolution.
     * This way change detection will be triggered after options state updated.
     * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
     */
    asyncUpdateOptionsDisabledState() {
        // Wrap Promise into Observable with `takeUntil(this.destroy$)` to prevent update if component destroyed.
        from(Promise.resolve())
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.updateOptionsDisabledState());
    }
}
NbOptionGroupComponent.ɵfac = function NbOptionGroupComponent_Factory(t) { return new (t || NbOptionGroupComponent)(); };
NbOptionGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOptionGroupComponent, selectors: [["nb-option-group"]], contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbOptionComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostVars: 1, hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.disabledAttribute);
    } }, inputs: { disabled: "disabled", title: "title" }, ngContentSelectors: _c42, decls: 3, vars: 1, consts: [[1, "option-group-title"]], template: function NbOptionGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c41);
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
    } }, styles: ["[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}"], changeDetection: 0 });
NbOptionGroupComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    disabledAttribute: [{ type: HostBinding, args: ['attr.disabled',] }],
    options: [{ type: ContentChildren, args: [NbOptionComponent, { descendants: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOptionGroupComponent, [{
        type: Component,
        args: [{
                selector: 'nb-option-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
                styles: [":host{display:block}.option-group-title{display:block}\n"]
            }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], title: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NbOptionComponent, { descendants: true }]
        }] }); })();

/**
 * The `NbOptionListComponent` is container component for `NbOptionGroupComponent` and`NbOptionComponent` list.
 *
 * @styles
 *
 * option-list-max-height:
 * option-list-shadow:
 * option-list-background-color:
 * option-list-border-style:
 * option-list-border-width:
 * option-list-border-color:
 * option-list-border-radius:
 * option-list-adjacent-border-color:
 * option-list-adjacent-border-style:
 * option-list-adjacent-border-width:
 * */
class NbOptionListComponent {
    constructor() {
        this.size = 'medium';
    }
    get positionTop() {
        return this.position === NbPosition.TOP;
    }
    get positionBottom() {
        return this.position === NbPosition.BOTTOM;
    }
    get sizeTiny() {
        return this.size === 'tiny';
    }
    get sizeSmall() {
        return this.size === 'small';
    }
    get sizeMedium() {
        return this.size === 'medium';
    }
    get sizeLarge() {
        return this.size === 'large';
    }
    get sizeGiant() {
        return this.size === 'giant';
    }
}
NbOptionListComponent.ɵfac = function NbOptionListComponent_Factory(t) { return new (t || NbOptionListComponent)(); };
NbOptionListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOptionListComponent, selectors: [["nb-option-list"]], hostVars: 14, hostBindings: function NbOptionListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("position-top", ctx.positionTop)("position-bottom", ctx.positionBottom)("size-tiny", ctx.sizeTiny)("size-small", ctx.sizeSmall)("size-medium", ctx.sizeMedium)("size-large", ctx.sizeLarge)("size-giant", ctx.sizeGiant);
    } }, inputs: { size: "size", position: "position" }, ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, "option-list"]], template: function NbOptionListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NbOptionListComponent.propDecorators = {
    size: [{ type: Input }],
    position: [{ type: Input }],
    positionTop: [{ type: HostBinding, args: ['class.position-top',] }],
    positionBottom: [{ type: HostBinding, args: ['class.position-bottom',] }],
    sizeTiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    sizeSmall: [{ type: HostBinding, args: ['class.size-small',] }],
    sizeMedium: [{ type: HostBinding, args: ['class.size-medium',] }],
    sizeLarge: [{ type: HostBinding, args: ['class.size-large',] }],
    sizeGiant: [{ type: HostBinding, args: ['class.size-giant',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOptionListComponent, [{
        type: Component,
        args: [{
                selector: 'nb-option-list',
                template: `
    <ul class="option-list">
      <ng-content></ng-content>
    </ul>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], positionTop: [{
            type: HostBinding,
            args: ['class.position-top']
        }], positionBottom: [{
            type: HostBinding,
            args: ['class.position-bottom']
        }], sizeTiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], sizeSmall: [{
            type: HostBinding,
            args: ['class.size-small']
        }], sizeMedium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], sizeLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], sizeGiant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], position: [{
            type: Input
        }] }); })();

const NB_OPTION_LIST_COMPONENTS = [
    NbOptionListComponent,
    NbOptionComponent,
    NbOptionGroupComponent,
];
class NbOptionModule {
}
NbOptionModule.ɵfac = function NbOptionModule_Factory(t) { return new (t || NbOptionModule)(); };
NbOptionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbOptionModule });
NbOptionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            NbCheckboxModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbOptionModule, { declarations: function () { return [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]; }, imports: function () { return [CommonModule, NbCheckboxModule]; }, exports: function () { return [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbOptionModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    ...NB_OPTION_LIST_COMPONENTS,
                ],
                imports: [
                    CommonModule,
                    NbCheckboxModule,
                ],
                exports: [
                    ...NB_OPTION_LIST_COMPONENTS,
                ]
            }]
    }], null, null); })();

const NB_SELECT_COMPONENTS = [
    NbSelectComponent,
    NbSelectLabelComponent,
];
class NbSelectModule {
}
NbSelectModule.ɵfac = function NbSelectModule_Factory(t) { return new (t || NbSelectModule)(); };
NbSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSelectModule });
NbSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbSharedModule,
            NbOverlayModule,
            NbButtonModule,
            NbInputModule,
            NbCardModule,
            NbIconModule,
            NbOptionModule,
        ], NbOptionModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSelectModule, { declarations: [NbSelectComponent, NbSelectLabelComponent], imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule], exports: [NbSelectComponent, NbSelectLabelComponent, NbOptionModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSelectModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbOverlayModule,
                    NbButtonModule,
                    NbInputModule,
                    NbCardModule,
                    NbIconModule,
                    NbOptionModule,
                ],
                exports: [
                    ...NB_SELECT_COMPONENTS,
                    NbOptionModule,
                ],
                declarations: [...NB_SELECT_COMPONENTS]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
// Component class scoped counter for aria attributes.
let lastAutocompleteId = 0;
/**
 * The `NbAutocompleteComponent` overlay component.
 * Provides an `NbOptionList` overlay component.
 * */
class NbAutocompleteComponent {
    constructor(cd) {
        this.cd = cd;
        this.destroy$ = new Subject();
        /**
         * Component scoped id for aria attributes.
         * */
        this.id = `nb-autocomplete-${lastAutocompleteId++}`;
        /**
         * @docs-private
         * Current overlay position because of we have to toggle overlayPosition
         * in [ngClass] direction.
         */
        this._overlayPosition = '';
        /**
         * Autocomplete size, available sizes:
         * `tiny`, `small`, `medium` (default), `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Flag passed as input to always make first option active.
         * */
        this.activeFirst = false;
        /**
         * Will be emitted when selected value changes.
         * */
        this.selectedChange = new EventEmitter();
    }
    get overlayPosition() {
        return this._overlayPosition;
    }
    set overlayPosition(value) {
        this._overlayPosition = value;
        // Need run change detection after first set from NbAutocompleteDirective
        this.cd.detectChanges();
    }
    /**
     * Returns width of the input.
     * */
    get hostWidth() {
        return this.hostRef.nativeElement.getBoundingClientRect().width;
    }
    ngAfterContentInit() {
        this.options.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Autocomplete knows nothing about host html input element.
     * So, attach method set input hostRef for styling.
     * */
    setHost(hostRef) {
        this.hostRef = hostRef;
    }
    /**
     * Propagate selected value.
     * */
    emitSelected(selected) {
        this.selectedChange.emit(selected);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
}
NbAutocompleteComponent.ɵfac = function NbAutocompleteComponent_Factory(t) { return new (t || NbAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAutocompleteComponent, selectors: [["nb-autocomplete"]], contentQueries: function NbAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbOptionComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, viewQuery: function NbAutocompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portal = _t.first);
    } }, hostVars: 10, hostBindings: function NbAutocompleteComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    } }, inputs: { size: "size", activeFirst: "activeFirst", handleDisplayFn: "handleDisplayFn", optionsListClass: "optionsListClass", optionsPanelClass: "optionsPanelClass" }, outputs: { selectedChange: "selectedChange" }, ngContentSelectors: _c44, decls: 1, vars: 0, consts: [["role", "listbox", 3, "size", "position", "width", "id", "empty", "ngClass", 4, "nbPortal"], ["role", "listbox", 3, "size", "position", "id", "ngClass"]], template: function NbAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c43);
        ɵngcc0.ɵɵtemplate(0, NbAutocompleteComponent_nb_option_list_0_Template, 2, 8, "nb-option-list", 0);
    } }, directives: [NbPortalDirective, NbOptionListComponent, ɵngcc2.NgClass], styles: ["[_nghost-%COMP%]:hover{cursor:pointer}nb-option-list.empty[_ngcontent-%COMP%]{border:none}"], changeDetection: 0 });
NbAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NbAutocompleteComponent.propDecorators = {
    handleDisplayFn: [{ type: Input }],
    size: [{ type: Input }],
    activeFirst: [{ type: Input }],
    optionsListClass: [{ type: Input }],
    optionsPanelClass: [{ type: Input }],
    selectedChange: [{ type: Output }],
    options: [{ type: ContentChildren, args: [NbOptionComponent, { descendants: true },] }],
    portal: [{ type: ViewChild, args: [NbPortalDirective,] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAutocompleteComponent, [{
        type: Component,
        args: [{
                selector: 'nb-autocomplete',
                template: "<nb-option-list *nbPortal\n                [size]=\"size\"\n                [position]=\"overlayPosition\"\n                [style.width.px]=\"hostWidth\"\n                role=\"listbox\"\n                [id]=\"id\"\n                [class.empty]=\"!options?.length\"\n                [ngClass]=\"optionsListClass\">\n  <ng-content select=\"nb-option, nb-option-group\"></ng-content>\n</nb-option-list>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host(:hover){cursor:pointer}nb-option-list.empty{border:none}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { size: [{
            type: Input
        }], activeFirst: [{
            type: Input
        }], selectedChange: [{
            type: Output
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], handleDisplayFn: [{
            type: Input
        }], optionsListClass: [{
            type: Input
        }], optionsPanelClass: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NbOptionComponent, { descendants: true }]
        }], portal: [{
            type: ViewChild,
            args: [NbPortalDirective]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbAutocompleteDirective` provides a capability to expand input with
 * `NbAutocompleteComponent` overlay containing options to select and fill input with.
 *
 * @stacked-example(Showcase, autocomplete/autocomplete-showcase.component)
 *
 * ### Installation
 *
 * Import `NbAutocompleteModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbAutocompleteModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * You can bind control with form controls or ngModel.
 *
 * @stacked-example(Autocomplete form binding, autocomplete/autocomplete-form.component)
 *
 * Options in the autocomplete may be grouped using `nb-option-group` component.
 *
 * @stacked-example(Grouping, autocomplete/autocomplete-group.component)
 *
 * Autocomplete may change selected option value via provided function.
 *
 * @stacked-example(Custom display, autocomplete/autocomplete-custom-display.component)
 *
 * Also, autocomplete may make first option in option list active automatically.
 *
 * @stacked-example(Active first, autocomplete/autocomplete-active-first.component)
 *
 * */
class NbAutocompleteDirective {
    constructor(hostRef, overlay, cd, triggerStrategyBuilder, positionBuilder, activeDescendantKeyManagerFactory, renderer) {
        this.hostRef = hostRef;
        this.overlay = overlay;
        this.cd = cd;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.positionBuilder = positionBuilder;
        this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
        this.renderer = renderer;
        this.destroy$ = new Subject();
        this._onChange = () => { };
        this._onTouched = () => { };
        /**
         * Determines options overlay offset (in pixels).
         **/
        this.overlayOffset = 8;
        this._focusInputOnValueChange = true;
        /**
         * Determines options overlay scroll strategy.
         **/
        this.scrollStrategy = 'block';
        this.role = 'combobox';
        this.ariaAutocomplete = 'list';
        this.hasPopup = 'true';
    }
    /**
     * Determines is autocomplete overlay opened.
     * */
    get isOpen() {
        return this.overlayRef && this.overlayRef.hasAttached();
    }
    /**
     * Determines is autocomplete overlay closed.
     * */
    get isClosed() {
        return !this.isOpen;
    }
    /**
     * Provides autocomplete component.
     * */
    get autocomplete() {
        return this._autocomplete;
    }
    set autocomplete(autocomplete) {
        this._autocomplete = autocomplete;
    }
    /**
     * Determines if the input will be focused when the control value is changed
     * */
    get focusInputOnValueChange() {
        return this._focusInputOnValueChange;
    }
    set focusInputOnValueChange(value) {
        this._focusInputOnValueChange = convertToBoolProperty(value);
    }
    get top() {
        return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.TOP;
    }
    get bottom() {
        return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.BOTTOM;
    }
    get ariaExpanded() {
        return this.isOpen && this.isOpen.toString();
    }
    get ariaOwns() {
        return this.isOpen ? this.autocomplete.id : null;
    }
    get ariaActiveDescendant() {
        return (this.isOpen && this.keyManager.activeItem) ? this.keyManager.activeItem.id : null;
    }
    ngAfterViewInit() {
        this.triggerStrategy = this.createTriggerStrategy();
        this.subscribeOnTriggers();
    }
    ngOnDestroy() {
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
        if (this.positionStrategy) {
            this.positionStrategy.dispose();
        }
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this.destroy$.next();
        this.destroy$.complete();
    }
    handleInput() {
        const currentValue = this.hostRef.nativeElement.value;
        this._onChange(currentValue);
        this.setHostInputValue(this.getDisplayValue(currentValue));
        this.show();
    }
    handleKeydown() {
        this.show();
    }
    handleBlur() {
        this._onTouched();
    }
    show() {
        if (this.isClosed) {
            this.attachToOverlay();
            this.setActiveItem();
        }
    }
    hide() {
        if (this.isOpen) {
            this.overlayRef.detach();
            // Need to update class via @HostBinding
            this.cd.markForCheck();
        }
    }
    writeValue(value) {
        this.handleInputValueUpdate(value);
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(disabled) {
        this.renderer.setProperty(this.hostRef.nativeElement, 'disabled', disabled);
    }
    subscribeOnOptionClick() {
        /**
         * If the user changes provided options list in the runtime we have to handle this
         * and resubscribe on options selection changes event.
         * Otherwise, the user will not be able to select new options.
         * */
        this.autocomplete.options.changes
            .pipe(tap(() => this.setActiveItem()), startWith(this.autocomplete.options), switchMap((options) => {
            return merge(...options.map(option => option.click));
        }), takeUntil(this.destroy$))
            .subscribe((clickedOption) => this.handleInputValueUpdate(clickedOption.value));
    }
    subscribeOnPositionChange() {
        this.positionStrategy.positionChange
            .pipe(takeUntil(this.destroy$))
            .subscribe((position) => {
            this.autocomplete.overlayPosition = position;
            this.cd.detectChanges();
        });
    }
    getActiveItem() {
        return this.keyManager.activeItem;
    }
    setupAutocomplete() {
        this.autocomplete.setHost(this.customOverlayHost || this.hostRef);
    }
    getDisplayValue(value) {
        const displayFn = this.autocomplete.handleDisplayFn;
        return displayFn ? displayFn(value) : value;
    }
    getContainer() {
        return this.overlayRef && this.isOpen && {
            location: {
                nativeElement: this.overlayRef.overlayElement,
            },
        };
    }
    handleInputValueUpdate(value) {
        if (value === undefined || value === null) {
            return;
        }
        this.setHostInputValue(value);
        this._onChange(value);
        if (this.focusInputOnValueChange) {
            this.hostRef.nativeElement.focus();
        }
        this.autocomplete.emitSelected(value);
        this.hide();
    }
    subscribeOnTriggers() {
        this.triggerStrategy.show$
            .pipe(filter(() => this.isClosed))
            .subscribe(() => this.show());
        this.triggerStrategy.hide$
            .pipe(filter(() => this.isOpen))
            .subscribe(() => this.hide());
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.FOCUS)
            .host(this.hostRef.nativeElement)
            .container(() => this.getContainer())
            .build();
    }
    createKeyManager() {
        this.keyManager = this.activeDescendantKeyManagerFactory
            .create(this.autocomplete.options);
    }
    setHostInputValue(value) {
        this.hostRef.nativeElement.value = this.getDisplayValue(value);
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.customOverlayHost || this.hostRef)
            .position(NbPosition.BOTTOM)
            .offset(this.overlayOffset)
            .adjustment(NbAdjustment.VERTICAL);
    }
    subscribeOnOverlayKeys() {
        this.overlayRef.keydownEvents()
            .pipe(takeUntil(this.destroy$))
            .subscribe((event) => {
            if (event.keyCode === ESCAPE && this.isOpen) {
                event.preventDefault();
                this.hostRef.nativeElement.focus();
                this.hide();
            }
            else if (event.keyCode === ENTER) {
                event.preventDefault();
                const activeItem = this.getActiveItem();
                if (!activeItem) {
                    return;
                }
                this.handleInputValueUpdate(activeItem.value);
            }
            else {
                this.keyManager.onKeydown(event);
            }
        });
    }
    setActiveItem() {
        // If autocomplete has activeFirst input set to true,
        // keyManager set first option active, otherwise - reset active option.
        const mode = this.autocomplete.activeFirst
            ? NbKeyManagerActiveItemMode.FIRST_ACTIVE
            : NbKeyManagerActiveItemMode.RESET_ACTIVE;
        this.keyManager.setActiveItem(mode);
        this.cd.detectChanges();
    }
    attachToOverlay() {
        if (!this.overlayRef) {
            this.setupAutocomplete();
            this.initOverlay();
        }
        this.overlayRef.attach(this.autocomplete.portal);
    }
    createOverlay() {
        const scrollStrategy = this.createScrollStrategy();
        this.overlayRef = this.overlay.create({ positionStrategy: this.positionStrategy, scrollStrategy, panelClass: this.autocomplete.optionsPanelClass });
    }
    initOverlay() {
        this.positionStrategy = this.createPositionStrategy();
        this.createKeyManager();
        this.subscribeOnPositionChange();
        this.subscribeOnOptionClick();
        this.checkOverlayVisibility();
        this.createOverlay();
        this.subscribeOnOverlayKeys();
    }
    checkOverlayVisibility() {
        this.autocomplete.options.changes
            .pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (!this.autocomplete.options.length) {
                this.hide();
            }
        });
    }
    createScrollStrategy() {
        return this.overlay.scrollStrategies[this.scrollStrategy]();
    }
}
NbAutocompleteDirective.ɵfac = function NbAutocompleteDirective_Factory(t) { return new (t || NbAutocompleteDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbAutocompleteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbAutocompleteDirective, selectors: [["input", "nbAutocomplete", ""]], hostVars: 10, hostBindings: function NbAutocompleteDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function NbAutocompleteDirective_input_HostBindingHandler() { return ctx.handleInput(); })("keydown.arrowDown", function NbAutocompleteDirective_keydown_arrowDown_HostBindingHandler() { return ctx.handleKeydown(); })("keydown.arrowUp", function NbAutocompleteDirective_keydown_arrowUp_HostBindingHandler() { return ctx.handleKeydown(); })("blur", function NbAutocompleteDirective_blur_HostBindingHandler() { return ctx.handleBlur(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-autocomplete", ctx.ariaAutocomplete)("haspopup", ctx.hasPopup)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant);
        ɵngcc0.ɵɵclassProp("nb-autocomplete-position-top", ctx.top)("nb-autocomplete-position-bottom", ctx.bottom);
    } }, inputs: { overlayOffset: "overlayOffset", scrollStrategy: "scrollStrategy", autocomplete: ["nbAutocomplete", "autocomplete"], focusInputOnValueChange: "focusInputOnValueChange", customOverlayHost: "customOverlayHost" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbAutocompleteDirective),
                multi: true
            }])] });
NbAutocompleteDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbOverlayService },
    { type: ChangeDetectorRef },
    { type: NbTriggerStrategyBuilderService },
    { type: NbPositionBuilderService },
    { type: NbActiveDescendantKeyManagerFactoryService },
    { type: Renderer2 }
];
NbAutocompleteDirective.propDecorators = {
    autocomplete: [{ type: Input, args: ['nbAutocomplete',] }],
    overlayOffset: [{ type: Input }],
    focusInputOnValueChange: [{ type: Input }],
    scrollStrategy: [{ type: Input }],
    customOverlayHost: [{ type: Input }],
    top: [{ type: HostBinding, args: ['class.nb-autocomplete-position-top',] }],
    bottom: [{ type: HostBinding, args: ['class.nb-autocomplete-position-bottom',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaAutocomplete: [{ type: HostBinding, args: ['attr.aria-autocomplete',] }],
    hasPopup: [{ type: HostBinding, args: ['attr.haspopup',] }],
    ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
    ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
    ariaActiveDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    handleInput: [{ type: HostListener, args: ['input',] }],
    handleKeydown: [{ type: HostListener, args: ['keydown.arrowDown',] }, { type: HostListener, args: ['keydown.arrowUp',] }],
    handleBlur: [{ type: HostListener, args: ['blur',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAutocompleteDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbAutocomplete]',
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbAutocompleteDirective),
                        multi: true
                    }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbOverlayService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbTriggerStrategyBuilderService }, { type: NbPositionBuilderService }, { type: NbActiveDescendantKeyManagerFactoryService }, { type: ɵngcc0.Renderer2 }]; }, { overlayOffset: [{
            type: Input
        }], scrollStrategy: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaAutocomplete: [{
            type: HostBinding,
            args: ['attr.aria-autocomplete']
        }], hasPopup: [{
            type: HostBinding,
            args: ['attr.haspopup']
        }], autocomplete: [{
            type: Input,
            args: ['nbAutocomplete']
        }], focusInputOnValueChange: [{
            type: Input
        }], top: [{
            type: HostBinding,
            args: ['class.nb-autocomplete-position-top']
        }], bottom: [{
            type: HostBinding,
            args: ['class.nb-autocomplete-position-bottom']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], ariaActiveDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], handleInput: [{
            type: HostListener,
            args: ['input']
        }], handleKeydown: [{
            type: HostListener,
            args: ['keydown.arrowDown']
        }, {
            type: HostListener,
            args: ['keydown.arrowUp']
        }], handleBlur: [{
            type: HostListener,
            args: ['blur']
        }], customOverlayHost: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_AUTOCOMPLETE_COMPONENTS = [
    NbAutocompleteComponent,
    NbAutocompleteDirective,
];
class NbAutocompleteModule {
}
NbAutocompleteModule.ɵfac = function NbAutocompleteModule_Factory(t) { return new (t || NbAutocompleteModule)(); };
NbAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbAutocompleteModule });
NbAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            FormsModule,
            NbOverlayModule,
            NbCardModule,
            NbOptionModule,
        ], NbOptionModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbAutocompleteModule, { declarations: function () { return [NbAutocompleteComponent, NbAutocompleteDirective]; }, imports: function () { return [CommonModule,
        FormsModule, NbOverlayModule, NbCardModule, NbOptionModule]; }, exports: function () { return [NbAutocompleteComponent, NbAutocompleteDirective, NbOptionModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbAutocompleteModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    NbOverlayModule,
                    NbCardModule,
                    NbOptionModule,
                ],
                exports: [
                    ...NB_AUTOCOMPLETE_COMPONENTS,
                    NbOptionModule,
                ],
                declarations: [...NB_AUTOCOMPLETE_COMPONENTS]
            }]
    }], null, null); })();

var NbWindowState;
(function (NbWindowState) {
    NbWindowState["MINIMIZED"] = "minimized";
    NbWindowState["MAXIMIZED"] = "maximized";
    NbWindowState["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
/**
 * Window configuration options.
 */
class NbWindowConfig {
    constructor(...configs) {
        /**
         * Window title.
         */
        this.title = '';
        /**
         * Initial window state. Full screen by default.
         */
        this.initialState = NbWindowState.FULL_SCREEN;
        /**
         * If true than backdrop will be rendered behind window.
         * By default set to true.
         */
        this.hasBackdrop = true;
        /**
         * If set to true mouse clicks on backdrop will close a window.
         * Default is true.
         */
        this.closeOnBackdropClick = true;
        /**
         * If true then escape press will close a window.
         * Default is true.
         */
        this.closeOnEsc = true;
        /**
         * Class to be applied to the window.
         */
        this.windowClass = '';
        /**
         * Both, template and component may receive data through `config.context` property.
         * For components, this data will be set as component properties.
         * For templates, you can access it inside template as $implicit.
         */
        this.context = {};
        /**
         * Where the attached component should live in Angular's *logical* component tree.
         * This affects what is available for injection and the change detection order for the
         * component instantiated inside of the window. This does not affect where the window
         * content will be rendered.
         */
        this.viewContainerRef = null;
        Object.assign(this, ...configs);
    }
}
const NB_WINDOW_CONTENT = new InjectionToken('Nebular Window Content');
const NB_WINDOW_CONFIG = new InjectionToken('Nebular Window Config');
const NB_WINDOW_CONTEXT = new InjectionToken('Nebular Window Context');

/**
 * The `NbWindowRef` helps to manipulate window after it was created.
 * The window can be dismissed by using `close` method of the windowRef.
 * You can access rendered component as `componentRef` property of the windowRef.
 */
class NbWindowRef {
    constructor(config) {
        this.config = config;
        this.stateChange$ = new ReplaySubject(1);
        this._closed = false;
        this.closed$ = new Subject();
        this.state = config.initialState;
    }
    /**
     * Current window state.
     */
    get state() {
        return this.stateValue;
    }
    set state(newState) {
        if (newState && this.stateValue !== newState) {
            this.prevStateValue = this.state;
            this.stateValue = newState;
            this.stateChange$.next({ oldState: this.prevStateValue, newState });
        }
    }
    /**
     * Emits when window state change.
     */
    get stateChange() {
        return this.stateChange$.asObservable();
    }
    /**
     * Emits when window was closed.
     */
    get onClose() {
        return this.closed$.asObservable();
    }
    /**
     * Minimize window.
     */
    minimize() {
        this.state = NbWindowState.MINIMIZED;
    }
    /**
     * Maximize window.
     */
    maximize() {
        this.state = NbWindowState.MAXIMIZED;
    }
    /**
     * Set window on top.
     */
    fullScreen() {
        this.state = NbWindowState.FULL_SCREEN;
    }
    toPreviousState() {
        this.state = this.prevStateValue;
    }
    /**
     * Closes window.
     * */
    close() {
        if (this._closed) {
            return;
        }
        this._closed = true;
        this.componentRef.destroy();
        this.stateChange$.complete();
        this.closed$.next();
        this.closed$.complete();
    }
}

class NbWindowsContainerComponent {
}
NbWindowsContainerComponent.ɵfac = function NbWindowsContainerComponent_Factory(t) { return new (t || NbWindowsContainerComponent)(); };
NbWindowsContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbWindowsContainerComponent, selectors: [["nb-windows-container"]], viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c45, 3, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    } }, decls: 2, vars: 0, consts: [["viewContainerRef", ""]], template: function NbWindowsContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, null, 0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"] });
NbWindowsContainerComponent.propDecorators = {
    viewContainerRef: [{ type: ViewChild, args: ['viewContainerRef', { read: ViewContainerRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbWindowsContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-windows-container',
                template: `<ng-container #viewContainerRef></ng-container>`,
                styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
            }]
    }], null, { viewContainerRef: [{
            type: ViewChild,
            args: ['viewContainerRef', { read: ViewContainerRef, static: true }]
        }] }); })();

class NbWindowComponent {
    constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
        this.content = content;
        this.context = context;
        this.windowRef = windowRef;
        this.config = config;
        this.focusTrapFactory = focusTrapFactory;
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    get isFullScreen() {
        return this.windowRef.state === NbWindowState.FULL_SCREEN;
    }
    get maximized() {
        return this.windowRef.state === NbWindowState.MAXIMIZED;
    }
    get minimized() {
        return this.windowRef.state === NbWindowState.MINIMIZED;
    }
    ngOnInit() {
        this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
        this.focusTrap.blurPreviouslyFocusedElement();
        this.focusTrap.focusInitialElement();
        if (this.config.windowClass) {
            this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
        }
    }
    ngAfterViewChecked() {
        if (!this.overlayContainer || this.overlayContainer.isAttached) {
            return;
        }
        if (this.content instanceof TemplateRef) {
            this.attachTemplate();
        }
        else {
            this.attachComponent();
        }
    }
    ngOnDestroy() {
        if (this.focusTrap) {
            this.focusTrap.restoreFocus();
        }
        this.close();
    }
    minimize() {
        if (this.windowRef.state === NbWindowState.MINIMIZED) {
            this.windowRef.toPreviousState();
        }
        else {
            this.windowRef.minimize();
        }
    }
    maximize() {
        this.windowRef.maximize();
    }
    fullScreen() {
        this.windowRef.fullScreen();
    }
    maximizeOrFullScreen() {
        if (this.windowRef.state === NbWindowState.MINIMIZED) {
            this.maximize();
        }
        else {
            this.fullScreen();
        }
    }
    close() {
        this.windowRef.close();
    }
    attachTemplate() {
        this.overlayContainer
            .attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
    }
    attachComponent() {
        const portal = new NbComponentPortal(this.content, null, null, this.cfr);
        const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
        ref.changeDetectorRef.detectChanges();
    }
}
NbWindowComponent.ɵfac = function NbWindowComponent_Factory(t) { return new (t || NbWindowComponent)(ɵngcc0.ɵɵdirectiveInject(NB_WINDOW_CONTENT), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW_CONTEXT), ɵngcc0.ɵɵdirectiveInject(NbWindowRef), ɵngcc0.ɵɵdirectiveInject(NbWindowConfig), ɵngcc0.ɵɵdirectiveInject(NbFocusTrapFactoryService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbWindowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbWindowComponent, selectors: [["nb-window"]], viewQuery: function NbWindowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbOverlayContainerComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, hostVars: 6, hostBindings: function NbWindowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
    } }, inputs: { cfr: "cfr" }, decls: 12, vars: 4, consts: [["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], [1, "buttons"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials"], [4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"]], template: function NbWindowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-card");
        ɵngcc0.ɵɵelementStart(1, "nb-card-header");
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 1);
        ɵngcc0.ɵɵelementStart(5, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NbWindowComponent_Template_button_click_5_listener() { return ctx.minimize(); });
        ɵngcc0.ɵɵelement(6, "nb-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NbWindowComponent_button_7_Template, 2, 0, "button", 4);
        ɵngcc0.ɵɵtemplate(8, NbWindowComponent_button_8_Template, 2, 0, "button", 4);
        ɵngcc0.ɵɵelementStart(9, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NbWindowComponent_Template_button_click_9_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelement(10, "nb-icon", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NbWindowComponent_nb_card_body_11_Template, 2, 0, "nb-card-body", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.config.title);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isFullScreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.minimized || ctx.maximized);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.maximized || ctx.isFullScreen);
    } }, directives: [NbCardComponent, NbCardHeaderComponent, NbButtonComponent, NbIconComponent, ɵngcc2.NgIf, NbCardBodyComponent, NbOverlayContainerComponent], styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:space-evenly}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%, -50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"] });
NbWindowComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_WINDOW_CONTENT,] }] },
    { type: Object, decorators: [{ type: Inject, args: [NB_WINDOW_CONTEXT,] }] },
    { type: NbWindowRef },
    { type: NbWindowConfig },
    { type: NbFocusTrapFactoryService },
    { type: ElementRef },
    { type: Renderer2 }
];
NbWindowComponent.propDecorators = {
    cfr: [{ type: Input }],
    isFullScreen: [{ type: HostBinding, args: ['class.full-screen',] }],
    maximized: [{ type: HostBinding, args: ['class.maximized',] }],
    minimized: [{ type: HostBinding, args: ['class.minimized',] }],
    overlayContainer: [{ type: ViewChild, args: [NbOverlayContainerComponent,] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbWindowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-window',
                template: `
    <nb-card>
      <nb-card-header>
        <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>

        <div class="buttons">
          <button nbButton ghost (click)="minimize()">
            <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
            <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
            <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost (click)="close()">
            <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
          </button>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
                styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:space-evenly}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%, -50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONTENT]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONTEXT]
            }] }, { type: NbWindowRef }, { type: NbWindowConfig }, { type: NbFocusTrapFactoryService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { isFullScreen: [{
            type: HostBinding,
            args: ['class.full-screen']
        }], maximized: [{
            type: HostBinding,
            args: ['class.maximized']
        }], minimized: [{
            type: HostBinding,
            args: ['class.minimized']
        }], cfr: [{
            type: Input
        }], overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent]
        }] }); })();

/**
 * The `NbWindowService` can be used to open windows.
 *
 * @stacked-example(Showcase, window/window-showcase.component)
 *
 * ### Installation
 *
 * Import `NbWindowModule` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbWindowModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * If you are using it in a lazy loaded module than you have to install `NbWindowModule.forChild`:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbWindowModule.forChild(config),
 *   ],
 * })
 * export class LazyLoadedModule { }
 * ```
 *
 * ### Usage
 *
 * A new window can be opened by calling the `open` method with a component or template to be loaded
 * and an optional configuration.
 * `open` method will return `NbWindowRef` that can be used for the further manipulations.
 *
 * ```ts
 * const windowRef = this.windowService.open(MyComponent, { ... });
 * ```
 *
 * `NbWindowRef` gives you ability manipulate opened window.
 * Also, you can inject `NbWindowRef` inside provided component which rendered in window.
 *
 * ```ts
 * this.windowService.open(MyWindowComponent, { ... });
 *
 * // my.component.ts
 * constructor(protected windowRef: NbWindowRef) {
 * }
 *
 * minimize() {
 *   this.windowRef.minimize();
 * }
 *
 * close() {
 *   this.windowRef.close();
 * }
 * ```
 *
 * Instead of component you can create window from TemplateRef. As usual you can access context provided via config
 * via `let-` variables. Also you can get reference to the `NbWindowRef` in context's `windowRef` property.
 *
 * @stacked-example(Window content from TemplateRef, window/template-window.component)
 *
 * ### Configuration
 *
 * As mentioned above, `open` method of the `NbWindowService` may receive optional configuration options.
 * Also, you can modify default windows configuration through `NbWindowModule.forRoot({ ... })`.
 * You can read about all available options on [API tab](docs/components/window/api#nbwindowconfig).
 *
 * @stacked-example(Configuration, window/windows-backdrop.component)
 */
class NbWindowService {
    constructor(componentFactoryResolver, overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, cfr, document) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.overlayService = overlayService;
        this.overlayPositionBuilder = overlayPositionBuilder;
        this.blockScrollStrategy = blockScrollStrategy;
        this.defaultWindowsConfig = defaultWindowsConfig;
        this.cfr = cfr;
        this.openWindows = [];
        this.document = document;
    }
    /**
     * Opens new window.
     * @param windowContent
     * @param windowConfig
     * */
    open(windowContent, windowConfig = {}) {
        if (this.shouldCreateWindowsContainer()) {
            this.createWindowsContainer();
        }
        const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
        const windowRef = new NbWindowRef(config);
        windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
        this.openWindows.push(windowRef);
        this.subscribeToEvents(windowRef);
        return windowRef;
    }
    shouldCreateWindowsContainer() {
        if (this.windowsContainerViewRef) {
            const containerEl = this.windowsContainerViewRef.element.nativeElement;
            return !this.document.body.contains(containerEl);
        }
        return true;
    }
    createWindowsContainer() {
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this.overlayRef = this.overlayService.create({
            scrollStrategy: this.overlayService.scrollStrategies.noop(),
            positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
            hasBackdrop: true,
        });
        const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null, this.cfr);
        const overlayRef = this.overlayRef.attach(windowsContainerPortal);
        this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
    }
    appendWindow(content, config, windowRef) {
        const context = content instanceof TemplateRef
            ? { $implicit: config.context, windowRef }
            : config.context;
        const providers = [
            { provide: NB_WINDOW_CONTENT, useValue: content },
            { provide: NB_WINDOW_CONTEXT, useValue: context },
            { provide: NbWindowConfig, useValue: config },
            { provide: NbWindowRef, useValue: windowRef },
        ];
        const parentInjector = config.viewContainerRef
            ? config.viewContainerRef.injector
            : this.windowsContainerViewRef.injector;
        const injector = Injector.create({ parent: parentInjector, providers });
        const windowFactory = this.componentFactoryResolver.resolveComponentFactory(NbWindowComponent);
        const ref = this.windowsContainerViewRef.createComponent(windowFactory, null, injector);
        ref.instance.cfr = this.cfr;
        ref.changeDetectorRef.detectChanges();
        return ref;
    }
    subscribeToEvents(windowRef) {
        if (windowRef.config.closeOnBackdropClick) {
            this.overlayRef.backdropClick().subscribe(() => windowRef.close());
        }
        if (windowRef.config.closeOnEsc) {
            this.overlayRef.keydownEvents()
                .pipe(filter((event) => event.keyCode === 27))
                .subscribe(() => windowRef.close());
        }
        windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
        windowRef.onClose.subscribe(() => {
            this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
            this.checkAndUpdateOverlay();
        });
    }
    checkAndUpdateOverlay() {
        const fullScreenWindows = this.openWindows.filter(w => w.state === NbWindowState.FULL_SCREEN);
        if (fullScreenWindows.length > 0) {
            this.blockScrollStrategy.enable();
        }
        else {
            this.blockScrollStrategy.disable();
        }
        if (fullScreenWindows.some(w => w.config.hasBackdrop)) {
            this.overlayRef.backdropElement.removeAttribute('hidden');
        }
        else {
            this.overlayRef.backdropElement.setAttribute('hidden', '');
        }
    }
}
NbWindowService.ɵfac = function NbWindowService_Factory(t) { return new (t || NbWindowService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(NbOverlayPositionBuilder), ɵngcc0.ɵɵinject(NbBlockScrollStrategyAdapter), ɵngcc0.ɵɵinject(NB_WINDOW_CONFIG), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbWindowService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbWindowService, factory: NbWindowService.ɵfac });
NbWindowService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: NbOverlayService },
    { type: NbOverlayPositionBuilder },
    { type: NbBlockScrollStrategyAdapter },
    { type: NbWindowConfig, decorators: [{ type: Inject, args: [NB_WINDOW_CONFIG,] }] },
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbWindowService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: NbOverlayService }, { type: NbOverlayPositionBuilder }, { type: NbBlockScrollStrategyAdapter }, { type: NbWindowConfig, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONFIG]
            }] }, { type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();

class NbWindowModule {
    static forRoot(defaultConfig) {
        return {
            ngModule: NbWindowModule,
            providers: [
                NbWindowService,
                { provide: NB_WINDOW_CONFIG, useValue: defaultConfig },
            ],
        };
    }
    static forChild(defaultConfig) {
        return {
            ngModule: NbWindowModule,
            providers: [
                NbWindowService,
                { provide: NB_WINDOW_CONFIG, useValue: defaultConfig },
            ],
        };
    }
}
NbWindowModule.ɵfac = function NbWindowModule_Factory(t) { return new (t || NbWindowModule)(); };
NbWindowModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbWindowModule });
NbWindowModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbWindowModule, { declarations: function () { return [NbWindowsContainerComponent, NbWindowComponent]; }, imports: function () { return [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbWindowModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
                declarations: [
                    NbWindowsContainerComponent,
                    NbWindowComponent,
                ],
                entryComponents: [NbWindowsContainerComponent, NbWindowComponent]
            }]
    }], null, null); })();

/**
 * The `NbTimePickerDirective` is form control that gives you ability to select a time. The timepicker
 * is shown when input receives a `focus` event.
 * ```html
 * <input [nbTimepicker]="timepicker">
 * <nb-timepicker #timepicker></nb-timepicker>
 * ```
 *
 * @stacked-example(Showcase, timepicker/timepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTimepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTimepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbTimepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTimepickerModule,
 *   ],
 * })
 * export class PageModule { }
 *
 * ```
 * <div id="native-parse-issue" class="note note-warning">
 * <div class="note-title">Note</div>
 * <div class="note-body">
 * Timepicker uses native Date object by default, which doesn't support parsing by custom format.
 * According to the ECMAScript specification, the only supported format is a format described by ISO 8061 standard.
 * This standard requires date part to be included in the date string,
 * meaning you have to type a date+time in the input.
 * We highly recommend you to use NbDateFnsDateModule or NbMomentDateModule to be able to support time only strings in
 * the timepicker inputs. These modules use date-fns and moment date libraries, which provide capabilities
 * to parse time only strings.
 * See "Formatting Issue" at
 * <a href="https://akveo.github.io/nebular/docs/components/datepicker/overview#formatting-issue">Date picker docs</a>
 * for installation instructions.
 * </div>
 * </div>
 * <hr>
 *
 * ### Usage
 *
 * To show seconds column along with hours and minutes use `withSeconds` input
 *
 * ```html
 * <input [nbTimepicker]="timepicker">
 * <nb-timepicker #timepicker withSeconds></nb-timepicker>
 * ```
 * @stacked-example(Time picker with seconds, timepicker/timepicker-with-seconds.component)
 *
 * To force timepicker work in 12 hours format, use `twelveHoursFormat` input.
 * By default, timepicker choose 12 or 24 formats based on application locale standards
 *
 * ```html
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicker></nb-timepicker>
 * ```
 *
 * @stacked-example(Twelve hours format showcase, timepicker/timepicker-twelve-hours-format.component)
 *
 * A single column picker with options value as time and minute, so users won’t be able to pick
 * hours and minutes individually.
 * You can control options minutes offset via `step` input, e.g.: 11:00, 11:20, 11:40...'
 *
 * @stacked-example(Single column, timepicker/timepicker-single-column.component)
 *
 * Timepicker support forms and reactive forms API so you can provide value using `formControl` and `ngModel` directives
 * @stacked-example(Form control, timepicker/timepicker-form-control.component)
 *
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicke [formControl]="formControl"></nb-timepicker>
 *
 * @stacked-example(NgModel, timepicker/timepicker-ng-model.component)
 *
 * <input [nbTimepicker]="timepicker" twelveHoursFormat>
 * <nb-timepicker #timepicke [ngModel]="date"></nb-timepicker>
 *
 * @styles
 *
 * timepicker-cell-text-color:
 * timepicker-cell-hover-background-color:
 * timepicker-cell-hover-text-color:
 * timepicker-cell-focus-background-color:
 * timepicker-cell-focus-text-color:
 * timepicker-cell-active-background-color:
 * timepicker-cell-active-text-color:
 * timepicker-cell-text-font-size:
 * timepicker-cell-text-font-family:
 * timepicker-cell-text-line-height:
 * timepicker-cell-text-font-weight:
 * timepicker-cell-height:
 * timepicker-header-cell-text-color:
 * timepicker-header-cell-text-font-size:
 * timepicker-header-cell-text-font-family:
 * timepicker-header-cell-height:
 * timepicker-header-cell-text-line-height:
 * timepicker-header-cell-text-font-weight:
 * timepicker-border-color:
 * timepicker-border-style:
 * timepicker-border-width:
 * timepicker-scrollbar-color:
 * timepicker-scrollbar-background-color:
 * timepicker-scrollbar-width:
 * timepicker-single-column-width:
 * timepicker-multiple-column-width:
 * timepicker-title-height:
 * timepicker-title-padding:
 * timepicker-container-width:
 * timepicker-container-height:
 * */
class NbTimePickerDirective {
    constructor(document, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
        this.document = document;
        this.positionBuilder = positionBuilder;
        this.hostRef = hostRef;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.overlay = overlay;
        this.cd = cd;
        this.calendarTimeModelService = calendarTimeModelService;
        this.dateService = dateService;
        this.renderer = renderer;
        this.placeholder = placeholder;
        /**
         * Time picker overlay offset.
         * */
        this.overlayOffset = 8;
        this.destroy$ = new Subject();
        this.onChange = () => {
        };
        this.onTouched = () => {
        };
    }
    /**
     * Provides timepicker component.
     * */
    get timepicker() {
        return this._timePickerComponent;
    }
    set timepicker(timePicker) {
        this._timePickerComponent = timePicker;
    }
    /**
     * Returns html input element.
     * @docs-private
     * */
    get input() {
        return this.hostRef.nativeElement;
    }
    /**
     * Determines is timepicker overlay opened.
     * @docs-private
     * */
    get isOpen() {
        return this.overlayRef && this.overlayRef.hasAttached();
    }
    /**
     * Determines is timepicker overlay closed.
     * @docs-private
     * */
    get isClosed() {
        return !this.isOpen;
    }
    /**
     * Returns host input value.
     * @docs-private
     * */
    get inputValue() {
        return this.input.value;
    }
    set inputValue(value) {
        this.input.value = value;
    }
    ngAfterViewInit() {
        this.subscribeOnInputChange();
        if (!this.placeholder) {
            this.renderer.setProperty(this.input, 'placeholder', this.timepicker.timeFormat);
        }
        this.triggerStrategy = this.createTriggerStrategy();
        this.subscribeOnTriggers();
        this.subscribeToBlur();
    }
    show() {
        if (this.isClosed) {
            this.attachToOverlay();
        }
    }
    hide() {
        if (this.isOpen) {
            this.overlayRef.detach();
            this.cd.markForCheck();
        }
    }
    /**
     * Attaches picker to the timepicker portal.
     * @docs-private
     * */
    attachToOverlay() {
        if (!this.overlayRef) {
            this.setupTimepicker();
            this.initOverlay();
        }
        this.overlayRef.attach(this.timepicker.portal);
    }
    setupTimepicker() {
        if (this.dateService.getId() === 'native' && isDevMode()) {
            console.warn('Date.parse noes not support parsing time with custom format.' +
                ' See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue');
        }
        this.timepicker.setHost(this.hostRef);
        if (this.inputValue) {
            const val = this.dateService.getId() === 'native' ? this.parseNativeDateString(this.inputValue) : this.inputValue;
            this.timepicker.date = this.dateService.parse(val, this.timepicker.timeFormat);
        }
        else {
            this.timepicker.date = this.calendarTimeModelService.getResetTime();
        }
    }
    initOverlay() {
        this.positionStrategy = this.createPositionStrategy();
        this.subscribeOnApplyClick();
        this.createOverlay();
    }
    subscribeOnApplyClick() {
        this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
            const time = this.dateService.format(value.time, this.timepicker.timeFormat).toUpperCase();
            this.inputValue = time;
            this.timepicker.date = value.time;
            this.onChange(value.time);
            if (value.save) {
                this.lastInputValue = time;
                this.hide();
            }
        });
    }
    createOverlay() {
        const scrollStrategy = this.createScrollStrategy();
        this.overlayRef = this.overlay.create({ positionStrategy: this.positionStrategy, scrollStrategy });
    }
    subscribeOnTriggers() {
        this.triggerStrategy.show$
            .pipe(filter(() => this.isClosed))
            .subscribe(() => this.show());
        this.triggerStrategy.hide$
            .pipe(filter(() => this.isOpen))
            .subscribe(() => {
            this.inputValue = this.lastInputValue || '';
            this.hide();
        });
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.FOCUS)
            .host(this.hostRef.nativeElement)
            .container(() => this.getContainer())
            .build();
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.hostRef)
            .position(NbPosition.BOTTOM)
            .offset(this.overlayOffset)
            .adjustment(NbAdjustment.VERTICAL);
    }
    getContainer() {
        return this.overlayRef && this.isOpen && {
            location: {
                nativeElement: this.overlayRef.overlayElement,
            },
        };
    }
    createScrollStrategy() {
        return this.overlay.scrollStrategies.block();
    }
    subscribeOnInputChange() {
        fromEvent(this.input, 'input')
            .pipe(map(() => this.inputValue), takeUntil(this.destroy$))
            .subscribe((value) => this.handleInputChange(value));
    }
    subscribeToBlur() {
        merge(this.timepicker.blur, fromEvent(this.input, 'blur').pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$))
            .subscribe(() => this.onTouched());
    }
    /**
     * Parses input value and write if it isn't null.
     * @docs-private
     * */
    handleInputChange(value) {
        if (this.dateService.getId() === 'native') {
            /**
             * Native date service dont parse only time string value,
             * and we adding year mouth and day to convert string to valid date format
             **/
            value = this.parseNativeDateString(value);
        }
        const isValidDate = this.dateService.isValidDateString(value, this.timepicker.timeFormat);
        if (isValidDate) {
            this.lastInputValue = value;
            const date = this.dateService.parse(value, this.timepicker.timeFormat);
            this.onChange(date);
            this.timepicker.date = date;
        }
    }
    updateValue(value) {
        if (value) {
            this.timepicker.date = value;
            this.inputValue = this.dateService.format(value, this.timepicker.timeFormat).toUpperCase();
        }
    }
    writeValue(value) {
        this.updateValue(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    parseNativeDateString(value) {
        const date = this.dateService.today();
        const year = this.dateService.getYear(date);
        const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
        const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
        return `${year}-${month}-${day} ${value}`;
    }
}
NbTimePickerDirective.ɵfac = function NbTimePickerDirective_Factory(t) { return new (t || NbTimePickerDirective)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbCalendarTimeModelService), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵinjectAttribute('placeholder')); };
NbTimePickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTimePickerDirective, selectors: [["input", "nbTimepicker", ""]], inputs: { overlayOffset: "overlayOffset", timepicker: ["nbTimepicker", "timepicker"] }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbTimePickerDirective),
                multi: true
            }])] });
NbTimePickerDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbPositionBuilderService },
    { type: ElementRef },
    { type: NbTriggerStrategyBuilderService },
    { type: NbOverlayService },
    { type: ChangeDetectorRef },
    { type: NbCalendarTimeModelService },
    { type: NbDateService },
    { type: Renderer2 },
    { type: String, decorators: [{ type: Attribute, args: ['placeholder',] }] }
];
NbTimePickerDirective.propDecorators = {
    timepicker: [{ type: Input, args: ['nbTimepicker',] }],
    overlayOffset: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTimePickerDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbTimepicker]',
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbTimePickerDirective),
                        multi: true
                    }]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPositionBuilderService }, { type: ɵngcc0.ElementRef }, { type: NbTriggerStrategyBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbCalendarTimeModelService }, { type: NbDateService }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{
                type: Attribute,
                args: ['placeholder']
            }] }]; }, { overlayOffset: [{
            type: Input
        }], timepicker: [{
            type: Input,
            args: ['nbTimepicker']
        }] }); })();

class NbTimePickerCellComponent {
    constructor(ngZone, platformService) {
        this.ngZone = ngZone;
        this.platformService = platformService;
        this.selectedChange$ = new Subject();
        this.unselected$ = this.selectedChange$.pipe(filter((selected) => !selected));
        this.destroy$ = new Subject();
        this.select = new EventEmitter();
    }
    set selected(selected) {
        if (selected) {
            this._selected = selected;
            this.scrollToElement();
        }
        this.selectedChange$.next(selected);
    }
    ;
    get selected() {
        return this._selected;
    }
    onClick() {
        this.select.emit({ value: this.value });
    }
    ngAfterViewInit() {
        if (this.selected) {
            // Since we render timepicker in the overlay, at the moment this hook called,
            // timepicker could be not fully rendered and placed. Because of it, we're waiting for Angular
            // to finish change detection run and only then scroll to the selected cell.
            this.ngZone.onStable
                .pipe(take(1), takeUntil(merge(this.unselected$, this.destroy$)))
                .subscribe(() => this.scrollToElement());
        }
    }
    scrollToElement() {
        if (this.valueContainerElement && this.platformService.isBrowser) {
            this.ngZone.runOutsideAngular(() => this.valueContainerElement.nativeElement.scrollIntoView({ block: 'center' }));
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NbTimePickerCellComponent.ɵfac = function NbTimePickerCellComponent_Factory(t) { return new (t || NbTimePickerCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbPlatform)); };
NbTimePickerCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTimePickerCellComponent, selectors: [["nb-timepicker-cell"]], viewQuery: function NbTimePickerCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c46, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueContainerElement = _t.first);
    } }, hostBindings: function NbTimePickerCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTimePickerCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { selected: "selected", value: "value" }, outputs: { select: "select" }, decls: 3, vars: 1, consts: [["valueContainer", ""]], template: function NbTimePickerCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
    } }, styles: ["[_nghost-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center;user-select:none}"], changeDetection: 0 });
NbTimePickerCellComponent.ctorParameters = () => [
    { type: NgZone },
    { type: NbPlatform }
];
NbTimePickerCellComponent.propDecorators = {
    selected: [{ type: Input }],
    value: [{ type: Input }],
    select: [{ type: Output }],
    valueContainerElement: [{ type: ViewChild, args: ['valueContainer',] }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTimePickerCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-timepicker-cell',
                template: `
    <div #valueContainer>{{ value }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%;height:100%;display:flex;align-items:center;justify-content:center;user-select:none}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: NbPlatform }]; }, { select: [{
            type: Output
        }], selected: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], value: [{
            type: Input
        }], valueContainerElement: [{
            type: ViewChild,
            args: ['valueContainer']
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTimepickerModule {
    static forRoot(config = {}) {
        return {
            ngModule: NbTimepickerModule,
            providers: [{ provide: NB_TIME_PICKER_CONFIG, useValue: config }],
        };
    }
    static forChild(config = {}) {
        return {
            ngModule: NbTimepickerModule,
            providers: [{ provide: NB_TIME_PICKER_CONFIG, useValue: config }],
        };
    }
}
NbTimepickerModule.ɵfac = function NbTimepickerModule_Factory(t) { return new (t || NbTimepickerModule)(); };
NbTimepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTimepickerModule });
NbTimepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [NbCalendarTimeModelService], imports: [[
            CommonModule,
            NbOverlayModule,
            NbListModule,
            NbCardModule,
            NbCalendarKitModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTimepickerModule, { declarations: function () { return [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]; }, imports: function () { return [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule]; }, exports: function () { return [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTimepickerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    NbOverlayModule,
                    NbListModule,
                    NbCardModule,
                    NbCalendarKitModule,
                ],
                providers: [NbCalendarTimeModelService],
                exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
                declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDateAdapterService extends NbDatepickerAdapter {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.picker = NbDatepickerComponent;
    }
    parse(date, format) {
        return this.dateService.parse(date, format);
    }
    format(date, format) {
        return this.dateService.format(date, format);
    }
    isValid(date, format) {
        return this.dateService.isValidDateString(date, format);
    }
}
NbDateAdapterService.ɵfac = function NbDateAdapterService_Factory(t) { return new (t || NbDateAdapterService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbDateAdapterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDateAdapterService, factory: NbDateAdapterService.ɵfac });
NbDateAdapterService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDateAdapterService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();
class NbRangeAdapterService extends NbDatepickerAdapter {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.picker = NbRangepickerComponent;
    }
    parse(range, format) {
        const [start, end] = range.split('-').map(subDate => subDate.trim());
        return {
            start: this.dateService.parse(start, format),
            end: this.dateService.parse(end, format),
        };
    }
    format(range, format) {
        if (!range) {
            return '';
        }
        const start = this.dateService.format(range.start, format);
        const isStartValid = this.dateService.isValidDateString(start, format);
        if (!isStartValid) {
            return '';
        }
        const end = this.dateService.format(range.end, format);
        const isEndValid = this.dateService.isValidDateString(end, format);
        if (isEndValid) {
            return `${start} - ${end}`;
        }
        else {
            return start;
        }
    }
    isValid(range, format) {
        const [start, end] = range.split('-').map(subDate => subDate.trim());
        return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
    }
}
NbRangeAdapterService.ɵfac = function NbRangeAdapterService_Factory(t) { return new (t || NbRangeAdapterService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbRangeAdapterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbRangeAdapterService, factory: NbRangeAdapterService.ɵfac });
NbRangeAdapterService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRangeAdapterService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();
class NbDateTimeAdapterService extends NbDatepickerAdapter {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.picker = NbDateTimePickerComponent;
    }
    parse(date, format) {
        return this.dateService.parse(date, format);
    }
    format(date, format) {
        return this.dateService.format(date, format);
    }
    isValid(date, format) {
        return this.dateService.isValidDateString(date, format);
    }
}
NbDateTimeAdapterService.ɵfac = function NbDateTimeAdapterService_Factory(t) { return new (t || NbDateTimeAdapterService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbDateTimeAdapterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDateTimeAdapterService, factory: NbDateTimeAdapterService.ɵfac });
NbDateTimeAdapterService.ctorParameters = () => [
    { type: NbDateService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDateTimeAdapterService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDatepickerModule {
    static forRoot() {
        return {
            ngModule: NbDatepickerModule,
            providers: [
                DatePipe,
                {
                    provide: NB_DATE_ADAPTER,
                    multi: true,
                    useClass: NbDateAdapterService,
                },
                {
                    provide: NB_DATE_ADAPTER,
                    multi: true,
                    useClass: NbRangeAdapterService,
                },
                {
                    provide: NB_DATE_ADAPTER,
                    multi: true,
                    useClass: NbDateTimeAdapterService,
                },
            ],
        };
    }
}
NbDatepickerModule.ɵfac = function NbDatepickerModule_Factory(t) { return new (t || NbDatepickerModule)(); };
NbDatepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbDatepickerModule });
NbDatepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            NbOverlayModule,
            NbCalendarModule,
            NbCalendarRangeModule,
            NbCardModule,
            NbBaseCalendarModule,
            NbTimepickerModule,
            NbCalendarKitModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbDatepickerModule, { declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent], imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule], exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbDatepickerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbOverlayModule,
                    NbCalendarModule,
                    NbCalendarRangeModule,
                    NbCardModule,
                    NbBaseCalendarModule,
                    NbTimepickerModule,
                    NbCalendarKitModule,
                ],
                exports: [
                    NbDatepickerDirective,
                    NbDatepickerComponent,
                    NbRangepickerComponent,
                    NbDateTimePickerComponent,
                    NbCalendarWithTimeComponent,
                ],
                declarations: [
                    NbDatepickerDirective,
                    NbDatepickerContainerComponent,
                    NbCalendarWithTimeComponent,
                    NbDateTimePickerComponent,
                    NbDatepickerComponent,
                    NbRangepickerComponent,
                    NbBasePickerComponent,
                ],
                entryComponents: [
                    NbCalendarComponent,
                    NbCalendarRangeComponent,
                    NbDatepickerContainerComponent,
                    NbCalendarWithTimeComponent,
                ]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbRadioComponent` provides the same functionality as native `<input type="radio">`
 * with Nebular styles and animations.
 *
 * @stacked-example(Showcase, radio/radio-showcase.component)
 *
 * ### Installation
 *
 * Import `NbRadioModule` to your feature module.
 *
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbRadioModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * Radio buttons should be wrapped in `nb-radio-group` to provide form bindings.
 *
 * ```html
 * <nb-radio-group [(ngModel)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * You can disable some radios in the group using a `disabled` attribute.
 *
 * @stacked-example(Disabled, radio/radio-disabled.component)
 *
 *
 * @styles
 *
 * radio-width:
 * radio-height:
 * radio-border-style:
 * radio-border-width:
 * radio-text-font-family:
 * radio-text-font-size:
 * radio-text-font-weight:
 * radio-text-line-height:
 * radio-outline-color:
 * radio-outline-width:
 * radio-basic-text-color:
 * radio-basic-border-color:
 * radio-basic-background-color:
 * radio-basic-checked-background-color:
 * radio-basic-checked-border-color:
 * radio-basic-inner-circle-color:
 * radio-basic-focus-border-color:
 * radio-basic-focus-inner-circle-color:
 * radio-basic-hover-background-color:
 * radio-basic-hover-border-color:
 * radio-basic-hover-inner-circle-color:
 * radio-basic-hover-checked-background-color:
 * radio-basic-active-border-color:
 * radio-basic-active-inner-circle-color:
 * radio-basic-disabled-background-color:
 * radio-basic-disabled-border-color:
 * radio-basic-disabled-text-color:
 * radio-basic-disabled-checked-background-color:
 * radio-basic-disabled-checked-border-color:
 * radio-basic-disabled-checked-inner-circle-color:
 * radio-primary-text-color:
 * radio-primary-border-color:
 * radio-primary-background-color:
 * radio-primary-checked-background-color:
 * radio-primary-checked-border-color:
 * radio-primary-inner-circle-color:
 * radio-primary-focus-border-color:
 * radio-primary-focus-inner-circle-color:
 * radio-primary-hover-background-color:
 * radio-primary-hover-border-color:
 * radio-primary-hover-inner-circle-color:
 * radio-primary-hover-checked-background-color:
 * radio-primary-active-border-color:
 * radio-primary-active-inner-circle-color:
 * radio-primary-disabled-background-color:
 * radio-primary-disabled-border-color:
 * radio-primary-disabled-text-color:
 * radio-primary-disabled-checked-background-color:
 * radio-primary-disabled-checked-border-color:
 * radio-primary-disabled-checked-inner-circle-color:
 * radio-success-text-color:
 * radio-success-border-color:
 * radio-success-background-color:
 * radio-success-checked-background-color:
 * radio-success-checked-border-color:
 * radio-success-inner-circle-color:
 * radio-success-focus-border-color:
 * radio-success-focus-inner-circle-color:
 * radio-success-hover-background-color:
 * radio-success-hover-border-color:
 * radio-success-hover-inner-circle-color:
 * radio-success-hover-checked-background-color:
 * radio-success-active-border-color:
 * radio-success-active-inner-circle-color:
 * radio-success-disabled-background-color:
 * radio-success-disabled-border-color:
 * radio-success-disabled-text-color:
 * radio-success-disabled-checked-background-color:
 * radio-success-disabled-checked-border-color:
 * radio-success-disabled-checked-inner-circle-color:
 * radio-info-text-color:
 * radio-info-border-color:
 * radio-info-background-color:
 * radio-info-checked-background-color:
 * radio-info-checked-border-color:
 * radio-info-inner-circle-color:
 * radio-info-focus-border-color:
 * radio-info-focus-inner-circle-color:
 * radio-info-hover-background-color:
 * radio-info-hover-border-color:
 * radio-info-hover-inner-circle-color:
 * radio-info-hover-checked-background-color:
 * radio-info-active-border-color:
 * radio-info-active-inner-circle-color:
 * radio-info-disabled-background-color:
 * radio-info-disabled-border-color:
 * radio-info-disabled-text-color:
 * radio-info-disabled-checked-background-color:
 * radio-info-disabled-checked-border-color:
 * radio-info-disabled-checked-inner-circle-color:
 * radio-warning-text-color:
 * radio-warning-border-color:
 * radio-warning-background-color:
 * radio-warning-checked-background-color:
 * radio-warning-checked-border-color:
 * radio-warning-inner-circle-color:
 * radio-warning-focus-border-color:
 * radio-warning-focus-inner-circle-color:
 * radio-warning-hover-background-color:
 * radio-warning-hover-border-color:
 * radio-warning-hover-inner-circle-color:
 * radio-warning-hover-checked-background-color:
 * radio-warning-active-border-color:
 * radio-warning-active-inner-circle-color:
 * radio-warning-disabled-background-color:
 * radio-warning-disabled-border-color:
 * radio-warning-disabled-text-color:
 * radio-warning-disabled-checked-background-color:
 * radio-warning-disabled-checked-border-color:
 * radio-warning-disabled-checked-inner-circle-color:
 * radio-danger-text-color:
 * radio-danger-border-color:
 * radio-danger-background-color:
 * radio-danger-checked-background-color:
 * radio-danger-checked-border-color:
 * radio-danger-inner-circle-color:
 * radio-danger-focus-border-color:
 * radio-danger-focus-inner-circle-color:
 * radio-danger-hover-background-color:
 * radio-danger-hover-border-color:
 * radio-danger-hover-inner-circle-color:
 * radio-danger-hover-checked-background-color:
 * radio-danger-active-border-color:
 * radio-danger-active-inner-circle-color:
 * radio-danger-disabled-background-color:
 * radio-danger-disabled-border-color:
 * radio-danger-disabled-text-color:
 * radio-danger-disabled-checked-background-color:
 * radio-danger-disabled-checked-border-color:
 * radio-danger-disabled-checked-inner-circle-color:
 * radio-control-text-color:
 * radio-control-background-color:
 * radio-control-border-color:
 * radio-control-checked-background-color:
 * radio-control-checked-border-color:
 * radio-control-inner-circle-color:
 * radio-control-focus-border-color:
 * radio-control-focus-inner-circle-color:
 * radio-control-hover-background-color:
 * radio-control-hover-border-color:
 * radio-control-hover-inner-circle-color:
 * radio-control-hover-checked-background-color:
 * radio-control-active-border-color:
 * radio-control-active-inner-circle-color:
 * radio-control-disabled-background-color:
 * radio-control-disabled-border-color:
 * radio-control-disabled-text-color:
 * radio-control-disabled-checked-background-color:
 * radio-control-disabled-checked-border-color:
 * radio-control-disabled-checked-inner-circle-color:
 * */
class NbRadioComponent {
    constructor(cd, renderer, statusService) {
        this.cd = cd;
        this.renderer = renderer;
        this.statusService = statusService;
        this._checked = false;
        this._disabled = false;
        this.status = 'basic';
        this.valueChange = new EventEmitter();
        this.blur = new EventEmitter();
    }
    get name() {
        return this._name;
    }
    set name(value) {
        if (this._name !== value) {
            this._name = value;
        }
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        const boolValue = convertToBoolProperty(value);
        if (this._checked !== boolValue) {
            this._checked = boolValue;
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (this._value !== value) {
            this._value = value;
        }
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        const boolValue = convertToBoolProperty(disabled);
        if (this._disabled !== boolValue) {
            this._disabled = boolValue;
        }
    }
    get isPrimary() {
        return this.status === 'primary';
    }
    get isSuccess() {
        return this.status === 'success';
    }
    get isWarning() {
        return this.status === 'warning';
    }
    get isDanger() {
        return this.status === 'danger';
    }
    get isInfo() {
        return this.status === 'info';
    }
    get isBasic() {
        return this.status === 'basic';
    }
    get isControl() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    onChange(event) {
        event.stopPropagation();
        this.checked = true;
        this.valueChange.emit(this.value);
    }
    onClick(event) {
        event.stopPropagation();
    }
    /*
     * @docs-private
     * We use this method when setting radio inputs from radio group component.
     * Otherwise Angular won't detect changes in radio template as cached last rendered
     * value didn't updated.
     **/
    _markForCheck() {
        this.cd.markForCheck();
    }
    /*
     * @docs-private
     * Use this method when setting radio name from radio group component.
     * In case option 'name' isn't set on nb-radio component we need to set name
     * right away, so it won't overlap with options without names from other radio
     * groups. Otherwise they all would have same name and will be considered as
     * options from one group so only the last option will stay selected.
     **/
    _setName(name) {
        this.name = name;
        if (this.input) {
            this.renderer.setProperty(this.input.nativeElement, 'name', name);
        }
    }
}
NbRadioComponent.ɵfac = function NbRadioComponent_Factory(t) { return new (t || NbRadioComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRadioComponent, selectors: [["nb-radio"]], viewQuery: function NbRadioComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c47, 1, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 16, hostBindings: function NbRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
    } }, inputs: { status: "status", name: "name", checked: "checked", value: "value", disabled: "disabled" }, outputs: { valueChange: "valueChange", blur: "blur" }, ngContentSelectors: _c0, decls: 7, vars: 4, consts: [["type", "radio", 1, "native-input", "visually-hidden", 3, "name", "value", "checked", "disabled", "change", "click"], ["input", ""], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]], template: function NbRadioComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label");
        ɵngcc0.ɵɵelementStart(1, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function NbRadioComponent_Template_input_change_1_listener($event) { return ctx.onChange($event); })("click", function NbRadioComponent_Template_input_click_1_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "span", 2);
        ɵngcc0.ɵɵelement(4, "span", 3);
        ɵngcc0.ɵɵelementStart(5, "span", 4);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
    } }, styles: ["[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:0.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(0.6)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}"], changeDetection: 0 });
NbRadioComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: NbStatusService }
];
NbRadioComponent.propDecorators = {
    name: [{ type: Input }],
    checked: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    status: [{ type: Input }],
    valueChange: [{ type: Output }],
    blur: [{ type: Output }],
    input: [{ type: ViewChild, args: ['input', { read: ElementRef },] }],
    isPrimary: [{ type: HostBinding, args: ['class.status-primary',] }],
    isSuccess: [{ type: HostBinding, args: ['class.status-success',] }],
    isWarning: [{ type: HostBinding, args: ['class.status-warning',] }],
    isDanger: [{ type: HostBinding, args: ['class.status-danger',] }],
    isInfo: [{ type: HostBinding, args: ['class.status-info',] }],
    isBasic: [{ type: HostBinding, args: ['class.status-basic',] }],
    isControl: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRadioComponent, [{
        type: Component,
        args: [{
                selector: 'nb-radio',
                template: `
    <label>
      <input
        #input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:0.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(0.6)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: NbStatusService }]; }, { status: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], blur: [{
            type: Output
        }], name: [{
            type: Input
        }], checked: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isPrimary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], isSuccess: [{
            type: HostBinding,
            args: ['class.status-success']
        }], isWarning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], isDanger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], isInfo: [{
            type: HostBinding,
            args: ['class.status-info']
        }], isBasic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], isControl: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], input: [{
            type: ViewChild,
            args: ['input', { read: ElementRef }]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbRadioGroupComponent` is the wrapper for `nb-radio` button.
 * It provides form bindings:
 *
 * ```html
 * <nb-radio-group [(ngModel)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * Also, you can use `value` and `valueChange` for binding without forms.
 *
 * ```html
 * <nb-radio-group [(value)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * Radio items name has to be provided through `name` input property of the radio group.
 *
 * ```html
 * <nb-radio-group name="my-radio-group">
 *   ...
 * </nb-radio-group>
 * ```
 *
 * You can change radio group status by setting `status` input.
 * @stacked-example(Statuses, radio/radio-statuses.component)
 *
 * Also, you can disable the whole group using `disabled` attribute.
 * @stacked-example(Disabled group, radio/radio-disabled-group.component)
 *
 * */
class NbRadioGroupComponent {
    constructor(hostElement, platformId, document) {
        this.hostElement = hostElement;
        this.platformId = platformId;
        this.document = document;
        this.destroy$ = new Subject();
        this.onChange = (value) => { };
        this.onTouched = () => { };
        this._status = 'basic';
        this.valueChange = new EventEmitter();
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.updateValues();
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        this.updateNames();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        this._disabled = convertToBoolProperty(disabled);
        this.updateDisabled();
    }
    /**
     * Radio buttons status.
     * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (this._status !== value) {
            this._status = value;
            this.updateStatus();
        }
    }
    ngAfterContentInit() {
        // In case option 'name' isn't set on nb-radio component,
        // we need to set it's name right away, so it won't overlap with options
        // without names from other radio groups. Otherwise they all would have
        // same name and will be considered as options from one group so only the
        // last option will stay selected.
        this.updateNames();
        this.radios.changes
            .pipe(startWith(this.radios), 
        // 'changes' emit during change detection run and we can't update
        // option properties right of since they already was initialized.
        // Instead we schedule microtask to update radios after change detection
        // run is finished and trigger one more change detection run.
        switchMap((radios) => from(Promise.resolve(radios))), takeUntil(this.destroy$))
            .subscribe(() => this.updateAndSubscribeToRadios());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(value) {
        this.value = value;
    }
    updateAndSubscribeToRadios() {
        this.updateValueFromCheckedOption();
        this.updateNames();
        this.updateValues();
        this.updateDisabled();
        this.updateStatus();
        this.subscribeOnRadiosValueChange();
        this.subscribeOnRadiosBlur();
    }
    updateNames() {
        if (this.radios) {
            this.radios.forEach((radio) => radio._setName(this.name));
        }
    }
    updateValues() {
        this.updateAndMarkForCheckRadios((radio) => radio.checked = radio.value === this.value);
    }
    updateDisabled() {
        if (typeof this.disabled !== 'undefined') {
            this.updateAndMarkForCheckRadios((radio) => radio.disabled = this.disabled);
        }
    }
    subscribeOnRadiosValueChange() {
        if (!this.radios || !this.radios.length) {
            return;
        }
        merge(...this.radios.map((radio) => radio.valueChange))
            .pipe(takeUntil(merge(this.radios.changes, this.destroy$)))
            .subscribe((value) => {
            this.writeValue(value);
            this.propagateValue(value);
        });
    }
    propagateValue(value) {
        this.valueChange.emit(value);
        this.onChange(value);
    }
    subscribeOnRadiosBlur() {
        const hasNoRadios = !this.radios || !this.radios.length;
        if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
            return;
        }
        const hostElement = this.hostElement.nativeElement;
        fromEvent(hostElement, 'focusin')
            .pipe(filter(event => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, 'focusin'), fromEvent(this.document, 'click'))), filter(event => !hostElement.contains(event.target)), takeUntil(merge(this.radios.changes, this.destroy$)))
            .subscribe(() => this.onTouched());
    }
    updateStatus() {
        this.updateAndMarkForCheckRadios((radio) => radio.status = this.status);
    }
    updateAndMarkForCheckRadios(updateFn) {
        if (this.radios) {
            this.radios.forEach((radio) => {
                updateFn(radio);
                radio._markForCheck();
            });
        }
    }
    updateValueFromCheckedOption() {
        const checkedRadio = this.radios.find((radio) => radio.checked);
        const isValueMissing = this.value === undefined || this.value === null;
        if (checkedRadio && isValueMissing && checkedRadio.value !== this.value) {
            this.value = checkedRadio.value;
        }
    }
}
NbRadioGroupComponent.ɵfac = function NbRadioGroupComponent_Factory(t) { return new (t || NbRadioGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT)); };
NbRadioGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRadioGroupComponent, selectors: [["nb-radio-group"]], contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbRadioComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radios = _t);
    } }, inputs: { value: "value", name: "name", disabled: "disabled", status: "status" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbRadioGroupComponent),
                multi: true
            },
        ])], ngContentSelectors: _c49, decls: 1, vars: 0, template: function NbRadioGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c48);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
NbRadioGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] }
];
NbRadioGroupComponent.propDecorators = {
    value: [{ type: Input }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    status: [{ type: Input }],
    radios: [{ type: ContentChildren, args: [NbRadioComponent, { descendants: true },] }],
    valueChange: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRadioGroupComponent, [{
        type: Component,
        args: [{
                selector: 'nb-radio-group',
                template: `
    <ng-content select="nb-radio"></ng-content>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbRadioGroupComponent),
                        multi: true
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, { valueChange: [{
            type: Output
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], disabled: [{
            type: Input
        }], status: [{
            type: Input
        }], radios: [{
            type: ContentChildren,
            args: [NbRadioComponent, { descendants: true }]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbRadioModule {
}
NbRadioModule.ɵfac = function NbRadioModule_Factory(t) { return new (t || NbRadioModule)(); };
NbRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbRadioModule });
NbRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbRadioModule, { declarations: [NbRadioComponent, NbRadioGroupComponent], exports: [NbRadioComponent, NbRadioGroupComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbRadioModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [NbRadioComponent, NbRadioGroupComponent],
                declarations: [NbRadioComponent, NbRadioGroupComponent]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
let tagUniqueId = 0;
/**
 *
 * To show a cross on a tag and enable `remove` event add the `removable` attribute.
 * @stacked-example(Removable tags, tag/tag-removable.component)
 *
 * You can change appearance via `appearance` input:
 * @stacked-example(Tag Appearance, tag/tag-appearance.component)
 *
 * You can change status via `status` input:
 * @stacked-example(Tag Status, tag/tag-status.component)
 *
 * @styles
 *
 * tag-text-font-family:
 * tag-text-transform:
 * tag-border-width:
 * tag-border-style:
 * tag-border-radius:
 * tag-tiny-text-font-size:
 * tag-tiny-text-font-weight:
 * tag-tiny-text-line-height:
 * tag-tiny-padding:
 * tag-tiny-close-offset:
 * tag-small-text-font-size:
 * tag-small-text-font-weight:
 * tag-small-text-line-height:
 * tag-small-padding:
 * tag-small-close-offset:
 * tag-medium-text-font-size:
 * tag-medium-text-font-weight:
 * tag-medium-text-line-height:
 * tag-medium-padding:
 * tag-medium-close-offset:
 * tag-large-text-font-size:
 * tag-large-text-font-weight:
 * tag-large-text-line-height:
 * tag-large-padding:
 * tag-large-close-offset:
 * tag-giant-text-font-size:
 * tag-giant-text-font-weight:
 * tag-giant-text-line-height:
 * tag-giant-padding:
 * tag-giant-close-offset:
 * tag-filled-basic-background-color:
 * tag-filled-basic-border-color:
 * tag-filled-basic-text-color:
 * tag-filled-basic-active-background-color:
 * tag-filled-basic-active-border-color:
 * tag-filled-basic-hover-background-color:
 * tag-filled-basic-hover-border-color:
 * tag-filled-basic-selected-background-color:
 * tag-filled-basic-selected-border-color:
 * tag-filled-primary-background-color:
 * tag-filled-primary-border-color:
 * tag-filled-primary-text-color:
 * tag-filled-primary-active-background-color:
 * tag-filled-primary-active-border-color:
 * tag-filled-primary-hover-background-color:
 * tag-filled-primary-hover-border-color:
 * tag-filled-primary-selected-background-color:
 * tag-filled-primary-selected-border-color:
 * tag-filled-success-background-color:
 * tag-filled-success-border-color:
 * tag-filled-success-text-color:
 * tag-filled-success-active-background-color:
 * tag-filled-success-active-border-color:
 * tag-filled-success-hover-background-color:
 * tag-filled-success-hover-border-color:
 * tag-filled-success-selected-background-color:
 * tag-filled-success-selected-border-color:
 * tag-filled-info-background-color:
 * tag-filled-info-border-color:
 * tag-filled-info-text-color:
 * tag-filled-info-active-background-color:
 * tag-filled-info-active-border-color:
 * tag-filled-info-hover-background-color:
 * tag-filled-info-hover-border-color:
 * tag-filled-info-selected-background-color:
 * tag-filled-info-selected-border-color:
 * tag-filled-warning-background-color:
 * tag-filled-warning-border-color:
 * tag-filled-warning-text-color:
 * tag-filled-warning-active-background-color:
 * tag-filled-warning-active-border-color:
 * tag-filled-warning-hover-background-color:
 * tag-filled-warning-hover-border-color:
 * tag-filled-warning-selected-background-color:
 * tag-filled-warning-selected-border-color:
 * tag-filled-danger-background-color:
 * tag-filled-danger-border-color:
 * tag-filled-danger-text-color:
 * tag-filled-danger-active-background-color:
 * tag-filled-danger-active-border-color:
 * tag-filled-danger-hover-background-color:
 * tag-filled-danger-hover-border-color:
 * tag-filled-danger-selected-background-color:
 * tag-filled-danger-selected-border-color:
 * tag-filled-control-background-color:
 * tag-filled-control-border-color:
 * tag-filled-control-text-color:
 * tag-filled-control-active-background-color:
 * tag-filled-control-active-border-color:
 * tag-filled-control-hover-background-color:
 * tag-filled-control-hover-border-color:
 * tag-filled-control-selected-background-color:
 * tag-filled-control-selected-border-color:
 * tag-outline-basic-background-color:
 * tag-outline-basic-border-color:
 * tag-outline-basic-text-color:
 * tag-outline-basic-active-background-color:
 * tag-outline-basic-active-border-color:
 * tag-outline-basic-active-text-color:
 * tag-outline-basic-hover-background-color:
 * tag-outline-basic-hover-border-color:
 * tag-outline-basic-hover-text-color:
 * tag-outline-basic-selected-background-color:
 * tag-outline-basic-selected-border-color:
 * tag-outline-basic-selected-text-color:
 * tag-outline-primary-background-color:
 * tag-outline-primary-border-color:
 * tag-outline-primary-text-color:
 * tag-outline-primary-active-background-color:
 * tag-outline-primary-active-border-color:
 * tag-outline-primary-active-text-color:
 * tag-outline-primary-hover-background-color:
 * tag-outline-primary-hover-border-color:
 * tag-outline-primary-hover-text-color:
 * tag-outline-primary-selected-background-color:
 * tag-outline-primary-selected-border-color:
 * tag-outline-primary-selected-text-color:
 * tag-outline-success-background-color:
 * tag-outline-success-border-color:
 * tag-outline-success-text-color:
 * tag-outline-success-active-background-color:
 * tag-outline-success-active-border-color:
 * tag-outline-success-active-text-color:
 * tag-outline-success-hover-background-color:
 * tag-outline-success-hover-border-color:
 * tag-outline-success-hover-text-color:
 * tag-outline-success-selected-background-color:
 * tag-outline-success-selected-border-color:
 * tag-outline-success-selected-text-color:
 * tag-outline-info-background-color:
 * tag-outline-info-border-color:
 * tag-outline-info-text-color:
 * tag-outline-info-active-background-color:
 * tag-outline-info-active-border-color:
 * tag-outline-info-active-text-color:
 * tag-outline-info-hover-background-color:
 * tag-outline-info-hover-border-color:
 * tag-outline-info-hover-text-color:
 * tag-outline-info-selected-background-color:
 * tag-outline-info-selected-border-color:
 * tag-outline-info-selected-text-color:
 * tag-outline-warning-background-color:
 * tag-outline-warning-border-color:
 * tag-outline-warning-text-color:
 * tag-outline-warning-active-background-color:
 * tag-outline-warning-active-border-color:
 * tag-outline-warning-active-text-color:
 * tag-outline-warning-hover-background-color:
 * tag-outline-warning-hover-border-color:
 * tag-outline-warning-hover-text-color:
 * tag-outline-warning-selected-background-color:
 * tag-outline-warning-selected-border-color:
 * tag-outline-warning-selected-text-color:
 * tag-outline-danger-background-color:
 * tag-outline-danger-border-color:
 * tag-outline-danger-text-color:
 * tag-outline-danger-active-background-color:
 * tag-outline-danger-active-border-color:
 * tag-outline-danger-active-text-color:
 * tag-outline-danger-hover-background-color:
 * tag-outline-danger-hover-border-color:
 * tag-outline-danger-hover-text-color:
 * tag-outline-danger-selected-background-color:
 * tag-outline-danger-selected-border-color:
 * tag-outline-danger-selected-text-color:
 * tag-outline-control-background-color:
 * tag-outline-control-border-color:
 * tag-outline-control-text-color:
 * tag-outline-control-active-background-color:
 * tag-outline-control-active-border-color:
 * tag-outline-control-active-text-color:
 * tag-outline-control-hover-background-color:
 * tag-outline-control-hover-border-color:
 * tag-outline-control-hover-text-color:
 * tag-outline-control-selected-background-color:
 * tag-outline-control-selected-border-color:
 * tag-outline-control-selected-text-color:
 */
class NbTagComponent {
    constructor(_hostElement, cd, renderer, zone, statusService) {
        this._hostElement = _hostElement;
        this.cd = cd;
        this.renderer = renderer;
        this.zone = zone;
        this.statusService = statusService;
        this._destroy$ = new Subject();
        this._selected = false;
        this._removable = false;
        /**
         * Tag appearance: `filled`, `outline`.
         */
        this.appearance = 'filled';
        /**
         * Tag status: `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
         */
        this.status = 'basic';
        /**
         * Tag size: `tiny`, `small`, `medium`, `large`, `giant`.
         */
        this.size = 'medium';
        this.role = 'option';
        /**
         * Emits when the user removes the tag
         * (whether by clicking on the remove button or by pressing `delete` or `backspace` key).
         */
        this.remove = new EventEmitter();
        this.selectedChange = new EventEmitter();
        this._isActive = false;
        this._id = `nb-tag-${tagUniqueId++}`;
    }
    get destroy$() {
        return this._destroy$.asObservable();
    }
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this.selected !== convertToBoolProperty(value)) {
            this._selected = !this.selected;
            this.selectedChange.emit({ tag: this, selected: this.selected });
        }
    }
    /**
     * Controls whether the user can remove a tag or not.
     */
    get removable() {
        return this._removable;
    }
    set removable(value) {
        this._removable = convertToBoolProperty(value);
    }
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    get basic() {
        return this.status === 'basic';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get control() {
        return this.status === 'control';
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    _remove() {
        if (this.removable) {
            this.remove.emit(this);
        }
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this._hostElement.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this._destroy$.next(this);
    }
    _toggleSelection() {
        this.selected = !this.selected;
        this.cd.markForCheck();
    }
    setActiveStyles() {
        if (!this._isActive) {
            this._isActive = true;
            this.cd.markForCheck();
        }
    }
    setInactiveStyles() {
        if (this._isActive) {
            this._isActive = false;
            this.cd.markForCheck();
        }
    }
}
NbTagComponent.ɵfac = function NbTagComponent_Factory(t) { return new (t || NbTagComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbTagComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTagComponent, selectors: [["nb-tag"]], hostVars: 37, hostBindings: function NbTagComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.delete", function NbTagComponent_keydown_delete_HostBindingHandler() { return ctx._remove(); })("keydown.backspace", function NbTagComponent_keydown_backspace_HostBindingHandler() { return ctx._remove(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("id", ctx._id)("aria-selected", ctx.selected);
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("active", ctx._isActive)("selected", ctx.selected)("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    } }, inputs: { appearance: "appearance", status: "status", size: "size", role: "role", selected: "selected", removable: "removable", text: "text" }, outputs: { remove: "remove", selectedChange: "selectedChange" }, exportAs: ["nbTag"], decls: 2, vars: 2, consts: [["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "class", "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"]], template: function NbTagComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
        ɵngcc0.ɵɵtemplate(1, NbTagComponent_nb_icon_1_Template, 1, 3, "nb-icon", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate1("", ctx.text, "\n");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.removable);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], encapsulation: 2, changeDetection: 0 });
NbTagComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: NbStatusService }
];
NbTagComponent.propDecorators = {
    text: [{ type: Input }],
    selected: [{ type: Input }, { type: HostBinding, args: ['class.selected',] }, { type: HostBinding, args: ['attr.aria-selected',] }],
    removable: [{ type: Input }],
    appearance: [{ type: Input }],
    status: [{ type: Input }],
    size: [{ type: Input }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    remove: [{ type: Output }],
    selectedChange: [{ type: Output }],
    _isActive: [{ type: HostBinding, args: ['class.active',] }],
    _id: [{ type: HostBinding, args: ['attr.id',] }],
    filled: [{ type: HostBinding, args: ['class.appearance-filled',] }],
    outline: [{ type: HostBinding, args: ['class.appearance-outline',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    tiny: [{ type: HostBinding, args: ['class.size-tiny',] }],
    small: [{ type: HostBinding, args: ['class.size-small',] }],
    medium: [{ type: HostBinding, args: ['class.size-medium',] }],
    large: [{ type: HostBinding, args: ['class.size-large',] }],
    giant: [{ type: HostBinding, args: ['class.size-giant',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    _remove: [{ type: HostListener, args: ['keydown.delete',] }, { type: HostListener, args: ['keydown.backspace',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTagComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tag',
                template: "{{ text }}\n<nb-icon *ngIf=\"removable\"\n         (click)=\"_remove()\"\n         class=\"nb-tag-remove size-{{size}}\"\n         icon=\"close-outline\"\n         pack=\"nebular-essentials\"\n         aria-hidden=\"true\">\n</nb-icon>\n",
                exportAs: 'nbTag',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { appearance: [{
            type: Input
        }], status: [{
            type: Input
        }], size: [{
            type: Input
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], remove: [{
            type: Output
        }], selectedChange: [{
            type: Output
        }], _isActive: [{
            type: HostBinding,
            args: ['class.active']
        }], _id: [{
            type: HostBinding,
            args: ['attr.id']
        }], selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.selected']
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }], removable: [{
            type: Input
        }], filled: [{
            type: HostBinding,
            args: ['class.appearance-filled']
        }], outline: [{
            type: HostBinding,
            args: ['class.appearance-outline']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], _remove: [{
            type: HostListener,
            args: ['keydown.delete']
        }, {
            type: HostListener,
            args: ['keydown.backspace']
        }], text: [{
            type: Input
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 *
 * `[nbTagInput]` directive connects input with a `nb-tag-list` component.
 *
 * @stacked-example(Tag Input, tag/tag-input.component)
 *
 * @additional-example(Tag Input with Autocomplete, tag/tag-input-with-autocomplete.component)
 *
 * @styles
 *
 * tag-list-tiny-tag-offset:
 * tag-list-small-tag-offset:
 * tag-list-medium-tag-offset:
 * tag-list-large-tag-offset:
 * tag-list-giant-tag-offset:
 * tag-list-with-input-tiny-padding:
 * tag-list-with-input-small-padding:
 * tag-list-with-input-medium-padding:
 * tag-list-with-input-large-padding:
 * tag-list-with-input-giant-padding:
 */
class NbTagInputDirective extends NbInputDirective {
    constructor(_hostElement, focusMonitor, renderer, zone, statusService) {
        super(_hostElement, focusMonitor, renderer, zone, statusService);
        this._hostElement = _hostElement;
        this.focusMonitor = focusMonitor;
        this.renderer = renderer;
        this.zone = zone;
        this.statusService = statusService;
        this.keyDown$ = new Subject();
        /**
         * Controls which keys should trigger tag add event.
         */
        this.separatorKeys = [ENTER];
        /**
         * Emits when a tag need to be added.
         */
        this.tagAdd = new EventEmitter();
        this.nbTagInputClass = true;
    }
    get _value() {
        return this._hostElement.nativeElement.value;
    }
    _onKeydown(event) {
        this.keyDown$.next(event);
    }
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.keyDown$
            .pipe(filter(({ keyCode }) => this.isSeparatorKey(keyCode)), map(() => this._value), takeUntil(this.destroy$))
            .subscribe((value) => this.tagAdd.emit({ value, input: this._hostElement }));
    }
    isSeparatorKey(keyCode) {
        return this.separatorKeys.includes(keyCode);
    }
}
NbTagInputDirective.ɵfac = function NbTagInputDirective_Factory(t) { return new (t || NbTagInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbFocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbTagInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTagInputDirective, selectors: [["input", "nbTagInput", ""]], hostVars: 2, hostBindings: function NbTagInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NbTagInputDirective_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-tag-input", ctx.nbTagInputClass);
    } }, inputs: { separatorKeys: "separatorKeys" }, outputs: { tagAdd: "tagAdd" }, exportAs: ["nbTagInput"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbFormFieldControl, useExisting: NbTagInputDirective },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbTagInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NbFocusMonitor },
    { type: Renderer2 },
    { type: NgZone },
    { type: NbStatusService }
];
NbTagInputDirective.propDecorators = {
    separatorKeys: [{ type: Input }],
    tagAdd: [{ type: Output }],
    nbTagInputClass: [{ type: HostBinding, args: ['class.nb-tag-input',] }],
    _onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTagInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbTagInput]',
                exportAs: 'nbTagInput',
                providers: [
                    { provide: NbFormFieldControl, useExisting: NbTagInputDirective },
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbFocusMonitor }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { separatorKeys: [{
            type: Input
        }], tagAdd: [{
            type: Output
        }], nbTagInputClass: [{
            type: HostBinding,
            args: ['class.nb-tag-input']
        }], _onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 *
 * `nb-tag-list` component displays a list of `nb-tag` components.
 *
 * @stacked-example(Tag List Showcase, tag/tag-showcase.component)
 *
 * @styles
 *
 * tag-list-tiny-tag-offset:
 * tag-list-small-tag-offset:
 * tag-list-medium-tag-offset:
 * tag-list-large-tag-offset:
 * tag-list-giant-tag-offset:
 * tag-list-with-input-tiny-padding:
 * tag-list-with-input-small-padding:
 * tag-list-with-input-medium-padding:
 * tag-list-with-input-large-padding:
 * tag-list-with-input-giant-padding:
 * tag-list-with-input-rectangle-border-radius:
 * tag-list-with-input-semi-round-border-radius:
 * tag-list-with-input-round-border-radius:
 */
class NbTagListComponent {
    constructor(hostElement, cd, renderer, zone, focusMonitor, activeDescendantKeyManagerFactory, directionService, statusService) {
        this.hostElement = hostElement;
        this.cd = cd;
        this.renderer = renderer;
        this.zone = zone;
        this.focusMonitor = focusMonitor;
        this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
        this.directionService = directionService;
        this.statusService = statusService;
        this.destroy$ = new Subject();
        this.keyDown$ = new Subject();
        this.tagClick$ = new Subject();
        this.focused = false;
        /**
         * Controls tags offset.
         */
        this.size = 'medium';
        this.tabIndex = 0;
        this.role = 'listbox';
        this._multiple = false;
        this.activeTagId = null;
        /**
         * Emits when tag need to be removed (whether because of click on the remove button
         * or when `delete` or `backspace` key pressed).
         */
        this.tagRemove = new EventEmitter();
    }
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = convertToBoolProperty(value);
    }
    get _hasInput() {
        return !!this.tagInput;
    }
    get _isFocused() {
        return this.focused;
    }
    get _isFullWidth() {
        var _a;
        return !!((_a = this.tagInput) === null || _a === void 0 ? void 0 : _a.fullWidth);
    }
    get _inputClasses() {
        if (this._hasInput) {
            return [
                `shape-${this.tagInput.shape}`,
                `size-${this.tagInput.fieldSize}`,
                this.statusService.getStatusClass(this.tagInput.status),
            ];
        }
        return [`size-${this.size}`];
    }
    _onKeydown(event) {
        this.keyDown$.next(event);
    }
    _onClick({ target }) {
        const clickedTag = this.tags.find((tag) => tag._hostElement.nativeElement === target);
        if (clickedTag) {
            this.tagClick$.next(clickedTag);
        }
    }
    ngOnInit() {
        this.focusMonitor.monitor(this.hostElement, true)
            .pipe(map(origin => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.hostElement)), takeUntil(this.destroy$))
            .subscribe((isFocused) => this.onFocusChange(isFocused));
    }
    ngAfterContentInit() {
        this.initKeyManager();
        this.setAutocompleteCustomHost();
    }
    ngAfterViewInit() {
        this.listenToLayoutDirectionChange();
        this.listenListKeyDown();
        this.listenInputKeyDown();
        this.listenTagClick();
        this.listenTagRemove();
        this.listenTagDestroy();
        this.listenActiveTagChange();
        this.listenNoTags();
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.hostElement.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    initKeyManager() {
        this.keyManager = this.activeDescendantKeyManagerFactory
            .create(this.tags)
            .withHorizontalOrientation(this.directionService.getDirection())
            .withWrap();
    }
    listenToLayoutDirectionChange() {
        this.directionService.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe((direction) => this.keyManager.withHorizontalOrientation(direction));
    }
    listenListKeyDown() {
        const tagListKeyDown$ = this.keyDown$
            .pipe(filter(({ target }) => target === this.hostElement.nativeElement));
        const activeTagKeyDown$ = tagListKeyDown$
            .pipe(filter(() => !!this.keyManager.activeItem));
        tagListKeyDown$
            .pipe(takeUntil(this.destroy$))
            .subscribe((event) => this.keyManager.onKeydown(event));
        activeTagKeyDown$
            .pipe(filter(({ keyCode }) => keyCode === SPACE), takeUntil(this.destroy$))
            .subscribe((event) => {
            this.toggleTag(this.keyManager.activeItem);
            // Prevents page scroll.
            event.preventDefault();
        });
        activeTagKeyDown$
            .pipe(filter(({ keyCode }) => this.isBackspaceOrDelete(keyCode)), map(() => this.keyManager.activeItem), takeUntil(this.destroy$))
            .subscribe((tagToRemove) => tagToRemove._remove());
    }
    listenInputKeyDown() {
        const inputKeyDown$ = this.keyDown$
            .pipe(filter(({ target }) => { var _a; return target === ((_a = this.tagInput) === null || _a === void 0 ? void 0 : _a._hostElement.nativeElement); }));
        inputKeyDown$
            .pipe(filter(({ keyCode }) => {
            return this.tagInput._value === '' && this.isBackspaceOrDelete(keyCode) && this.tags.length > 0;
        }), takeUntil(this.destroy$))
            .subscribe(() => {
            this.hostElement.nativeElement.focus();
            this.keyManager.setLastItemActive();
            this.cd.markForCheck();
        });
    }
    listenTagClick() {
        this.tagClick$
            .pipe(takeUntil(this.destroy$))
            .subscribe((clickedTag) => {
            this.toggleTag(clickedTag);
            this.keyManager.setActiveItem(clickedTag);
        });
    }
    listenTagRemove() {
        this.tags.changes
            .pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.remove))), takeUntil(this.destroy$))
            .subscribe((tagToRemove) => this.tagRemove.emit(tagToRemove));
    }
    listenTagDestroy() {
        this.tags.changes
            .pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.destroy$))), filter((destroyedTag) => destroyedTag === this.keyManager.activeItem), map((destroyedTag) => destroyedTag === this.tags.last), takeUntil(this.destroy$))
            .subscribe((isLastTagDestroyed) => {
            if (isLastTagDestroyed) {
                this.keyManager.setPreviousItemActive();
            }
            else {
                this.keyManager.setNextItemActive();
            }
        });
    }
    listenNoTags() {
        this.tags.changes
            .pipe(startWith(this.tags), filter((tags) => tags.length === 0), takeUntil(this.destroy$))
            .subscribe(() => this.focusInput());
    }
    listenActiveTagChange() {
        this.keyManager.change
            .pipe(map(() => { var _a; return (_a = this.keyManager.activeItem) === null || _a === void 0 ? void 0 : _a._id; }), takeUntil(this.destroy$))
            .subscribe((activeTagId) => {
            this.activeTagId = activeTagId;
            this.cd.markForCheck();
        });
    }
    onFocusChange(isFocused) {
        var _a;
        this.focused = isFocused;
        this.cd.markForCheck();
        if (!isFocused || ((_a = this.tagInput) === null || _a === void 0 ? void 0 : _a.focused$.value)) {
            this.keyManager.setActiveItem(-1);
            return;
        }
        // Focus input when focusing tag list without tags. Otherwise select first tag.
        if (this.tags.length === 0 && this._hasInput) {
            this.focusInput();
        }
        else {
            this.keyManager.setFirstItemActive();
        }
    }
    isBackspaceOrDelete(keyCode) {
        return keyCode === BACKSPACE || keyCode === DELETE;
    }
    setAutocompleteCustomHost() {
        if (this.autocompleteDirective) {
            this.autocompleteDirective.customOverlayHost = this.hostElement;
        }
    }
    toggleTag(tagToToggle) {
        tagToToggle._toggleSelection();
        if (tagToToggle.selected && !this.multiple) {
            this.tags.forEach((tag) => {
                if (tag !== tagToToggle) {
                    tag.selected = false;
                }
            });
        }
    }
    focusInput() {
        if (this._hasInput) {
            this.tagInput._hostElement.nativeElement.focus();
        }
    }
}
NbTagListComponent.ɵfac = function NbTagListComponent_Factory(t) { return new (t || NbTagListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbFocusMonitor), ɵngcc0.ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbTagListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTagListComponent, selectors: [["nb-tag-list"]], contentQueries: function NbTagListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbTagInputDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbAutocompleteDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbTagComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tagInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.autocompleteDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tags = _t);
    } }, hostVars: 12, hostBindings: function NbTagListComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function NbTagListComponent_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("click", function NbTagListComponent_click_HostBindingHandler($event) { return ctx._onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex)("role", ctx.role)("aria-activedescendant", ctx.activeTagId)("aria-multiselectable", ctx.multiple);
        ɵngcc0.ɵɵclassMap(ctx._inputClasses);
        ɵngcc0.ɵɵclassProp("nb-tag-list-with-input", ctx._hasInput)("focus", ctx._isFocused)("input-full-width", ctx._isFullWidth);
    } }, inputs: { size: "size", tabIndex: "tabIndex", role: "role", multiple: "multiple" }, outputs: { tagRemove: "tagRemove" }, exportAs: ["nbTagList"], ngContentSelectors: _c51, decls: 2, vars: 0, consts: [[1, "nb-tag-list-tags-wrapper"]], template: function NbTagListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c50);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2, changeDetection: 0 });
NbTagListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: NbFocusMonitor },
    { type: NbActiveDescendantKeyManagerFactoryService },
    { type: NbLayoutDirectionService },
    { type: NbStatusService }
];
NbTagListComponent.propDecorators = {
    tags: [{ type: ContentChildren, args: [NbTagComponent,] }],
    tagInput: [{ type: ContentChild, args: [NbTagInputDirective,] }],
    autocompleteDirective: [{ type: ContentChild, args: [NbAutocompleteDirective,] }],
    size: [{ type: Input }],
    tabIndex: [{ type: Input }, { type: HostBinding, args: ['attr.tabindex',] }],
    role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
    multiple: [{ type: Input }, { type: HostBinding, args: ['attr.aria-multiselectable',] }],
    activeTagId: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
    tagRemove: [{ type: Output }],
    _hasInput: [{ type: HostBinding, args: ['class.nb-tag-list-with-input',] }],
    _isFocused: [{ type: HostBinding, args: ['class.focus',] }],
    _isFullWidth: [{ type: HostBinding, args: ['class.input-full-width',] }],
    _inputClasses: [{ type: HostBinding, args: ['class',] }],
    _onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    _onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTagListComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tag-list',
                template: `
    <div class="nb-tag-list-tags-wrapper">
      <ng-content select="nb-tag, input[nbTagInput]"></ng-content>
    </div>
  `,
                exportAs: 'nbTagList',
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: NbFocusMonitor }, { type: NbActiveDescendantKeyManagerFactoryService }, { type: NbLayoutDirectionService }, { type: NbStatusService }]; }, { size: [{
            type: Input
        }], tabIndex: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.tabindex']
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], activeTagId: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], tagRemove: [{
            type: Output
        }], multiple: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-multiselectable']
        }], _hasInput: [{
            type: HostBinding,
            args: ['class.nb-tag-list-with-input']
        }], _isFocused: [{
            type: HostBinding,
            args: ['class.focus']
        }], _isFullWidth: [{
            type: HostBinding,
            args: ['class.input-full-width']
        }], _inputClasses: [{
            type: HostBinding,
            args: ['class']
        }], _onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], _onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], tags: [{
            type: ContentChildren,
            args: [NbTagComponent]
        }], tagInput: [{
            type: ContentChild,
            args: [NbTagInputDirective]
        }], autocompleteDirective: [{
            type: ContentChild,
            args: [NbAutocompleteDirective]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTagModule {
}
NbTagModule.ɵfac = function NbTagModule_Factory(t) { return new (t || NbTagModule)(); };
NbTagModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTagModule });
NbTagModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTagModule, { declarations: function () { return [NbTagComponent, NbTagListComponent, NbTagInputDirective]; }, imports: function () { return [CommonModule, NbIconModule]; }, exports: function () { return [NbTagComponent, NbTagListComponent, NbTagInputDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTagModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    NbIconModule,
                ],
                declarations: [
                    NbTagComponent,
                    NbTagListComponent,
                    NbTagInputDirective,
                ],
                exports: [
                    NbTagComponent,
                    NbTagListComponent,
                    NbTagInputDirective,
                ]
            }]
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_DEFAULT_ROW_LEVEL = 0;
/**
 * Implicit context of cells and rows
 */
class NbTreeGridPresentationNode {
    constructor(
    /**
     * Data object associated with row
     */
    data, children, 
    /**
     * Row expand state
     */
    expanded, level) {
        this.data = data;
        this.children = children;
        this.expanded = expanded;
        this.level = level;
    }
    /**
     * True if row has child rows
     */
    hasChildren() {
        return !!this.children && !!this.children.length;
    }
}

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTreeGridDataService {
    constructor() {
        this.defaultGetters = {
            dataGetter: node => node.data,
            childrenGetter: d => d.children || undefined,
            expandedGetter: d => !!d.expanded,
        };
    }
    toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
        const getters = Object.assign(Object.assign({}, this.defaultGetters), customGetters);
        return this.mapNodes(nodes, getters, level);
    }
    mapNodes(nodes, getters, level) {
        const { dataGetter, childrenGetter, expandedGetter } = getters;
        return nodes.map(node => {
            const childrenNodes = childrenGetter(node);
            let children;
            if (childrenNodes) {
                children = this.toPresentationNodes(childrenNodes, getters, level + 1);
            }
            return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
        });
    }
    flattenExpanded(nodes) {
        return nodes.reduce((res, node) => {
            res.push(node);
            if (node.expanded && node.hasChildren()) {
                res.push(...this.flattenExpanded(node.children));
            }
            return res;
        }, []);
    }
    copy(nodes) {
        return nodes.map((node) => {
            let children;
            if (node.hasChildren()) {
                children = this.copy(node.children);
            }
            return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
        });
    }
}
NbTreeGridDataService.ɵfac = function NbTreeGridDataService_Factory(t) { return new (t || NbTreeGridDataService)(); };
NbTreeGridDataService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridDataService, factory: NbTreeGridDataService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridDataService, [{
        type: Injectable
    }], function () { return []; }, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Service used to filter tree grid data. Searched searchString in all object values.
 * If you need custom filter, you can extend this service and override filterPredicate or whole filter method.
 */
class NbTreeGridFilterService {
    filter(query, data) {
        if (!query) {
            return data;
        }
        return data.reduce((filtered, node) => {
            let filteredChildren;
            if (node.children) {
                filteredChildren = this.filter(query, node.children);
                node.children = filteredChildren;
            }
            node.expanded = false;
            if (filteredChildren && filteredChildren.length) {
                node.expanded = true;
                filtered.push(node);
            }
            else if (this.filterPredicate(node.data, query)) {
                filtered.push(node);
            }
            return filtered;
        }, []);
    }
    filterPredicate(data, searchQuery) {
        const preparedQuery = searchQuery.trim().toLocaleLowerCase();
        for (const val of Object.values(data)) {
            const preparedVal = `${val}`.trim().toLocaleLowerCase();
            if (preparedVal.includes(preparedQuery)) {
                return true;
            }
        }
        return false;
    }
}
NbTreeGridFilterService.ɵfac = function NbTreeGridFilterService_Factory(t) { return new (t || NbTreeGridFilterService)(); };
NbTreeGridFilterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridFilterService, factory: NbTreeGridFilterService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridFilterService, [{
        type: Injectable
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var NbSortDirection;
(function (NbSortDirection) {
    NbSortDirection["ASCENDING"] = "asc";
    NbSortDirection["DESCENDING"] = "desc";
    NbSortDirection["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
const sortDirections = [
    NbSortDirection.ASCENDING,
    NbSortDirection.DESCENDING,
    NbSortDirection.NONE,
];
/**
 * Directive triggers sort method of passed object when sort header changes direction
 */
class NbSortDirective {
    constructor() {
        this.sort = new EventEmitter();
    }
    emitSort(sortRequest) {
        if (this.sortable && this.sortable.sort) {
            this.sortable.sort(sortRequest);
        }
        this.sort.emit(sortRequest);
    }
}
NbSortDirective.ɵfac = function NbSortDirective_Factory(t) { return new (t || NbSortDirective)(); };
NbSortDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSortDirective, selectors: [["", "nbSort", ""]], inputs: { sortable: ["nbSort", "sortable"] }, outputs: { sort: "sort" } });
NbSortDirective.propDecorators = {
    sortable: [{ type: Input, args: ['nbSort',] }],
    sort: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSortDirective, [{
        type: Directive,
        args: [{ selector: '[nbSort]' }]
    }], function () { return []; }, { sort: [{
            type: Output
        }], sortable: [{
            type: Input,
            args: ['nbSort']
        }] }); })();
/**
 * Directive for headers sort icons. Mark you icon implementation with this structural directive and
 * it'll set template's implicit context with current direction. Context also has `isAscending`,
 * `isDescending` and `isNone` properties.
 */
class NbSortHeaderIconDirective {
}
NbSortHeaderIconDirective.ɵfac = function NbSortHeaderIconDirective_Factory(t) { return new (t || NbSortHeaderIconDirective)(); };
NbSortHeaderIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSortHeaderIconDirective, selectors: [["", "nbSortHeaderIcon", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSortHeaderIconDirective, [{
        type: Directive,
        args: [{ selector: '[nbSortHeaderIcon]' }]
    }], null, null); })();
class NbSortIconComponent {
    constructor() {
        this.direction = NbSortDirection.NONE;
    }
    isAscending() {
        return this.direction === NbSortDirection.ASCENDING;
    }
    isDescending() {
        return this.direction === NbSortDirection.DESCENDING;
    }
    isDirectionSet() {
        return this.isAscending() || this.isDescending();
    }
}
NbSortIconComponent.ɵfac = function NbSortIconComponent_Factory(t) { return new (t || NbSortIconComponent)(); };
NbSortIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSortIconComponent, selectors: [["nb-sort-icon"]], inputs: { direction: "direction" }, decls: 1, vars: 1, consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbSortIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDirectionSet());
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], encapsulation: 2 });
NbSortIconComponent.propDecorators = {
    direction: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSortIconComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sort-icon',
                template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `
            }]
    }], function () { return []; }, { direction: [{
            type: Input
        }] }); })();
/**
 * Marks header as sort header so it emitting sort event when clicked.
 */
class NbSortHeaderComponent {
    constructor(sort, columnDef) {
        this.sort = sort;
        this.columnDef = columnDef;
        this.disabledValue = false;
    }
    /**
     * Disable sort header
     */
    set disabled(value) {
        this.disabledValue = convertToBoolProperty(value);
    }
    get disabled() {
        return this.disabledValue;
    }
    sortIfEnabled() {
        if (!this.disabled) {
            this.sortData();
        }
    }
    isAscending() {
        return this.direction === NbSortDirection.ASCENDING;
    }
    isDescending() {
        return this.direction === NbSortDirection.DESCENDING;
    }
    sortData() {
        const sortRequest = this.createSortRequest();
        this.sort.emitSort(sortRequest);
    }
    getIconContext() {
        return {
            $implicit: this.direction,
            isAscending: this.isAscending(),
            isDescending: this.isDescending(),
            isNone: !this.isAscending() && !this.isDescending(),
        };
    }
    getDisabledAttributeValue() {
        return this.disabled ? '' : null;
    }
    createSortRequest() {
        this.direction = this.getNextDirection();
        return { direction: this.direction, column: this.columnDef.name };
    }
    getNextDirection() {
        const sortDirectionCycle = sortDirections;
        let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    }
}
NbSortHeaderComponent.ɵfac = function NbSortHeaderComponent_Factory(t) { return new (t || NbSortHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbSortDirective), ɵngcc0.ɵɵdirectiveInject(NB_SORT_HEADER_COLUMN_DEF)); };
NbSortHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSortHeaderComponent, selectors: [["", "nbSortHeader", ""]], contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbSortHeaderIconDirective, 1, TemplateRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sortIcon = _t.first);
    } }, hostVars: 2, hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbSortHeaderComponent_click_HostBindingHandler() { return ctx.sortIfEnabled(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", direction: ["nbSortHeader", "direction"] }, attrs: _c52, ngContentSelectors: _c0, decls: 5, vars: 5, consts: [["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["customIcon", ""], [3, "direction"]], template: function NbSortHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbSortHeaderComponent_Template_button_click_0_listener() { return ctx.sortData(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 1);
        ɵngcc0.ɵɵtemplate(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 2, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵattribute("disabled", ctx.getDisabledAttributeValue());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.sortIcon)("ngIfElse", _r1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, NbSortIconComponent], encapsulation: 2 });
NbSortHeaderComponent.ctorParameters = () => [
    { type: NbSortDirective },
    { type: undefined, decorators: [{ type: Inject, args: [NB_SORT_HEADER_COLUMN_DEF,] }] }
];
NbSortHeaderComponent.propDecorators = {
    sortIcon: [{ type: ContentChild, args: [NbSortHeaderIconDirective, { read: TemplateRef },] }],
    direction: [{ type: Input, args: ['nbSortHeader',] }],
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.disabled',] }],
    sortIfEnabled: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSortHeaderComponent, [{
        type: Component,
        args: [{
                selector: '[nbSortHeader]',
                template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `
            }]
    }], function () { return [{ type: NbSortDirective }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_SORT_HEADER_COLUMN_DEF]
            }] }]; }, { disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], sortIfEnabled: [{
            type: HostListener,
            args: ['click']
        }], direction: [{
            type: Input,
            args: ['nbSortHeader']
        }], sortIcon: [{
            type: ContentChild,
            args: [NbSortHeaderIconDirective, { read: TemplateRef }]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Service used to sort tree grid data. Uses Array.prototype.sort method.
 * If you need custom sorting, you can extend this service and override comparator or whole sort method.
 */
class NbTreeGridSortService {
    sort(request, data) {
        if (!request) {
            return data;
        }
        const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
        for (const node of data) {
            if (node.children) {
                node.children = this.sort(request, node.children);
            }
        }
        return sorted;
    }
    comparator(request, na, nb) {
        const key = request.column;
        const dir = request.direction;
        const a = na.data[key];
        const b = nb.data[key];
        let res = 0;
        if (a > b) {
            res = 1;
        }
        if (a < b) {
            res = -1;
        }
        return dir === NbSortDirection.ASCENDING ? res : res * -1;
    }
}
NbTreeGridSortService.ɵfac = function NbTreeGridSortService_Factory(t) { return new (t || NbTreeGridSortService)(); };
NbTreeGridSortService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridSortService, factory: NbTreeGridSortService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridSortService, [{
        type: Injectable
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTreeGridService {
    expand(data, row, options = {}) {
        const node = this.find(data, row);
        node.expanded = true;
        if (options.deep && node.hasChildren()) {
            node.children.forEach((n) => this.expand(data, n.data, options));
        }
    }
    collapse(data, row, options = {}) {
        const node = this.find(data, row);
        node.expanded = false;
        if (options.deep && node.hasChildren()) {
            node.children.forEach((n) => this.collapse(data, n.data, options));
        }
    }
    toggle(data, row, options = {}) {
        const node = this.find(data, row);
        if (node.expanded) {
            this.collapse(data, row, options);
        }
        else {
            this.expand(data, row, options);
        }
    }
    find(data, row) {
        const toCheck = [...data];
        for (const node of toCheck) {
            if (node.data === row) {
                return node;
            }
            if (node.hasChildren()) {
                toCheck.push(...node.children);
            }
        }
    }
}
NbTreeGridService.ɵfac = function NbTreeGridService_Factory(t) { return new (t || NbTreeGridService)(); };
NbTreeGridService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridService, factory: NbTreeGridService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridService, [{
        type: Injectable
    }], null, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTreeGridDataSource extends NbDataSource {
    constructor(sortService, filterService, treeGridService, treeGridDataService) {
        super();
        this.sortService = sortService;
        this.filterService = filterService;
        this.treeGridService = treeGridService;
        this.treeGridDataService = treeGridDataService;
        /** Stream emitting render data to the table (depends on ordered data changes). */
        this.renderData = new BehaviorSubject([]);
        this.filterRequest = new BehaviorSubject('');
        this.sortRequest = new BehaviorSubject(null);
    }
    setData(data, customGetters) {
        let presentationData = [];
        if (data) {
            presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
        }
        this.data = new BehaviorSubject(presentationData);
        this.updateChangeSubscription();
    }
    connect(collectionViewer) {
        return this.renderData;
    }
    disconnect(collectionViewer) {
    }
    expand(row) {
        this.treeGridService.expand(this.data.value, row);
        this.data.next(this.data.value);
    }
    collapse(row) {
        this.treeGridService.collapse(this.data.value, row);
        this.data.next(this.data.value);
    }
    toggle(row, options) {
        this.treeGridService.toggle(this.data.value, row, options);
        this.data.next(this.data.value);
    }
    toggleByIndex(dataIndex, options) {
        const node = this.renderData.value && this.renderData.value[dataIndex];
        if (node) {
            this.toggle(node.data, options);
        }
    }
    getLevel(rowIndex) {
        const row = this.renderData.value[rowIndex];
        return row ? row.level : NB_DEFAULT_ROW_LEVEL;
    }
    sort(sortRequest) {
        this.sortRequest.next(sortRequest);
    }
    filter(searchQuery) {
        this.filterRequest.next(searchQuery);
    }
    updateChangeSubscription() {
        const dataStream = this.data;
        const filteredData = combineLatest(dataStream, this.filterRequest)
            .pipe(map(([data]) => this.treeGridDataService.copy(data)), map(data => this.filterData(data)));
        const sortedData = combineLatest(filteredData, this.sortRequest)
            .pipe(map(([data]) => this.sortData(data)));
        sortedData
            .pipe(map((data) => this.treeGridDataService.flattenExpanded(data)))
            .subscribe((data) => this.renderData.next(data));
    }
    filterData(data) {
        return this.filterService.filter(this.filterRequest.value, data);
    }
    sortData(data) {
        return this.sortService.sort(this.sortRequest.value, data);
    }
}
class NbTreeGridDataSourceBuilder {
    constructor(filterService, sortService, treeGridService, treeGridDataService) {
        this.filterService = filterService;
        this.sortService = sortService;
        this.treeGridService = treeGridService;
        this.treeGridDataService = treeGridDataService;
    }
    create(data, customGetters) {
        const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
        dataSource.setData(data, customGetters);
        return dataSource;
    }
}
NbTreeGridDataSourceBuilder.ɵfac = function NbTreeGridDataSourceBuilder_Factory(t) { return new (t || NbTreeGridDataSourceBuilder)(ɵngcc0.ɵɵinject(NbTreeGridFilterService), ɵngcc0.ɵɵinject(NbTreeGridSortService), ɵngcc0.ɵɵinject(NbTreeGridService), ɵngcc0.ɵɵinject(NbTreeGridDataService)); };
NbTreeGridDataSourceBuilder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridDataSourceBuilder, factory: NbTreeGridDataSourceBuilder.ɵfac });
NbTreeGridDataSourceBuilder.ctorParameters = () => [
    { type: NbTreeGridFilterService },
    { type: NbTreeGridSortService },
    { type: NbTreeGridService },
    { type: NbTreeGridDataService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridDataSourceBuilder, [{
        type: Injectable
    }], function () { return [{ type: NbTreeGridFilterService }, { type: NbTreeGridSortService }, { type: NbTreeGridService }, { type: NbTreeGridDataService }]; }, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TREE_GRID = new InjectionToken('NB_TREE_GRID');

class NbColumnsService {
    constructor(differs) {
        this.differs = differs;
        this.columnHide$ = new Subject();
        this.columnShow$ = new Subject();
    }
    setColumns(columns) {
        if (!this.changesDiffer) {
            this.changesDiffer = this.differs.find(columns || []).create();
        }
        if (this.changesDiffer.diff(columns)) {
            this.allColumns = Array.from(columns);
            this.visibleColumns = Array.from(columns);
        }
    }
    getVisibleColumns() {
        return this.visibleColumns;
    }
    hideColumn(column) {
        const toRemove = this.visibleColumns.indexOf(column);
        if (toRemove > -1) {
            this.visibleColumns.splice(toRemove, 1);
            this.columnHide$.next();
        }
    }
    showColumn(column) {
        if (this.visibleColumns.includes(column)) {
            return;
        }
        this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
        this.columnShow$.next();
    }
    onColumnsChange() {
        return merge(this.columnShow$, this.columnHide$);
    }
    findInsertIndex(column) {
        const initialIndex = this.allColumns.indexOf(column);
        if (initialIndex === 0 || !this.visibleColumns.length) {
            return 0;
        }
        if (initialIndex === this.allColumns.length - 1) {
            return this.visibleColumns.length;
        }
        const leftSiblingIndex = initialIndex - 1;
        for (let i = leftSiblingIndex; i >= 0; i--) {
            const leftSibling = this.allColumns[i];
            const index = this.visibleColumns.indexOf(leftSibling);
            if (index !== -1) {
                return index + 1;
            }
        }
        const rightSiblingIndex = initialIndex + 1;
        for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
            const rightSibling = this.allColumns[i];
            const index = this.visibleColumns.indexOf(rightSibling);
            if (index !== -1) {
                return index;
            }
        }
        throw new Error(`Can't restore column position.`);
    }
}
NbColumnsService.ɵfac = function NbColumnsService_Factory(t) { return new (t || NbColumnsService)(ɵngcc0.ɵɵinject(ɵngcc0.IterableDiffers)); };
NbColumnsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbColumnsService, factory: NbColumnsService.ɵfac });
NbColumnsService.ctorParameters = () => [
    { type: IterableDiffers }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbColumnsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.IterableDiffers }]; }, null); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Tree grid component that can be used to display nested rows of data.
 * Supports filtering and sorting.
 * @stacked-example(Showcase, tree-grid/tree-grid-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTreeGridModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTreeGridModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * As the most basic usage you need to define [nbTreeGridRowDef](docs/components/treegrid/api#nbtreegridrowdefdirective)
 * where you should pass columns to display in rows and
 * [nbTreeGridColumnDef](docs/components/treegrid/api#nbtreegridcolumndefdirective) - component containing cell
 * definitions for each column passed to row definition.
 * @stacked-example(Basic, tree-grid/tree-grid-basic.component)
 *
 * `NbTreeGridComponent`'s source input and `NbTreeGridDataSourceBuilder.create` expecting data to be an array of
 * objects with `data`, `children` and `expanded` properties. If your data doesn't match this interface, you can pass
 * getter functions for each property as arguments to `NbTreeGridDataSourceBuilder.create` method.
 * @stacked-example(Custom node structure, tree-grid/tree-grid-custom-node-structure.component)
 *
 * To use sorting you can add `nbSort` directive to table and subscribe to `sort` method. When user click on header,
 * sort event will be emitted. Event object contain clicked column name and desired sort direction.
 * @stacked-example(Sortable, tree-grid/tree-grid-sortable.component)
 *
 * You can use `Data Source Builder` to create `NbTreeGridDataSource` which would have toggle, sort and
 * filter methods. Then you can call this methods to change sort or toggle rows programmatically. Also `nbSort` and
 * `nbFilterInput` directives both support `NbTreeGridDataSource`, so you can pass it directly as an input and
 * directives will trigger sort, toggle themselves.
 * @stacked-example(Data Source Builder, tree-grid/tree-grid-showcase.component)
 *
 * You can create responsive grid by setting `hideOn` and `showOn` inputs of
 * [nbTreeGridColumnDef](docs/components/tree-grid/api#nbtreegridcolumndefdirective) directive.
 * When viewport reaches specified width grid hides or shows columns.
 * @stacked-example(Responsive columns, tree-grid/tree-grid-responsive.component)
 *
 * To customize sort or row toggle icons you can use `nbSortHeaderIcon` and `nbTreeGridRowToggle` directives
 * respectively. `nbSortHeaderIcon` is a structural directive and it's implicit context set to current direction.
 * Also context has three properties: `isAscending`, `isDescending` and `isNone`.
 * @stacked-example(Custom icons, tree-grid/tree-grid-custom-icons.component)
 *
 * By default, row to toggle happens when user clicks anywhere in the row. Also double click expands row deeply.
 * To disable this you can set `[clickToToggle]="false"` input of `nbTreeGridRow`.
 * @stacked-example(Disable click toggle, tree-grid/tree-grid-disable-click-toggle.component)
 *
 * @styles
 *
 * tree-grid-cell-border-width:
 * tree-grid-cell-border-style:
 * tree-grid-cell-border-color:
 * tree-grid-row-min-height:
 * tree-grid-cell-padding:
 * tree-grid-header-background-color:
 * tree-grid-header-text-color:
 * tree-grid-header-text-font-family:
 * tree-grid-header-text-font-size:
 * tree-grid-header-text-font-weight:
 * tree-grid-header-text-line-height:
 * tree-grid-footer-background-color:
 * tree-grid-footer-text-color:
 * tree-grid-footer-text-font-family:
 * tree-grid-footer-text-font-size:
 * tree-grid-footer-text-font-weight:
 * tree-grid-footer-text-line-height:
 * tree-grid-row-background-color:
 * tree-grid-row-even-background-color:
 * tree-grid-row-hover-background-color:
 * tree-grid-row-text-color:
 * tree-grid-row-text-font-family:
 * tree-grid-row-text-font-size:
 * tree-grid-row-text-font-weight:
 * tree-grid-row-text-line-height:
 * tree-grid-sort-header-button-background-color:
 * tree-grid-sort-header-button-border:
 * tree-grid-sort-header-button-padding:
 */
class NbTreeGridComponent extends NbTable {
    constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document, platform, window, _viewRepeater, _coalescedStyleScheduler) {
        super(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler);
        this.dataSourceBuilder = dataSourceBuilder;
        this.window = window;
        this._viewRepeater = _viewRepeater;
        this._coalescedStyleScheduler = _coalescedStyleScheduler;
        this.destroy$ = new Subject();
        this.levelPadding = '';
        this.equalColumnsWidthValue = false;
        this.treeClass = true;
        this.platform = platform;
    }
    /**
     * The table's data
     * @param data
     * @type {<T>[] | NbTreeGridDataSource}
     */
    set source(data) {
        if (!data) {
            return;
        }
        if (data instanceof NbTreeGridDataSource) {
            this._source = data;
        }
        else {
            this._source = this.dataSourceBuilder.create(data);
        }
        this.dataSource = this._source;
    }
    /**
     * Make all columns equal width. False by default.
     */
    set equalColumnsWidth(value) {
        this.equalColumnsWidthValue = convertToBoolProperty(value);
    }
    get equalColumnsWidth() {
        return this.equalColumnsWidthValue;
    }
    ngAfterViewInit() {
        this.checkDefsCount();
        const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
        rowsChange$.pipe(takeUntil(this.destroy$))
            .subscribe(() => this.checkDefsCount());
        if (this.platform.isBrowser) {
            this.updateVisibleColumns();
            const windowResize$ = fromEvent(this.window, 'resize').pipe(debounceTime(50));
            merge(rowsChange$, this._contentColumnDefs.changes, windowResize$)
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => this.updateVisibleColumns());
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    toggleRow(row, options) {
        const context = this.getRowContext(row);
        this._source.toggle(context.$implicit.data, options);
    }
    toggleCellRow(cell) {
        const context = this.getCellContext(cell);
        this._source.toggle(context.$implicit.data);
    }
    getColumnWidth() {
        if (this.equalColumnsWidth) {
            return `${100 / this.getColumnsCount()}%`;
        }
        return '';
    }
    getCellLevel(cell, columnName) {
        if (this.isFirstColumn(columnName)) {
            return this.getCellContext(cell).$implicit.level;
        }
        return NB_DEFAULT_ROW_LEVEL;
    }
    getRowContext(row) {
        return this.getContextByRowEl(row.elementRef.nativeElement);
    }
    getCellContext(cell) {
        return this.getContextByCellEl(cell.elementRef.nativeElement);
    }
    getContextByCellEl(cellEl) {
        return this.getContextByRowEl(cellEl.parentElement);
    }
    getContextByRowEl(rowEl) {
        const rowsContainer = this._rowOutlet.viewContainer;
        for (let i = 0; i < rowsContainer.length; i++) {
            const rowViewRef = rowsContainer.get(i);
            if (rowViewRef.rootNodes.includes(rowEl)) {
                return rowViewRef.context;
            }
        }
    }
    getColumns() {
        let rowDef;
        if (this._contentHeaderRowDefs.length) {
            rowDef = this._contentHeaderRowDefs.first;
        }
        else {
            rowDef = this._contentRowDefs.first;
        }
        return Array.from(rowDef.getVisibleColumns() || []);
    }
    getColumnsCount() {
        return this.getColumns().length;
    }
    isFirstColumn(columnName) {
        return this.getColumns()[0] === columnName;
    }
    checkDefsCount() {
        if (this._contentRowDefs.length > 1) {
            throw new Error(`Found multiple row definitions`);
        }
        if (this._contentHeaderRowDefs.length > 1) {
            throw new Error(`Found multiple header row definitions`);
        }
        if (this._contentFooterRowDefs.length > 1) {
            throw new Error(`Found multiple footer row definitions`);
        }
    }
    updateVisibleColumns() {
        const width = this.window.innerWidth;
        const columnDefs = this._contentColumnDefs;
        const columnsToHide = columnDefs
            .filter((col) => col.shouldHide(width))
            .map(col => col.name);
        const columnsToShow = columnDefs
            .filter((col) => col.shouldShow(width))
            .map(col => col.name);
        if (!columnsToHide.length && !columnsToShow.length) {
            return;
        }
        const rowDefs = [
            this._contentHeaderRowDefs.first,
            this._contentRowDefs.first,
            this._contentFooterRowDefs.first,
        ].filter(d => !!d);
        for (const rowDef of rowDefs) {
            for (const column of columnsToHide) {
                rowDef.hideColumn(column);
            }
            for (const column of columnsToShow) {
                rowDef.showColumn(column);
            }
        }
    }
}
NbTreeGridComponent.ɵfac = function NbTreeGridComponent_Factory(t) { return new (t || NbTreeGridComponent)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridDataSourceBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NbDirectionality), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPlatform), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(NB_VIEW_REPEATER_STRATEGY, 8), ɵngcc0.ɵɵdirectiveInject(NB_COALESCED_STYLE_SCHEDULER, 8)); };
NbTreeGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridComponent, selectors: [["table", "nbTreeGrid", ""]], hostVars: 2, hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-tree-grid", ctx.treeClass);
    } }, inputs: { levelPadding: "levelPadding", source: ["nbTreeGrid", "source"], equalColumnsWidth: "equalColumnsWidth" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NB_TREE_GRID, useExisting: NbTreeGridComponent },
            NbColumnsService,
            ...NB_TABLE_PROVIDERS,
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c53, decls: 4, vars: 0, consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbNoDataRowOutlet", ""], ["nbFooterRowOutlet", ""]], template: function NbTreeGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementContainer(1, 1);
        ɵngcc0.ɵɵelementContainer(2, 2);
        ɵngcc0.ɵɵelementContainer(3, 3);
    } }, directives: [NbHeaderRowOutletDirective, NbDataRowOutletDirective, NbNoDataRowOutletDirective, NbFooterRowOutletDirective], styles: ["[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}"] });
NbTreeGridComponent.ctorParameters = () => [
    { type: NbTreeGridDataSourceBuilder },
    { type: IterableDiffers },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: String, decorators: [{ type: Attribute, args: ['role',] }] },
    { type: NbDirectionality },
    { type: undefined, decorators: [{ type: Inject, args: [NB_DOCUMENT,] }] },
    { type: NbPlatform },
    { type: undefined, decorators: [{ type: Inject, args: [NB_WINDOW,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_VIEW_REPEATER_STRATEGY,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NB_COALESCED_STYLE_SCHEDULER,] }] }
];
NbTreeGridComponent.propDecorators = {
    source: [{ type: Input, args: ['nbTreeGrid',] }],
    levelPadding: [{ type: Input }],
    equalColumnsWidth: [{ type: Input }],
    treeClass: [{ type: HostBinding, args: ['class.nb-tree-grid',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridComponent, [{
        type: Component,
        args: [{
                selector: 'table[nbTreeGrid]',
                template: NB_TABLE_TEMPLATE,
                providers: [
                    { provide: NB_TREE_GRID, useExisting: NbTreeGridComponent },
                    NbColumnsService,
                    ...NB_TABLE_PROVIDERS,
                ],
                styles: [":host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n"]
            }]
    }], function () { return [{ type: NbTreeGridDataSourceBuilder }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NbDirectionality }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPlatform }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_VIEW_REPEATER_STRATEGY]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_COALESCED_STYLE_SCHEDULER]
            }] }]; }, { levelPadding: [{
            type: Input
        }], treeClass: [{
            type: HostBinding,
            args: ['class.nb-tree-grid']
        }], source: [{
            type: Input,
            args: ['nbTreeGrid']
        }], equalColumnsWidth: [{
            type: Input
        }] }); })();

const NbCdkRowDef = CdkRowDef;
const NbCdkRow = CdkRow;
const NbCdkCellDef = CdkCellDef;
const NbCdkHeaderRowDef = CdkHeaderRowDef;
const NbCdkHeaderRow = CdkHeaderRow;
const NbCdkHeaderCellDef = CdkHeaderCellDef;
const NbCdkFooterRowDef = CdkFooterRowDef;
const NbCdkFooterRow = CdkFooterRow;
const NbCdkFooterCellDef = CdkFooterCellDef;
const NbCdkColumnDef = CdkColumnDef;
const NbCdkCell = CdkCell;
const NbCdkHeaderCell = CdkHeaderCell;
const NbCdkFooterCell = CdkFooterCell;

/**
 * Data row definition for the tree-grid.
 * Captures the header row's template and columns to display.
 */
class NbTreeGridRowDefDirective extends NbRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['columns']) {
            this.updateColumns(this.columns);
        }
    }
    updateColumns(columns) {
        this.columnsService.setColumns(columns);
    }
    getVisibleColumns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
}
NbTreeGridRowDefDirective.ɵfac = function NbTreeGridRowDefDirective_Factory(t) { return new (t || NbTreeGridRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridRowDefDirective, selectors: [["", "nbTreeGridRowDef", ""]], inputs: { columns: ["nbTreeGridRowDefColumns", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkRowDef, useExisting: NbTreeGridRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
NbTreeGridRowDefDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: NbColumnsService }
];
NbTreeGridRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbTreeGridRowDefColumns',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridRowDef]',
                providers: [{ provide: NbCdkRowDef, useExisting: NbTreeGridRowDefDirective }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridRowDefColumns']
        }] }); })();
class NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['columns']) {
            this.updateColumns(this.columns);
        }
    }
    updateColumns(columns) {
        this.columnsService.setColumns(columns);
    }
    getVisibleColumns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
}
NbTreeGridHeaderRowDefDirective.ɵfac = function NbTreeGridHeaderRowDefDirective_Factory(t) { return new (t || NbTreeGridHeaderRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridHeaderRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderRowDefDirective, selectors: [["", "nbTreeGridHeaderRowDef", ""]], inputs: { columns: ["nbTreeGridHeaderRowDef", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderRowDef, useExisting: NbTreeGridHeaderRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
NbTreeGridHeaderRowDefDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: NbColumnsService }
];
NbTreeGridHeaderRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbTreeGridHeaderRowDef',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridHeaderRowDef]',
                providers: [{ provide: NbCdkHeaderRowDef, useExisting: NbTreeGridHeaderRowDefDirective }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridHeaderRowDef']
        }] }); })();
class NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['columns']) {
            this.updateColumns(this.columns);
        }
    }
    updateColumns(columns) {
        this.columnsService.setColumns(columns);
    }
    getVisibleColumns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
}
NbTreeGridFooterRowDefDirective.ɵfac = function NbTreeGridFooterRowDefDirective_Factory(t) { return new (t || NbTreeGridFooterRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridFooterRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterRowDefDirective, selectors: [["", "nbTreeGridFooterRowDef", ""]], inputs: { columns: ["nbTreeGridFooterRowDef", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterRowDef, useExisting: NbTreeGridFooterRowDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
NbTreeGridFooterRowDefDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: NbColumnsService }
];
NbTreeGridFooterRowDefDirective.propDecorators = {
    columns: [{ type: Input, args: ['nbTreeGridFooterRowDef',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridFooterRowDef]',
                providers: [{ provide: NbCdkFooterRowDef, useExisting: NbTreeGridFooterRowDefDirective }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridFooterRowDef']
        }] }); })();
/**
 * Cell definition for a nb-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
class NbTreeGridCellDefDirective extends NbCellDefDirective {
}
NbTreeGridCellDefDirective.ɵfac = function NbTreeGridCellDefDirective_Factory(t) { return ɵNbTreeGridCellDefDirective_BaseFactory(t || NbTreeGridCellDefDirective); };
NbTreeGridCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridCellDefDirective, selectors: [["", "nbTreeGridCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkCellDef, useExisting: NbTreeGridCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbTreeGridCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridCellDef]',
                providers: [{ provide: NbCdkCellDef, useExisting: NbTreeGridCellDefDirective }]
            }]
    }], null, null); })();
/**
 * Header cell definition for the nb-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
class NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
}
NbTreeGridHeaderCellDefDirective.ɵfac = function NbTreeGridHeaderCellDefDirective_Factory(t) { return ɵNbTreeGridHeaderCellDefDirective_BaseFactory(t || NbTreeGridHeaderCellDefDirective); };
NbTreeGridHeaderCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderCellDefDirective, selectors: [["", "nbTreeGridHeaderCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderCellDef, useExisting: NbTreeGridHeaderCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbTreeGridHeaderCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridHeaderCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridHeaderCellDef]',
                providers: [{ provide: NbCdkHeaderCellDef, useExisting: NbTreeGridHeaderCellDefDirective }]
            }]
    }], null, null); })();
/**
 * Footer cell definition for the nb-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
class NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
}
NbTreeGridFooterCellDefDirective.ɵfac = function NbTreeGridFooterCellDefDirective_Factory(t) { return ɵNbTreeGridFooterCellDefDirective_BaseFactory(t || NbTreeGridFooterCellDefDirective); };
NbTreeGridFooterCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterCellDefDirective, selectors: [["", "nbTreeGridFooterCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterCellDef, useExisting: NbTreeGridFooterCellDefDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵNbTreeGridFooterCellDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridFooterCellDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridFooterCellDef]',
                providers: [{ provide: NbCdkFooterCellDef, useExisting: NbTreeGridFooterCellDefDirective }]
            }]
    }], null, null); })();

const NB_ROW_DOUBLE_CLICK_DELAY = 200;
/**
 * Cells container. Adds the right class and role.
 */
class NbTreeGridRowComponent extends NbRowComponent {
    constructor(tree, elementRef) {
        super();
        this.elementRef = elementRef;
        this.doubleClick$ = new Subject();
        /**
         * Time to wait for second click to expand row deeply.
         * 200ms by default.
         */
        this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
        /**
         * Toggle row on click. Enabled by default.
         */
        this.clickToToggle = true;
        this.tree = tree;
    }
    toggleIfEnabledNode() {
        if (!this.clickToToggle) {
            return;
        }
        timer(NB_ROW_DOUBLE_CLICK_DELAY)
            .pipe(take(1), takeUntil(this.doubleClick$))
            .subscribe(() => this.tree.toggleRow(this));
    }
    toggleIfEnabledNodeDeep() {
        if (!this.clickToToggle) {
            return;
        }
        this.doubleClick$.next();
        this.tree.toggleRow(this, { deep: true });
    }
    ngOnDestroy() {
        this.doubleClick$.complete();
    }
}
NbTreeGridRowComponent.ɵfac = function NbTreeGridRowComponent_Factory(t) { return new (t || NbTreeGridRowComponent)(ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbTreeGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridRowComponent, selectors: [["tr", "nbTreeGridRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-row"], hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowComponent_click_HostBindingHandler() { return ctx.toggleIfEnabledNode(); })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() { return ctx.toggleIfEnabledNodeDeep(); });
    } }, inputs: { doubleClickDelay: "doubleClickDelay", clickToToggle: "clickToToggle" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkRow, useExisting: NbTreeGridRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c54, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
NbTreeGridRowComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NB_TREE_GRID,] }] },
    { type: ElementRef }
];
NbTreeGridRowComponent.propDecorators = {
    doubleClickDelay: [{ type: Input }],
    clickToToggle: [{ type: Input }],
    toggleIfEnabledNode: [{ type: HostListener, args: ['click',] }],
    toggleIfEnabledNodeDeep: [{ type: HostListener, args: ['dblclick',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridRow]',
                template: `<ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-row',
                    'role': 'row'
                },
                providers: [{ provide: NbCdkRow, useExisting: NbTreeGridRowComponent }]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { doubleClickDelay: [{
            type: Input
        }], clickToToggle: [{
            type: Input
        }], toggleIfEnabledNode: [{
            type: HostListener,
            args: ['click']
        }], toggleIfEnabledNodeDeep: [{
            type: HostListener,
            args: ['dblclick']
        }] }); })();
class NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
}
NbTreeGridHeaderRowComponent.ɵfac = function NbTreeGridHeaderRowComponent_Factory(t) { return ɵNbTreeGridHeaderRowComponent_BaseFactory(t || NbTreeGridHeaderRowComponent); };
NbTreeGridHeaderRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridHeaderRowComponent, selectors: [["tr", "nbTreeGridHeaderRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderRow, useExisting: NbTreeGridHeaderRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c55, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
const ɵNbTreeGridHeaderRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridHeaderRowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridHeaderRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-header-row',
                    'role': 'row'
                },
                providers: [{ provide: NbCdkHeaderRow, useExisting: NbTreeGridHeaderRowComponent }]
            }]
    }], null, null); })();
class NbTreeGridFooterRowComponent extends NbFooterRowComponent {
}
NbTreeGridFooterRowComponent.ɵfac = function NbTreeGridFooterRowComponent_Factory(t) { return ɵNbTreeGridFooterRowComponent_BaseFactory(t || NbTreeGridFooterRowComponent); };
NbTreeGridFooterRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridFooterRowComponent, selectors: [["tr", "nbTreeGridFooterRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterRow, useExisting: NbTreeGridFooterRowComponent }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c56, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridFooterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2 });
const ɵNbTreeGridFooterRowComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridFooterRowComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridFooterRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-footer-row',
                    'role': 'row'
                },
                providers: [{ provide: NbCdkFooterRow, useExisting: NbTreeGridFooterRowComponent }]
            }]
    }], null, null); })();

/**
 * Column definition for the tree-grid.
 * Defines a set of cells available for a table column.
 */
class NbTreeGridColumnDefDirective extends NbColumnDefDirective {
    constructor() {
        super(...arguments);
        this.hideOnValue = null;
        this.showOnValue = null;
    }
    /**
     * Column name
     */
    get name() {
        return this._name;
    }
    set name(value) {
        this._setNameInput(value);
    }
    /**
     * Amount of pixels of viewport at which column should be hidden.
     * type number
     */
    get hideOn() {
        return this.hideOnValue;
    }
    set hideOn(value) {
        this.hideOnValue = !value && value !== 0
            ? null
            : parseInt(value, 10);
    }
    /**
     * Amount of pixels of viewport at which column should be shown.
     * type number
     */
    get showOn() {
        return this.showOnValue;
    }
    set showOn(value) {
        this.showOnValue = !value && value !== 0
            ? null
            : parseInt(value, 10);
    }
    ngOnChanges() {
        if (this.hideOn != null && this.showOn != null) {
            throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
        }
    }
    shouldHide(width) {
        return !this.shouldShow(width);
    }
    shouldShow(width) {
        if (this.hideOn == null && this.showOn == null) {
            return true;
        }
        if (this.hideOn != null) {
            return width > this.hideOn;
        }
        return width >= this.showOn;
    }
}
NbTreeGridColumnDefDirective.ɵfac = function NbTreeGridColumnDefDirective_Factory(t) { return ɵNbTreeGridColumnDefDirective_BaseFactory(t || NbTreeGridColumnDefDirective); };
NbTreeGridColumnDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridColumnDefDirective, selectors: [["", "nbTreeGridColumnDef", ""]], inputs: { name: ["nbTreeGridColumnDef", "name"], hideOn: "hideOn", showOn: "showOn" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbCdkColumnDef, useExisting: NbTreeGridColumnDefDirective },
            { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbTreeGridColumnDefDirective },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
NbTreeGridColumnDefDirective.propDecorators = {
    name: [{ type: Input, args: ['nbTreeGridColumnDef',] }],
    hideOn: [{ type: Input }],
    showOn: [{ type: Input }]
};
const ɵNbTreeGridColumnDefDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridColumnDefDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridColumnDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridColumnDef]',
                providers: [
                    { provide: NbCdkColumnDef, useExisting: NbTreeGridColumnDefDirective },
                    { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbTreeGridColumnDefDirective },
                ]
            }]
    }], null, { name: [{
            type: Input,
            args: ['nbTreeGridColumnDef']
        }], hideOn: [{
            type: Input
        }], showOn: [{
            type: Input
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbTreeGridCellDirective extends NbCellDirective {
    constructor(columnDef, elementRef, tree, platformId, window, sanitizer, directionService, columnService, cd) {
        super(columnDef, elementRef);
        this.platformId = platformId;
        this.window = window;
        this.sanitizer = sanitizer;
        this.directionService = directionService;
        this.columnService = columnService;
        this.cd = cd;
        this.destroy$ = new Subject();
        this.initialLeftPadding = '';
        this.initialRightPadding = '';
        this.tree = tree;
        this.columnDef = columnDef;
        this.elementRef = elementRef;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        if (this.latestWidth) {
            return this.latestWidth;
        }
        return null;
    }
    get leftPadding() {
        if (this.directionService.isLtr()) {
            return this.getStartPadding();
        }
        return null;
    }
    get rightPadding() {
        if (this.directionService.isRtl()) {
            return this.getStartPadding();
        }
        return null;
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            const style$$1 = this.window.getComputedStyle(this.elementRef.nativeElement);
            this.initialLeftPadding = style$$1.paddingLeft;
            this.initialRightPadding = style$$1.paddingRight;
        }
        this.columnService.onColumnsChange()
            .pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    toggleRow() {
        this.tree.toggleCellRow(this);
    }
    get initialStartPadding() {
        return this.directionService.isLtr()
            ? this.initialLeftPadding
            : this.initialRightPadding;
    }
    getStartPadding() {
        const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
        if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
            return null;
        }
        const nestingLevel = rowLevel + 1;
        let padding = '';
        if (this.tree.levelPadding) {
            padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
        }
        else if (this.initialStartPadding) {
            padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
        }
        if (!padding) {
            return null;
        }
        return this.sanitizer.bypassSecurityTrustStyle(padding);
    }
}
NbTreeGridCellDirective.ɵfac = function NbTreeGridCellDirective_Factory(t) { return new (t || NbTreeGridCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridCellDirective, selectors: [["td", "nbTreeGridCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"], hostVars: 6, hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkCell, useExisting: NbTreeGridCellDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbTreeGridCellDirective.ctorParameters = () => [
    { type: NbTreeGridColumnDefDirective },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [NB_TREE_GRID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [NB_WINDOW,] }] },
    { type: DomSanitizer },
    { type: NbLayoutDirectionService },
    { type: NbColumnsService },
    { type: ChangeDetectorRef }
];
NbTreeGridCellDirective.propDecorators = {
    columnWidth: [{ type: HostBinding, args: ['style.width',] }],
    leftPadding: [{ type: HostBinding, args: ['style.padding-left',] }],
    rightPadding: [{ type: HostBinding, args: ['style.padding-right',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridCellDirective, [{
        type: Directive,
        args: [{
                selector: 'td[nbTreeGridCell]',
                host: {
                    'class': 'nb-tree-grid-cell',
                    'role': 'gridcell'
                },
                providers: [{ provide: NbCdkCell, useExisting: NbTreeGridCellDirective }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: ɵngcc4.DomSanitizer }, { type: NbLayoutDirectionService }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], leftPadding: [{
            type: HostBinding,
            args: ['style.padding-left']
        }], rightPadding: [{
            type: HostBinding,
            args: ['style.padding-right']
        }] }); })();
class NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
    constructor(columnDef, elementRef, tree, columnService, cd) {
        super(columnDef, elementRef);
        this.columnService = columnService;
        this.cd = cd;
        this.destroy$ = new Subject();
        this.tree = tree;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        return this.latestWidth || null;
    }
    ngOnInit() {
        this.columnService.onColumnsChange()
            .pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NbTreeGridHeaderCellDirective.ɵfac = function NbTreeGridHeaderCellDirective_Factory(t) { return new (t || NbTreeGridHeaderCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridHeaderCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderCellDirective, selectors: [["th", "nbTreeGridHeaderCell", ""]], hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"], hostVars: 2, hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderCell, useExisting: NbTreeGridHeaderCellDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbTreeGridHeaderCellDirective.ctorParameters = () => [
    { type: NbTreeGridColumnDefDirective },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [NB_TREE_GRID,] }] },
    { type: NbColumnsService },
    { type: ChangeDetectorRef }
];
NbTreeGridHeaderCellDirective.propDecorators = {
    columnWidth: [{ type: HostBinding, args: ['style.width',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderCellDirective, [{
        type: Directive,
        args: [{
                selector: 'th[nbTreeGridHeaderCell]',
                host: {
                    'class': 'nb-tree-grid-header-cell',
                    'role': 'columnheader'
                },
                providers: [{ provide: NbCdkHeaderCell, useExisting: NbTreeGridHeaderCellDirective }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }] }); })();
class NbTreeGridFooterCellDirective extends NbFooterCellDirective {
    constructor(columnDef, elementRef, tree, columnService, cd) {
        super(columnDef, elementRef);
        this.columnService = columnService;
        this.cd = cd;
        this.destroy$ = new Subject();
        this.tree = tree;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        return this.latestWidth || null;
    }
    ngOnInit() {
        this.columnService.onColumnsChange()
            .pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
NbTreeGridFooterCellDirective.ɵfac = function NbTreeGridFooterCellDirective_Factory(t) { return new (t || NbTreeGridFooterCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridFooterCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterCellDirective, selectors: [["td", "nbTreeGridFooterCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"], hostVars: 2, hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterCell, useExisting: NbTreeGridFooterCellDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbTreeGridFooterCellDirective.ctorParameters = () => [
    { type: NbTreeGridColumnDefDirective },
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [NB_TREE_GRID,] }] },
    { type: NbColumnsService },
    { type: ChangeDetectorRef }
];
NbTreeGridFooterCellDirective.propDecorators = {
    columnWidth: [{ type: HostBinding, args: ['style.width',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterCellDirective, [{
        type: Directive,
        args: [{
                selector: 'td[nbTreeGridFooterCell]',
                host: {
                    'class': 'nb-tree-grid-footer-cell',
                    'role': 'gridcell'
                },
                providers: [{ provide: NbCdkFooterCell, useExisting: NbTreeGridFooterCellDirective }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbFilterDirective {
    filter(filterRequest) {
        this.filterable.filter(filterRequest);
    }
}
NbFilterDirective.ɵfac = function NbFilterDirective_Factory(t) { return new (t || NbFilterDirective)(); };
NbFilterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFilterDirective, selectors: [["", "nbFilter", ""]], inputs: { filterable: ["nbFilter", "filterable"] } });
NbFilterDirective.propDecorators = {
    filterable: [{ type: Input, args: ['nbFilter',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFilterDirective, [{
        type: Directive,
        args: [{ selector: '[nbFilter]' }]
    }], null, { filterable: [{
            type: Input,
            args: ['nbFilter']
        }] }); })();
/**
 * Helper directive to trigger data source's filter method when user types in input
 */
class NbFilterInputDirective extends NbFilterDirective {
    constructor() {
        super(...arguments);
        this.search$ = new Subject();
        this.destroy$ = new Subject();
        /**
         * Debounce time before triggering filter method. Set in milliseconds.
         * Default 200.
         */
        this.debounceTime = 200;
    }
    ngOnInit() {
        this.search$
            .pipe(debounceTime(this.debounceTime), takeUntil(this.destroy$))
            .subscribe((query) => {
            super.filter(query);
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.search$.complete();
    }
    filter(event) {
        this.search$.next(event.target.value);
    }
}
NbFilterInputDirective.ɵfac = function NbFilterInputDirective_Factory(t) { return ɵNbFilterInputDirective_BaseFactory(t || NbFilterInputDirective); };
NbFilterInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFilterInputDirective, selectors: [["", "nbFilterInput", ""]], hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function NbFilterInputDirective_input_HostBindingHandler($event) { return ctx.filter($event); });
    } }, inputs: { debounceTime: "debounceTime", filterable: ["nbFilterInput", "filterable"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbFilterDirective, useExisting: NbFilterInputDirective }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
NbFilterInputDirective.propDecorators = {
    filterable: [{ type: Input, args: ['nbFilterInput',] }],
    debounceTime: [{ type: Input }],
    filter: [{ type: HostListener, args: ['input', ['$event'],] }]
};
const ɵNbFilterInputDirective_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NbFilterInputDirective);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFilterInputDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFilterInput]',
                providers: [{ provide: NbFilterDirective, useExisting: NbFilterInputDirective }]
            }]
    }], null, { debounceTime: [{
            type: Input
        }], filter: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], filterable: [{
            type: Input,
            args: ['nbFilterInput']
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * When using custom row toggle, apply this directive on your toggle to toggle row on element click.
 */
class NbTreeGridRowToggleDirective {
    constructor(cell) {
        this.cell = cell;
    }
    toggleRow($event) {
        this.cell.toggleRow();
        $event.stopPropagation();
    }
}
NbTreeGridRowToggleDirective.ɵfac = function NbTreeGridRowToggleDirective_Factory(t) { return new (t || NbTreeGridRowToggleDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridCellDirective)); };
NbTreeGridRowToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridRowToggleDirective, selectors: [["", "nbTreeGridRowToggle", ""]], hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) { return ctx.toggleRow($event); });
    } } });
NbTreeGridRowToggleDirective.ctorParameters = () => [
    { type: NbTreeGridCellDirective }
];
NbTreeGridRowToggleDirective.propDecorators = {
    toggleRow: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridRowToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridRowToggle]'
            }]
    }], function () { return [{ type: NbTreeGridCellDirective }]; }, { toggleRow: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * NbTreeGridRowToggleComponent
 */
class NbTreeGridRowToggleComponent {
    constructor(cell) {
        this.cell = cell;
    }
    set expanded(value) {
        this.expandedValue = value;
    }
    get expanded() {
        return this.expandedValue;
    }
    toggleRow($event) {
        this.cell.toggleRow();
        $event.stopPropagation();
    }
}
NbTreeGridRowToggleComponent.ɵfac = function NbTreeGridRowToggleComponent_Factory(t) { return new (t || NbTreeGridRowToggleComponent)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridCellDirective)); };
NbTreeGridRowToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridRowToggleComponent, selectors: [["nb-tree-grid-row-toggle"]], hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) { return ctx.toggleRow($event); });
    } }, inputs: { expanded: "expanded" }, decls: 2, vars: 2, consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]], template: function NbTreeGridRowToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelement(1, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.expanded ? "collapse" : "expand");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
    } }, directives: [NbIconComponent], styles: ["button[_ngcontent-%COMP%] {\n      background: transparent;\n      border: none;\n      padding: 0;\n    }"] });
NbTreeGridRowToggleComponent.ctorParameters = () => [
    { type: NbTreeGridCellDirective }
];
NbTreeGridRowToggleComponent.propDecorators = {
    expanded: [{ type: Input }],
    toggleRow: [{ type: HostListener, args: ['click', ['$event'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridRowToggleComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tree-grid-row-toggle',
                template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
                styles: [`
    button {
      background: transparent;
      border: none;
      padding: 0;
    }
  `]
            }]
    }], function () { return [{ type: NbTreeGridCellDirective }]; }, { expanded: [{
            type: Input
        }], toggleRow: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const COMPONENTS$2 = [
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective,
];
class NbTreeGridModule {
}
NbTreeGridModule.ɵfac = function NbTreeGridModule_Factory(t) { return new (t || NbTreeGridModule)(); };
NbTreeGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTreeGridModule });
NbTreeGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [
        NbTreeGridSortService,
        NbTreeGridFilterService,
        NbTreeGridService,
        NbTreeGridDataService,
        NbTreeGridDataSourceBuilder,
    ], imports: [[CommonModule, NbTableModule, NbIconModule], NbTableModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTreeGridModule, { declarations: function () { return [NbTreeGridComponent, NbTreeGridRowDefDirective, NbTreeGridRowComponent, NbTreeGridCellDefDirective, NbTreeGridCellDirective, NbTreeGridHeaderRowDefDirective, NbTreeGridHeaderRowComponent, NbTreeGridHeaderCellDefDirective, NbTreeGridHeaderCellDirective, NbTreeGridFooterRowDefDirective, NbTreeGridFooterRowComponent, NbTreeGridFooterCellDefDirective, NbTreeGridFooterCellDirective, NbTreeGridColumnDefDirective, NbSortDirective, NbSortHeaderComponent, NbSortIconComponent, NbFilterDirective, NbFilterInputDirective, NbTreeGridRowToggleDirective, NbTreeGridRowToggleComponent, NbSortHeaderIconDirective]; }, imports: function () { return [CommonModule, NbTableModule, NbIconModule]; }, exports: function () { return [NbTableModule, NbTreeGridComponent, NbTreeGridRowDefDirective, NbTreeGridRowComponent, NbTreeGridCellDefDirective, NbTreeGridCellDirective, NbTreeGridHeaderRowDefDirective, NbTreeGridHeaderRowComponent, NbTreeGridHeaderCellDefDirective, NbTreeGridHeaderCellDirective, NbTreeGridFooterRowDefDirective, NbTreeGridFooterRowComponent, NbTreeGridFooterCellDefDirective, NbTreeGridFooterCellDirective, NbTreeGridColumnDefDirective, NbSortDirective, NbSortHeaderComponent, NbSortIconComponent, NbFilterDirective, NbFilterInputDirective, NbTreeGridRowToggleDirective, NbTreeGridRowToggleComponent, NbSortHeaderIconDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbTreeGridModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbTableModule, NbIconModule],
                declarations: [...COMPONENTS$2],
                exports: [NbTableModule, ...COMPONENTS$2],
                providers: [
                    NbTreeGridSortService,
                    NbTreeGridFilterService,
                    NbTreeGridService,
                    NbTreeGridDataService,
                    NbTreeGridDataSourceBuilder,
                ]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Toggle is a control representing `on` and `off` states.
 *
 * @stacked-example(Showcase, toggle/toggle-showcase.component)
 *
 * ### Installation
 *
 * Import `NbToggleComponent` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbToggleModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Toggle may have one of the following statuses: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`
 *
 * @stacked-example(Toggle status, toggle/toggle-status.component)
 *
 * Toggle can be disabled via `disabled` input.
 *
 * @stacked-example(Disabled Toggles, toggle/toggle-disabled.component)
 *
 * Toggle may have a label with following positions: `left`, `right`, `start`, `end` (default)
 *
 * @stacked-example(Toggles With Labels, toggle/toggle-label-position.component.ts)
 *
 * You can set control state via `checked` binding:
 *
 * ```html
 * <nb-toggle [(checked)]="checked"></nb-toggle>
 * ```
 *
 * Or it could be set via reactive forms or ngModel bindings:
 *
 * @stacked-example(Toggle form binding, toggle/toggle-form.component)
 *
 * @styles
 *
 * toggle-height:
 * toggle-width:
 * toggle-border-width:
 * toggle-border-radius:
 * toggle-outline-width:
 * toggle-outline-color:
 * toggle-switcher-size:
 * toggle-switcher-icon-size:
 * toggle-text-font-family:
 * toggle-text-font-size:
 * toggle-text-font-weight:
 * toggle-text-line-height:
 * toggle-cursor:
 * toggle-disabled-cursor:
 * toggle-basic-text-color:
 * toggle-basic-background-color:
 * toggle-basic-border-color:
 * toggle-basic-checked-background-color:
 * toggle-basic-checked-border-color:
 * toggle-basic-checked-switcher-background-color:
 * toggle-basic-checked-switcher-checkmark-color:
 * toggle-basic-focus-background-color:
 * toggle-basic-focus-border-color:
 * toggle-basic-focus-checked-background-color:
 * toggle-basic-focus-checked-border-color:
 * toggle-basic-hover-background-color:
 * toggle-basic-hover-border-color:
 * toggle-basic-hover-checked-background-color:
 * toggle-basic-hover-checked-border-color:
 * toggle-basic-active-background-color:
 * toggle-basic-active-border-color:
 * toggle-basic-active-checked-background-color:
 * toggle-basic-active-checked-border-color:
 * toggle-basic-disabled-background-color:
 * toggle-basic-disabled-border-color:
 * toggle-basic-disabled-switcher-background-color:
 * toggle-basic-disabled-checked-switcher-checkmark-color:
 * toggle-basic-disabled-text-color:
 * toggle-primary-text-color:
 * toggle-primary-background-color:
 * toggle-primary-border-color:
 * toggle-primary-checked-background-color:
 * toggle-primary-checked-border-color:
 * toggle-primary-checked-switcher-background-color:
 * toggle-primary-checked-switcher-checkmark-color:
 * toggle-primary-focus-background-color:
 * toggle-primary-focus-border-color:
 * toggle-primary-focus-checked-background-color:
 * toggle-primary-focus-checked-border-color:
 * toggle-primary-hover-background-color:
 * toggle-primary-hover-border-color:
 * toggle-primary-hover-checked-background-color:
 * toggle-primary-hover-checked-border-color:
 * toggle-primary-active-background-color:
 * toggle-primary-active-border-color:
 * toggle-primary-active-checked-background-color:
 * toggle-primary-active-checked-border-color:
 * toggle-primary-disabled-background-color:
 * toggle-primary-disabled-border-color:
 * toggle-primary-disabled-switcher-background-color:
 * toggle-primary-disabled-checked-switcher-checkmark-color:
 * toggle-primary-disabled-text-color:
 * toggle-success-text-color:
 * toggle-success-background-color:
 * toggle-success-border-color:
 * toggle-success-checked-background-color:
 * toggle-success-checked-border-color:
 * toggle-success-checked-switcher-background-color:
 * toggle-success-checked-switcher-checkmark-color:
 * toggle-success-focus-background-color:
 * toggle-success-focus-border-color:
 * toggle-success-focus-checked-background-color:
 * toggle-success-focus-checked-border-color:
 * toggle-success-hover-background-color:
 * toggle-success-hover-border-color:
 * toggle-success-hover-checked-background-color:
 * toggle-success-hover-checked-border-color:
 * toggle-success-active-background-color:
 * toggle-success-active-border-color:
 * toggle-success-active-checked-background-color:
 * toggle-success-active-checked-border-color:
 * toggle-success-disabled-background-color:
 * toggle-success-disabled-border-color:
 * toggle-success-disabled-switcher-background-color:
 * toggle-success-disabled-checked-switcher-checkmark-color:
 * toggle-success-disabled-text-color:
 * toggle-info-text-color:
 * toggle-info-background-color:
 * toggle-info-border-color:
 * toggle-info-checked-background-color:
 * toggle-info-checked-border-color:
 * toggle-info-checked-switcher-background-color:
 * toggle-info-checked-switcher-checkmark-color:
 * toggle-info-focus-background-color:
 * toggle-info-focus-border-color:
 * toggle-info-focus-checked-background-color:
 * toggle-info-focus-checked-border-color:
 * toggle-info-hover-background-color:
 * toggle-info-hover-border-color:
 * toggle-info-hover-checked-background-color:
 * toggle-info-hover-checked-border-color:
 * toggle-info-active-background-color:
 * toggle-info-active-border-color:
 * toggle-info-active-checked-background-color:
 * toggle-info-active-checked-border-color:
 * toggle-info-disabled-background-color:
 * toggle-info-disabled-border-color:
 * toggle-info-disabled-switcher-background-color:
 * toggle-info-disabled-checked-switcher-checkmark-color:
 * toggle-info-disabled-text-color:
 * toggle-warning-text-color:
 * toggle-warning-background-color:
 * toggle-warning-border-color:
 * toggle-warning-checked-background-color:
 * toggle-warning-checked-border-color:
 * toggle-warning-checked-switcher-background-color:
 * toggle-warning-checked-switcher-checkmark-color:
 * toggle-warning-focus-background-color:
 * toggle-warning-focus-border-color:
 * toggle-warning-focus-checked-background-color:
 * toggle-warning-focus-checked-border-color:
 * toggle-warning-hover-background-color:
 * toggle-warning-hover-border-color:
 * toggle-warning-hover-checked-background-color:
 * toggle-warning-hover-checked-border-color:
 * toggle-warning-active-background-color:
 * toggle-warning-active-border-color:
 * toggle-warning-active-checked-background-color:
 * toggle-warning-active-checked-border-color:
 * toggle-warning-disabled-background-color:
 * toggle-warning-disabled-border-color:
 * toggle-warning-disabled-switcher-background-color:
 * toggle-warning-disabled-checked-switcher-checkmark-color:
 * toggle-warning-disabled-text-color:
 * toggle-danger-text-color:
 * toggle-danger-background-color:
 * toggle-danger-border-color:
 * toggle-danger-checked-background-color:
 * toggle-danger-checked-border-color:
 * toggle-danger-checked-switcher-background-color:
 * toggle-danger-checked-switcher-checkmark-color:
 * toggle-danger-focus-background-color:
 * toggle-danger-focus-border-color:
 * toggle-danger-focus-checked-background-color:
 * toggle-danger-focus-checked-border-color:
 * toggle-danger-hover-background-color:
 * toggle-danger-hover-border-color:
 * toggle-danger-hover-checked-background-color:
 * toggle-danger-hover-checked-border-color:
 * toggle-danger-active-background-color:
 * toggle-danger-active-border-color:
 * toggle-danger-active-checked-background-color:
 * toggle-danger-active-checked-border-color:
 * toggle-danger-disabled-background-color:
 * toggle-danger-disabled-border-color:
 * toggle-danger-disabled-switcher-background-color:
 * toggle-danger-disabled-checked-switcher-checkmark-color:
 * toggle-danger-disabled-text-color:
 * toggle-control-text-color:
 * toggle-control-background-color:
 * toggle-control-border-color:
 * toggle-control-checked-background-color:
 * toggle-control-checked-border-color:
 * toggle-control-checked-switcher-background-color:
 * toggle-control-checked-switcher-checkmark-color:
 * toggle-control-focus-background-color:
 * toggle-control-focus-border-color:
 * toggle-control-focus-checked-background-color:
 * toggle-control-focus-checked-border-color:
 * toggle-control-hover-background-color:
 * toggle-control-hover-border-color:
 * toggle-control-hover-checked-background-color:
 * toggle-control-hover-checked-border-color:
 * toggle-control-active-background-color:
 * toggle-control-active-border-color:
 * toggle-control-active-checked-background-color:
 * toggle-control-active-checked-border-color:
 * toggle-control-disabled-background-color:
 * toggle-control-disabled-border-color:
 * toggle-control-disabled-switcher-background-color:
 * toggle-control-disabled-checked-switcher-checkmark-color:
 * toggle-control-disabled-text-color:
 */
class NbToggleComponent {
    constructor(changeDetector, layoutDirection, renderer, hostElement, zone, statusService) {
        this.changeDetector = changeDetector;
        this.layoutDirection = layoutDirection;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.zone = zone;
        this.statusService = statusService;
        this.onChange = () => { };
        this.onTouched = () => { };
        this.destroy$ = new Subject();
        this._checked = false;
        this._disabled = false;
        /**
         * Toggle status.
         * Possible values are: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`.
         */
        this.status = 'basic';
        /**
         * Toggle label position.
         * Possible values are: `left`, `right`, `start`, `end` (default)
         */
        this.labelPosition = 'end';
        /**
         * Output when checked state is changed by a user
         * @type EventEmitter<boolean>
         */
        this.checkedChange = new EventEmitter();
    }
    /**
     * Toggle checked
     * @type {boolean}
     */
    get checked() {
        return this._checked;
    }
    set checked(value) {
        this._checked = convertToBoolProperty(value);
    }
    /**
     * Controls input disabled state
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get info() {
        return this.status === 'info';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get additionalClasses() {
        if (this.statusService.isCustomStatus(this.status)) {
            return [this.statusService.getStatusClass(this.status)];
        }
        return [];
    }
    get labelLeft() {
        return this.labelPosition === 'left';
    }
    get labelRight() {
        return this.labelPosition === 'right';
    }
    get labelStart() {
        return this.labelPosition === 'start';
    }
    get labelEnd() {
        return this.labelPosition === 'end';
    }
    ngOnInit() {
        this.layoutDirection.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.changeDetector.detectChanges());
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.hostElement.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkState() {
        if (this.checked) {
            return this.layoutDirection.isLtr() ? 'right' : 'left';
        }
        return this.layoutDirection.isLtr() ? 'left' : 'right';
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(val) {
        this.checked = val;
        this.changeDetector.markForCheck();
    }
    setDisabledState(val) {
        this.disabled = convertToBoolProperty(val);
        this.changeDetector.markForCheck();
    }
    updateValue(event) {
        const input = event.target;
        this.checked = input.checked;
        this.checkedChange.emit(this.checked);
        this.onChange(this.checked);
    }
    onInputClick(event) {
        event.stopPropagation();
    }
}
NbToggleComponent.ɵfac = function NbToggleComponent_Factory(t) { return new (t || NbToggleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(NbStatusService)); };
NbToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToggleComponent, selectors: [["nb-toggle"]], hostVars: 24, hostBindings: function NbToggleComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.additionalClasses);
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
    } }, inputs: { status: "status", labelPosition: "labelPosition", checked: "checked", disabled: "disabled" }, outputs: { checkedChange: "checkedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbToggleComponent),
                multi: true
            }])], ngContentSelectors: _c0, decls: 7, vars: 7, consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "change", "blur", "click"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]], template: function NbToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("change", function NbToggleComponent_Template_input_change_1_listener($event) { return ctx.updateValue($event); })("blur", function NbToggleComponent_Template_input_blur_1_listener() { return ctx.onTouched(); })("click", function NbToggleComponent_Template_input_click_1_listener($event) { return ctx.onInputClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtemplate(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@position", ctx.checkState());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.checked);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:0.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:0.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.nb-transition[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}"], data: { animation: [
            trigger('position', [
                state('right', style({ right: 0, left: '*' })),
                state('left', style({ left: 0, right: '*' })),
                transition(':enter', [animate(0)]),
                transition('right <=> left', [animate('0.15s')]),
            ]),
        ] }, changeDetection: 0 });
NbToggleComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NbLayoutDirectionService },
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone },
    { type: NbStatusService }
];
NbToggleComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    status: [{ type: Input }],
    labelPosition: [{ type: Input }],
    checkedChange: [{ type: Output }],
    primary: [{ type: HostBinding, args: ['class.status-primary',] }],
    success: [{ type: HostBinding, args: ['class.status-success',] }],
    warning: [{ type: HostBinding, args: ['class.status-warning',] }],
    danger: [{ type: HostBinding, args: ['class.status-danger',] }],
    info: [{ type: HostBinding, args: ['class.status-info',] }],
    basic: [{ type: HostBinding, args: ['class.status-basic',] }],
    control: [{ type: HostBinding, args: ['class.status-control',] }],
    additionalClasses: [{ type: HostBinding, args: ['class',] }],
    labelLeft: [{ type: HostBinding, args: ['class.toggle-label-left',] }],
    labelRight: [{ type: HostBinding, args: ['class.toggle-label-right',] }],
    labelStart: [{ type: HostBinding, args: ['class.toggle-label-start',] }],
    labelEnd: [{ type: HostBinding, args: ['class.toggle-label-end',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToggleComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toggle',
                animations: [
                    trigger('position', [
                        state('right', style({ right: 0, left: '*' })),
                        state('left', style({ left: 0, right: '*' })),
                        transition(':enter', [animate(0)]),
                        transition('right <=> left', [animate('0.15s')]),
                    ]),
                ],
                template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbToggleComponent),
                        multi: true
                    }],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:0.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:0.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}:host(.nb-transition) .toggle{transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: NbLayoutDirectionService }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: NbStatusService }]; }, { status: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], checkedChange: [{
            type: Output
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], additionalClasses: [{
            type: HostBinding,
            args: ['class']
        }], labelLeft: [{
            type: HostBinding,
            args: ['class.toggle-label-left']
        }], labelRight: [{
            type: HostBinding,
            args: ['class.toggle-label-right']
        }], labelStart: [{
            type: HostBinding,
            args: ['class.toggle-label-start']
        }], labelEnd: [{
            type: HostBinding,
            args: ['class.toggle-label-end']
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbToggleModule {
}
NbToggleModule.ɵfac = function NbToggleModule_Factory(t) { return new (t || NbToggleModule)(); };
NbToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbToggleModule });
NbToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            NbIconModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbToggleModule, { declarations: function () { return [NbToggleComponent]; }, imports: function () { return [CommonModule, NbIconModule]; }, exports: function () { return [NbToggleComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbToggleModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    NbIconModule,
                ],
                declarations: [NbToggleComponent],
                exports: [NbToggleComponent]
            }]
    }], null, null); })();

class NbPrefixDirective {
}
NbPrefixDirective.ɵfac = function NbPrefixDirective_Factory(t) { return new (t || NbPrefixDirective)(); };
NbPrefixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPrefixDirective, selectors: [["", "nbPrefix", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbPrefixDirective, [{
        type: Directive,
        args: [{
                selector: '[nbPrefix]'
            }]
    }], null, null); })();

class NbSuffixDirective {
}
NbSuffixDirective.ɵfac = function NbSuffixDirective_Factory(t) { return new (t || NbSuffixDirective)(); };
NbSuffixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSuffixDirective, selectors: [["", "nbSuffix", ""]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbSuffixDirective, [{
        type: Directive,
        args: [{
                selector: '[nbSuffix]'
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function throwFormControlElementNotFound() {
    throw new Error(`NbFormFieldComponent must contain [nbInput]`);
}
/*
 * NbFormFieldComponent
 *
 * @styles
 *
 * form-field-addon-basic-text-color:
 * form-field-addon-basic-highlight-text-color:
 * form-field-addon-primary-text-color:
 * form-field-addon-primary-highlight-text-color:
 * form-field-addon-success-text-color:
 * form-field-addon-success-highlight-text-color:
 * form-field-addon-info-text-color:
 * form-field-addon-info-highlight-text-color:
 * form-field-addon-warning-text-color:
 * form-field-addon-warning-highlight-text-color:
 * form-field-addon-danger-text-color:
 * form-field-addon-danger-highlight-text-color:
 * form-field-addon-control-text-color:
 * form-field-addon-control-highlight-text-color:
 * form-field-addon-disabled-text-color:
 * form-field-addon-tiny-height:
 * form-field-addon-tiny-width:
 * form-field-addon-tiny-icon-size:
 * form-field-addon-tiny-font-size:
 * form-field-addon-tiny-line-height:
 * form-field-addon-tiny-font-weight:
 * form-field-addon-small-height:
 * form-field-addon-small-width:
 * form-field-addon-small-icon-size:
 * form-field-addon-small-font-size:
 * form-field-addon-small-line-height:
 * form-field-addon-small-font-weight:
 * form-field-addon-medium-height:
 * form-field-addon-medium-width:
 * form-field-addon-medium-icon-size:
 * form-field-addon-medium-font-size:
 * form-field-addon-medium-line-height:
 * form-field-addon-medium-font-weight:
 * form-field-addon-large-height:
 * form-field-addon-large-width:
 * form-field-addon-large-icon-size:
 * form-field-addon-large-font-size:
 * form-field-addon-large-line-height:
 * form-field-addon-large-font-weight:
 * form-field-addon-giant-height:
 * form-field-addon-giant-width:
 * form-field-addon-giant-icon-size:
 * form-field-addon-giant-font-size:
 * form-field-addon-giant-line-height:
 * form-field-addon-giant-font-weight:
 **/
class NbFormFieldComponent {
    constructor(cd, zone, elementRef, renderer) {
        this.cd = cd;
        this.zone = zone;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.destroy$ = new Subject();
        this.formControlState$ = new ReplaySubject(1);
        this.prefixClasses$ = this.formControlState$.pipe(map(s => this.getAddonClasses('prefix', s)));
        this.suffixClasses$ = this.formControlState$.pipe(map(s => this.getAddonClasses('suffix', s)));
    }
    ngAfterContentChecked() {
        if (!this.formControl) {
            throwFormControlElementNotFound();
        }
    }
    ngAfterContentInit() {
        this.subscribeToFormControlStateChange();
        this.subscribeToAddonChange();
    }
    ngAfterViewInit() {
        // TODO: #2254
        this.zone.runOutsideAngular(() => setTimeout(() => {
            this.renderer.addClass(this.elementRef.nativeElement, 'nb-transition');
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    shouldShowPrefix() {
        return this.getFormControlConfig().supportsPrefix && !!this.prefix.length;
    }
    shouldShowSuffix() {
        return this.getFormControlConfig().supportsSuffix && !!this.suffix.length;
    }
    subscribeToFormControlStateChange() {
        const { disabled$, focused$, size$, status$, fullWidth$ } = this.formControl;
        combineLatest([disabled$, focused$, size$, status$, fullWidth$])
            .pipe(map(([disabled, focused, size, status, fullWidth]) => ({ disabled, focused, size, status, fullWidth })), distinctUntilChanged((oldState, state$$1) => this.isStatesEqual(oldState, state$$1)), tap(({ size, fullWidth }) => {
            const formFieldClasses = [`nb-form-field-size-${size}`];
            if (!fullWidth) {
                formFieldClasses.push('nb-form-field-limited-width');
            }
            this.formFieldClasses = formFieldClasses.join(' ');
        }), takeUntil(this.destroy$))
            .subscribe(this.formControlState$);
    }
    subscribeToAddonChange() {
        merge(this.prefix.changes, this.suffix.changes)
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.cd.markForCheck());
    }
    getAddonClasses(addon, state$$1) {
        const classes = [
            'nb-form-field-addon',
            `nb-form-field-${addon}-${state$$1.size}`,
        ];
        if (state$$1.disabled) {
            classes.push(`nb-form-field-addon-disabled`);
        }
        else if (state$$1.focused) {
            classes.push(`nb-form-field-addon-${state$$1.status}-highlight`);
        }
        else {
            classes.push(`nb-form-field-addon-${state$$1.status}`);
        }
        return classes;
    }
    getFormControlConfig() {
        return this.formControlConfig || new NbFormFieldControlConfig();
    }
    isStatesEqual(oldState, state$$1) {
        return oldState.status === state$$1.status &&
            oldState.disabled === state$$1.disabled &&
            oldState.focused === state$$1.focused &&
            oldState.fullWidth === state$$1.fullWidth &&
            oldState.size === state$$1.size;
    }
}
NbFormFieldComponent.ɵfac = function NbFormFieldComponent_Factory(t) { return new (t || NbFormFieldComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbFormFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbFormFieldComponent, selectors: [["nb-form-field"]], contentQueries: function NbFormFieldComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbFormFieldControl, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbFormFieldControlConfig, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbPrefixDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbSuffixDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.formControlConfig = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prefix = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.suffix = _t);
    } }, hostVars: 2, hostBindings: function NbFormFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.formFieldClasses);
    } }, ngContentSelectors: _c58, decls: 4, vars: 6, consts: [[3, "ngClass", 4, "ngIf"], [1, "nb-form-control-container"], [3, "ngClass"]], template: function NbFormFieldComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c57);
        ɵngcc0.ɵɵtemplate(0, NbFormFieldComponent_div_0_Template, 3, 3, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbFormFieldComponent_div_3_Template, 3, 3, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowPrefix());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("nb-form-field-control-with-prefix", ctx.shouldShowPrefix())("nb-form-field-control-with-suffix", ctx.shouldShowSuffix());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowSuffix());
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgClass], pipes: [ɵngcc2.AsyncPipe], styles: ["[_nghost-%COMP%]{display:flex;align-items:center}.nb-form-control-container[_ngcontent-%COMP%]{width:100%}"], changeDetection: 0 });
NbFormFieldComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef },
    { type: Renderer2 }
];
NbFormFieldComponent.propDecorators = {
    prefix: [{ type: ContentChildren, args: [NbPrefixDirective, { descendants: true },] }],
    suffix: [{ type: ContentChildren, args: [NbSuffixDirective, { descendants: true },] }],
    formControl: [{ type: ContentChild, args: [NbFormFieldControl, { static: false },] }],
    formControlConfig: [{ type: ContentChild, args: [NbFormFieldControlConfig, { static: false },] }],
    formFieldClasses: [{ type: HostBinding, args: ['class',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFormFieldComponent, [{
        type: Component,
        args: [{
                selector: 'nb-form-field',
                template: "<div *ngIf=\"shouldShowPrefix()\" [ngClass]=\"prefixClasses$ | async\">\n  <ng-content select=\"[nbPrefix]\"></ng-content>\n</div>\n\n<div class=\"nb-form-control-container\"\n     [class.nb-form-field-control-with-prefix]=\"shouldShowPrefix()\"\n     [class.nb-form-field-control-with-suffix]=\"shouldShowSuffix()\">\n  <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"shouldShowSuffix()\" [ngClass]=\"suffixClasses$ | async\">\n  <ng-content select=\"[nbSuffix]\"></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;align-items:center}.nb-form-control-container{width:100%}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { formFieldClasses: [{
            type: HostBinding,
            args: ['class']
        }], prefix: [{
            type: ContentChildren,
            args: [NbPrefixDirective, { descendants: true }]
        }], suffix: [{
            type: ContentChildren,
            args: [NbSuffixDirective, { descendants: true }]
        }], formControl: [{
            type: ContentChild,
            args: [NbFormFieldControl, { static: false }]
        }], formControlConfig: [{
            type: ContentChild,
            args: [NbFormFieldControlConfig, { static: false }]
        }] }); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const COMPONENTS$3 = [
    NbFormFieldComponent,
    NbPrefixDirective,
    NbSuffixDirective,
];
class NbFormFieldModule {
}
NbFormFieldModule.ɵfac = function NbFormFieldModule_Factory(t) { return new (t || NbFormFieldModule)(); };
NbFormFieldModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbFormFieldModule });
NbFormFieldModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbFormFieldModule, { declarations: function () { return [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NbFormFieldModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [...COMPONENTS$3],
                exports: [...COMPONENTS$3]
            }]
    }], null, null); })();

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
// TODO: export all components

/**
 * Generated bundle index. Do not edit.
 */

export { NbCalendarActionsComponent as ɵe, NbActiveDescendantKeyManagerFactoryService as ɵd, NbFocusKeyManagerFactoryService as ɵc, NbCalendarWithTimeComponent as ɵg, NbMenuInternalService as ɵa, NbSharedModule as ɵb, NbTimePickerCellComponent as ɵf, NbCalendarDayCellComponent, NbDateTimePickerComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, MONTHS_IN_VIEW, MONTHS_IN_COLUMN, NbCalendarDayPickerComponent, NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarWeekNumberComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarMonthModelService, NbNativeDateService, NbDateService, NbMenuService, NbMenuItem, NbSidebarService, NB_THEME_OPTIONS, NB_MEDIA_BREAKPOINTS, NB_BUILT_IN_JS_THEMES, NB_JS_THEMES, NB_WINDOW, NB_DOCUMENT, windowFactory, NbThemeModule, NbThemeService, NbSpinnerService, DEFAULT_MEDIA_BREAKPOINTS, NbMediaBreakpointsService, NbColorHelper, NbLayoutDirection, NB_LAYOUT_DIRECTION, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, NbStatusService, BUILT_IN_THEMES, NbJSThemesRegistry, CORPORATE_THEME, COSMIC_THEME, DEFAULT_THEME, DARK_THEME, NbCardModule, NbCardHeaderComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardComponent, NbFlipCardComponent, NbRevealCardComponent, NbCardFrontComponent, NbCardBackComponent, NbCalendarModule, NbCalendarComponent, NbCalendarRangeModule, NbCalendarRangeComponent, NbBaseCalendarComponent, NbBaseCalendarModule, NbBaseCalendarRangeCell, NbCalendarRangeDayCellComponent, NbCalendarRangeMonthCellComponent, NbCalendarRangeYearCellComponent, NbCalendarYearModelService, NbCalendarTimeModelService, NbCalendarViewMode, NbCalendarSize, NbCalendarKitModule, NbLayoutModule, NbLayoutComponent, NbLayoutColumnComponent, NbLayoutHeaderComponent, NbLayoutFooterComponent, NbRestoreScrollTopHelper, NbMenuModule, NbToggleStates, NbMenuItemComponent, NbMenuComponent, NbRouteTabsetModule, NbRouteTabsetComponent, NbSidebarModule, NbSidebarHeaderComponent, NbSidebarFooterComponent, NbSidebarComponent, NbTabsetModule, NbTabComponent, NbTabsetComponent, NbUserModule, NbUserComponent, NbActionsModule, NbActionComponent, NbActionsComponent, NbSearchModule, NbSearchService, NbSearchFieldComponent, NbSearchComponent, NbCheckboxComponent, NbCheckboxModule, NbBadgeComponent, NbBadgeModule, NbPopoverDirective, NbPopoverModule, NbPopoverComponent, NbContextMenuDirective, NbContextMenuComponent, NbContextMenuModule, NbProgressBarComponent, NbProgressBarModule, NbAlertComponent, NbAlertModule, NbChatComponent, NbChatMessageComponent, NbChatMessageMapComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageTextComponent, NbChatFormComponent, NbChatModule, NbChatOptions, NbSpinnerComponent, NbSpinnerDirective, NbSpinnerModule, NB_STEPPER, NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective, NbStepperModule, NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemBodyComponent, NbAccordionItemHeaderComponent, NbAccordionModule, NbButton, NbButtonComponent, NbButtonModule, NbButtonGroupComponent, NbButtonGroupModule, NbButtonToggleDirective, NbListComponent, NbListItemComponent, NbListModule, NbListPageTrackerDirective, NbScrollableContainerDimentions, NbInfiniteListDirective, NbInputDirective, NbInputModule, NbOverlayModule, patch, createContainer, NbOverlayService, NbAdjustment, NbPosition, NbAdjustableConnectedPositionStrategy, NbGlobalPositionStrategy, NbPositionBuilderService, NbPositionedContainerComponent, NbOverlayContainerComponent, NbTrigger, NbTriggerStrategyBase, NbClickTriggerStrategy, NbHoverTriggerStrategy, NbHintTriggerStrategy, NbFocusTriggerStrategy, NbNoopTriggerStrategy, NbTriggerStrategyBuilderService, NbPortalDirective, NbPortalOutletDirective, NbComponentPortal, NbOverlay, NbOverlayPositionBuilder, NbTemplatePortal, NbOverlayContainer, NbFlexibleConnectedPositionStrategy, NbPortalInjector, NbCdkMappingModule, NbGlobalLogicalPosition, NbGlobalPhysicalPosition, NbPositionHelper, NbDynamicOverlay, NbDynamicOverlayChange, NbDynamicOverlayHandler, NbPlatform, NbFocusMonitor, NbA11yModule, NbFocusTrap, NbFocusTrapFactoryService, NbCdkAdapterModule, NbBlockScrollStrategyAdapter, NbScrollStrategyOptions, NbOverlayContainerAdapter, NbScrollDispatcherAdapter, NbViewportRulerAdapter, NbDirectionality, NbBidiModule, NbCellDefDirective, NbHeaderCellDefDirective, NbFooterCellDefDirective, NB_SORT_HEADER_COLUMN_DEF, NbColumnDefDirective, NbHeaderCellDirective, NbFooterCellDirective, NbCellDirective, NbDataSource, NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective, NbCellOutletDirective, NbHeaderRowDefDirective, NbFooterRowDefDirective, NbRowDefDirective, NbHeaderRowComponent, NbFooterRowComponent, NbRowComponent, NB_TABLE_TEMPLATE, NB_VIEW_REPEATER_STRATEGY, NB_COALESCED_STYLE_SCHEDULER, NB_TABLE_PROVIDERS, NbTable, NbTableModule, NB_DIALOG_CONFIG, NbDialogConfig, NbDialogRef, NbDialogService, NbDialogModule, NbToastrModule, NbToastRef, NbToastContainer, NbToastrContainerRegistry, NbToastrService, NbToast, NbToastComponent, NB_TOASTR_CONFIG, NbToastrConfig, NbToastrContainerComponent, NbTooltipModule, NbTooltipDirective, NbTooltipComponent, NbSelectModule, NbSelectLabelComponent, nbSelectFormFieldControlConfigFactory, NbSelectComponent, NbOptionModule, NbOptionComponent, NbOptionGroupComponent, NbOptionListComponent, NB_SELECT_INJECTION_TOKEN, NbAutocompleteModule, NbAutocompleteComponent, NbAutocompleteDirective, NbWindowModule, NbWindowService, NbWindowRef, NbWindowState, NbWindowConfig, NB_WINDOW_CONTENT, NB_WINDOW_CONFIG, NB_WINDOW_CONTEXT, NbWindowComponent, NbWindowsContainerComponent, NbTimepickerModule, NB_TIME_PICKER_CONFIG, NbTimePickerComponent, NbTimePickerDirective, NbDatepickerModule, NbDatepickerAdapter, NbDatepicker, NB_DATE_ADAPTER, NB_DATE_SERVICE_OPTIONS, NbDatepickerDirective, NbDateAdapterService, NbRangeAdapterService, NbDateTimeAdapterService, NbDatepickerContainerComponent, NbBasePicker, NbBasePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbDialogContainerComponent, NbRadioModule, NbRadioGroupComponent, NbRadioComponent, NbTagModule, NbTagComponent, NbTagListComponent, NbTagInputDirective, NbTreeGridModule, NbTreeGridComponent, NB_ROW_DOUBLE_CLICK_DELAY, NbTreeGridRowComponent, NbTreeGridHeaderRowComponent, NbTreeGridFooterRowComponent, NB_TREE_GRID, NbSortDirection, NbSortDirective, NbSortHeaderIconDirective, NbSortIconComponent, NbSortHeaderComponent, NbTreeGridRowToggleComponent, NbTreeGridColumnDefDirective, NbTreeGridCellDirective, NbTreeGridHeaderCellDirective, NbTreeGridFooterCellDirective, NbTreeGridRowDefDirective, NbTreeGridHeaderRowDefDirective, NbTreeGridFooterRowDefDirective, NbTreeGridCellDefDirective, NbTreeGridHeaderCellDefDirective, NbTreeGridFooterCellDefDirective, NbFilterDirective, NbFilterInputDirective, NbTreeGridRowToggleDirective, NB_DEFAULT_ROW_LEVEL, NbTreeGridPresentationNode, NbTreeGridDataSource, NbTreeGridDataSourceBuilder, NbTreeGridDataService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridSortService, NbColumnsService, NbIconModule, NbIconComponent, NbFontIcon, NbSvgIcon, NbIconPackType, NbIconDefinition, NbIconLibraries, NbToggleModule, NbToggleComponent, NbFormFieldModule, NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective, NbFormFieldControl, NbFormFieldControlConfig };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJJQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBHQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnSEFHRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dJQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7MEJBR0U7QUFDRjtBQUNBOzs7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7OzswQkFHRTtBQUNGO0FBQ0E7Ozs7OzswQkFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzBCQVdFO0FBQ0Y7QUFDQTtBQUNBO3NHQUFDO0FBQ0Q7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrSUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0hBR0U7QUFDRjtBQUNBO0FBQ0E7OztrRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3SUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7bUtBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7MkpBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztpRkFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnSEFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7dUdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MklBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSkFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztxR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FJQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NkpBR0U7QUFDRjtBQUNBO0FBQ0E7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBaUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OzBCQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtvR0FBQztBQUNEOzs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozt5U0FRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2NBYUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozt5RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzBCQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7bThCQWVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxK0RBc0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzRGQXdCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzJOQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O2lEQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aUpBR0U7QUFDRjtBQUNBO0FBQ0E7Ozt1RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7aURBV0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b1FBNEJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozt5T0FVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztpREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztrSEFtQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhJQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7dUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzttR0FZRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O3VKQWNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O3FJQW9CRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O21JQWFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7aURBV0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBGQW1CRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7NEVBYUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lIQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7a0NBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OElBR0U7QUFDRjtBQUNBO0FBQ0E7Ozt1RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzBJQXNCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFhRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NFRBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztpREFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztpREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztpREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztvRUF3QkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBaUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O2k5QkFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a3pCQXNERTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozt3RUFRRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7ZUFpQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aXZCQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRVQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29WQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2doQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0lBR0U7QUFDRjtBQUNBO0FBQ0E7Ozt1RUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2a0ZBdUJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7NkJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzZCQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzZCQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWdCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytIQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7eUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O3lqQkFzQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7bWlCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3V4Q0FxQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzswQkFRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzBCQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O2lvQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FpQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBYUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O3dEQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3aERBK0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFlRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzekJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFjRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O2d0QkE2Q0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBFQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cXBnQkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQTRCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzttYUFzQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBd0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MG1CQThCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0hBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs0S0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUlBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7eUpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7b0pBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K25CQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7MEJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs0REFRRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztrYUFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzBCQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Mk5BY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OzBCQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O2lYQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrT0EyQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBaURFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NJQWtCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O21IQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O2lLQTJCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7a0xBZUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztzR0FVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzRDQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWdCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztvZUFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Mk1BR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzZCQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MHZDQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O3FDQUtFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7cUNBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQW9CRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7aURBU0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs4Q0FXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7a0dBY0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7c0VBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQTJCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7MEJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O2tEQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O2lEQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7eUdBT0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3dGQU9FO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs0R0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7d0tBS0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7a0RBU0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlBBU0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzsyR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5UEFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzJHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lOQVNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7MkdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTs7Ozs7Ozs7OzswQkFNRTtBQUNGO0FBQ0E7Ozs7Ozs7Ozs7MEJBTUU7QUFDRjtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvWEFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1hBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MlVBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFZRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVlFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBWUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJSQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzBCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7b0VBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozt3S0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aWpCQU9FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFhRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJJQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztrQ0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7dUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzswQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUF5QkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZwQkFPRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7MEJBUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztrcEJBZUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4M0NBa0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lJQVdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztpREFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBa0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7K01BUUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O29CQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWdCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OzJKQU9FO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrcENBK0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2R0FHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O2tDQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7MEJBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztvQkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs2SkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFjRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0SEFHRTtBQUNGO0FBQ0E7QUFDQTs7O3VFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrSEFHRTtBQUNGO0FBQ0E7QUFDQTs7O3VFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dJQUdFO0FBQ0Y7QUFDQTtBQUNBOzs7dUVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQW1DRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyaUNBMEJFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7aURBZUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OzZGQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztrREFTRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQWtCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FMQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7MEJBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7eUVBV0U7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzR0FnQkU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OzBCQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzswQkFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lKQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Z0xBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0hBR0U7QUFDRjtBQUNBO0FBQ0E7OztnRkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzBXQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1hBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K1lBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K1lBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OzBCQU1FO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztrRUFXRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVlFO0FBQ0Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVlFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7K0VBU0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztxSkFVRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lLQVVFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7aUtBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzS0FHRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzttUEFNRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7V0FLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7a0tBb0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFjRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0F5Q0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBVUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7OzBCQUtFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7OzswQkFLRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZOQVFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MEJBT0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0LCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgSW5wdXQsIEl0ZXJhYmxlRGlmZmVycywgTE9DQUxFX0lELCBOZ01vZHVsZSwgTmdab25lLCBPcHRpb25hbCwgT3V0cHV0LCBQTEFURk9STV9JRCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2UsIFRlbXBsYXRlUmVmLCBUeXBlLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgVmlld0NvbnRhaW5lclJlZiwgZm9yd2FyZFJlZiwgaXNEZXZNb2RlLCDJtcm1ZGVmaW5lSW5qZWN0YWJsZSwgybXJtWluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUsIERPQ1VNRU5ULCBEYXRlUGlwZSwgRm9ybVN0eWxlLCBGb3JtYXRXaWR0aCwgTG9jYXRpb24sIFRyYW5zbGF0aW9uV2lkdGgsIGdldExvY2FsZURheU5hbWVzLCBnZXRMb2NhbGVGaXJzdERheU9mV2VlaywgZ2V0TG9jYWxlTW9udGhOYW1lcywgZ2V0TG9jYWxlVGltZUZvcm1hdCwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBFTVBUWSwgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgU3ViamVjdCwgY29tYmluZUxhdGVzdCwgZm9ya0pvaW4sIGZyb20sIGZyb21FdmVudCwgaW50ZXJ2YWwsIG1lcmdlLCBvZiwgdGltZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZGVsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIGZpbmFsaXplLCBtYXAsIHBhaXJ3aXNlLCByZWZDb3VudCwgcmVwZWF0LCBzaGFyZSwgc2tpcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbCwgdGFrZVdoaWxlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgTmF2aWdhdGlvbkVuZCwgUm91dGVyLCBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIsIEZvY3VzS2V5TWFuYWdlciwgRm9jdXNNb25pdG9yLCBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnksIEludGVyYWN0aXZpdHlDaGVja2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ2RrUG9ydGFsLCBDZGtQb3J0YWxPdXRsZXQsIENvbXBvbmVudFBvcnRhbCwgUG9ydGFsSW5qZWN0b3IsIFBvcnRhbE1vZHVsZSwgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IEJsb2NrU2Nyb2xsU3RyYXRlZ3ksIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgR2xvYmFsUG9zaXRpb25TdHJhdGVneSwgT3ZlcmxheSwgT3ZlcmxheUNvbnRhaW5lciwgT3ZlcmxheU1vZHVsZSwgT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgU2Nyb2xsRGlzcGF0Y2hlciwgU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLCBWaWV3cG9ydFJ1bGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IERvbVNhbml0aXplciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgYW5pbWF0ZSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgJ2ludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5pbXBvcnQgeyBCaWRpTW9kdWxlLCBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IENka0NlbGwsIENka0NlbGxEZWYsIENka0NlbGxPdXRsZXQsIENka0NvbHVtbkRlZiwgQ2RrRm9vdGVyQ2VsbCwgQ2RrRm9vdGVyQ2VsbERlZiwgQ2RrRm9vdGVyUm93LCBDZGtGb290ZXJSb3dEZWYsIENka0hlYWRlckNlbGwsIENka0hlYWRlckNlbGxEZWYsIENka0hlYWRlclJvdywgQ2RrSGVhZGVyUm93RGVmLCBDZGtSb3csIENka1Jvd0RlZiwgQ2RrVGFibGUsIENka1RhYmxlTW9kdWxlLCBEYXRhUm93T3V0bGV0LCBEYXRhU291cmNlLCBGb290ZXJSb3dPdXRsZXQsIEhlYWRlclJvd091dGxldCwgTm9EYXRhUm93T3V0bGV0LCBfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUiwgX0NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RhYmxlJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBfRGlzcG9zZVZpZXdSZXBlYXRlclN0cmF0ZWd5LCBfVklFV19SRVBFQVRFUl9TVFJBVEVHWSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgeyBCQUNLU1BBQ0UsIERFTEVURSwgRU5URVIsIEVTQ0FQRSwgU1BBQ0UgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0ICogYXMgX2FuZ3VsYXJfY2RrX2tleWNvZGVzIGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IE5CX1RIRU1FX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgVGhlbWUgT3B0aW9ucycpO1xuY29uc3QgTkJfTUVESUFfQlJFQUtQT0lOVFMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgTWVkaWEgQnJlYWtwb2ludHMnKTtcbmNvbnN0IE5CX0JVSUxUX0lOX0pTX1RIRU1FUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmVidWxhciBCdWlsdC1pbiBKUyBUaGVtZXMnKTtcbmNvbnN0IE5CX0pTX1RIRU1FUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmVidWxhciBKUyBUaGVtZXMnKTtcbi8qKlxuICogV2UncmUgcHJvdmlkaW5nIGJyb3dzZXIgYXBpcyB3aXRoIHRva2VucyB0byBpbXByb3ZlIHRlc3RpbmcgY2FwYWJpbGl0aWVzLlxuICogKi9cbmNvbnN0IE5CX1dJTkRPVyA9IG5ldyBJbmplY3Rpb25Ub2tlbignV2luZG93Jyk7XG5jb25zdCBOQl9ET0NVTUVOVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignRG9jdW1lbnQnKTtcblxuY29uc3QgcGFsZXR0ZSA9IHtcbiAgICBwcmltYXJ5OiAnIzMzNjZmZicsXG4gICAgc3VjY2VzczogJyMwMGQ2OGYnLFxuICAgIGluZm86ICcjMDA5NWZmJyxcbiAgICB3YXJuaW5nOiAnI2ZmYWEwMCcsXG4gICAgZGFuZ2VyOiAnI2ZmM2Q3MScsXG59O1xuY29uc3QgREVGQVVMVF9USEVNRSA9IHtcbiAgICBuYW1lOiAnZGVmYXVsdCcsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGZvbnRNYWluOiAnT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNlY29uZGFyeTogJ1JhbGV3YXksIHNhbnMtc2VyaWYnLFxuICAgICAgICBiZzogJyNmZmZmZmYnLFxuICAgICAgICBiZzI6ICcjZjdmOWZjJyxcbiAgICAgICAgYmczOiAnI2VkZjFmNycsXG4gICAgICAgIGJnNDogJyNlNGU5ZjInLFxuICAgICAgICBib3JkZXI6ICcjZmZmZmZmJyxcbiAgICAgICAgYm9yZGVyMjogJyNmN2Y5ZmMnLFxuICAgICAgICBib3JkZXIzOiAnI2VkZjFmNycsXG4gICAgICAgIGJvcmRlcjQ6ICcjZTRlOWYyJyxcbiAgICAgICAgYm9yZGVyNTogJyNjNWNlZTAnLFxuICAgICAgICBmZzogJyM4ZjliYjMnLFxuICAgICAgICBmZ0hlYWRpbmc6ICcjMWEyMTM4JyxcbiAgICAgICAgZmdUZXh0OiAnIzFhMjEzOCcsXG4gICAgICAgIGZnSGlnaGxpZ2h0OiBwYWxldHRlLnByaW1hcnksXG4gICAgICAgIGxheW91dEJnOiAnI2Y3ZjlmYycsXG4gICAgICAgIHNlcGFyYXRvcjogJyNlZGYxZjcnLFxuICAgICAgICBwcmltYXJ5OiBwYWxldHRlLnByaW1hcnksXG4gICAgICAgIHN1Y2Nlc3M6IHBhbGV0dGUuc3VjY2VzcyxcbiAgICAgICAgaW5mbzogcGFsZXR0ZS5pbmZvLFxuICAgICAgICB3YXJuaW5nOiBwYWxldHRlLndhcm5pbmcsXG4gICAgICAgIGRhbmdlcjogcGFsZXR0ZS5kYW5nZXIsXG4gICAgICAgIHByaW1hcnlMaWdodDogJyM1OThiZmYnLFxuICAgICAgICBzdWNjZXNzTGlnaHQ6ICcjMmNlNjliJyxcbiAgICAgICAgaW5mb0xpZ2h0OiAnIzQyYWFmZicsXG4gICAgICAgIHdhcm5pbmdMaWdodDogJyNmZmM5NGQnLFxuICAgICAgICBkYW5nZXJMaWdodDogJyNmZjcwOGQnLFxuICAgIH0sXG59O1xuXG5jb25zdCBwYWxldHRlJDEgPSB7XG4gICAgcHJpbWFyeTogJyNhMTZlZmYnLFxuICAgIHN1Y2Nlc3M6ICcjMDBkNjhmJyxcbiAgICBpbmZvOiAnIzAwOTVmZicsXG4gICAgd2FybmluZzogJyNmZmFhMDAnLFxuICAgIGRhbmdlcjogJyNmZjNkNzEnLFxufTtcbmNvbnN0IENPU01JQ19USEVNRSA9IHtcbiAgICBuYW1lOiAnY29zbWljJyxcbiAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgZm9udE1haW46ICdPcGVuIFNhbnMsIHNhbnMtc2VyaWYnLFxuICAgICAgICBmb250U2Vjb25kYXJ5OiAnUmFsZXdheSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGJnOiAnIzMyMzI1OScsXG4gICAgICAgIGJnMjogJyMyNTI1NDcnLFxuICAgICAgICBiZzM6ICcjMWIxYjM4JyxcbiAgICAgICAgYmc0OiAnIzEzMTMyYicsXG4gICAgICAgIGJvcmRlcjogJyMzMjMyNTknLFxuICAgICAgICBib3JkZXIyOiAnIzI1MjU0NycsXG4gICAgICAgIGJvcmRlcjM6ICcjMWIxYjM4JyxcbiAgICAgICAgYm9yZGVyNDogJyMxMzEzMmInLFxuICAgICAgICBib3JkZXI1OiAnIzEzMTMyYicsXG4gICAgICAgIGZnOiAnI2I0YjRkYicsXG4gICAgICAgIGZnSGVhZGluZzogJyNmZmZmZmYnLFxuICAgICAgICBmZ1RleHQ6ICcjZmZmZmZmJyxcbiAgICAgICAgZmdIaWdobGlnaHQ6IHBhbGV0dGUkMS5wcmltYXJ5LFxuICAgICAgICBsYXlvdXRCZzogJyMxNTFhMzAnLFxuICAgICAgICBzZXBhcmF0b3I6ICcjMTUxYTMwJyxcbiAgICAgICAgcHJpbWFyeTogcGFsZXR0ZSQxLnByaW1hcnksXG4gICAgICAgIHN1Y2Nlc3M6IHBhbGV0dGUkMS5zdWNjZXNzLFxuICAgICAgICBpbmZvOiBwYWxldHRlJDEuaW5mbyxcbiAgICAgICAgd2FybmluZzogcGFsZXR0ZSQxLndhcm5pbmcsXG4gICAgICAgIGRhbmdlcjogcGFsZXR0ZSQxLmRhbmdlcixcbiAgICAgICAgcHJpbWFyeUxpZ2h0OiAnI2IxOGFmZicsXG4gICAgICAgIHN1Y2Nlc3NMaWdodDogJyMyY2U2OWInLFxuICAgICAgICBpbmZvTGlnaHQ6ICcjNDJhYWZmJyxcbiAgICAgICAgd2FybmluZ0xpZ2h0OiAnI2ZmYzk0ZCcsXG4gICAgICAgIGRhbmdlckxpZ2h0OiAnI2ZmNzA4ZCcsXG4gICAgfSxcbn07XG5cbmNvbnN0IHBhbGV0dGUkMiA9IHtcbiAgICBwcmltYXJ5OiAnIzczYTFmZicsXG4gICAgc3VjY2VzczogJyM1ZGNmZTMnLFxuICAgIGluZm86ICcjYmE3ZmVjJyxcbiAgICB3YXJuaW5nOiAnI2ZmYTM2YicsXG4gICAgZGFuZ2VyOiAnI2ZmNmI4MycsXG59O1xuY29uc3QgQ09SUE9SQVRFX1RIRU1FID0ge1xuICAgIG5hbWU6ICdjb3Jwb3JhdGUnLFxuICAgIGJhc2U6ICdkZWZhdWx0JyxcbiAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgZm9udE1haW46ICdPcGVuIFNhbnMsIHNhbnMtc2VyaWYnLFxuICAgICAgICBmb250U2Vjb25kYXJ5OiAnUmFsZXdheSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJnMjogJyNmN2Y5ZmMnLFxuICAgICAgICBiZzM6ICcjZWRmMWY3JyxcbiAgICAgICAgYmc0OiAnI2U0ZTlmMicsXG4gICAgICAgIGJvcmRlcjogJyNmZmZmZmYnLFxuICAgICAgICBib3JkZXIyOiAnI2Y3ZjlmYycsXG4gICAgICAgIGJvcmRlcjM6ICcjZWRmMWY3JyxcbiAgICAgICAgYm9yZGVyNDogJyNlNGU5ZjInLFxuICAgICAgICBib3JkZXI1OiAnI2M1Y2VlMCcsXG4gICAgICAgIGZnOiAnIzhmOWJiMycsXG4gICAgICAgIGZnSGVhZGluZzogJyMxYTIxMzgnLFxuICAgICAgICBmZ1RleHQ6ICcjMWEyMTM4JyxcbiAgICAgICAgZmdIaWdobGlnaHQ6IHBhbGV0dGUkMi5wcmltYXJ5LFxuICAgICAgICBsYXlvdXRCZzogJyNmN2Y5ZmMnLFxuICAgICAgICBzZXBhcmF0b3I6ICcjZWRmMWY3JyxcbiAgICAgICAgcHJpbWFyeTogcGFsZXR0ZSQyLnByaW1hcnksXG4gICAgICAgIHN1Y2Nlc3M6IHBhbGV0dGUkMi5zdWNjZXNzLFxuICAgICAgICBpbmZvOiBwYWxldHRlJDIuaW5mbyxcbiAgICAgICAgd2FybmluZzogcGFsZXR0ZSQyLndhcm5pbmcsXG4gICAgICAgIGRhbmdlcjogcGFsZXR0ZSQyLmRhbmdlcixcbiAgICAgICAgcHJpbWFyeUxpZ2h0OiAnIzU5OGJmZicsXG4gICAgICAgIHN1Y2Nlc3NMaWdodDogJyMyY2U2OWInLFxuICAgICAgICBpbmZvTGlnaHQ6ICcjNDJhYWZmJyxcbiAgICAgICAgd2FybmluZ0xpZ2h0OiAnI2ZmYzk0ZCcsXG4gICAgICAgIGRhbmdlckxpZ2h0OiAnI2ZmNzA4ZCcsXG4gICAgfSxcbn07XG5cbmNvbnN0IHBhbGV0dGUkMyA9IHtcbiAgICBwcmltYXJ5OiAnIzMzNjZmZicsXG4gICAgc3VjY2VzczogJyMwMGQ2OGYnLFxuICAgIGluZm86ICcjMDA5NWZmJyxcbiAgICB3YXJuaW5nOiAnI2ZmYWEwMCcsXG4gICAgZGFuZ2VyOiAnI2ZmM2Q3MScsXG59O1xuY29uc3QgREFSS19USEVNRSA9IHtcbiAgICBuYW1lOiAnZGFyaycsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGZvbnRNYWluOiAnT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNlY29uZGFyeTogJ1JhbGV3YXksIHNhbnMtc2VyaWYnLFxuICAgICAgICBiZzogJyMyMjJiNDUnLFxuICAgICAgICBiZzI6ICcjMWEyMTM4JyxcbiAgICAgICAgYmczOiAnIzE1MWEzMCcsXG4gICAgICAgIGJnNDogJyMxMDE0MjYnLFxuICAgICAgICBib3JkZXI6ICcjMjIyYjQ1JyxcbiAgICAgICAgYm9yZGVyMjogJyMxYTIxMzgnLFxuICAgICAgICBib3JkZXIzOiAnIzE1MWEzMCcsXG4gICAgICAgIGJvcmRlcjQ6ICcjMTAxNDI2JyxcbiAgICAgICAgYm9yZGVyNTogJyMxMDE0MjYnLFxuICAgICAgICBmZzogJyM4ZjliYjMnLFxuICAgICAgICBmZ0hlYWRpbmc6ICcjZmZmZmZmJyxcbiAgICAgICAgZmdUZXh0OiAnI2ZmZmZmZicsXG4gICAgICAgIGZnSGlnaGxpZ2h0OiBwYWxldHRlJDMucHJpbWFyeSxcbiAgICAgICAgbGF5b3V0Qmc6ICcjMWIxYjM4JyxcbiAgICAgICAgc2VwYXJhdG9yOiAnIzFiMWIzOCcsXG4gICAgICAgIHByaW1hcnk6IHBhbGV0dGUkMy5wcmltYXJ5LFxuICAgICAgICBzdWNjZXNzOiBwYWxldHRlJDMuc3VjY2VzcyxcbiAgICAgICAgaW5mbzogcGFsZXR0ZSQzLmluZm8sXG4gICAgICAgIHdhcm5pbmc6IHBhbGV0dGUkMy53YXJuaW5nLFxuICAgICAgICBkYW5nZXI6IHBhbGV0dGUkMy5kYW5nZXIsXG4gICAgICAgIHByaW1hcnlMaWdodDogJyM1OThiZmYnLFxuICAgICAgICBzdWNjZXNzTGlnaHQ6ICcjMmNlNjliJyxcbiAgICAgICAgaW5mb0xpZ2h0OiAnIzQyYWFmZicsXG4gICAgICAgIHdhcm5pbmdMaWdodDogJyNmZmM5NGQnLFxuICAgICAgICBkYW5nZXJMaWdodDogJyNmZjcwOGQnLFxuICAgIH0sXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBCVUlMVF9JTl9USEVNRVMgPSBbXG4gICAgREVGQVVMVF9USEVNRSxcbiAgICBDT1NNSUNfVEhFTUUsXG4gICAgQ09SUE9SQVRFX1RIRU1FLFxuICAgIERBUktfVEhFTUUsXG5dO1xuLyoqXG4gKiBKcyBUaGVtZXMgcmVnaXN0cnkgLSBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEpTIHRoZW1lcycgdmFyaWFibGVzLlxuICogVXN1YWxseSBzaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseSwgYnV0IHRocm91Z2ggdGhlIE5iVGhlbWVTZXJ2aWNlIGNsYXNzIG1ldGhvZHMgKGdldEpzVGhlbWUpLlxuICovXG5jbGFzcyBOYkpTVGhlbWVzUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKGJ1aWx0SW5UaGVtZXMsIG5ld1RoZW1lcyA9IFtdKSB7XG4gICAgICAgIHRoaXMudGhlbWVzID0ge307XG4gICAgICAgIGNvbnN0IHRoZW1lcyA9IHRoaXMuY29tYmluZUJ5TmFtZXMobmV3VGhlbWVzLCBidWlsdEluVGhlbWVzKTtcbiAgICAgICAgdGhlbWVzLmZvckVhY2goKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHRoZW1lLCB0aGVtZS5uYW1lLCB0aGVtZS5iYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBKUyB0aGVtZVxuICAgICAqIEBwYXJhbSBjb25maWcgYW55XG4gICAgICogQHBhcmFtIHRoZW1lTmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gYmFzZVRoZW1lIHN0cmluZ1xuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbmZpZywgdGhlbWVOYW1lLCBiYXNlVGhlbWUpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuaGFzKGJhc2VUaGVtZSkgPyB0aGlzLmdldChiYXNlVGhlbWUpIDoge307XG4gICAgICAgIHRoaXMudGhlbWVzW3RoZW1lTmFtZV0gPSB0aGlzLm1lcmdlRGVlcCh7fSwgYmFzZSwgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHRoZW1lIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0gdGhlbWVOYW1lXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGhhcyh0aGVtZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy50aGVtZXNbdGhlbWVOYW1lXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdGhlbWVcbiAgICAgKiBAcGFyYW0gdGhlbWVOYW1lXG4gICAgICogQHJldHVybnMgTmJKU1RoZW1lT3B0aW9uc1xuICAgICAqL1xuICAgIGdldCh0aGVtZU5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRoZW1lc1t0aGVtZU5hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTmJUaGVtZUNvbmZpZzogbm8gdGhlbWUgJyR7dGhlbWVOYW1lfScgZm91bmQgcmVnaXN0ZXJlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnRoZW1lc1t0aGVtZU5hbWVdKSk7XG4gICAgfVxuICAgIGNvbWJpbmVCeU5hbWVzKG5ld1RoZW1lcywgb2xkVGhlbWVzKSB7XG4gICAgICAgIGlmIChuZXdUaGVtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFRoZW1lcyA9IFtdO1xuICAgICAgICAgICAgbmV3VGhlbWVzLmZvckVhY2goKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FtZU9sZCA9IG9sZFRoZW1lcy5maW5kKCh0bSkgPT4gdG0ubmFtZSA9PT0gdGhlbWUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkVGhlbWUgPSB0aGlzLm1lcmdlRGVlcCh7fSwgc2FtZU9sZCwgdGhlbWUpO1xuICAgICAgICAgICAgICAgIG1lcmdlZFRoZW1lcy5wdXNoKG1lcmdlZFRoZW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2xkVGhlbWVzLmZvckVhY2goKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXJnZWRUaGVtZXMuZmluZCgodG0pID0+IHRtLm5hbWUgPT09IHRoZW1lLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFRoZW1lcy5wdXNoKHRoZW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZWRUaGVtZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZFRoZW1lcztcbiAgICB9XG4gICAgaXNPYmplY3QoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG4gICAgfVxuICAgIC8vIFRPRE86IG1vdmUgdG8gaGVscGVyc1xuICAgIG1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHRhcmdldCkgJiYgdGhpcy5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHsgW2tleV06IHt9IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlRGVlcCh0YXJnZXQsIC4uLnNvdXJjZXMpO1xuICAgIH1cbn1cbk5iSlNUaGVtZXNSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJKU1RoZW1lc1JlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0JVSUxUX0lOX0pTX1RIRU1FUyxdIH1dIH0sXG4gICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfSlNfVEhFTUVTLF0gfV0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgREVGQVVMVF9NRURJQV9CUkVBS1BPSU5UUyA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICd4cycsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaXMnLFxuICAgICAgICB3aWR0aDogNDAwLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnc20nLFxuICAgICAgICB3aWR0aDogNTc2LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbWQnLFxuICAgICAgICB3aWR0aDogNzY4LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbGcnLFxuICAgICAgICB3aWR0aDogOTkyLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAneGwnLFxuICAgICAgICB3aWR0aDogMTIwMCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3h4bCcsXG4gICAgICAgIHdpZHRoOiAxNDAwLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAneHh4bCcsXG4gICAgICAgIHdpZHRoOiAxNjAwLFxuICAgIH0sXG5dO1xuLyoqXG4gKiBNYW5hZ2VzIG1lZGlhIGJyZWFrcG9pbnRzXG4gKlxuICogUHJvdmlkZXMgYWNjZXNzIHRvIGF2YWlsYWJsZSBtZWRpYSBicmVha3BvaW50cyB0byBjb252ZXJ0IHdpbmRvdyB3aWR0aCB0byBhIGNvbmZpZ3VyZWQgYnJlYWtwb2ludCxcbiAqIGUuZy4gMjAwcHggLSAqeHMqIGJyZWFrcG9pbnRcbiAqL1xuY2xhc3MgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYnJlYWtwb2ludHMpIHtcbiAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IGJyZWFrcG9pbnRzO1xuICAgICAgICB0aGlzLmJyZWFrcG9pbnRzTWFwID0gdGhpcy5icmVha3BvaW50cy5yZWR1Y2UoKHJlcywgYikgPT4ge1xuICAgICAgICAgICAgcmVzW2IubmFtZV0gPSBiLndpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29uZmlndXJlZCBicmVha3BvaW50IGJ5IHdpZHRoXG4gICAgICogQHBhcmFtIHdpZHRoIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtafHtuYW1lOiBzdHJpbmcsIHdpZHRoOiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldEJ5V2lkdGgod2lkdGgpIHtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IHsgbmFtZTogJ3Vua25vd24nLCB3aWR0aDogd2lkdGggfTtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSB0aGlzLmdldEJyZWFrcG9pbnRzKCk7XG4gICAgICAgIHJldHVybiBicmVha3BvaW50c1xuICAgICAgICAgICAgLmZpbmQoKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGJyZWFrcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPj0gcG9pbnQud2lkdGggJiYgKCFuZXh0IHx8IHdpZHRoIDwgbmV4dC53aWR0aCk7XG4gICAgICAgIH0pIHx8IHVua25vd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25maWd1cmVkIGJyZWFrcG9pbnQgYnkgbmFtZVxuICAgICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIE5iTWVkaWFCcmVha3BvaW50XG4gICAgICovXG4gICAgZ2V0QnlOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IHsgbmFtZTogJ3Vua25vd24nLCB3aWR0aDogTmFOIH07XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gdGhpcy5nZXRCcmVha3BvaW50cygpO1xuICAgICAgICByZXR1cm4gYnJlYWtwb2ludHMuZmluZCgocG9pbnQpID0+IG5hbWUgPT09IHBvaW50Lm5hbWUpIHx8IHVua25vd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbmZpZ3VyZWQgYnJlYWtwb2ludHMgZm9yIHRoZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIE5iTWVkaWFCcmVha3BvaW50W11cbiAgICAgKi9cbiAgICBnZXRCcmVha3BvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJlYWtwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgY29uZmlndXJlZCBicmVha3BvaW50cyBmb3IgdGhlIHRoZW1lXG4gICAgICogQHJldHVybnMge1twOiBzdHJpbmddOiBudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QnJlYWtwb2ludHNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRzTWFwO1xuICAgIH1cbn1cbk5iTWVkaWFCcmVha3BvaW50c1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iTWVkaWFCcmVha3BvaW50c1NlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX01FRElBX0JSRUFLUE9JTlRTLF0gfV0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBNYWluIE5lYnVsYXIgc2VydmljZS4gSW5jbHVkZXMgdmFyaW91cyBoZWxwZXIgbWV0aG9kcy5cbiAqL1xuY2xhc3MgTmJUaGVtZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGJyZWFrcG9pbnRTZXJ2aWNlLCBqc1RoZW1lc1JlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYnJlYWtwb2ludFNlcnZpY2UgPSBicmVha3BvaW50U2VydmljZTtcbiAgICAgICAgdGhpcy5qc1RoZW1lc1JlZ2lzdHJ5ID0ganNUaGVtZXNSZWdpc3RyeTtcbiAgICAgICAgdGhpcy50aGVtZUNoYW5nZXMkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIHRoaXMuYXBwZW5kTGF5b3V0Q2xhc3MkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzcyQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNoYW5nZVdpbmRvd1dpZHRoJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDIpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGhlbWUob3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY3VycmVudCBhcHBsaWNhdGlvbiB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgY2hhbmdlVGhlbWUobmFtZSkge1xuICAgICAgICB0aGlzLnRoZW1lQ2hhbmdlcyQubmV4dCh7IG5hbWUsIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRUaGVtZSB9KTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGhlbWUgPSBuYW1lO1xuICAgIH1cbiAgICBjaGFuZ2VXaW5kb3dXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLmNoYW5nZVdpbmRvd1dpZHRoJC5uZXh0KHdpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRoZW1lIG9iamVjdCB3aXRoIHZhcmlhYmxlcyAoY29sb3IvcGFkZGluZ3MvZXRjKSBvbiBhIHRoZW1lIGNoYW5nZS5cbiAgICAgKiBPbmNlIHN1YnNjcmliZWQgLSByZXR1cm5zIGN1cnJlbnQgdGhlbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxOYkpTVGhlbWVPcHRpb25zPn1cbiAgICAgKi9cbiAgICBnZXRKc1RoZW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblRoZW1lQ2hhbmdlKCkucGlwZShtYXAoKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qc1RoZW1lc1JlZ2lzdHJ5LmdldCh0aGVtZS5uYW1lKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBtZWRpYSBxdWVyeSBicmVha3BvaW50IGNoYW5nZVxuICAgICAqIFJldHVybnMgYSBwYWlyIHdoZXJlIHRoZSBmaXJzdCBpdGVtIGlzIHByZXZpb3VzIG1lZGlhIGJyZWFrcG9pbnQgYW5kIHRoZSBzZWNvbmQgaXRlbSBpcyBjdXJyZW50IGJyZWFrcG9pdC5cbiAgICAgKiBgYGB0c1xuICAgICAqICBbeyBuYW1lOiAneHMnLCB3aWR0aDogMCB9LCB7IG5hbWU6ICdtZCcsIHdpZHRoOiA3NjggfV0gLy8gY2hhbmdlIGZyb20gYHhzYCB0byBgbWRgXG4gICAgICogYGBgXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8W05iTWVkaWFCcmVha3BvaW50LCBOYk1lZGlhQnJlYWtwb2ludF0+fVxuICAgICAqL1xuICAgIG9uTWVkaWFRdWVyeUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlV2luZG93V2lkdGgkXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodW5kZWZpbmVkKSwgcGFpcndpc2UoKSwgbWFwKChbcHJldldpZHRoLCB3aWR0aF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3BvaW50U2VydmljZS5nZXRCeVdpZHRoKHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3BvaW50U2VydmljZS5nZXRCeVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLCBmaWx0ZXIoKFtwcmV2UG9pbnQsIHBvaW50XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZQb2ludC5uYW1lICE9PSBwb2ludC5uYW1lO1xuICAgICAgICB9KSwgZGlzdGluY3RVbnRpbENoYW5nZWQobnVsbCwgcGFyYW1zID0+IHBhcmFtc1swXS5uYW1lICsgcGFyYW1zWzFdLm5hbWUpLCBzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gY3VycmVudCB0aGVtZSBpcyBjaGFuZ2VkXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8YW55Pn1cbiAgICAgKi9cbiAgICBvblRoZW1lQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVtZUNoYW5nZXMkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIGNsYXNzIHRvIG5iLWxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBhcHBlbmRMYXlvdXRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRMYXlvdXRDbGFzcyQubmV4dChjbGFzc05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIG5ldyBjbGFzcyBpcyBhZGRlZCB0byBuYi1sYXlvdXQgdGhyb3VnaCBgYXBwZW5kTGF5b3V0Q2xhc3NgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25BcHBlbmRMYXlvdXRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kTGF5b3V0Q2xhc3MkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIG5iLWxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICByZW1vdmVMYXlvdXRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzcyQubmV4dChjbGFzc05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGNsYXNzIGlzIHJlbW92ZWQgZnJvbSBuYi1sYXlvdXQgdGhyb3VnaCBgcmVtb3ZlTGF5b3V0Q2xhc3NgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25SZW1vdmVMYXlvdXRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGF5b3V0Q2xhc3MkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxufVxuTmJUaGVtZVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iVGhlbWVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9USEVNRV9PUFRJT05TLF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iTWVkaWFCcmVha3BvaW50c1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iSlNUaGVtZXNSZWdpc3RyeSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFNlcnZpY2UgdG8gY29udHJvbCB0aGUgZ2xvYmFsIHBhZ2Ugc3Bpbm5lci5cbiAqL1xuY2xhc3MgTmJTcGlubmVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmxvYWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICduYi1nbG9iYWwtc3Bpbm5lcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgbmV3IGxvYWRlciB0byB0aGUgbGlzdCBvZiBsb2FkZXIgdG8gYmUgY29tcGxldGVkIGJlZm9yZVxuICAgICAqIHNwaW5uZXIgd2lsbCBiZSBoaWRkZW5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIFByb21pc2U8YW55PlxuICAgICAqL1xuICAgIHJlZ2lzdGVyTG9hZGVyKG1ldGhvZCkge1xuICAgICAgICB0aGlzLmxvYWRlcnMucHVzaChtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGxpc3Qgb2YgbG9hZGVyXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubG9hZGVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbG9hZGVyIHByb2Nlc3MsIHNob3cgc3Bpbm5kZXIgYW5kIGV4ZWN1dGUgbG9hZGVyc1xuICAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHRoaXMuc2hvd1NwaW5uZXIoKTtcbiAgICAgICAgdGhpcy5leGVjdXRlQWxsKCk7XG4gICAgfVxuICAgIGV4ZWN1dGVBbGwoZG9uZSA9ICgpID0+IHsgfSkge1xuICAgICAgICBQcm9taXNlLmFsbCh0aGlzLmxvYWRlcnMpLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlU3Bpbm5lcigpO1xuICAgICAgICAgICAgZG9uZS5jYWxsKG51bGwsIHZhbHVlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9taXNlLnJlamVjdFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPIGlzIHRoZXJlIGFueSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXM/XG4gICAgc2hvd1NwaW5uZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5nZXRTcGlubmVyRWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlWydkaXNwbGF5J10gPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGVTcGlubmVyKCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZ2V0U3Bpbm5lckVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBlbC5zdHlsZVsnZGlzcGxheSddID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNwaW5uZXJFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnNlbGVjdG9yKTtcbiAgICB9XG59XG5OYlNwaW5uZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYlNwaW5uZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ET0NVTUVOVCxdIH1dIH1cbl07XG5cbi8qKlxuICogTGF5b3V0IGRpcmVjdGlvbi5cbiAqICovXG52YXIgTmJMYXlvdXREaXJlY3Rpb247XG4oZnVuY3Rpb24gKE5iTGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgTmJMYXlvdXREaXJlY3Rpb25bXCJMVFJcIl0gPSBcImx0clwiO1xuICAgIE5iTGF5b3V0RGlyZWN0aW9uW1wiUlRMXCJdID0gXCJydGxcIjtcbn0pKE5iTGF5b3V0RGlyZWN0aW9uIHx8IChOYkxheW91dERpcmVjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogTGF5b3V0IGRpcmVjdGlvbiBzZXR0aW5nIGluamVjdGlvbiB0b2tlbi5cbiAqICovXG5jb25zdCBOQl9MQVlPVVRfRElSRUNUSU9OID0gbmV3IEluamVjdGlvblRva2VuKCdMYXlvdXQgZGlyZWN0aW9uJyk7XG4vKipcbiAqIExheW91dCBEaXJlY3Rpb24gU2VydmljZS5cbiAqIEFsbG93cyB0byBzZXQgb3IgZ2V0IGxheW91dCBkaXJlY3Rpb24gYW5kIGxpc3RlbiB0byBpdHMgY2hhbmdlc1xuICovXG5jbGFzcyBOYkxheW91dERpcmVjdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRpcmVjdGlvbiA9IE5iTGF5b3V0RGlyZWN0aW9uLkxUUikge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy4kZGlyZWN0aW9uQ2hhbmdlID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBsYXlvdXQgZGlyZWN0aW9uIHNldCB0byBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW4uXG4gICAgICogKi9cbiAgICBpc0x0cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYkxheW91dERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBsYXlvdXQgZGlyZWN0aW9uIHNldCB0byByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW4uXG4gICAgICogKi9cbiAgICBpc1J0bCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYkxheW91dERpcmVjdGlvbi5SVEw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBsYXlvdXQgZGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIE5iTGF5b3V0RGlyZWN0aW9uLlxuICAgICAqICovXG4gICAgZ2V0RGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgbGF5b3V0IGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSB7TmJMYXlvdXREaXJlY3Rpb259IGRpcmVjdGlvblxuICAgICAqL1xuICAgIHNldERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuJGRpcmVjdGlvbkNoYW5nZS5uZXh0KGRpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGRpcmVjdGlvbiB3YXMgY2hhbmdlZC5cbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPE5iTGF5b3V0RGlyZWN0aW9uPi5cbiAgICAgKi9cbiAgICBvbkRpcmVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGRpcmVjdGlvbkNoYW5nZS5waXBlKHNoYXJlKCkpO1xuICAgIH1cbn1cbk5iTGF5b3V0RGlyZWN0aW9uU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0xBWU9VVF9ESVJFQ1RJT04sXSB9XSB9XG5dO1xuXG4vKipcbiAqIExheW91dCBzY3JvbGwgc2VydmljZS4gUHJvdmlkZXMgaW5mb3JtYXRpb24gYWJvdXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sXG4gKiBhcyB3ZWxsIGFzIG1ldGhvZHMgdG8gdXBkYXRlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwuXG4gKlxuICogVGhlIHJlYXNvbiB3ZSBhZGRlZCB0aGlzIHNlcnZpY2UgaXMgdGhhdCBpbiBOZWJ1bGFyIHRoZXJlIGFyZSB0d28gc2Nyb2xsIG1vZGVzOlxuICogLSB0aGUgZGVmYXVsdCBtb2RlIHdoZW4gc2Nyb2xsIGlzIG9uIGJvZHlcbiAqIC0gYW5kIHRoZSBgd2l0aFNjcm9sbGAgbW9kZSwgd2hlbiBzY3JvbGwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBib2R5IGFuZCBtb3ZlZCB0byBhbiBlbGVtZW50IGluc2lkZSBvZiB0aGVcbiAqIGBuYi1sYXlvdXRgIGNvbXBvbmVudFxuICovXG5jbGFzcyBOYkxheW91dFNjcm9sbFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uUmVxJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubWFudWFsU2Nyb2xsJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNjcm9sbCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8TmJTY3JvbGxQb3NpdGlvbj59XG4gICAgICovXG4gICAgZ2V0UG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uUmVxJC5uZXh0KHsgbGlzdGVuZXIgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgc2Nyb2xsVG8oeCA9IG51bGwsIHkgPSBudWxsKSB7XG4gICAgICAgIHRoaXMubWFudWFsU2Nyb2xsJC5uZXh0KHsgeCwgeSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBzY3JvbGwgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxhbnk+fVxuICAgICAqL1xuICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGwkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTxOYlNjcm9sbFBvc2l0aW9uPi5cbiAgICAgKi9cbiAgICBvbk1hbnVhbFNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsU2Nyb2xsJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtTdWJqZWN0PGFueT59XG4gICAgICovXG4gICAgb25HZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25SZXEkO1xuICAgIH1cbiAgICBvblNjcm9sbGFibGVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGFibGUkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAgICovXG4gICAgZmlyZVNjcm9sbENoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNjcm9sbCQubmV4dChldmVudCk7XG4gICAgfVxuICAgIHNjcm9sbGFibGUoc2Nyb2xsYWJsZSkge1xuICAgICAgICB0aGlzLnNjcm9sbGFibGUkLm5leHQoc2Nyb2xsYWJsZSk7XG4gICAgfVxufVxuTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qKlxuICogU2ltcGxlIGhlbHBlciBzZXJ2aWNlIHRvIHJldHVybiBMYXlvdXQgZGltZW5zaW9uc1xuICogRGVwZW5kaW5nIG9mIGN1cnJlbnQgTGF5b3V0IHNjcm9sbCBtb2RlIChkZWZhdWx0IG9yIGB3aXRoU2Nyb2xsYCB3aGVuIHNjcm9sbCBpcyBtb3ZlZCB0byBhbiBlbGVtZW50XG4gKiBpbnNpZGUgb2YgdGhlIGxheW91dCkgY29ycmVzcG9uZGluZyBkaW1lbnNpb25zIHdpbGwgYmUgcmV0dXJucyAgLSBvZiBgZG9jdW1lbnRFbGVtZW50YCBpbiBmaXJzdCBjYXNlIGFuZFxuICogYC5zY3JvbGxhYmxlLWNvbnRhaW5lcmAgaW4gdGhlIHNlY29uZC5cbiAqL1xuY2xhc3MgTmJMYXlvdXRSdWxlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnREaW1lbnNpb25zUmVxJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPE5iTGF5b3V0RGltZW5zaW9ucz59XG4gICAgICovXG4gICAgZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgbGlzdGVuZXIuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERpbWVuc2lvbnNSZXEkLm5leHQoeyBsaXN0ZW5lciB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7U3ViamVjdDxhbnk+fVxuICAgICAqL1xuICAgIG9uR2V0RGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERpbWVuc2lvbnNSZXEkO1xuICAgIH1cbn1cbk5iTGF5b3V0UnVsZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iU2hhcmVkTW9kdWxlIHtcbn1cbk5iU2hhcmVkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgd2UgZG9uJ3QgbmVlZCBGb3Jtc01vZHVsZSBpbiBTaGFyZWRNb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIFJvdXRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogT3ZlcnJpZGVzIGFuZ3VsYXIgY2RrIGZvY3VzIHRyYXAgdG8ga2VlcCByZXN0b3JlIGZ1bmN0aW9uYWxpdHkgaW5zaWRlIHRyYXAuXG4gKiAqL1xuY2xhc3MgTmJGb2N1c1RyYXAgZXh0ZW5kcyBGb2N1c1RyYXAge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNoZWNrZXIsIG5nWm9uZSwgZG9jdW1lbnQsIGRlZmVyQW5jaG9ycykge1xuICAgICAgICBzdXBlcihlbGVtZW50LCBjaGVja2VyLCBuZ1pvbmUsIGRvY3VtZW50LCBkZWZlckFuY2hvcnMpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNoZWNrZXIgPSBjaGVja2VyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLnNhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgYmx1clByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBzYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG59XG5jbGFzcyBOYkZvY3VzVHJhcEZhY3RvcnlTZXJ2aWNlIGV4dGVuZHMgRm9jdXNUcmFwRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hlY2tlciwgbmdab25lLCBkb2N1bWVudCkge1xuICAgICAgICBzdXBlcihjaGVja2VyLCBuZ1pvbmUsIGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5jaGVja2VyID0gY2hlY2tlcjtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgY3JlYXRlKGVsZW1lbnQsIGRlZmVyQ2FwdHVyZUVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJGb2N1c1RyYXAoZWxlbWVudCwgdGhpcy5jaGVja2VyLCB0aGlzLm5nWm9uZSwgdGhpcy5kb2N1bWVudCwgZGVmZXJDYXB0dXJlRWxlbWVudHMpO1xuICAgIH1cbn1cbk5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJbnRlcmFjdGl2aXR5Q2hlY2tlciB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfVxuXTtcblxuY2xhc3MgTmJGb2N1c0tleU1hbmFnZXIgZXh0ZW5kcyBGb2N1c0tleU1hbmFnZXIge1xufVxuY2xhc3MgTmJGb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZSB7XG4gICAgY3JlYXRlKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJGb2N1c0tleU1hbmFnZXIoaXRlbXMpO1xuICAgIH1cbn1cblxuY2xhc3MgTmJBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBleHRlbmRzIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIHtcbn1cbmNsYXNzIE5iQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5U2VydmljZSB7XG4gICAgY3JlYXRlKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcihpdGVtcyk7XG4gICAgfVxufVxudmFyIE5iS2V5TWFuYWdlckFjdGl2ZUl0ZW1Nb2RlO1xuKGZ1bmN0aW9uIChOYktleU1hbmFnZXJBY3RpdmVJdGVtTW9kZSkge1xuICAgIE5iS2V5TWFuYWdlckFjdGl2ZUl0ZW1Nb2RlW05iS2V5TWFuYWdlckFjdGl2ZUl0ZW1Nb2RlW1wiUkVTRVRfQUNUSVZFXCJdID0gLTFdID0gXCJSRVNFVF9BQ1RJVkVcIjtcbiAgICBOYktleU1hbmFnZXJBY3RpdmVJdGVtTW9kZVtOYktleU1hbmFnZXJBY3RpdmVJdGVtTW9kZVtcIkZJUlNUX0FDVElWRVwiXSA9IDBdID0gXCJGSVJTVF9BQ1RJVkVcIjtcbn0pKE5iS2V5TWFuYWdlckFjdGl2ZUl0ZW1Nb2RlIHx8IChOYktleU1hbmFnZXJBY3RpdmVJdGVtTW9kZSA9IHt9KSk7XG5cbmNsYXNzIE5iRm9jdXNNb25pdG9yIGV4dGVuZHMgRm9jdXNNb25pdG9yIHtcbn1cbk5iRm9jdXNNb25pdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5jbGFzcyBOYkExMXlNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iQTExeU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJGb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZSxcbiAgICAgICAgICAgICAgICBOYkFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkZvY3VzTW9uaXRvciwgdXNlQ2xhc3M6IEZvY3VzTW9uaXRvciB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5OYkExMXlNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe30sXSB9XG5dO1xuXG5jbGFzcyBOYlBvcnRhbERpcmVjdGl2ZSBleHRlbmRzIENka1BvcnRhbCB7XG59XG5OYlBvcnRhbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuYlBvcnRhbF0nIH0sXSB9XG5dO1xuY2xhc3MgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBDZGtQb3J0YWxPdXRsZXQge1xufVxuTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmJQb3J0YWxPdXRsZXRdJyB9LF0gfVxuXTtcbmNsYXNzIE5iQ29tcG9uZW50UG9ydGFsIGV4dGVuZHMgQ29tcG9uZW50UG9ydGFsIHtcbn1cbmNsYXNzIE5iT3ZlcmxheSBleHRlbmRzIE92ZXJsYXkge1xufVxuTmJPdmVybGF5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5jbGFzcyBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgZXh0ZW5kcyBPdmVybGF5UG9zaXRpb25CdWlsZGVyIHtcbn1cbk5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuY2xhc3MgTmJUZW1wbGF0ZVBvcnRhbCBleHRlbmRzIFRlbXBsYXRlUG9ydGFsIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lclJlZiwgY29udGV4dCkge1xuICAgICAgICBzdXBlcih0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lclJlZiwgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTmJPdmVybGF5Q29udGFpbmVyIGV4dGVuZHMgT3ZlcmxheUNvbnRhaW5lciB7XG59XG5OYk92ZXJsYXlDb250YWluZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbmNsYXNzIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbn1cbmNsYXNzIE5iUG9ydGFsSW5qZWN0b3IgZXh0ZW5kcyBQb3J0YWxJbmplY3RvciB7XG59XG5jb25zdCBDREtfTU9EVUxFUyA9IFtPdmVybGF5TW9kdWxlLCBQb3J0YWxNb2R1bGVdO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBoZWxwcyB1cyB0byBrZWVwIGFsbCBhbmd1bGFyL2NkayBkZXBzIGluc2lkZSBvdXIgY2RrIG1vZHVsZSB2aWEgcHJvdmlkaW5nIGFsaWFzZXMuXG4gKiBBcHByb2FjaCB3aWxsIGhlbHAgdXMgbW92ZSBjZGsgaW4gc2VwYXJhdGUgbnBtIHBhY2thZ2UgYW5kIHJlZmFjdG9yIG5lYnVsYXIvdGhlbWUgY29kZS5cbiAqICovXG5jbGFzcyBOYkNka01hcHBpbmdNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iQ2RrTWFwcGluZ01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iT3ZlcmxheSxcbiAgICAgICAgICAgICAgICBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk5iQ2RrTWFwcGluZ01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogWy4uLkNES19NT0RVTEVTXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLkNES19NT0RVTEVTLFxuICAgICAgICAgICAgICAgICAgICBOYlBvcnRhbERpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlBvcnRhbERpcmVjdGl2ZSwgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmVdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbmNsYXNzIE5iUGxhdGZvcm0gZXh0ZW5kcyBQbGF0Zm9ybSB7XG59XG5OYlBsYXRmb3JtLsm1cHJvdiA9IMm1ybVkZWZpbmVJbmplY3RhYmxlKHsgZmFjdG9yeTogZnVuY3Rpb24gTmJQbGF0Zm9ybV9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IFBsYXRmb3JtKMm1ybVpbmplY3QoUExBVEZPUk1fSUQpKTsgfSwgdG9rZW46IE5iUGxhdGZvcm0sIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuTmJQbGF0Zm9ybS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgICAgICAgICAgdXNlQ2xhc3M6IFBsYXRmb3JtLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogUHJvdmlkZXMgbmItbGF5b3V0IGFzIG92ZXJsYXkgY29udGFpbmVyLlxuICogQ29udGFpbmVyIGhhcyB0byBiZSBjbGVhcmVkIHdoZW4gbGF5b3V0IGRlc3Ryb3lzLlxuICogQW5vdGhlciB3YXkgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgY29udGFpbmVyIHdpbGwgYmUgdXNlZFxuICogYnV0IGl0IGlzbid0IGluc2VydGVkIGluIERPTSBhbmQgZXhpc3RzIGluIG1lbW9yeSBvbmx5LlxuICogVGhpcyBjYXNlIGltcG9ydGFudCBvbmx5IGlmIHlvdSBzd2l0Y2ggYmV0d2VlbiBtdWx0aXBsZSBsYXlvdXRzLlxuICogKi9cbmNsYXNzIE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgZXh0ZW5kcyBOYk92ZXJsYXlDb250YWluZXIge1xuICAgIHNldENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGNsZWFyQ29udGFpbmVyKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBfY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LWNvbnRhaW5lcicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyO1xuICAgIH1cbn1cbk5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcblxuY2xhc3MgTmJWaWV3cG9ydFJ1bGVyQWRhcHRlciBleHRlbmRzIFZpZXdwb3J0UnVsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtLCBuZ1pvbmUsIHJ1bGVyLCBzY3JvbGwsIGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKHBsYXRmb3JtLCBuZ1pvbmUsIGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5ydWxlciA9IHJ1bGVyO1xuICAgICAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB9XG4gICAgZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICAvKlxuICAgICAgICAqIGdldERpbWVuc2lvbnMgY2FsbCBpcyByZWFsbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuICAgICAgICAqIEFuZCB3ZSBoYXZlIHRvIGNvbmZvcm0gd2l0aCB0aGUgaW50ZXJmYWNlIG9mIHRoZSBvcmlnaW5hbCBzZXJ2aWNlLlxuICAgICAgICAqICovXG4gICAgICAgIHRoaXMucnVsZXIuZ2V0RGltZW5zaW9ucygpXG4gICAgICAgICAgICAucGlwZShtYXAoZGltZW5zaW9ucyA9PiAoeyB3aWR0aDogZGltZW5zaW9ucy5jbGllbnRXaWR0aCwgaGVpZ2h0OiBkaW1lbnNpb25zLmNsaWVudEhlaWdodCB9KSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHJlY3QgPT4gcmVzID0gcmVjdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIC8qXG4gICAgICAgICogZ2V0UG9zaXRpb24gY2FsbCBpcyByZWFsbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuICAgICAgICAqIEFuZCB3ZSBoYXZlIHRvIGNvbmZvcm0gd2l0aCB0aGUgaW50ZXJmYWNlIG9mIHRoZSBvcmlnaW5hbCBzZXJ2aWNlLlxuICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2Nyb2xsLmdldFBvc2l0aW9uKClcbiAgICAgICAgICAgIC5waXBlKG1hcCgocG9zaXRpb24pID0+ICh7IHRvcDogcG9zaXRpb24ueSwgbGVmdDogcG9zaXRpb24ueCB9KSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHBvc2l0aW9uID0+IHJlcyA9IHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5OYlZpZXdwb3J0UnVsZXJBZGFwdGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYlZpZXdwb3J0UnVsZXJBZGFwdGVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJQbGF0Zm9ybSB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBOYkxheW91dFJ1bGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfVxuXTtcblxudmFyIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbikge1xuICAgIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uW1wiVE9QX1NUQVJUXCJdID0gXCJ0b3Atc3RhcnRcIjtcbiAgICBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbltcIlRPUF9FTkRcIl0gPSBcInRvcC1lbmRcIjtcbiAgICBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbltcIkJPVFRPTV9TVEFSVFwiXSA9IFwiYm90dG9tLXN0YXJ0XCI7XG4gICAgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb25bXCJCT1RUT01fRU5EXCJdID0gXCJib3R0b20tZW5kXCI7XG59KShOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbiB8fCAoTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24gPSB7fSkpO1xudmFyIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbjtcbihmdW5jdGlvbiAoTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uKSB7XG4gICAgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uW1wiVE9QX1JJR0hUXCJdID0gXCJ0b3AtcmlnaHRcIjtcbiAgICBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb25bXCJUT1BfTEVGVFwiXSA9IFwidG9wLWxlZnRcIjtcbiAgICBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb25bXCJCT1RUT01fUklHSFRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xuICAgIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbltcIkJPVFRPTV9MRUZUXCJdID0gXCJib3R0b20tbGVmdFwiO1xufSkoTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uIHx8IChOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24gPSB7fSkpO1xuY2xhc3MgTmJQb3NpdGlvbkhlbHBlciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uID0gbGF5b3V0RGlyZWN0aW9uO1xuICAgIH1cbiAgICB0b0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbikuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0RGlyZWN0aW9uLmlzTHRyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTG9naWNhbFBvc2l0aW9uV2hlbkx0cihwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0xvZ2ljYWxQb3NpdGlvbldoZW5SdGwocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUGh5c2ljYWxQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24pLmluY2x1ZGVzKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dERpcmVjdGlvbi5pc0x0cigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1BoeXNpY2FsUG9zaXRpb25XaGVuTHRyKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUGh5c2ljYWxQb3NpdGlvbldoZW5SdGwocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzVG9wUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgbG9naWNhbFBvc2l0aW9uID0gdGhpcy50b0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiBsb2dpY2FsUG9zaXRpb24gPT09IE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9FTkRcbiAgICAgICAgICAgIHx8IGxvZ2ljYWxQb3NpdGlvbiA9PT0gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUO1xuICAgIH1cbiAgICBpc1JpZ2h0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcGh5c2ljYWxQb3NpdGlvbiA9IHRoaXMudG9QaHlzaWNhbFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHBoeXNpY2FsUG9zaXRpb24gPT09IE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5UT1BfUklHSFRcbiAgICAgICAgICAgIHx8IHBoeXNpY2FsUG9zaXRpb24gPT09IE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fUklHSFQ7XG4gICAgfVxuICAgIHRvTG9naWNhbFBvc2l0aW9uV2hlbkx0cihwb3NpdGlvbikge1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5UT1BfUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9FTkQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5UT1BfTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uQk9UVE9NX1JJR0hUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fRU5EO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uQk9UVE9NX0xFRlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9TVEFSVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0xvZ2ljYWxQb3NpdGlvbldoZW5SdGwocG9zaXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX1JJR0hUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfU1RBUlQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5UT1BfTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uQk9UVE9NX1NUQVJUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uQk9UVE9NX0xFRlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9FTkQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9QaHlzaWNhbFBvc2l0aW9uV2hlbkx0cihwb3NpdGlvbikge1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9TVEFSVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLlRPUF9MRUZUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfRU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX1JJR0hUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fU1RBUlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fTEVGVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uQk9UVE9NX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9SSUdIVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1BoeXNpY2FsUG9zaXRpb25XaGVuUnRsKHBvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX1JJR0hUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfRU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX0xFRlQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9TVEFSVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9SSUdIVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uQk9UVE9NX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9MRUZUO1xuICAgICAgICB9XG4gICAgfVxufVxuTmJQb3NpdGlvbkhlbHBlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJQb3NpdGlvbkhlbHBlci5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSB9XG5dO1xuXG52YXIgTmJBZGp1c3RtZW50O1xuKGZ1bmN0aW9uIChOYkFkanVzdG1lbnQpIHtcbiAgICBOYkFkanVzdG1lbnRbXCJOT09QXCJdID0gXCJub29wXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiQ0xPQ0tXSVNFXCJdID0gXCJjbG9ja3dpc2VcIjtcbiAgICBOYkFkanVzdG1lbnRbXCJDT1VOVEVSQ0xPQ0tXSVNFXCJdID0gXCJjb3VudGVyY2xvY2t3aXNlXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiVkVSVElDQUxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiSE9SSVpPTlRBTFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoTmJBZGp1c3RtZW50IHx8IChOYkFkanVzdG1lbnQgPSB7fSkpO1xudmFyIE5iUG9zaXRpb247XG4oZnVuY3Rpb24gKE5iUG9zaXRpb24pIHtcbiAgICBOYlBvc2l0aW9uW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgICBOYlBvc2l0aW9uW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgICBOYlBvc2l0aW9uW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICAgIE5iUG9zaXRpb25bXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRcIl0gPSBcInN0YXJ0XCI7XG4gICAgTmJQb3NpdGlvbltcIkVORFwiXSA9IFwiZW5kXCI7XG4gICAgTmJQb3NpdGlvbltcIlRPUF9FTkRcIl0gPSBcInRvcC1lbmRcIjtcbiAgICBOYlBvc2l0aW9uW1wiVE9QX1NUQVJUXCJdID0gXCJ0b3Atc3RhcnRcIjtcbiAgICBOYlBvc2l0aW9uW1wiQk9UVE9NX0VORFwiXSA9IFwiYm90dG9tLWVuZFwiO1xuICAgIE5iUG9zaXRpb25bXCJCT1RUT01fU1RBUlRcIl0gPSBcImJvdHRvbS1zdGFydFwiO1xuICAgIE5iUG9zaXRpb25bXCJFTkRfVE9QXCJdID0gXCJlbmQtdG9wXCI7XG4gICAgTmJQb3NpdGlvbltcIkVORF9CT1RUT01cIl0gPSBcImVuZC1ib3R0b21cIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRfVE9QXCJdID0gXCJzdGFydC10b3BcIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRfQk9UVE9NXCJdID0gXCJzdGFydC1ib3R0b21cIjtcbn0pKE5iUG9zaXRpb24gfHwgKE5iUG9zaXRpb24gPSB7fSkpO1xuY29uc3QgUE9TSVRJT05TID0ge1xuICAgIFtOYlBvc2l0aW9uLlJJR0hUXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdjZW50ZXInLCBvZmZzZXRYOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLkJPVFRPTV0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcsIG9mZnNldFk6IG9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uTEVGVF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJywgb2Zmc2V0WDogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uVE9QXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6ICd0b3AnLCBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WTogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uU1RBUlRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpc1tOYlBvc2l0aW9uLkxFRlRdKG9mZnNldCk7XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5FTkRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpc1tOYlBvc2l0aW9uLlJJR0hUXShvZmZzZXQpO1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uRU5EX1RPUF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WDogb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5FTkRfQk9UVE9NXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICd0b3AnLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRYOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdlbmQnLCBvdmVybGF5WTogJ3RvcCcsIG9mZnNldFk6IG9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uQk9UVE9NX0VORF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRZOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLlNUQVJUX1RPUF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WDogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uU1RBUlRfQk9UVE9NXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRYOiAtb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5UT1BfU1RBUlRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdib3R0b20nLCBvZmZzZXRZOiAtb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5UT1BfRU5EXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScsIG9mZnNldFk6IC1vZmZzZXQgfTtcbiAgICB9LFxufTtcbmNvbnN0IENPVU5URVJfQ0xPQ0tXSVNFX1BPU0lUSU9OUyA9IFtcbiAgICBOYlBvc2l0aW9uLlRPUCxcbiAgICBOYlBvc2l0aW9uLlRPUF9FTkQsXG4gICAgTmJQb3NpdGlvbi5UT1BfU1RBUlQsXG4gICAgTmJQb3NpdGlvbi5TVEFSVCxcbiAgICBOYlBvc2l0aW9uLlNUQVJUX1RPUCxcbiAgICBOYlBvc2l0aW9uLlNUQVJUX0JPVFRPTSxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTSxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVCxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9FTkQsXG4gICAgTmJQb3NpdGlvbi5FTkQsXG4gICAgTmJQb3NpdGlvbi5FTkRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uRU5EX1RPUCxcbl07XG5jb25zdCBDTE9DS1dJU0VfUE9TSVRJT05TID0gW1xuICAgIE5iUG9zaXRpb24uVE9QLFxuICAgIE5iUG9zaXRpb24uVE9QX1NUQVJULFxuICAgIE5iUG9zaXRpb24uVE9QX0VORCxcbiAgICBOYlBvc2l0aW9uLkVORCxcbiAgICBOYlBvc2l0aW9uLkVORF9UT1AsXG4gICAgTmJQb3NpdGlvbi5FTkRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uQk9UVE9NX0VORCxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVCxcbiAgICBOYlBvc2l0aW9uLlNUQVJULFxuICAgIE5iUG9zaXRpb24uU1RBUlRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uU1RBUlRfVE9QLFxuXTtcbmNvbnN0IFZFUlRJQ0FMX1BPU0lUSU9OUyA9IFtOYlBvc2l0aW9uLkJPVFRPTSwgTmJQb3NpdGlvbi5UT1BdO1xuY29uc3QgSE9SSVpPTlRBTF9QT1NJVElPTlMgPSBbTmJQb3NpdGlvbi5TVEFSVCwgTmJQb3NpdGlvbi5FTkRdO1xuZnVuY3Rpb24gY29tcGFyZVBvc2l0aW9ucyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEub3JpZ2luWCA9PT0gcDIub3JpZ2luWFxuICAgICAgICAmJiBwMS5vcmlnaW5ZID09PSBwMi5vcmlnaW5ZXG4gICAgICAgICYmIHAxLm92ZXJsYXlYID09PSBwMi5vdmVybGF5WFxuICAgICAgICAmJiBwMS5vdmVybGF5WSA9PT0gcDIub3ZlcmxheVk7XG59XG4vKipcbiAqIFRoZSBtYWluIGlkZWEgb2YgdGhlIGFkanVzdGFibGUgY29ubmVjdGVkIHN0cmF0ZWd5IGlzIHRvIHByb3ZpZGUgcHJlZGVmaW5lZCBzZXQgb2YgcG9zaXRpb25zIGZvciB5b3VyIG92ZXJsYXkuXG4gKiBZb3UgaGF2ZSB0byBwcm92aWRlIGFkanVzdG1lbnQgYW5kIGFwcHJvcHJpYXRlIHN0cmF0ZWd5IHdpbGwgYmUgY2hvc2VuIGluIHJ1bnRpbWUuXG4gKiAqL1xuY2xhc3MgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMTU7XG4gICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2UgPSB0aGlzLnBvc2l0aW9uQ2hhbmdlcy5waXBlKG1hcCgocG9zaXRpb25DaGFuZ2UpID0+IHBvc2l0aW9uQ2hhbmdlLmNvbm5lY3Rpb25QYWlyKSwgbWFwKChjb25uZWN0aW9uUGFpcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGllZFBvc2l0aW9ucy5maW5kKCh7IGNvbm5lY3RlZFBvc2l0aW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvc2l0aW9ucyhjb25uZWN0ZWRQb3NpdGlvbiwgY29ubmVjdGlvblBhaXIpO1xuICAgICAgICAgICAgfSkua2V5O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGF0dGFjaChvdmVybGF5UmVmKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBoYXZlIHRvIGFwcGx5IHBvc2l0aW9ucyBiZWZvcmUgYXR0YWNoIGJlY2F1c2Ugc3VwZXIuYXR0YWNoKCkgdmFsaWRhdGVzIHBvc2l0aW9ucyBhbmQgY3Jhc2hlcyBhcHBcbiAgICAgICAgICogaWYgbm8gcG9zaXRpb25zIHByb3ZpZGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb25zKCk7XG4gICAgICAgIHN1cGVyLmF0dGFjaChvdmVybGF5UmVmKTtcbiAgICB9XG4gICAgYXBwbHkoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbnMoKTtcbiAgICAgICAgc3VwZXIuYXBwbHkoKTtcbiAgICB9XG4gICAgcG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkanVzdG1lbnQoYWRqdXN0bWVudCkge1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gYWRqdXN0bWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXBwbHlQb3NpdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuY3JlYXRlUG9zaXRpb25zKCk7XG4gICAgICAgIHRoaXMucGVyc2lzdENob3NlblBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLndpdGhQb3NpdGlvbnModGhpcy5hcHBsaWVkUG9zaXRpb25zLm1hcCgoeyBjb25uZWN0ZWRQb3NpdGlvbiB9KSA9PiBjb25uZWN0ZWRQb3NpdGlvbikpO1xuICAgIH1cbiAgICBjcmVhdGVQb3NpdGlvbnMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWRqdXN0bWVudCkge1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuTk9PUDpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuX3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGNhc2UgTmJBZGp1c3RtZW50LkNMT0NLV0lTRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKENMT0NLV0lTRV9QT1NJVElPTlMpO1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKENPVU5URVJfQ0xPQ0tXSVNFX1BPU0lUSU9OUyk7XG4gICAgICAgICAgICBjYXNlIE5iQWRqdXN0bWVudC5IT1JJWk9OVEFMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlb3JkZXJQcmVmZXJyZWRQb3NpdGlvbnMoSE9SSVpPTlRBTF9QT1NJVElPTlMpO1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuVkVSVElDQUw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVvcmRlclByZWZlcnJlZFBvc2l0aW9ucyhWRVJUSUNBTF9QT1NJVElPTlMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlcnNpc3RDaG9zZW5Qb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMuYXBwbGllZFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5tYXAocG9zaXRpb24gPT4gKHtcbiAgICAgICAgICAgIGtleTogcG9zaXRpb24sXG4gICAgICAgICAgICBjb25uZWN0ZWRQb3NpdGlvbjogUE9TSVRJT05TW3Bvc2l0aW9uXSh0aGlzLl9vZmZzZXQpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlb3JkZXJQcmVmZXJyZWRQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICAgIC8vIFBoeXNpY2FsIHBvc2l0aW9ucyBzaG91bGQgYmUgbWFwcGVkIHRvIGxvZ2ljYWwgYXMgYWRqdXN0bWVudHMgdXNlIGxvZ2ljYWwgcG9zaXRpb25zLlxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uSW5kZXggPSBwb3NpdGlvbnMuaW5kZXhPZih0aGlzLm1hcFRvTG9naWNhbFBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBvc2l0aW9ucy5zbGljZShzdGFydFBvc2l0aW9uSW5kZXgpO1xuICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gcG9zaXRpb25zLnNsaWNlKDAsIHN0YXJ0UG9zaXRpb25JbmRleCk7XG4gICAgICAgIHJldHVybiBmaXJzdFBhcnQuY29uY2F0KHNlY29uZFBhcnQpO1xuICAgIH1cbiAgICBtYXBUb0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IE5iUG9zaXRpb24uTEVGVCkge1xuICAgICAgICAgICAgcmV0dXJuIE5iUG9zaXRpb24uU1RBUlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBOYlBvc2l0aW9uLlJJR0hUKSB7XG4gICAgICAgICAgICByZXR1cm4gTmJQb3NpdGlvbi5FTkQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbn1cbmNsYXNzIE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcCgpLmxlZnQoKTtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b3AoKS5yaWdodCgpO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fU1RBUlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tKCkubGVmdCgpO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fRU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSgpLnJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCB2aWV3cG9ydFJ1bGVyLCBwbGF0Zm9ybSwgcG9zaXRpb25CdWlsZGVyLCBvdmVybGF5Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy52aWV3cG9ydFJ1bGVyID0gdmlld3BvcnRSdWxlcjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQnVpbGRlciA9IHBvc2l0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyID0gb3ZlcmxheUNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2xvYmFsKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIH1cbiAgICBjb25uZWN0ZWRUbyhlbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneShlbGVtZW50UmVmLCB0aGlzLnZpZXdwb3J0UnVsZXIsIHRoaXMuZG9jdW1lbnQsIHRoaXMucGxhdGZvcm0sIHRoaXMub3ZlcmxheUNvbnRhaW5lcilcbiAgICAgICAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgICAgICAgLndpdGhQdXNoKGZhbHNlKTtcbiAgICB9XG59XG5OYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iUG9zaXRpb25CdWlsZGVyU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfRE9DVU1FTlQsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJWaWV3cG9ydFJ1bGVyQWRhcHRlciB9LFxuICAgIHsgdHlwZTogTmJQbGF0Zm9ybSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyIH0sXG4gICAgeyB0eXBlOiBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyIH1cbl07XG5cbmNsYXNzIE5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uVE9QO1xuICAgIH1cbiAgICBnZXQgdG9wU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLlRPUF9TVEFSVDtcbiAgICB9XG4gICAgZ2V0IHRvcEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uVE9QX0VORDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5SSUdIVCB8fCB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkVORDtcbiAgICB9XG4gICAgZ2V0IGVuZFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uRU5EX1RPUDtcbiAgICB9XG4gICAgZ2V0IGVuZEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uRU5EX0JPVFRPTTtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uQk9UVE9NO1xuICAgIH1cbiAgICBnZXQgYm90dG9tU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVDtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uQk9UVE9NX0VORDtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkxFRlQgfHwgdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5TVEFSVDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5TVEFSVF9UT1A7XG4gICAgfVxuICAgIGdldCBzdGFydEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uU1RBUlRfQk9UVE9NO1xuICAgIH1cbn1cbk5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlBvc2l0aW9uZWRDb250YWluZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgcG9zaXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS10b3AnLF0gfV0sXG4gICAgdG9wU3RhcnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLW92ZXJsYXktdG9wLXN0YXJ0JyxdIH1dLFxuICAgIHRvcEVuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS10b3AtZW5kJyxdIH1dLFxuICAgIHJpZ2h0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5uYi1vdmVybGF5LXJpZ2h0JyxdIH1dLFxuICAgIGVuZFRvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS1lbmQtdG9wJyxdIH1dLFxuICAgIGVuZEJvdHRvbTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS1lbmQtYm90dG9tJyxdIH1dLFxuICAgIGJvdHRvbTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS1ib3R0b20nLF0gfV0sXG4gICAgYm90dG9tU3RhcnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLW92ZXJsYXktYm90dG9tLXN0YXJ0JyxdIH1dLFxuICAgIGJvdHRvbUVuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS1ib3R0b20tZW5kJyxdIH1dLFxuICAgIGxlZnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLW92ZXJsYXktbGVmdCcsXSB9XSxcbiAgICBzdGFydFRvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItb3ZlcmxheS1zdGFydC10b3AnLF0gfV0sXG4gICAgc3RhcnRCb3R0b206IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLW92ZXJsYXktc3RhcnQtYm90dG9tJyxdIH1dXG59O1xuY2xhc3MgTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2Y3IsIGluamVjdG9yLCBjaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLnZjciA9IHZjcjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaXNTdHJpbmdDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIGF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwsIGNvbnRleHQpIHtcbiAgICAgICAgcG9ydGFsLmluamVjdG9yID0gdGhpcy5jcmVhdGVDaGlsZEluamVjdG9yKHBvcnRhbC5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLnBvcnRhbE91dGxldC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29tcG9uZW50UmVmLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfVxuICAgIGF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVJlZiA9IHRoaXMucG9ydGFsT3V0bGV0LmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIHRlbXBsYXRlUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBhdHRhY2hTdHJpbmdDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9ydGFsT3V0bGV0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsT3V0bGV0LmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0YWNoU3RyaW5nQ29udGVudChudWxsKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkSW5qZWN0b3IoY2ZyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJQb3J0YWxJbmplY3Rvcih0aGlzLmluamVjdG9yLCBuZXcgV2Vha01hcChbXG4gICAgICAgICAgICBbQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBjZnJdLFxuICAgICAgICBdKSk7XG4gICAgfVxufVxuTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1vdmVybGF5LWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2ICpuZ0lmPVwiaXNTdHJpbmdDb250ZW50XCIgY2xhc3M9XCJwcmltaXRpdmUtb3ZlcmxheVwiPnt7IGNvbnRlbnQgfX08L2Rpdj5cbiAgICA8bmctdGVtcGxhdGUgbmJQb3J0YWxPdXRsZXQ+PC9uZy10ZW1wbGF0ZT5cbiAgYFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYk92ZXJsYXlDb250YWluZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmIH0sXG4gICAgeyB0eXBlOiBJbmplY3RvciB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBwb3J0YWxPdXRsZXQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iUG9ydGFsT3V0bGV0RGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV1cbn07XG5cbmZ1bmN0aW9uIHBhdGNoKGNvbnRhaW5lciwgY29udGFpbmVyQ29udGV4dCkge1xuICAgIE9iamVjdC5hc3NpZ24oY29udGFpbmVyLmluc3RhbmNlLCBjb250YWluZXJDb250ZXh0KTtcbiAgICBjb250YWluZXIuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIHJldHVybiBjb250YWluZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocmVmLCBjb250YWluZXIsIGNvbnRleHQsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHJlZi5hdHRhY2gobmV3IE5iQ29tcG9uZW50UG9ydGFsKGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSk7XG4gICAgcGF0Y2goY29udGFpbmVyUmVmLCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGFpbmVyUmVmO1xufVxuY2xhc3MgTmJPdmVybGF5U2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheSwgbGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uID0gbGF5b3V0RGlyZWN0aW9uO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsU3RyYXRlZ2llcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzO1xuICAgIH1cbiAgICBjcmVhdGUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGlyID0+IG92ZXJsYXlSZWYuc2V0RGlyZWN0aW9uKGRpcikpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheVJlZjtcbiAgICB9XG59XG5OYk92ZXJsYXlTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYk92ZXJsYXlTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJPdmVybGF5IH0sXG4gICAgeyB0eXBlOiBOYkxheW91dERpcmVjdGlvblNlcnZpY2UgfVxuXTtcblxuY2xhc3MgTmJTY3JvbGxEaXNwYXRjaGVyQWRhcHRlciBleHRlbmRzIFNjcm9sbERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSwgcGxhdGZvcm0sIHNjcm9sbFNlcnZpY2UsIGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKG5nWm9uZSwgcGxhdGZvcm0sIGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICB9XG4gICAgc2Nyb2xsZWQoYXVkaXRUaW1lSW5Ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxTZXJ2aWNlLm9uU2Nyb2xsKCk7XG4gICAgfVxufVxuTmJTY3JvbGxEaXNwYXRjaGVyQWRhcHRlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJTY3JvbGxEaXNwYXRjaGVyQWRhcHRlci5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJQbGF0Zm9ybSB9LFxuICAgIHsgdHlwZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfVxuXTtcblxuLyoqXG4gKiBPdmVycmlkZXMgZGVmYXVsdCBibG9jayBzY3JvbGwgc3RyYXRlZ3kgYmVjYXVzZSBkZWZhdWx0IHN0cmF0ZWd5IGJsb2NrcyBzY3JvbGxpbmcgb24gdGhlIGJvZHkgb25seS5cbiAqIEJ1dCBOZWJ1bGFyIGhhcyBpdHMgb3duIHNjcm9sbGFibGUgY29udGFpbmVyIC0gbmItbGF5b3V0LiBTbywgd2UgbmVlZCB0byBibG9jayBzY3JvbGxpbmcgaW4gaXQgdG8uXG4gKiAqL1xuY2xhc3MgTmJCbG9ja1Njcm9sbFN0cmF0ZWd5QWRhcHRlciBleHRlbmRzIEJsb2NrU2Nyb2xsU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCB2aWV3cG9ydFJ1bGVyLCBzY3JvbGxTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHZpZXdwb3J0UnVsZXIsIGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICBzdXBlci5lbmFibGUoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlLnNjcm9sbGFibGUoZmFsc2UpO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICBzdXBlci5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5zY3JvbGxhYmxlKHRydWUpO1xuICAgIH1cbn1cbk5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iVmlld3BvcnRSdWxlckFkYXB0ZXIgfSxcbiAgICB7IHR5cGU6IE5iTGF5b3V0U2Nyb2xsU2VydmljZSB9XG5dO1xuY2xhc3MgTmJTY3JvbGxTdHJhdGVneU9wdGlvbnMgZXh0ZW5kcyBTY3JvbGxTdHJhdGVneU9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKHNjcm9sbFNlcnZpY2UsIHNjcm9sbERpc3BhdGNoZXIsIHZpZXdwb3J0UnVsZXIsIG5nWm9uZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIoc2Nyb2xsRGlzcGF0Y2hlciwgdmlld3BvcnRSdWxlciwgbmdab25lLCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZSA9IHNjcm9sbFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzcGF0Y2hlciA9IHNjcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMudmlld3BvcnRSdWxlciA9IHZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSAoKSA9PiBuZXcgTmJCbG9ja1Njcm9sbFN0cmF0ZWd5QWRhcHRlcih0aGlzLmRvY3VtZW50LCB0aGlzLnZpZXdwb3J0UnVsZXIsIHRoaXMuc2Nyb2xsU2VydmljZSk7XG4gICAgfVxufVxuTmJTY3JvbGxTdHJhdGVneU9wdGlvbnMuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyIH0sXG4gICAgeyB0eXBlOiBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfRE9DVU1FTlQsXSB9XSB9XG5dO1xuXG5jbGFzcyBOYkNka0FkYXB0ZXJNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iQ2RrQWRhcHRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlcixcbiAgICAgICAgICAgICAgICBOYkJsb2NrU2Nyb2xsU3RyYXRlZ3lBZGFwdGVyLFxuICAgICAgICAgICAgICAgIE5iU2Nyb2xsRGlzcGF0Y2hlckFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgTmJTY3JvbGxTdHJhdGVneU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBPdmVybGF5Q29udGFpbmVyLCB1c2VFeGlzdGluZzogTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlciB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTmJPdmVybGF5Q29udGFpbmVyLCB1c2VFeGlzdGluZzogTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlciB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogU2Nyb2xsRGlzcGF0Y2hlciwgdXNlRXhpc3Rpbmc6IE5iU2Nyb2xsRGlzcGF0Y2hlckFkYXB0ZXIgfSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFNjcm9sbFN0cmF0ZWd5T3B0aW9ucywgdXNlRXhpc3Rpbmc6IE5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk5iQ2RrQWRhcHRlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7fSxdIH1cbl07XG5cbnZhciBOYlRyaWdnZXI7XG4oZnVuY3Rpb24gKE5iVHJpZ2dlcikge1xuICAgIE5iVHJpZ2dlcltcIk5PT1BcIl0gPSBcIm5vb3BcIjtcbiAgICBOYlRyaWdnZXJbXCJDTElDS1wiXSA9IFwiY2xpY2tcIjtcbiAgICBOYlRyaWdnZXJbXCJIT1ZFUlwiXSA9IFwiaG92ZXJcIjtcbiAgICBOYlRyaWdnZXJbXCJISU5UXCJdID0gXCJoaW50XCI7XG4gICAgTmJUcmlnZ2VyW1wiRk9DVVNcIl0gPSBcImZvY3VzXCI7XG59KShOYlRyaWdnZXIgfHwgKE5iVHJpZ2dlciA9IHt9KSk7XG4vKipcbiAqIFRPRE8gbWF5YmUgd2UgaGF2ZSB0byB1c2UgcmVuZGVyZXIubGlzdGVuIGluc3RlYWQgb2Ygb2JzZXJ2YWJsZUZyb21FdmVudD9cbiAqIFJlbmRlcmVyIHByb3ZpZGVzIGNhcGFiaWxpdHkgdXNlIGl0IGluIHNlcnZpY2Ugd29ya2VyLCBzc3IgYW5kIHNvIG9uLlxuICogKi9cbmNsYXNzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGhvc3QsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCQubmV4dCgpO1xuICAgIH1cbiAgICBpc05vdE9uSG9zdE9yQ29udGFpbmVyKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc09uSG9zdChldmVudCkgJiYgIXRoaXMuaXNPbkNvbnRhaW5lcihldmVudCk7XG4gICAgfVxuICAgIGlzT25Ib3N0T3JDb250YWluZXIoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPbkhvc3QoZXZlbnQpIHx8IHRoaXMuaXNPbkNvbnRhaW5lcihldmVudCk7XG4gICAgfVxuICAgIGlzT25Ib3N0KHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5jb250YWlucyh0YXJnZXQpO1xuICAgIH1cbiAgICBpc09uQ29udGFpbmVyKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyKCkgJiYgdGhpcy5jb250YWluZXIoKS5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHNob3cgYW5kIGhpZGUgZXZlbnQgc3RyZWFtcy5cbiAqIEZpcmVzIHRvZ2dsZSBldmVudCB3aGVuIHRoZSBjbGljayB3YXMgcGVyZm9ybWVkIG9uIHRoZSBob3N0IGVsZW1lbnQuXG4gKiBGaXJlcyBjbG9zZSBldmVudCB3aGVuIHRoZSBjbGljayB3YXMgcGVyZm9ybWVkIG9uIHRoZSBkb2N1bWVudCBidXRcbiAqIG5vdCBvbiB0aGUgaG9zdCBvciBjb250YWluZXIuXG4gKiAqL1xuY2xhc3MgTmJDbGlja1RyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHNpbmNlIHdlIHNob3VsZCB0cmFjayBjbGljayBmb3IgYm90aCBTSE9XIGFuZCBISURFIGV2ZW50IHdlIGZpcnN0bHkgbmVlZCB0byB0cmFjayB0aGUgY2xpY2sgYW5kIHRoZSBzdGF0ZVxuICAgICAgICAvLyBvZiB0aGUgY29udGFpbmVyIGFuZCB0aGVuIGxhdGVyIG9uIGRlY2lkZSBzaG91bGQgd2UgaGlkZSBpdCBvciBzaG93XG4gICAgICAgIC8vIGlmIHdlIHRyYWNrIHRoZSBjbGljayAmIHN0YXRlIHNlcGFyYXRlbHkgdGhpcyB3aWxsIGNhc2UgYSBiZWhhdmlvciB3aGVuIHRoZSBjb250YWluZXIgaXMgZ2V0dGluZyBzaG93blxuICAgICAgICAvLyBhbmQgdGhlbiBoaWRkZW4gcmlnaHQgYXdheVxuICAgICAgICB0aGlzLmNsaWNrJCA9IGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnY2xpY2snKVxuICAgICAgICAgICAgLnBpcGUobWFwKChldmVudCkgPT4gWyF0aGlzLmNvbnRhaW5lcigpICYmIHRoaXMuaXNPbkhvc3QoZXZlbnQpLCBldmVudF0pLCBzaGFyZSgpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgICAgIHRoaXMuc2hvdyQgPSB0aGlzLmNsaWNrJFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChbc2hvdWxkU2hvd10pID0+IHNob3VsZFNob3cpLCBtYXAoKFssIGV2ZW50XSkgPT4gZXZlbnQpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgICAgIHRoaXMuaGlkZSQgPSB0aGlzLmNsaWNrJFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChbc2hvdWxkU2hvdywgZXZlbnRdKSA9PiAhc2hvdWxkU2hvdyAmJiAhdGhpcy5pc09uQ29udGFpbmVyKGV2ZW50KSksIG1hcCgoWywgZXZlbnRdKSA9PiBldmVudCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogRmlyZXMgb3BlbiBldmVudCB3aGVuIGEgbW91c2UgaG92ZXJzIG92ZXIgdGhlIGhvc3QgZWxlbWVudCBhbmQgc3RheSBvdmVyIGF0IGxlYXN0IDEwMCBtaWxsaXNlY29uZHMuXG4gKiBGaXJlcyBjbG9zZSBldmVudCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGhvc3QgZWxlbWVudCBhbmQgc3RvcHMgb3V0IG9mIHRoZSBob3N0IGFuZCBwb3BvdmVyIGNvbnRhaW5lci5cbiAqICovXG5jbGFzcyBOYkhvdmVyVHJpZ2dlclN0cmF0ZWd5IGV4dGVuZHMgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zaG93JCA9IGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWVudGVyJylcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5jb250YWluZXIoKSksIFxuICAgICAgICAvLyB0aGlzIGBkZWxheSAmIHRha2VVbnRpbCAmIHJlcGVhdGAgb3BlcmF0b3JzIGNvbWJpbmF0aW9uIGlzIGEgc3lub255bSBmb3IgYGNvbmRpdGlvbmFsIGRlYm91bmNlYFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgaWYgb25lIGV2ZW50IG9jY3VycyBpbiBzb21lIHRpbWUgYWZ0ZXIgdGhlIGluaXRpYWwgb25lIHdlIHdvbid0IHJlYWN0IHRvIGl0XG4gICAgICAgIGRlbGF5KDEwMCksIFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cnhqcy1uby11bnNhZmUtdGFrZXVudGlsXG4gICAgICAgIHRha2VVbnRpbChmcm9tRXZlbnQodGhpcy5ob3N0LCAnbW91c2VsZWF2ZScpKSwgcmVwZWF0KCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5oaWRlJCA9IGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWxlYXZlJylcbiAgICAgICAgICAgIC5waXBlKHN3aXRjaE1hcCgoKSA9PiBmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ21vdXNlbW92ZScpXG4gICAgICAgICAgICAucGlwZShkZWJvdW5jZVRpbWUoMTAwKSwgdGFrZVdoaWxlKCgpID0+ICEhdGhpcy5jb250YWluZXIoKSksIGZpbHRlcihldmVudCA9PiB0aGlzLmlzTm90T25Ib3N0T3JDb250YWluZXIoZXZlbnQpKSkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHNob3cgYW5kIGhpZGUgZXZlbnQgc3RyZWFtcy5cbiAqIEZpcmVzIG9wZW4gZXZlbnQgd2hlbiBhIG1vdXNlIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnQgYW5kIHN0YXkgb3ZlciBhdCBsZWFzdCAxMDAgbWlsbGlzZWNvbmRzLlxuICogRmlyZXMgY2xvc2UgZXZlbnQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBob3N0IGVsZW1lbnQuXG4gKiAqL1xuY2xhc3MgTmJIaW50VHJpZ2dlclN0cmF0ZWd5IGV4dGVuZHMgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zaG93JCA9IGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWVudGVyJylcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAvLyB0aGlzIGBkZWxheSAmIHRha2VVbnRpbCAmIHJlcGVhdGAgb3BlcmF0b3JzIGNvbWJpbmF0aW9uIGlzIGEgc3lub255bSBmb3IgYGNvbmRpdGlvbmFsIGRlYm91bmNlYFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgaWYgb25lIGV2ZW50IG9jY3VycyBpbiBzb21lIHRpbWUgYWZ0ZXIgdGhlIGluaXRpYWwgb25lIHdlIHdvbid0IHJlYWN0IHRvIGl0XG4gICAgICAgIGRlbGF5KDEwMCksIFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cnhqcy1uby11bnNhZmUtdGFrZXVudGlsXG4gICAgICAgIHRha2VVbnRpbChmcm9tRXZlbnQodGhpcy5ob3N0LCAnbW91c2VsZWF2ZScpKSwgcmVwZWF0KCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5oaWRlJCA9IGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWxlYXZlJylcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogRmlyZXMgb3BlbiBldmVudCB3aGVuIGEgZm9jdXMgaXMgb24gdGhlIGhvc3QgZWxlbWVudCBhbmQgc3RheSBvdmVyIGF0IGxlYXN0IDEwMCBtaWxsaXNlY29uZHMuXG4gKiBGaXJlcyBjbG9zZSBldmVudCB3aGVuIHRoZSBmb2N1cyBsZWF2ZXMgdGhlIGhvc3QgZWxlbWVudC5cbiAqICovXG5jbGFzcyBOYkZvY3VzVHJpZ2dlclN0cmF0ZWd5IGV4dGVuZHMgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5mb2N1c091dCQgPSBmcm9tRXZlbnQodGhpcy5ob3N0LCAnZm9jdXNvdXQnKVxuICAgICAgICAgICAgLnBpcGUoc3dpdGNoTWFwKCgpID0+IGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnZm9jdXNpbicpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gISF0aGlzLmNvbnRhaW5lcigpKSwgZmlsdGVyKGV2ZW50ID0+IHRoaXMuaXNOb3RPbkhvc3RPckNvbnRhaW5lcihldmVudCkpKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5jbGlja0luJCA9IGZyb21FdmVudCh0aGlzLmhvc3QsICdjbGljaycpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gIXRoaXMuY29udGFpbmVyKCkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgICAgIHRoaXMuY2xpY2tPdXQkID0gZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdjbGljaycpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gISF0aGlzLmNvbnRhaW5lcigpKSwgZmlsdGVyKGV2ZW50ID0+IHRoaXMuaXNOb3RPbkhvc3RPckNvbnRhaW5lcihldmVudCkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgICAgIHRoaXMudGFiS2V5UHJlc3MkID0gZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdrZXlkb3duJylcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoZXZlbnQpID0+IGV2ZW50LmtleUNvZGUgPT09IDkpLCBmaWx0ZXIoKCkgPT4gISF0aGlzLmNvbnRhaW5lcigpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgICAgICB0aGlzLnNob3ckID0gbWVyZ2UoZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ2ZvY3VzaW4nKSwgdGhpcy5jbGlja0luJClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5jb250YWluZXIoKSksIGRlYm91bmNlVGltZSgxMDApLCBcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnJ4anMtbm8tdW5zYWZlLXRha2V1bnRpbFxuICAgICAgICB0YWtlVW50aWwoZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ2ZvY3Vzb3V0JykpLCByZXBlYXQoKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgICAgICB0aGlzLmhpZGUkID0gbWVyZ2UodGhpcy5mb2N1c091dCQsIHRoaXMudGFiS2V5UHJlc3MkLCB0aGlzLmNsaWNrT3V0JClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgZW1wdHkgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogKi9cbmNsYXNzIE5iTm9vcFRyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2hvdyQgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5oaWRlJCA9IEVNUFRZO1xuICAgIH1cbn1cbmNsYXNzIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICB9XG4gICAgdHJpZ2dlcih0cmlnZ2VyJCQxKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIgPSB0cmlnZ2VyJCQxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaG9zdChob3N0KSB7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl90cmlnZ2VyKSB7XG4gICAgICAgICAgICBjYXNlIE5iVHJpZ2dlci5DTElDSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5iQ2xpY2tUcmlnZ2VyU3RyYXRlZ3kodGhpcy5fZG9jdW1lbnQsIHRoaXMuX2hvc3QsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBjYXNlIE5iVHJpZ2dlci5ISU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmJIaW50VHJpZ2dlclN0cmF0ZWd5KHRoaXMuX2RvY3VtZW50LCB0aGlzLl9ob3N0LCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgY2FzZSBOYlRyaWdnZXIuSE9WRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYkhvdmVyVHJpZ2dlclN0cmF0ZWd5KHRoaXMuX2RvY3VtZW50LCB0aGlzLl9ob3N0LCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgY2FzZSBOYlRyaWdnZXIuRk9DVVM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYkZvY3VzVHJpZ2dlclN0cmF0ZWd5KHRoaXMuX2RvY3VtZW50LCB0aGlzLl9ob3N0LCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgY2FzZSBOYlRyaWdnZXIuTk9PUDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5iTm9vcFRyaWdnZXJTdHJhdGVneSh0aGlzLl9kb2N1bWVudCwgdGhpcy5faG9zdCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmlnZ2VyIGhhdmUgdG8gYmUgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfVxuXTtcblxuY2xhc3MgTmJPdmVybGF5TW9kdWxlIHtcbiAgICBzdGF0aWMgZm9yUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYk92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSxcbiAgICAgICAgICAgICAgICBOYk92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iUG9zaXRpb25IZWxwZXIsXG4gICAgICAgICAgICAgICAgLi4uTmJDZGtNYXBwaW5nTW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgLi4uTmJDZGtBZGFwdGVyTW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgLi4uTmJBMTF5TW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk5iT3ZlcmxheU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYkNka01hcHBpbmdNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYkNka01hcHBpbmdNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2RrQWRhcHRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJTdGF0dXNTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3JlU3RhdHVzZXMgPSBbJ2Jhc2ljJywgJ3ByaW1hcnknLCAnaW5mbycsICd3YXJuaW5nJywgJ2RhbmdlcicsICdjb250cm9sJ107XG4gICAgfVxuICAgIGlzQ29yZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29yZVN0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cyk7XG4gICAgfVxuICAgIGlzQ3VzdG9tU3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkU3RhdHVzU3RyaW5nKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc0NvcmVTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFN0YXR1c0NsYXNzKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkU3RhdHVzU3RyaW5nKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBgc3RhdHVzLSR7c3RhdHVzfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaXNWYWxpZFN0YXR1c1N0cmluZyhzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0dXMgPT09ICdzdHJpbmcnICYmIHN0YXR1cy5sZW5ndGggPiAwO1xuICAgIH1cbn1cbk5iU3RhdHVzU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiB3aW5kb3dGYWN0b3J5KHBsYXRmb3JtSWQpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIocGxhdGZvcm1JZCkpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgLy8gUHJvdmlkZSB1bmRlZmluZWQgdG8gZ2V0IHRoZSBlcnJvciB3aGVuIHRyeWluZyB0byBhY2Nlc3MgdGhlIHdpbmRvdyBhcyBpdFxuICAgIC8vIHNob3VsZG4ndCBiZSB1c2VkIG91dHNpZGUgdGhlIGJyb3dzZXIuIFRob3NlIHdobyBuZWVkIHRvIHByb3ZpZGUgc29tZXRoaW5nXG4gICAgLy8gaW5zdGVhZCBvZiB3aW5kb3cgKGUuZy4gZG9taW5vIHdpbmRvdyB3aGVuIHJ1bm5pbmcgaW4gbm9kZSkgY291bGQgb3ZlcnJpZGVcbiAgICAvLyBOQl9XSU5ET1cgdG9rZW4uXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIE5iVGhlbWVNb2R1bGUge1xuICAgIC8vIFRPRE86IGNoZWNrIHRoZSBvcHRpb25zICh0aHJvdyBleGNlcHRpb24/KVxuICAgIC8qKlxuICAgICAqIE1haW4gVGhlbWUgTW9kdWxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmJUaGVtZU9wdGlvbnMge05iVGhlbWVPcHRpb25zfSBNYWluIHRoZW1lIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gbmJKU1RoZW1lcyB7TmJKU1RoZW1lT3B0aW9uc1tdfSBMaXN0IG9mIEpTIFRoZW1lcywgd2lsbCBiZSBtZXJnZWQgd2l0aCBkZWZhdWx0IHRoZW1lc1xuICAgICAqIEBwYXJhbSBuYk1lZGlhQnJlYWtwb2ludHMge05iTWVkaWFCcmVha3BvaW50fSBBdmFpbGFibGUgbWVkaWEgYnJlYWtwb2ludHNcbiAgICAgKiBAcGFyYW0gbGF5b3V0RGlyZWN0aW9uIHtOYkxheW91dERpcmVjdGlvbn0gTGF5b3V0IGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge01vZHVsZVdpdGhQcm92aWRlcnN9XG4gICAgICovXG4gICAgc3RhdGljIGZvclJvb3QobmJUaGVtZU9wdGlvbnMgPSB7IG5hbWU6ICdkZWZhdWx0JyB9LCBuYkpTVGhlbWVzLCBuYk1lZGlhQnJlYWtwb2ludHMsIGxheW91dERpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iVGhlbWVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX1RIRU1FX09QVElPTlMsIHVzZVZhbHVlOiBuYlRoZW1lT3B0aW9ucyB8fCB7fSB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfQlVJTFRfSU5fSlNfVEhFTUVTLCB1c2VWYWx1ZTogQlVJTFRfSU5fVEhFTUVTIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9KU19USEVNRVMsIHVzZVZhbHVlOiBuYkpTVGhlbWVzIHx8IFtdIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9NRURJQV9CUkVBS1BPSU5UUywgdXNlVmFsdWU6IG5iTWVkaWFCcmVha3BvaW50cyB8fCBERUZBVUxUX01FRElBX0JSRUFLUE9JTlRTIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9ET0NVTUVOVCwgdXNlRXhpc3Rpbmc6IERPQ1VNRU5UIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1csIHVzZUZhY3Rvcnk6IHdpbmRvd0ZhY3RvcnksIGRlcHM6IFtQTEFURk9STV9JRF0gfSxcbiAgICAgICAgICAgICAgICBOYkpTVGhlbWVzUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgTmJUaGVtZVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSxcbiAgICAgICAgICAgICAgICBOYlNwaW5uZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfTEFZT1VUX0RJUkVDVElPTiwgdXNlVmFsdWU6IGxheW91dERpcmVjdGlvbiB8fCBOYkxheW91dERpcmVjdGlvbi5MVFIgfSxcbiAgICAgICAgICAgICAgICBOYkxheW91dERpcmVjdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iTGF5b3V0UnVsZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIC4uLk5iT3ZlcmxheU1vZHVsZS5mb3JSb290KCkucHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIE5iU3RhdHVzU2VydmljZSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuTmJUaGVtZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG5jbGFzcyBOYkNvbG9ySGVscGVyIHtcbiAgICBzdGF0aWMgc2hhZGUoY29sb3IsIHdlaWdodCkge1xuICAgICAgICByZXR1cm4gTmJDb2xvckhlbHBlci5taXgoJyMwMDAwMDAnLCBjb2xvciwgd2VpZ2h0KTtcbiAgICB9XG4gICAgc3RhdGljIHRpbnQoY29sb3IsIHdlaWdodCkge1xuICAgICAgICByZXR1cm4gTmJDb2xvckhlbHBlci5taXgoJyNmZmZmZmYnLCBjb2xvciwgd2VpZ2h0KTtcbiAgICB9XG4gICAgc3RhdGljIG1peChjb2xvcjEsIGNvbG9yMiwgd2VpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGQyaCA9IChkKSA9PiBkLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY29uc3QgaDJkID0gKGgpID0+IHBhcnNlSW50KGgsIDE2KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcjJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA3OyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IGgyZChjb2xvcjEuc3Vic3RyKGksIDIpKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhcnQgPSBoMmQoY29sb3IyLnN1YnN0cihpLCAyKSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRQYXJ0ID0gZDJoKE1hdGguZmxvb3Ioc2Vjb25kUGFydCArIChmaXJzdFBhcnQgLSBzZWNvbmRQYXJ0KSAqICh3ZWlnaHQgLyAxMDAuMCkpKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAoJzAnICsgcmVzdWx0UGFydCkuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBoZXhUb1JnYkEoaGV4LCBhbHBoYSkge1xuICAgICAgICBsZXQgYztcbiAgICAgICAgaWYgKC9eIyhbQS1GYS1mMC05XXszfSl7MSwyfSQvLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgYyA9IGhleC5zdWJzdHJpbmcoMSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgYyA9IFtjWzBdLCBjWzBdLCBjWzFdLCBjWzFdLCBjWzJdLCBjWzJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSAnMHgnICsgYy5qb2luKCcnKTtcbiAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgWyhjID4+IDE2KSAmIDI1NSwgKGMgPj4gOCkgJiAyNTUsIGMgJiAyNTVdLmpvaW4oJywnKSArICcsJyArIGFscGhhICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIEhleCcpO1xuICAgIH1cbn1cblxudmFyIE5iSWNvblBhY2tUeXBlO1xuKGZ1bmN0aW9uIChOYkljb25QYWNrVHlwZSkge1xuICAgIE5iSWNvblBhY2tUeXBlW1wiU1ZHXCJdID0gXCJzdmdcIjtcbiAgICBOYkljb25QYWNrVHlwZVtcIkZPTlRcIl0gPSBcImZvbnRcIjtcbn0pKE5iSWNvblBhY2tUeXBlIHx8IChOYkljb25QYWNrVHlwZSA9IHt9KSk7XG5cbmNsYXNzIE5iRm9udEljb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRlbnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBnZXRDbGFzc2VzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMucGFja0NsYXNzKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5wYXJhbXMucGFja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJhbXMuaWNvbkNsYXNzUHJlZml4ID8gYCR7dGhpcy5wYXJhbXMuaWNvbkNsYXNzUHJlZml4fS0ke3RoaXMubmFtZX1gIDogdGhpcy5uYW1lO1xuICAgICAgICBjbGFzc2VzLnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cbiAgICBnZXRDb250ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9XG59XG5jbGFzcyBOYlN2Z0ljb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRlbnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBnZXRDbGFzc2VzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMucGFja0NsYXNzKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5wYXJhbXMucGFja0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgZ2V0Q29udGVudChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkljb25EZWZpbml0aW9uIHtcbn1cbmZ1bmN0aW9uIHRocm93UGFja05vdEZvdW5kRXJyb3IobmFtZSkge1xuICAgIHRocm93IEVycm9yKGBJY29uIFBhY2sgJyR7bmFtZX0nIGlzIG5vdCByZWdpc3RlcmVkYCk7XG59XG5mdW5jdGlvbiB0aHJvd05vRGVmYXVsdFBhY2tFcnJvcigpIHtcbiAgICB0aHJvdyBFcnJvcignRGVmYXVsdCBwYWNrIGlzIG5vdCByZWdpc3RlcmVkLicpO1xufVxuZnVuY3Rpb24gdGhyb3dXcm9uZ1BhY2tUeXBlRXJyb3IobmFtZSwgdHlwZSwgZGVzaXJlZFR5cGUpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFjayAnJHtuYW1lfScgaXMgbm90IGFuICcke2Rlc2lyZWRUeXBlfScgUGFjayBhbmQgaXRzIHR5cGUgaXMgJyR7dHlwZX0nYCk7XG59XG4vKipcbiAqIFRoaXMgc2VydmljZSBhbGxvd3MgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgaWNvbiBwYWNrcyB0byB1c2UgdGhlbSBsYXRlciB3aXRoaW4gYDxuYi1pY29uPjwvbmItaWNvbj5gIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgTmJJY29uTGlicmFyaWVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIG5ldyBTdmcgaWNvbiBwYWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge05iSWNvbn0gaWNvbnNcbiAgICAgKiBAcGFyYW0ge05iSWNvblBhY2tQYXJhbXN9IHBhcmFtc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyU3ZnUGFjayhuYW1lLCBpY29ucywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5wYWNrcy5zZXQobmFtZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGljb25zOiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGljb25zKSksXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB0eXBlOiBOYkljb25QYWNrVHlwZS5TVkcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbmV3IGZvbnQgcGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtOYkljb25QYWNrUGFyYW1zfSBwYXJhbXNcbiAgICAgKi9cbiAgICByZWdpc3RlckZvbnRQYWNrKG5hbWUsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGFja3Muc2V0KG5hbWUsIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBpY29uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgdHlwZTogTmJJY29uUGFja1R5cGUuRk9OVCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGFjayBieSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBnZXRQYWNrKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFja3MuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHBhY2sgYXMgYSBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBzZXREZWZhdWx0UGFjayhuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wYWNrcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93UGFja05vdEZvdW5kRXJyb3IobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0UGFjayA9IHRoaXMucGFja3MuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFN2ZyBpY29uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFja1xuICAgICAqXG4gICAgICogQHJldHVybnMgTmJJY29uRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGdldFN2Z0ljb24obmFtZSwgcGFjaykge1xuICAgICAgICBjb25zdCBpY29uc1BhY2sgPSBwYWNrID8gdGhpcy5nZXRQYWNrT3JUaHJvdyhwYWNrKSA6IHRoaXMuZ2V0RGVmYXVsdFBhY2tPclRocm93KCk7XG4gICAgICAgIGlmIChpY29uc1BhY2sudHlwZSAhPT0gTmJJY29uUGFja1R5cGUuU1ZHKSB7XG4gICAgICAgICAgICB0aHJvd1dyb25nUGFja1R5cGVFcnJvcihpY29uc1BhY2submFtZSwgaWNvbnNQYWNrLnR5cGUsICdTVkcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5nZXRJY29uRnJvbVBhY2sobmFtZSwgaWNvbnNQYWNrKTtcbiAgICAgICAgaWYgKCFpY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhY2s6IGljb25zUGFjay5uYW1lLFxuICAgICAgICAgICAgdHlwZTogTmJJY29uUGFja1R5cGUuU1ZHLFxuICAgICAgICAgICAgaWNvbjogdGhpcy5jcmVhdGVTdmdJY29uKG5hbWUsIGljb24sIGljb25zUGFjay5wYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEZvbnQgaWNvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE5iSWNvbkRlZmluaXRpb25cbiAgICAgKi9cbiAgICBnZXRGb250SWNvbihuYW1lLCBwYWNrKSB7XG4gICAgICAgIGNvbnN0IGljb25zUGFjayA9IHBhY2sgPyB0aGlzLmdldFBhY2tPclRocm93KHBhY2spIDogdGhpcy5nZXREZWZhdWx0UGFja09yVGhyb3coKTtcbiAgICAgICAgaWYgKGljb25zUGFjay50eXBlICE9PSBOYkljb25QYWNrVHlwZS5GT05UKSB7XG4gICAgICAgICAgICB0aHJvd1dyb25nUGFja1R5cGVFcnJvcihpY29uc1BhY2submFtZSwgaWNvbnNQYWNrLnR5cGUsICdGb250Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0SWNvbkZyb21QYWNrKG5hbWUsIGljb25zUGFjayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcGFjazogaWNvbnNQYWNrLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBOYkljb25QYWNrVHlwZS5GT05ULFxuICAgICAgICAgICAgaWNvbjogdGhpcy5jcmVhdGVGb250SWNvbihuYW1lLCBpY29uID8gaWNvbiA6ICcnLCBpY29uc1BhY2sucGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpY29uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFja1xuICAgICAqXG4gICAgICogQHJldHVybnMgTmJJY29uRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGdldEljb24obmFtZSwgcGFjaykge1xuICAgICAgICBjb25zdCBpY29uc1BhY2sgPSBwYWNrID8gdGhpcy5nZXRQYWNrT3JUaHJvdyhwYWNrKSA6IHRoaXMuZ2V0RGVmYXVsdFBhY2tPclRocm93KCk7XG4gICAgICAgIGlmIChpY29uc1BhY2sudHlwZSA9PT0gTmJJY29uUGFja1R5cGUuU1ZHKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdmdJY29uKG5hbWUsIHBhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvbnRJY29uKG5hbWUsIHBhY2spO1xuICAgIH1cbiAgICBjcmVhdGVTdmdJY29uKG5hbWUsIGNvbnRlbnQsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gY29udGVudCBpbnN0YW5jZW9mIE5iU3ZnSWNvbiA/IGNvbnRlbnQgOiBuZXcgTmJTdmdJY29uKG5hbWUsIGNvbnRlbnQsIHBhcmFtcyk7XG4gICAgfVxuICAgIGNyZWF0ZUZvbnRJY29uKG5hbWUsIGNvbnRlbnQsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gY29udGVudCBpbnN0YW5jZW9mIE5iRm9udEljb24gPyBjb250ZW50IDogbmV3IE5iRm9udEljb24obmFtZSwgY29udGVudCwgcGFyYW1zKTtcbiAgICB9XG4gICAgZ2V0UGFja09yVGhyb3cobmFtZSkge1xuICAgICAgICBjb25zdCBwYWNrID0gdGhpcy5wYWNrcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghcGFjaykge1xuICAgICAgICAgICAgdGhyb3dQYWNrTm90Rm91bmRFcnJvcihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjaztcbiAgICB9XG4gICAgZ2V0RGVmYXVsdFBhY2tPclRocm93KCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFBhY2spIHtcbiAgICAgICAgICAgIHRocm93Tm9EZWZhdWx0UGFja0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFBhY2s7XG4gICAgfVxuICAgIGdldEljb25Gcm9tUGFjayhuYW1lLCBwYWNrKSB7XG4gICAgICAgIGlmIChwYWNrLmljb25zLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2suaWNvbnMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbk5iSWNvbkxpYnJhcmllcy7JtXByb3YgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIE5iSWNvbkxpYnJhcmllc19GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE5iSWNvbkxpYnJhcmllcygpOyB9LCB0b2tlbjogTmJJY29uTGlicmFyaWVzLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbk5iSWNvbkxpYnJhcmllcy5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIEljb24gY29tcG9uZW50LiBBbGxvd3MgdG8gcmVuZGVyIGJvdGggYHN2Z2AgYW5kIGBmb250YCBpY29ucy5cbiAqIFN0YXJ0aW5nIGZyb20gTmVidWxhciA0LjAgdXNlcyBbRXZhIEljb25zXShodHRwczovL2FrdmVvLmdpdGh1Yi5pby9ldmEtaWNvbnMvKSBwYWNrIGJ5IGRlZmF1bHQuXG4gKlxuICogQmFzaWMgaWNvbiBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgaWNvbi9pY29uLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBJY29uIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWljb24gaWNvbj1cInN0YXJcIj48L25iLWljb24+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBCeSBkZWZhdWx0IE5lYnVsYXIgY29tZXMgd2l0aG91dCBhbnkgcHJlLWluc3RhbGxlZCBpY29uIHBhY2suXG4gKiBTdGFydGluZyB3aXRoIE5lYnVsYXIgNC4wLjAgd2Ugc2hpcCBzZXBhcmF0ZSBwYWNrYWdlIGNhbGxlZCBgQG5lYnVsYXIvZXZhLWljb25zYFxuICogd2hpY2ggaW50ZWdyYXRlcyBTVkcgW0V2YSBJY29uc10oaHR0cHM6Ly9ha3Zlby5naXRodWIuaW8vZXZhLWljb25zLykgcGFjayB0byBOZWJ1bGFyLiBUbyBhZGQgaXQgdG8geW91clxuICogcHJvamVjdCBydW46XG4gKiBgYGBzaFxuICogbnBtIGkgZXZhLWljb25zIEBuZWJ1bGFyL2V2YS1pY29uc1xuICogYGBgXG4gKiBUaGlzIGNvbW1hbmQgd2lsbCBpbnN0YWxsIEV2YSBJY29ucyBwYWNrLiBUaGVuIHJlZ2lzdGVyIGBOYkV2YUljb25zTW9kdWxlYCBpbnRvIHlvdXIgYXBwIG1vZHVsZTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBOYkV2YUljb25zTW9kdWxlIH0gZnJvbSAnQG5lYnVsYXIvZXZhLWljb25zJztcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJFdmFJY29uc01vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKiBMYXN0IHRoaW5nLCBpbXBvcnQgYE5iSWNvbk1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZSB3aGVyZSB5b3UgbmVlZCB0byBzaG93IGFuIGljb246XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTmJJY29uTW9kdWxlIH0gZnJvbSAnQG5lYnVsYXIvdGhlbWUnO1xuICpcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkljb25Nb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEljb24gY2FuIGJlIGNvbG9yZWQgdXNpbmcgYHN0YXR1c2AgaW5wdXQ6XG4gKiBgYGBodG1sXG4gKiA8bmItaWNvbiBpY29uPVwic3RhclwiIHN0YXR1cz1cIndhcm5pbmdcIj48L25iLWljb24+XG4gKiBgYGBcbiAqXG4gKiBDb2xvcmVkIGljb25zOlxuICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIEljb25zLCBpY29uL2ljb24tY29sb3JzLmNvbXBvbmVudClcbiAqXG4gKiBJbiBjYXNlIHlvdSBuZWVkIHRvIHNwZWNpZnkgYW4gaWNvbiBmcm9tIGEgc3BlY2lmaWMgaWNvbiBwYWNrLCB0aGlzIGNvdWxkIGJlIGRvbmUgdXNpbmcgYHBhY2tgIGlucHV0IHByb3BlcnR5OlxuICogYGBgaHRtbFxuICogPG5iLWljb24gaWNvbj1cInN0YXJcIiBwYWNrPVwiZm9udC1hd2Vzb21lXCI+PC9uYi1pY29uPlxuICogYGBgXG4gKiBBZGRpdGlvbmFsIGljb24gc2V0dGluZ3MgKGlmIGF2YWlsYWJsZSBieSB0aGUgaWNvbiBwYWNrKSBjb3VsZCBiZSBwYXNzZWQgdXNpbmcgYG9wdGlvbnNgIGlucHV0OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1pY29uIGljb249XCJzdGFyXCIgW29wdGlvbnNdPVwieyBhbmltYXRpb246IHsgdHlwZTogJ3pvb20nIH0gfVwiPjwvbmItaWNvbj5cbiAqIGBgYFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBpY29uLWZvbnQtc2l6ZTpcbiAqIGljb24tbGluZS1oZWlnaHQ6XG4gKiBpY29uLXdpZHRoOlxuICogaWNvbi1oZWlnaHQ6XG4gKiBpY29uLXN2Zy12ZXJ0aWNhbC1hbGlnbjpcbiAqIGljb24tYmFzaWMtY29sb3I6XG4gKiBpY29uLXByaW1hcnktY29sb3I6XG4gKiBpY29uLWluZm8tY29sb3I6XG4gKiBpY29uLXN1Y2Nlc3MtY29sb3I6XG4gKiBpY29uLXdhcm5pbmctY29sb3I6XG4gKiBpY29uLWRhbmdlci1jb2xvcjpcbiAqIGljb24tY29udHJvbC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJJY29uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzYW5pdGl6ZXIsIGljb25MaWJyYXJ5LCBlbCwgcmVuZGVyZXIsIHN0YXR1c1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuaWNvbkxpYnJhcnkgPSBpY29uTGlicmFyeTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgICAgIHRoaXMucHJldkNsYXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5odG1sID0gJyc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYWxsIGljb24gY29uZmlndXJhYmxlIHByb3BlcnRpZXMgdmlhIGNvbmZpZyBvYmplY3QuXG4gICAgICogSWYgcGFzc2VkIHZhbHVlIGlzIGEgc3RyaW5nIHNldCBpY29uIG5hbWUuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuICAgIHNldCBjb25maWcodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5pY29uID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmljb24gPSB2YWx1ZS5pY29uO1xuICAgICAgICAgICAgdGhpcy5wYWNrID0gdmFsdWUucGFjaztcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gdmFsdWUuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gdmFsdWUub3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pY29uRGVmID0gdGhpcy5yZW5kZXJJY29uKHRoaXMuaWNvbiwgdGhpcy5wYWNrLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgaWNvbkRlZiA9IHRoaXMuaWNvbkxpYnJhcnkuZ2V0SWNvbih0aGlzLmljb24sIHRoaXMucGFjayk7XG4gICAgICAgIGlmIChpY29uRGVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckljb24odGhpcy5pY29uLCB0aGlzLnBhY2ssIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySWNvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlckljb24obmFtZSwgcGFjaywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBpY29uRGVmaW5pdGlvbiA9IHRoaXMuaWNvbkxpYnJhcnkuZ2V0SWNvbihuYW1lLCBwYWNrKTtcbiAgICAgICAgaWYgKCFpY29uRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpY29uRGVmaW5pdGlvbi5pY29uLmdldENvbnRlbnQob3B0aW9ucyk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmh0bWwgPSB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2lnbkNsYXNzZXMoaWNvbkRlZmluaXRpb24uaWNvbi5nZXRDbGFzc2VzKG9wdGlvbnMpKTtcbiAgICAgICAgcmV0dXJuIGljb25EZWZpbml0aW9uO1xuICAgIH1cbiAgICBjbGVhckljb24oKSB7XG4gICAgICAgIHRoaXMuaHRtbCA9ICcnO1xuICAgICAgICB0aGlzLmFzc2lnbkNsYXNzZXMoW10pO1xuICAgIH1cbiAgICBhc3NpZ25DbGFzc2VzKGNsYXNzZXMpIHtcbiAgICAgICAgdGhpcy5wcmV2Q2xhc3Nlcy5mb3JFYWNoKChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcmV2Q2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgfVxufVxuTmJJY29uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1pY29uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJycsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmlubGluZS1ibG9ja31cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJJY29uQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH0sXG4gICAgeyB0eXBlOiBOYkljb25MaWJyYXJpZXMgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYkljb25Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaHRtbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnaW5uZXJIdG1sJyxdIH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XSxcbiAgICBpY29uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYWNrOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcHRpb25zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbmZpZzogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iSWNvbk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoaWNvbnNMaWJyYXJ5KSB7XG4gICAgICAgIHRoaXMuaWNvbnNMaWJyYXJ5ID0gaWNvbnNMaWJyYXJ5O1xuICAgICAgICB0aGlzLmVzc2VudGlhbHNQYWNrTmFtZSA9ICduZWJ1bGFyLWVzc2VudGlhbHMnO1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGNvbnNlcXVlbnQgY2FsbHMgd2UgZG9uJ3QgbmVlZCB0byBlbmFibGUgYG5lYnVsYXItZXNzZW50aWFsc2AgcGFjayBhZ2FpblxuICAgICAgICBpZiAodGhpcy5pY29uc0xpYnJhcnkuZ2V0UGFjayh0aGlzLmVzc2VudGlhbHNQYWNrTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgdGhpcy5pY29uc0xpYnJhcnkucmVnaXN0ZXJTdmdQYWNrKHRoaXMuZXNzZW50aWFsc1BhY2tOYW1lLCB7XG4gICAgICAgICAgICAnY2hldnJvbi1kb3duLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZXZyb24tZG93blwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTIgMTUuNWExIDEgMCAwIDEtLjcxLS4yOWwtNC00YTEgMSAwIDEgMSAxLjQyLTEuNDJMMTIgMTMuMWwzLjMtMy4xOGExIDEgMCAxIDEgMS4zOCAxLjQ0bC00IDMuODZhMSAxIDAgMCAxLS42OC4yOHpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2NoZXZyb24tdXAtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiY2hldnJvbi11cFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xNiAxNC41YTEgMSAwIDAgMS0uNzEtLjI5TDEyIDEwLjlsLTMuMyAzLjE4YTEgMSAwIDAgMS0xLjQxIDAgMSAxIDAgMCAxIDAtMS40Mmw0LTMuODZhMSAxIDAgMCAxIDEuNCAwbDQgNGExIDEgMCAwIDEgMCAxLjQyIDEgMSAwIDAgMS0uNjkuMjh6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGV2cm9uLWxlZnQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiY2hldnJvbi1sZWZ0XCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTMuMzYgMTdhMSAxIDAgMCAxLS43Mi0uMzFsLTMuODYtNGExIDEgMCAwIDEgMC0xLjRsNC00YTEgMSAwIDEgMSAxLjQyIDEuNDJMMTAuOSAxMmwzLjE4IDMuM2ExIDEgMCAwIDEgMCAxLjQxIDEgMSAwIDAgMS0uNzIuMjl6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGV2cm9uLXJpZ2h0LW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZXZyb24tcmlnaHRcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB0cmFuc2Zvcm09XCJyb3RhdGUoLTkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTAuNSAxN2ExIDEgMCAwIDEtLjcxLS4yOSAxIDEgMCAwIDEgMC0xLjQyTDEzLjEgMTIgOS45MiA4LjY5YTEgMSAwIDAgMSAwLTEuNDEgMSAxIDAgMCAxIDEuNDIgMGwzLjg2IDRhMSAxIDAgMCAxIDAgMS40bC00IDRhMSAxIDAgMCAxLS43LjMyelwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnY2hlY2ttYXJrLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZWNrbWFya1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNOS44NiAxOGExIDEgMCAwIDEtLjczLS4zMmwtNC44Ni01LjE3YTEgMSAwIDEgMSAxLjQ2LTEuMzdsNC4xMiA0LjM5IDguNDEtOS4yYTEgMSAwIDEgMSAxLjQ4IDEuMzRsLTkuMTQgMTBhMSAxIDAgMCAxLS43My4zM3pcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3BhcGVyLXBsYW5lLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cInBhcGVyLXBsYW5lXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0yMSA0YTEuMzEgMS4zMSAwIDAgMC0uMDYtLjI3di0uMDlhMSAxIDAgMCAwLS4yLS4zIDEgMSAwIDAgMC0uMjktLjE5aC0uMDlhLjg2Ljg2IDAgMCAwLS4zMS0uMTVIMjBhMSAxIDAgMCAwLS4zIDBsLTE4IDZhMSAxIDAgMCAwIDAgMS45bDguNTMgMi44NCAyLjg0IDguNTNhMSAxIDAgMCAwIDEuOSAwbDYtMThBMSAxIDAgMCAwIDIxIDR6bS00LjcgMi4yOWwtNS41NyA1LjU3TDUuMTYgMTB6TTE0IDE4Ljg0bC0xLjg2LTUuNTcgNS41Ny01LjU3elwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnZmlsZS10ZXh0LW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImZpbGUtdGV4dFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTUgMTZIOWExIDEgMCAwIDAgMCAyaDZhMSAxIDAgMCAwIDAtMnpcIi8+PHBhdGggZD1cIk05IDE0aDNhMSAxIDAgMCAwIDAtMkg5YTEgMSAwIDAgMCAwIDJ6XCIvPjxwYXRoIGQ9XCJNMTkuNzQgOC4zM2wtNS40NC02YTEgMSAwIDAgMC0uNzQtLjMzaC03QTIuNTMgMi41MyAwIDAgMCA0IDQuNXYxNUEyLjUzIDIuNTMgMCAwIDAgNi41NiAyMmgxMC44OEEyLjUzIDIuNTMgMCAwIDAgMjAgMTkuNVY5YTEgMSAwIDAgMC0uMjYtLjY3ek0xNCA1bDIuNzQgM2gtMmEuNzkuNzkgMCAwIDEtLjc0LS44NXptMy40NCAxNUg2LjU2YS41My41MyAwIDAgMS0uNTYtLjV2LTE1YS41My41MyAwIDAgMSAuNTYtLjVIMTJ2My4xNUEyLjc5IDIuNzkgMCAwIDAgMTQuNzEgMTBIMTh2OS41YS41My41MyAwIDAgMS0uNTYuNXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2FsZXJ0LXRyaWFuZ2xlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImFsZXJ0LXRyaWFuZ2xlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMjIuNTYgMTYuM0wxNC44OSAzLjU4YTMuNDMgMy40MyAwIDAgMC01Ljc4IDBMMS40NCAxNi4zYTMgMyAwIDAgMC0uMDUgM0EzLjM3IDMuMzcgMCAwIDAgNC4zMyAyMWgxNS4zNGEzLjM3IDMuMzcgMCAwIDAgMi45NC0xLjY2IDMgMyAwIDAgMC0uMDUtMy4wNHptLTEuNyAyLjA1YTEuMzEgMS4zMSAwIDAgMS0xLjE5LjY1SDQuMzNhMS4zMSAxLjMxIDAgMCAxLTEuMTktLjY1IDEgMSAwIDAgMSAwLTFsNy42OC0xMi43M2ExLjQ4IDEuNDggMCAwIDEgMi4zNiAwbDcuNjcgMTIuNzJhMSAxIDAgMCAxIC4wMSAxLjAxelwiLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjE2XCIgcj1cIjFcIi8+PHBhdGggZD1cIk0xMiA4YTEgMSAwIDAgMC0xIDF2NGExIDEgMCAwIDAgMiAwVjlhMSAxIDAgMCAwLTEtMXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3F1ZXN0aW9uLW1hcmstb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwicXVlc3Rpb24tbWFya1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xNyA5QTUgNSAwIDAgMCA3IDlhMSAxIDAgMCAwIDIgMCAzIDMgMCAxIDEgMyAzIDEgMSAwIDAgMC0xIDF2MmExIDEgMCAwIDAgMiAwdi0xLjFBNSA1IDAgMCAwIDE3IDl6XCIvPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTlcIiByPVwiMVwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnZW1haWwtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiZW1haWxcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDRINWEzIDMgMCAwIDAtMyAzdjEwYTMgMyAwIDAgMCAzIDNoMTRhMyAzIDAgMCAwIDMtM1Y3YTMgMyAwIDAgMC0zLTN6bS0uNjcgMkwxMiAxMC43NSA1LjY3IDZ6TTE5IDE4SDVhMSAxIDAgMCAxLTEtMVY3LjI1bDcuNCA1LjU1YTEgMSAwIDAgMCAuNi4yIDEgMSAwIDAgMCAuNi0uMkwyMCA3LjI1VjE3YTEgMSAwIDAgMS0xIDF6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdmbGFzaC1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJmbGFzaFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTEuMTEgMjNhMSAxIDAgMCAxLS4zNC0uMDYgMSAxIDAgMCAxLS42NS0xLjA1bC43Ny03LjA5SDVhMSAxIDAgMCAxLS44My0xLjU2bDcuODktMTEuOGExIDEgMCAwIDEgMS4xNy0uMzggMSAxIDAgMCAxIC42NSAxbC0uNzcgNy4xNEgxOWExIDEgMCAwIDEgLjgzIDEuNTZsLTcuODkgMTEuOGExIDEgMCAwIDEtLjgzLjQ0ek02Ljg3IDEyLjhIMTJhMSAxIDAgMCAxIC43NC4zMyAxIDEgMCAwIDEgLjI1Ljc4bC0uNDUgNC4xNSA0LjU5LTYuODZIMTJhMSAxIDAgMCAxLTEtMS4xMWwuNDUtNC4xNXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3NlYXJjaC1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJzZWFyY2hcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTIwLjcxIDE5LjI5bC0zLjQtMy4zOUE3LjkyIDcuOTIgMCAwIDAgMTkgMTFhOCA4IDAgMSAwLTggOCA3LjkyIDcuOTIgMCAwIDAgNC45LTEuNjlsMy4zOSAzLjRhMSAxIDAgMCAwIDEuNDIgMCAxIDEgMCAwIDAgMC0xLjQyek01IDExYTYgNiAwIDEgMSA2IDYgNiA2IDAgMCAxLTYtNnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2Nsb3NlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNsb3NlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTEzLjQxIDEybDQuMy00LjI5YTEgMSAwIDEgMC0xLjQyLTEuNDJMMTIgMTAuNTlsLTQuMjktNC4zYTEgMSAwIDAgMC0xLjQyIDEuNDJsNC4zIDQuMjktNC4zIDQuMjlhMSAxIDAgMCAwIDAgMS40MiAxIDEgMCAwIDAgMS40MiAwbDQuMjktNC4zIDQuMjkgNC4zYTEgMSAwIDAgMCAxLjQyIDAgMSAxIDAgMCAwIDAtMS40MnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2NvbGxhcHNlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNvbGxhcHNlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDloLTIuNThsMy4yOS0zLjI5YTEgMSAwIDEgMC0xLjQyLTEuNDJMMTUgNy41N1Y1YTEgMSAwIDAgMC0xLTEgMSAxIDAgMCAwLTEgMXY1YTEgMSAwIDAgMCAxIDFoNWExIDEgMCAwIDAgMC0yelwiLz48cGF0aCBkPVwiTTEwIDEzSDVhMSAxIDAgMCAwIDAgMmgyLjU3bC0zLjI4IDMuMjlhMSAxIDAgMCAwIDAgMS40MiAxIDEgMCAwIDAgMS40MiAwTDkgMTYuNDJWMTlhMSAxIDAgMCAwIDEgMSAxIDEgMCAwIDAgMS0xdi01YTEgMSAwIDAgMC0xLTF6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdleHBhbmQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiZXhwYW5kXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTIwIDVhMSAxIDAgMCAwLTEtMWgtNWExIDEgMCAwIDAgMCAyaDIuNTdsLTMuMjggMy4yOWExIDEgMCAwIDAgMCAxLjQyIDEgMSAwIDAgMCAxLjQyIDBMMTggNy40MlYxMGExIDEgMCAwIDAgMSAxIDEgMSAwIDAgMCAxLTF6XCIvPjxwYXRoIGQ9XCJNMTAuNzEgMTMuMjlhMSAxIDAgMCAwLTEuNDIgMEw2IDE2LjU3VjE0YTEgMSAwIDAgMC0xLTEgMSAxIDAgMCAwLTEgMXY1YTEgMSAwIDAgMCAxIDFoNWExIDEgMCAwIDAgMC0ySDcuNDJsMy4yOS0zLjI5YTEgMSAwIDAgMCAwLTEuNDJ6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdtaW51cy1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJtaW51c1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xOSAxM0g1YTEgMSAwIDAgMSAwLTJoMTRhMSAxIDAgMCAxIDAgMnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ21pbnVzLWJvbGQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDggMlwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj48ZGVmcz48cmVjdCBpZD1cIm5iLW1ib1wiIHk9XCIzXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiMlwiIHJ4PVwiMVwiLz48L2RlZnM+PHVzZSB4bGluazpocmVmPVwiI25iLW1ib1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIC0zKVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGVja21hcmstYm9sZC1vdXRsaW5lJzogJzxzdmcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgOCA3XCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPjxkZWZzPjxwYXRoIGlkPVwibmItY2JvXCIgZD1cIk02LjAzOSAxLjQzYTEuMTEgMS4xMSAwIDAgMSAxLjUxNy0uMjI4Yy40ODMuMzQyLjU4OC45OTguMjM0IDEuNDY2TDQuNDMxIDcuMWExIDEgMCAwIDEtMS40OTIuMTE1TC4zMTcgNC42NzdhMS4wMjMgMS4wMjMgMCAwIDEgLjAwMi0xLjQ4MyAxLjExMyAxLjExMyAwIDAgMSAxLjUzNS4wMDJsMS42NDEgMS41OUw2LjA0IDEuNDI4elwiLz48L2RlZnM+PHVzZSB4bGluazpocmVmPVwiI25iLWNib1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIC0xKVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgICdhcnJvdy1iYWNrJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiYXJyb3ctYmFja1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDExSDcuMTRsMy42My00LjM2YTEgMSAwIDEgMC0xLjU0LTEuMjhsLTUgNmExLjE5IDEuMTkgMCAwIDAtLjA5LjE1YzAgLjA1IDAgLjA4LS4wNy4xM0ExIDEgMCAwIDAgNCAxMmExIDEgMCAwIDAgLjA3LjM2YzAgLjA1IDAgLjA4LjA3LjEzYTEuMTkgMS4xOSAwIDAgMCAuMDkuMTVsNSA2QTEgMSAwIDAgMCAxMCAxOWExIDEgMCAwIDAgLjY0LS4yMyAxIDEgMCAwIDAgLjEzLTEuNDFMNy4xNCAxM0gxOWExIDEgMCAwIDAgMC0yelwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aFxuICAgIH1cbn1cbk5iSWNvbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYkljb25Db21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJJY29uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJJY29uTGlicmFyaWVzIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSBgPG5iLWNhcmQ+YCBjb21wb25lbnQuXG4gKiBJdCBhZGRzIHN0eWxlcyBmb3IgYSBwcmVzZXQgaGVhZGVyIHNlY3Rpb24uXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNhcmQtaGVhZGVyLXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2FyZC1oZWFkZXItdGV4dC1mb250LXNpemU6XG4gKiBjYXJkLWhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FyZC1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhcmQtaGVhZGVyLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1iYXNpYy10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1oZWFkZXItcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1oZWFkZXItaW5mby10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1oZWFkZXItc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1oZWFkZXItd2FybmluZy10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGNhcmQtaGVhZGVyLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhcmQtaGVhZGVyLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJDYXJkSGVhZGVyQ29tcG9uZW50IHtcbn1cbk5iQ2FyZEhlYWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FyZC1oZWFkZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gIHRoZSBgPG5iLWNhcmQ+YCBjb21wb25lbnQuXG4gKiBBZGRzIHN0eWxlcyBmb3IgYSBwcmVzZXQgYm9keSBzZWN0aW9uLlxuICovXG5jbGFzcyBOYkNhcmRCb2R5Q29tcG9uZW50IHtcbn1cbk5iQ2FyZEJvZHlDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNhcmQtYm9keScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YFxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiAgdGhlIGA8bmItY2FyZD5gIGNvbXBvbmVudC5cbiAqIEFkZHMgc3R5bGVzIGZvciBhIHByZXNldCBmb290ZXIgc2VjdGlvbi5cbiAqL1xuY2xhc3MgTmJDYXJkRm9vdGVyQ29tcG9uZW50IHtcbn1cbk5iQ2FyZEZvb3RlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FyZC1mb290ZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqXG4gKiBCYXNpYyBjb250ZW50IGNvbnRhaW5lciBjb21wb25lbnQuXG4gKlxuICogQmFzaWMgY2FyZCBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgY2FyZC9jYXJkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYXNpYyBjYXJkIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWNhcmQ+XG4gKiAgIDxuYi1jYXJkLWJvZHk+XG4gKiAgICAgQ2FyZFxuICogICA8L25iLWNhcmQtYm9keT5cbiAqIDwvbmItY2FyZD5cbiAqIGBgYFxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ2FyZE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJDYXJkTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDYXJkIHdpdGggaGVhZGVyIGFuZCBmb290ZXI6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpdGggSGVhZGVyICYgRm9vdGVyLCBjYXJkL2NhcmQtZnVsbC5jb21wb25lbnQpXG4gKlxuICogTW9zdCBvZiB0aGUgdGltZSBtYWluIGNhcmQgY29udGVudCBnb2VzIHRvIGBuYi1jYXJkLWJvZHlgLFxuICogc28gaXQgaXMgc3R5bGVkIGFuZCBhbGlnbmVkIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKiBJbiBjYXNlIHlvdSBuZWVkIGEgaGlnaGVyIGxldmVsIG9mIGNvbnRyb2wsIHlvdSBjYW4gcGFzcyBjb250ZW5kIGRpcmVjdGx5IHRvIGBuYi1jYXJkYCxcbiAqIHNvIGBuYi1jYXJkLWJvZHlgIHN0eWxpbmcgd2lsbCBub3QgYmUgYXBwbGllZC5cbiAqXG4gKiBDb25zaWRlciBhbiBleGFtcGxlIHdpdGggYG5iLWxpc3RgIGNvbXBvbmVudDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ2FyZCB3aXRoIGxpc3QsIGNhcmQvY2FyZC13aXRob3V0LWJvZHkuY29tcG9uZW50KVxuICpcbiAqIENvbG9yZWQgY2FyZHMgY291bGQgYmUgc2ltcGx5IGNvbmZpZ3VyZWQgYnkgcHJvdmlkaW5nIGEgYHN0YXR1c2AgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgQ2FyZCwgY2FyZC9jYXJkLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhc3NpZ24gYW4gYGFjY2VudGAgcHJvcGVydHkgZm9yIGEgc2xpZ2h0IGNhcmQgaGlnaGxpZ2h0XG4gKiBhcyB3ZWxsIGFzIGNvbWJpbmUgaXQgd2l0aCBgc3RhdHVzYDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWNjZW50IENhcmQsIGNhcmQvY2FyZC1hY2NlbnRzLmNvbXBvbmVudClcbiAqXG4gKiBDYXJkcyBvZiBzbWFsbGVyIHNpemVzIGNvdWxkIGJlIGNvbWJpbmVkIGFuZCBwdXQgb24gdGhlIHNhbWUgcm93IHdpdGggYSBiaWdnZXIgY2FyZCBzbyB0aGV5IGhhdmUgdGhlIHNhbWUgaGVpZ2h0cy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQ2FyZCBzaXplcyBjb21iaW5hdGlvbnMsIGNhcmQvY2FyZC1zaXplcy1jb21iaW5hdGlvbnMuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIGNhcmQvY2FyZC1zaXplcy5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNhcmQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhcmQtdGV4dC1jb2xvcjpcbiAqIGNhcmQtdGV4dC1mb250LWZhbWlseTpcbiAqIGNhcmQtdGV4dC1mb250LXNpemU6XG4gKiBjYXJkLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYXJkLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYXJkLWJvcmRlci13aWR0aDpcbiAqIGNhcmQtYm9yZGVyLXN0eWxlOlxuICogY2FyZC1ib3JkZXItY29sb3I6XG4gKiBjYXJkLWJvcmRlci1yYWRpdXM6XG4gKiBjYXJkLXBhZGRpbmc6XG4gKiBjYXJkLXNoYWRvdzpcbiAqIGNhcmQtZGl2aWRlci1jb2xvcjpcbiAqIGNhcmQtZGl2aWRlci1zdHlsZTpcbiAqIGNhcmQtZGl2aWRlci13aWR0aDpcbiAqIGNhcmQtaGVpZ2h0LXRpbnk6XG4gKiBjYXJkLWhlaWdodC1zbWFsbDpcbiAqIGNhcmQtaGVpZ2h0LW1lZGl1bTpcbiAqIGNhcmQtaGVpZ2h0LWxhcmdlOlxuICogY2FyZC1oZWlnaHQtZ2lhbnQ6XG4gKiBjYXJkLW1hcmdpbi1ib3R0b206XG4gKiBjYXJkLXNjcm9sbGJhci1jb2xvcjpcbiAqIGNhcmQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLXNjcm9sbGJhci13aWR0aDpcbiAqL1xuY2xhc3MgTmJDYXJkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgICAgIHRoaXMuX3NpemUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcmQgc3RhdHVzOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXJkIGFjY2VudCAoY29sb3Igb2YgdGhlIHRvcCBib3JkZXIpOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZW50ID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcmQgc2l6ZSwgYXZhaWxhYmxlIHNpemVzOlxuICAgICAqIHRpbnksIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCBnaWFudFxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgc2V0IHNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgaGFzQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQ7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5QWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm9BY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2Vzc0FjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlckFjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuTmJDYXJkQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYXJkJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNhcmQtaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNhcmQtYm9keVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gIGAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhcmRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlN0YXR1c1NlcnZpY2UgfVxuXTtcbk5iQ2FyZENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFjY2VudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgaGFzQWNjZW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hY2NlbnQnLF0gfV0sXG4gICAgcHJpbWFyeUFjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LXByaW1hcnknLF0gfV0sXG4gICAgaW5mb0FjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LWluZm8nLF0gfV0sXG4gICAgc3VjY2Vzc0FjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZ0FjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyQWNjZW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hY2NlbnQtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljQWNjZW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hY2NlbnQtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbEFjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LWNvbnRyb2wnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqXG4gKiBSZXZlYWwgY2FyZCBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShNeSBleGFtcGxlLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQXMgYSBjb250ZW50IFJldmVhbCBjYXJkIGFjY2VwdHMgdHdvIGluc3RhbmNlcyBvZiBgbmItY2FyZGAgLSBmb3IgZnJvbnQgYW5kIGJhY2sgc2lkZXMuXG4gKlxuICogQmFzaWMgcmV2ZWFsIGNhcmQgY29uZmlndXJhdGlvbjpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItcmV2ZWFsLWNhcmQ+XG4gKiAgIDxuYi1jYXJkLWZyb250PlxuICogICAgIDxuYi1jYXJkPlxuICogICAgICAgPG5iLWNhcmQtYm9keT5cbiAqICAgICAgICAgRnJvbnRcbiAqICAgICAgIDwvbmItY2FyZC1ib2R5PlxuICogICAgIDwvbmItY2FyZD5cbiAqICAgPC9uYi1jYXJkLWZyb250PlxuICogICA8bmItY2FyZC1iYWNrPlxuICogICAgIDxuYi1jYXJkPlxuICogICAgICAgPG5iLWNhcmQtYm9keT5cbiAqICAgICAgICAgQmFja1xuICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gKiAgICAgPC9uYi1jYXJkPlxuICogICA8L25iLWNhcmQtYmFjaz5cbiAqIDwvbmItcmV2ZWFsLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNhcmRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2FyZE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogUmV2ZWFsIENhcmQgd2l0aCBoZWFkZXIgYW5kIGZvb3RlcjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBIZWFkZXIgJiBGb290ZXIsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLWZ1bGwuY29tcG9uZW50KVxuICpcbiAqIENvbG9yZWQgcmV2ZWFsLWNhcmRzIGNvdWxkIGJlIHNpbXBseSBjb25maWd1cmVkIGJ5IHByb3ZpZGluZyBhIGBzdGF0dXNgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENhcmQsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhc3NpZ24gYW4gYGFjY2VudGAgcHJvcGVydHkgZm9yIGEgc2xpZ2h0IGNhcmQgaGlnaGxpZ2h0XG4gKiBhcyB3ZWxsIGFzIGNvbWJpbmUgaXQgd2l0aCBgc3RhdHVzYDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWNjZW50IENhcmQsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLWFjY2VudHMuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLXNpemVzLmNvbXBvbmVudClcbiAqL1xuY2xhc3MgTmJSZXZlYWxDYXJkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldmVhbCBzdGF0ZVxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJldmVhbGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93L2hpZGUgdG9nZ2xlIGJ1dHRvbiB0byBiZSBhYmxlIHRvIGNvbnRyb2wgdG9nZ2xlIGZyb20geW91ciBjb2RlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93VG9nZ2xlQnV0dG9uID0gdHJ1ZTtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLnJldmVhbGVkID0gIXRoaXMucmV2ZWFsZWQ7XG4gICAgfVxufVxuTmJSZXZlYWxDYXJkQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1yZXZlYWwtY2FyZCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkLWZyb250XCI+PC9uZy1jb250ZW50PlxuICAgIDxkaXYgY2xhc3M9XCJzZWNvbmQtY2FyZC1jb250YWluZXJcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNhcmQtYmFja1wiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8YSAqbmdJZj1cInNob3dUb2dnbGVCdXR0b25cIiBjbGFzcz1cInJldmVhbC1idXR0b25cIiAoY2xpY2spPVwidG9nZ2xlKClcIj5cbiAgICAgIDxuYi1pY29uIGljb249XCJjaGV2cm9uLWRvd24tb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L25iLWljb24+XG4gICAgPC9hPlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59Omhvc3QgLnNlY29uZC1jYXJkLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtyaWdodDowO2xlZnQ6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjp0b3AgMHMgMC41c306aG9zdCA6Om5nLWRlZXAgbmItY2FyZC1mcm9udCBuYi1jYXJkLDpob3N0IDo6bmctZGVlcCBuYi1jYXJkLWJhY2sgbmItY2FyZHtib3gtc2hhZG93Om5vbmU7bWFyZ2luOjB9Omhvc3QgOjpuZy1kZWVwIG5iLWNhcmQtZnJvbnR7ZGlzcGxheTpibG9jaztoZWlnaHQ6MTAwJX06aG9zdCA6Om5nLWRlZXAgbmItY2FyZC1iYWNre3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MTAwJTt3aWR0aDoxMDAlO3RyYW5zaXRpb246dG9wIDAuNXN9Omhvc3QgLnJldmVhbC1idXR0b257Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdCgucmV2ZWFsZWQpIC5zZWNvbmQtY2FyZC1jb250YWluZXJ7dG9wOjA7dHJhbnNpdGlvbjpub25lfTpob3N0KC5yZXZlYWxlZCkgLnNlY29uZC1jYXJkLWNvbnRhaW5lciA6Om5nLWRlZXAgbmItY2FyZC1iYWNre3RvcDowfTpob3N0KC5yZXZlYWxlZCkgLnJldmVhbC1idXR0b257dHJhbnNmb3JtOm5vbmV9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iUmV2ZWFsQ2FyZENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByZXZlYWxlZDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5yZXZlYWxlZCcsXSB9XSxcbiAgICBzaG93VG9nZ2xlQnV0dG9uOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKlxuICogRmxpcCBjYXJkIGV4YW1wbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBmbGlwLWNhcmQvZmxpcC1jYXJkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBBcyBhIGNvbnRlbnQgRmxpcCBjYXJkIGFjY2VwdHMgdHdvIGluc3RhbmNlcyBvZiBgbmItY2FyZGAgLSBmb3IgZnJvbnQgYW5kIGJhY2sgc2lkZXMuXG4gKlxuICogQmFzaWMgZmxpcCBjYXJkIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWZsaXAtY2FyZD5cbiAqICAgPG5iLWNhcmQtZnJvbnQ+XG4gKiAgICAgPG5iLWNhcmQ+XG4gKiAgICAgICA8bmItY2FyZC1ib2R5PlxuICogICAgICAgICBGcm9udFxuICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gKiAgICAgPC9uYi1jYXJkPlxuICogICA8L25iLWNhcmQtZnJvbnQ+XG4gKiAgIDxuYi1jYXJkLWJhY2s+XG4gKiAgICAgPG5iLWNhcmQ+XG4gKiAgICAgICA8bmItY2FyZC1ib2R5PlxuICogICAgICAgICBCYWNrXG4gKiAgICAgICA8L25iLWNhcmQtYm9keT5cbiAqICAgICA8L25iLWNhcmQ+XG4gKiAgIDwvbmItY2FyZC1iYWNrPlxuICogPC9uYi1mbGlwLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNhcmRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2FyZE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogRmxpcCBDYXJkIHdpdGggaGVhZGVyIGFuZCBmb290ZXI6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpdGggSGVhZGVyICYgRm9vdGVyLCBmbGlwLWNhcmQvZmxpcC1jYXJkLWZ1bGwuY29tcG9uZW50LnRzKVxuICpcbiAqIENvbG9yZWQgZmxpcC1jYXJkcyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBDYXJkLCBmbGlwLWNhcmQvZmxpcC1jYXJkLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhc3NpZ24gYW4gYGFjY2VudGAgcHJvcGVydHkgZm9yIGEgc2xpZ2h0IGNhcmQgaGlnaGxpZ2h0XG4gKiBhcyB3ZWxsIGFzIGNvbWJpbmUgaXQgd2l0aCBgc3RhdHVzYDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWNjZW50IENhcmQsIGZsaXAtY2FyZC9mbGlwLWNhcmQtYWNjZW50cy5jb21wb25lbnQpXG4gKlxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShNdWx0aXBsZSBTaXplcywgZmxpcC1jYXJkL2ZsaXAtY2FyZC1zaXplcy5jb21wb25lbnQpXG4gKlxuICovXG5jbGFzcyBOYkZsaXBDYXJkQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXAgc3RhdGVcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGlwcGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93L2hpZGUgdG9nZ2xlIGJ1dHRvbiB0byBiZSBhYmxlIHRvIGNvbnRyb2wgdG9nZ2xlIGZyb20geW91ciBjb2RlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93VG9nZ2xlQnV0dG9uID0gdHJ1ZTtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmZsaXBwZWQgPSAhdGhpcy5mbGlwcGVkO1xuICAgIH1cbn1cbk5iRmxpcENhcmRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWZsaXAtY2FyZCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiZmxpcGNhcmQtYm9keVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImZyb250LWNvbnRhaW5lclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkLWZyb250XCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8YSAqbmdJZj1cInNob3dUb2dnbGVCdXR0b25cIiBjbGFzcz1cImZsaXAtYnV0dG9uXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgICAgICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tbGVmdC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvbmItaWNvbj5cbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYmFjay1jb250YWluZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1iYWNrXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8YSAqbmdJZj1cInNob3dUb2dnbGVCdXR0b25cIiBjbGFzcz1cImZsaXAtYnV0dG9uXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgICAgICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tbGVmdC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvbmItaWNvbj5cbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO3BlcnNwZWN0aXZlOjEyMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX06aG9zdC1jb250ZXh0KC5mbGlwcGVkKSAuZmxpcGNhcmQtYm9keXt0cmFuc2Zvcm06cm90YXRlWSgtMTgwZGVnKX06aG9zdC1jb250ZXh0KC5mbGlwcGVkKSAuZmxpcGNhcmQtYm9keSAuZnJvbnQtY29udGFpbmVye29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMHMgMC4yNXM7YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbn06aG9zdC1jb250ZXh0KC5mbGlwcGVkKSAuZmxpcGNhcmQtYm9keSAuZnJvbnQtY29udGFpbmVyIC5mbGlwLWJ1dHRvbntvcGFjaXR5OjA7ei1pbmRleDotMX06aG9zdC1jb250ZXh0KC5mbGlwcGVkKSAuZmxpcGNhcmQtYm9keSAuYmFjay1jb250YWluZXJ7YmFja2ZhY2UtdmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTp2aXNpYmxlfS5mbGlwY2FyZC1ib2R5e2Rpc3BsYXk6ZmxleDt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzO3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZH0uZmxpcGNhcmQtYm9keSAuZnJvbnQtY29udGFpbmVyLC5mbGlwY2FyZC1ib2R5IC5iYWNrLWNvbnRhaW5lcntmbGV4OjF9LmZsaXBjYXJkLWJvZHkgLmZyb250LWNvbnRhaW5lciAuZmxpcC1idXR0b24sLmZsaXBjYXJkLWJvZHkgLmJhY2stY29udGFpbmVyIC5mbGlwLWJ1dHRvbntjdXJzb3I6cG9pbnRlcjtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgMHMgMC4xNXN9LmZsaXBjYXJkLWJvZHkgLmZyb250LWNvbnRhaW5lcntiYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7dHJhbnNpdGlvbjpvcGFjaXR5IDBzIDAuMnN9LmZsaXBjYXJkLWJvZHkgLmJhY2stY29udGFpbmVye2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47dHJhbnNmb3JtOnJvdGF0ZVkoMTgwZGVnKX1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJGbGlwQ2FyZENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmbGlwcGVkOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmZsaXBwZWQnLF0gfV0sXG4gICAgc2hvd1RvZ2dsZUJ1dHRvbjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSBgPG5iLWZsaXAtY2FyZD5gIGFuZCBgPG5iLXJldmVhbC1jYXJkPmAgY29tcG9uZW50cy5cbiAqXG4gKiBVc2UgaXQgYXMgYSBjb250YWluZXIgZm9yIHRoZSBmcm9udCBjYXJkLlxuICovXG5jbGFzcyBOYkNhcmRGcm9udENvbXBvbmVudCB7XG59XG5OYkNhcmRGcm9udENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FyZC1mcm9udCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkXCI+PC9uZy1jb250ZW50PidcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gdGhlIGA8bmItZmxpcC1jYXJkPmAgYW5kIGA8bmItcmV2ZWFsLWNhcmQ+YCBjb21wb25lbnRzLlxuICpcbiAqIFVzZSBpdCBhcyBhIGNvbnRhaW5lciBmb3IgdGhlIGJhY2sgY2FyZC5cbiAqL1xuY2xhc3MgTmJDYXJkQmFja0NvbXBvbmVudCB7XG59XG5OYkNhcmRCYWNrQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYXJkLWJhY2snLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZFwiPjwvbmctY29udGVudD4nXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfQ0FSRF9DT01QT05FTlRTID0gW1xuICAgIE5iQ2FyZENvbXBvbmVudCxcbiAgICBOYkNhcmRCb2R5Q29tcG9uZW50LFxuICAgIE5iQ2FyZEZvb3RlckNvbXBvbmVudCxcbiAgICBOYkNhcmRIZWFkZXJDb21wb25lbnQsXG4gICAgTmJSZXZlYWxDYXJkQ29tcG9uZW50LFxuICAgIE5iRmxpcENhcmRDb21wb25lbnQsXG4gICAgTmJDYXJkRnJvbnRDb21wb25lbnQsXG4gICAgTmJDYXJkQmFja0NvbXBvbmVudCxcbl07XG5jbGFzcyBOYkNhcmRNb2R1bGUge1xufVxuTmJDYXJkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkljb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfQ0FSRF9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9DQVJEX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgTmJDYWxlbmRhclZpZXdNb2RlO1xuKGZ1bmN0aW9uIChOYkNhbGVuZGFyVmlld01vZGUpIHtcbiAgICBOYkNhbGVuZGFyVmlld01vZGVbXCJZRUFSXCJdID0gXCJ5ZWFyXCI7XG4gICAgTmJDYWxlbmRhclZpZXdNb2RlW1wiTU9OVEhcIl0gPSBcIm1vbnRoXCI7XG4gICAgTmJDYWxlbmRhclZpZXdNb2RlW1wiREFURVwiXSA9IFwiZGF0ZVwiO1xufSkoTmJDYWxlbmRhclZpZXdNb2RlIHx8IChOYkNhbGVuZGFyVmlld01vZGUgPSB7fSkpO1xudmFyIE5iQ2FsZW5kYXJTaXplO1xuKGZ1bmN0aW9uIChOYkNhbGVuZGFyU2l6ZSkge1xuICAgIE5iQ2FsZW5kYXJTaXplW1wiTUVESVVNXCJdID0gXCJtZWRpdW1cIjtcbiAgICBOYkNhbGVuZGFyU2l6ZVtcIkxBUkdFXCJdID0gXCJsYXJnZVwiO1xufSkoTmJDYWxlbmRhclNpemUgfHwgKE5iQ2FsZW5kYXJTaXplID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHJldHVybiAodmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAnJyk7XG4gICAgfVxuICAgIHJldHVybiAhIXZhbDtcbn1cblxuZnVuY3Rpb24gZmlyc3RDaGlsZE5vdENvbW1lbnQobm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXlcbiAgICAgICAgLmZyb20obm9kZS5jaGlsZE5vZGVzKVxuICAgICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKTtcbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG59XG5mdW5jdGlvbiBsYXN0Q2hpbGROb3RDb21tZW50KG5vZGUpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5XG4gICAgICAgIC5mcm9tKG5vZGUuY2hpbGROb2RlcylcbiAgICAgICAgLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIENhbGVuZGFyIGNvbXBvbmVudCBwcm92aWRlcyBhIGNhcGFiaWxpdHkgdG8gY2hvb3NlIGEgZGF0ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItY2FsZW5kYXIgWyhkYXRlKV09XCJkYXRlXCI+PC9uYi1jYWxlbmRhcj5cbiAqIDxuYi1jYWxlbmRhciBbZGF0ZV09XCJkYXRlXCIgKGRhdGVDaGFuZ2UpPVwiaGFuZGxlRGF0ZUNoYW5nZSgkZXZlbnQpXCI+PC9uYi1jYWxlbmRhcj5cbiAqIGBgYFxuICpcbiAqIEJhc2ljIHVzYWdlIGV4YW1wbGVcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGNhbGVuZGFyL2NhbGVuZGFyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNhbGVuZGFyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkNhbGVuZGFyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBzZWxlY3QgcmFuZ2VzIHlvdSBjYW4gdXNlIGBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnRgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1jYWxlbmRhci1yYW5nZSBbKHJhbmdlKV09XCJyYW5nZVwiPjwvbmItY2FsZW5kYXItcmFuZ2U+XG4gKiA8bmItY2FsZW5kYXItcmFuZ2UgW3JhbmdlXT1cInJhbmdlXCIgKHJhbmdlQ2hhbmdlKT1cImhhbmRsZVJhbmdlQ2hhbmdlKCRldmVudClcIj48L25iLWNhbGVuZGFyLXJhbmdlPlxuICogYGBgXG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIGl0LCB5b3UgaGF2ZSB0byBpbXBvcnQgYE5iQ2FsZW5kYXJSYW5nZU1vZHVsZWAuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJhbmdlLCBjYWxlbmRhci9jYWxlbmRhci1yYW5nZS1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogVGhlIGNhbGVuZGFyIGNvbXBvbmVudCBpcyBzdXBwbGllZCB3aXRoIGEgY2FsZW5kYXIgbmF2aWdhdGlvbiB0aGF0IGNvbnRhaW5zIG5hdmlnYXRlIGJ1dHRvbnMuXG4gKiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIGl0IHlvdSBjYW4gaGlkZSBjYWxlbmRhciBuYXZpZ2F0aW9uIHVzaW5nIGBzaG93TmF2aWdhdGlvbmAgcHJvcGVydHkuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpdGhvdXQgbmF2aWdhdGlvbiwgY2FsZW5kYXIvY2FsZW5kYXItd2l0aG91dC1uYXZpZ2F0aW9uLmNvbXBvbmVudClcbiAqXG4gKiBBcyB5b3UgY2FuIHNlZSBpbiB0aGUgYmFzaWMgdXNhZ2UgZXhhbXBsZSBjYWxlbmRhciBjb250YWlucyBwcmV2aW91cyBhbmQgbmV4dCBtb250aCBkYXlzXG4gKiB3aGljaCBjYW4gYmUgZGlzYWJsZWQgdXNpbmcgYGJvdW5kaW5nTW9udGhgIHByb3BlcnR5LlxuICogQHN0YWNrZWQtZXhhbXBsZShCb3VuZGluZyBtb250aHMsIGNhbGVuZGFyL2NhbGVuZGFyLWJvdW5kaW5nLW1vbnRoLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIGRlZmluZSBzdGFydGluZyB2aWV3IG9mIHRoZSBjYWxlbmRhciBieSBzZXR0aW5nIGBzdGFydFZpZXdgIHByb3BlcnR5LlxuICogQXZhaWxhYmxlIHZhbHVlczogeWVhciwgbW9udGggYW5kIGRhdGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFN0YXJ0IHZpZXcsIGNhbGVuZGFyL2NhbGVuZGFyLXN0YXJ0LXZpZXcuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gdXNlIGEgbGFyZ2VyIHZlcnNpb24gb2YgdGhlIGNhbGVuZGFyIGJ5IGRlZmluaW5nIHNpemUgcHJvcGVydHkuXG4gKiBBdmFpbGFibGUgdmFsdWVzOiBtZWRpdW0od2hpY2ggaXMgZGVmYXVsdCkgYW5kIGxhcmdlLlxuICogQHN0YWNrZWQtZXhhbXBsZShTaXplLCBjYWxlbmRhci9jYWxlbmRhci1zaXplLmNvbXBvbmVudClcbiAqXG4gKiBDYWxlbmRhciBzdXBwb3J0cyBtaW4gYW5kIG1heCBkYXRlcyB3aGljaCBkaXNhYmxlcyB2YWx1ZXMgb3V0IG9mIG1pbi1tYXggcmFuZ2UuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJvcmRlcnMsIGNhbGVuZGFyL2NhbGVuZGFyLW1pbi1tYXguY29tcG9uZW50KVxuICpcbiAqIEFsc28sIHlvdSBjYW4gZGVmaW5lIGN1c3RvbSBmaWx0ZXIgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgcHJlZGljYXRlIHdoaWNoIHJlY2VpdmVzXG4gKiBkYXRlIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZGF0ZSBoYXMgdG8gYmUgZGlzYWJsZWQuIEluIHRoaXMgZXhhbXBsZSwgd2UgcHJvdmlkZSB0aGUgZmlsdGVyXG4gKiB3aGljaCBkaXNhYmxlcyB3ZWVrZGF5cy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRmlsdGVyLCBjYWxlbmRhci9jYWxlbmRhci1maWx0ZXIuY29tcG9uZW50KVxuICpcbiAqIFdlZWsgbnVtYmVycyBjb2x1bW4gY291bGQgYmUgZW5hYmxlZCB2aWEgYHNob3dXZWVrTnVtYmVyYCBiaW5kaW5nOlxuICogQHN0YWNrZWQtZXhhbXBsZShXZWVrIG51bWJlciwgY2FsZW5kYXIvY2FsZW5kYXItd2Vlay1udW1iZXIuY29tcG9uZW50KVxuICpcbiAqIElmIHlvdSBuZWVkIGNyZWF0ZSBjdXN0b20gY2VsbHMgeW91IGNhbiBlYXNpbHkgcHJvdmlkZSBjdXN0b20gY29tcG9uZW50cyBmb3JcbiAqIGNhbGVuZGFyLiBGb3IgZXhhbXBsZXMgaWYgeW91IHdhbnQgdG8gc2hvdyBhbnkgYXZlcmFnZSBwcmljZSB1bmRlciBlYWNoIGRhdGUgeW91IGNhblxuICoganVzdCBwcm92aWRlIGN1c3RvbSBgZGF5Q2VsbENvbXBvbmVudGAuIEN1c3RvbSBjZWxscyBmb3IgbW9udGggYW5kIHllYXIgY2FuIGJlIHByb3ZpZGVkXG4gKiB0aGUgc2FtZSB3YXksIGNoZWNrIEFQSSByZWZlcmVuY2UuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEN1c3RvbSBkYXkgY2VsbCwgY2FsZW5kYXIvY2FsZW5kYXItY3VzdG9tLWRheS1jZWxsLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY2FsZW5kYXItd2lkdGg6XG4gKiBjYWxlbmRhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItYm9yZGVyLXN0eWxlOlxuICogY2FsZW5kYXItYm9yZGVyLXdpZHRoOlxuICogY2FsZW5kYXItYm9yZGVyLXJhZGl1czpcbiAqIGNhbGVuZGFyLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2FsZW5kYXItdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLXBpY2tlci1wYWRkaW5nLXRvcDpcbiAqIGNhbGVuZGFyLXBpY2tlci1wYWRkaW5nLWJvdHRvbTpcbiAqIGNhbGVuZGFyLXBpY2tlci1wYWRkaW5nLXN0YXJ0OlxuICogY2FsZW5kYXItcGlja2VyLXBhZGRpbmctZW5kOlxuICogY2FsZW5kYXItbmF2aWdhdGlvbi10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItbmF2aWdhdGlvbi10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2FsZW5kYXItbmF2aWdhdGlvbi10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tdGl0bGUtdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tcGFkZGluZzpcbiAqIGNhbGVuZGFyLWNlbGwtaW5hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXNlbGVjdGVkLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXNlbGVjdGVkLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXNlbGVjdGVkLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktc2VsZWN0ZWQtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXNlbGVjdGVkLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaW4tcmFuZ2UtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaW4tcmFuZ2UtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaW4tcmFuZ2UtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1pbi1yYW5nZS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaW4tcmFuZ2UtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1zZWxlY3RlZC10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1zZWxlY3RlZC10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1zZWxlY3RlZC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXItZGF5LWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXItbW9udGgtY2VsbC13aWR0aDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXIteWVhci1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXIteWVhci1jZWxsLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktZGl2aWRlci13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWhvbGlkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItd2lkdGg6XG4gKiBjYWxlbmRhci1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXItZGF5LWNlbGwtbGFyZ2UtaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXItd2Vla251bWJlci1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXItbW9udGgtY2VsbC1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtbGFyZ2UtaGVpZ2h0OlxuICogY2FsZW5kYXIteWVhci1jZWxsLWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXIteWVhci1jZWxsLWxhcmdlLWhlaWdodDpcbiAqICovXG5jbGFzcyBOYkNhbGVuZGFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgICAgICogaW4gdGhlIGN1cnJlbnQgbW9udGggdmlldy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5ib3VuZGluZ01vbnRoID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgc3RhcnRpbmcgdmlldyBmb3IgY2FsZW5kYXIuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc3RhcnRWaWV3ID0gTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXJzIG5hdmlnYXRpb24gb3Igbm90LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNob3dOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvd1dlZWtOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgc3ltYm9sIHVzZWQgYXMgYSBoZWFkZXIgZm9yIHdlZWsgbnVtYmVycyBjb2x1bW5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyU3ltYm9sID0gJyMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgZGF0ZSB3aGVuIHNlbGVjdGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgZ2V0IHNob3dXZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1dlZWtOdW1iZXI7XG4gICAgfVxuICAgIHNldCBzaG93V2Vla051bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxufVxuTmJDYWxlbmRhckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWJhc2UtY2FsZW5kYXJcbiAgICAgIFtib3VuZGluZ01vbnRoXT1cImJvdW5kaW5nTW9udGhcIlxuICAgICAgW3N0YXJ0Vmlld109XCJzdGFydFZpZXdcIlxuICAgICAgW2RhdGVdPVwiZGF0ZVwiXG4gICAgICBbbWluXT1cIm1pblwiXG4gICAgICBbbWF4XT1cIm1heFwiXG4gICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICBbZGF5Q2VsbENvbXBvbmVudF09XCJkYXlDZWxsQ29tcG9uZW50XCJcbiAgICAgIFttb250aENlbGxDb21wb25lbnRdPVwibW9udGhDZWxsQ29tcG9uZW50XCJcbiAgICAgIFt5ZWFyQ2VsbENvbXBvbmVudF09XCJ5ZWFyQ2VsbENvbXBvbmVudFwiXG4gICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgIFt2aXNpYmxlRGF0ZV09XCJ2aXNpYmxlRGF0ZVwiXG4gICAgICBbc2hvd05hdmlnYXRpb25dPVwic2hvd05hdmlnYXRpb25cIlxuICAgICAgW3Nob3dXZWVrTnVtYmVyXT1cInNob3dXZWVrTnVtYmVyXCJcbiAgICAgIFt3ZWVrTnVtYmVyU3ltYm9sXT1cIndlZWtOdW1iZXJTeW1ib2xcIlxuICAgICAgKGRhdGVDaGFuZ2UpPVwiZGF0ZUNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgID48L25iLWJhc2UtY2FsZW5kYXI+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBib3VuZGluZ01vbnRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGFydFZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRheUNlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1vbnRoQ2VsbENvbXBvbmVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgeWVhckNlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93TmF2aWdhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd1dlZWtOdW1iZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdlZWtOdW1iZXJTeW1ib2w6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbmNsYXNzIE5iQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgaG9zdEVsZW1lbnQsIGNkLCB6b25lLCBzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdXR0b24gc2l6ZSwgYXZhaWxhYmxlIHNpemVzOlxuICAgICAgICAgKiBgdGlueWAsIGBzbWFsbGAsIGBtZWRpdW1gLCBgbGFyZ2VgLCBgZ2lhbnRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1dHRvbiBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnV0dG9uIHNoYXBlczogYHJlY3RhbmdsZWAsIGByb3VuZGAsIGBzZW1pLXJvdW5kYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9ICdyZWN0YW5nbGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnV0dG9uIGFwcGVhcmFuY2U6IGBmaWxsZWRgLCBgb3V0bGluZWAsIGBnaG9zdGAsIGBoZXJvYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2ZpbGxlZCc7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGBmaWxsZWRgIGFwcGVhcmFuY2VcbiAgICAgKi9cbiAgICBnZXQgZmlsbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlYXJhbmNlID09PSAnZmlsbGVkJztcbiAgICB9XG4gICAgc2V0IGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2ZpbGxlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBgb3V0bGluZWAgYXBwZWFyYW5jZVxuICAgICAqL1xuICAgIGdldCBvdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlYXJhbmNlID09PSAnb3V0bGluZSc7XG4gICAgfVxuICAgIHNldCBvdXRsaW5lKHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnb3V0bGluZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBgZ2hvc3RgIGFwcGVhcmFuY2VcbiAgICAgKi9cbiAgICBnZXQgZ2hvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdnaG9zdCc7XG4gICAgfVxuICAgIHNldCBnaG9zdCh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2dob3N0JztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgZWxlbWVudCB3aWxsIGZpbGwgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldCBmdWxsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxsV2lkdGg7XG4gICAgfVxuICAgIHNldCBmdWxsV2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZnVsbFdpZHRoID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIGJ1dHRvblxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgIT09IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gIXRoaXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgdGhpcy5kaXNhYmxlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaXNzdWUgIzc5NFxuICAgIGdldCB0YWJiYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnLTEnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhYkluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFiSW5kZXgudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCByZWN0YW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAncmVjdGFuZ2xlJztcbiAgICB9XG4gICAgZ2V0IHJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JvdW5kJztcbiAgICB9XG4gICAgZ2V0IHNlbWlSb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdzZW1pLXJvdW5kJztcbiAgICB9XG4gICAgZ2V0IGljb25MZWZ0KCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuaWNvbkVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAhIShpY29uICYmIGZpcnN0Q2hpbGROb3RDb21tZW50KGVsKSA9PT0gaWNvbik7XG4gICAgfVxuICAgIGdldCBpY29uUmlnaHQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5pY29uRWxlbWVudDtcbiAgICAgICAgcmV0dXJuICEhKGljb24gJiYgbGFzdENoaWxkTm90Q29tbWVudChlbCkgPT09IGljb24pO1xuICAgIH1cbiAgICBnZXQgYWRkaXRpb25hbENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1NlcnZpY2UuaXNDdXN0b21TdGF0dXModGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RhdHVzU2VydmljZS5nZXRTdGF0dXNDbGFzcyh0aGlzLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBUT0RPOiAjMjI1NFxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ25iLXRyYW5zaXRpb24nKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICoqL1xuICAgIHVwZGF0ZVByb3BlcnRpZXMoY29uZmlnKSB7XG4gICAgICAgIGxldCBpc1Byb3BlcnR5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0aGlzW2tleV0gIT09IGNvbmZpZ1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgaXNQcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3BlcnR5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWNvbkVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcignbmItaWNvbicpO1xuICAgIH1cbn1cbk5iQnV0dG9uLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUgfVxuXTtcbk5iQnV0dG9uLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBOYlN0YXR1c1NlcnZpY2UgfVxuXTtcbk5iQnV0dG9uLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hhcGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFwcGVhcmFuY2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbGxlZDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hcHBlYXJhbmNlLWZpbGxlZCcsXSB9XSxcbiAgICBvdXRsaW5lOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFwcGVhcmFuY2Utb3V0bGluZScsXSB9XSxcbiAgICBnaG9zdDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hcHBlYXJhbmNlLWdob3N0JyxdIH1dLFxuICAgIGZ1bGxXaWR0aDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5mdWxsLXdpZHRoJyxdIH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1kaXNhYmxlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmJ0bi1kaXNhYmxlZCcsXSB9XSxcbiAgICB0YWJJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiYmFibGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiaW5kZXgnLF0gfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcmVjdGFuZ2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yZWN0YW5nbGUnLF0gfV0sXG4gICAgcm91bmQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNoYXBlLXJvdW5kJyxdIH1dLFxuICAgIHNlbWlSb3VuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2hhcGUtc2VtaS1yb3VuZCcsXSB9XSxcbiAgICBpY29uTGVmdDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaWNvbi1zdGFydCcsXSB9XSxcbiAgICBpY29uUmlnaHQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmljb24tZW5kJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBCYXNpYyBidXR0b24gY29tcG9uZW50LlxuICpcbiAqIERlZmF1bHQgYnV0dG9uIHNpemUgaXMgYG1lZGl1bWAgYW5kIHN0YXR1cyBjb2xvciBpcyBgYmFzaWNgOlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gU2hvd2Nhc2UsIGJ1dHRvbi9idXR0b24tc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJCdXR0b24+PC9idXR0b24+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQnV0dG9uTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkJ1dHRvbk1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQnV0dG9ucyBhcmUgYXZhaWxhYmxlIGluIG11bHRpcGxlIGNvbG9ycyB1c2luZyBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIENvbG9ycywgYnV0dG9uL2J1dHRvbi1jb2xvcnMuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIGJ1dHRvbiBzaXplczpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbiBTaXplcywgYnV0dG9uL2J1dHRvbi1zaXplcy5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBBbmQgdHdvIGFkZGl0aW9uYWwgc3R5bGUgdHlwZXMgLSBgb3V0bGluZWA6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShPdXRsaW5lIEJ1dHRvbnMsIGJ1dHRvbi9idXR0b24tb3V0bGluZS5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBhbmQgYGhlcm9gOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIEhlcm8sIGJ1dHRvbi9idXR0b24taGVyby5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBCdXR0b25zIGF2YWlsYWJsZSBpbiBkaWZmZXJlbnQgc2hhcGVzLCB3aGljaCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIHRoZSBvdGhlciBwcm9wZXJ0aWVzOlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gU2hhcGVzLCBidXR0b24vYnV0dG9uLXNoYXBlcy5jb21wb25lbnQpXG4gKlxuICogYG5iQnV0dG9uYCBjb3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBmb2xsb3dpbmcgc2VsZWN0b3JzIC0gYGJ1dHRvbmAsIGBpbnB1dFt0eXBlPVwiYnV0dG9uXCJdYCwgYGlucHV0W3R5cGU9XCJzdWJtaXRcIl1gXG4gKiBhbmQgYGFgOlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gRWxlbWVudHMsIGJ1dHRvbi9idXR0b24tdHlwZXMuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogQnV0dG9uIGNhbiBiZSBtYWRlIGBmdWxsV2lkdGhgOlxuICogQHN0YWNrZWQtZXhhbXBsZShGdWxsIFdpZHRoIEJ1dHRvbiwgYnV0dG9uL2J1dHRvbi1mdWxsLXdpZHRoLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIEljb24gY2FuIGJlIHBsYWNlZCBpbnNpZGUgb2YgYSBidXR0b24gYXMgYSBjaGlsZCBlbGVtZW50OlxuICogQHN0YWNrZWQtZXhhbXBsZShJY29uIEJ1dHRvbiwgYnV0dG9uL2J1dHRvbi1pY29uLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoSW50ZXJhY3RpdmUgZXhhbXBsZSwgYnV0dG9uL2J1dHRvbi1pbnRlcmFjdGl2ZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGJ1dHRvbi1jdXJzb3I6XG4gKiBidXR0b24tb3V0bGluZS13aWR0aDpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbG9yOlxuICogYnV0dG9uLXRleHQtZm9udC1mYW1pbHk6XG4gKiBidXR0b24tdGV4dC1mb250LXdlaWdodDpcbiAqIGJ1dHRvbi1kaXNhYmxlZC1jdXJzb3I6XG4gKiBidXR0b24tdGlueS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGJ1dHRvbi10aW55LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBidXR0b24tdGlueS1pY29uLXNpemU6XG4gKiBidXR0b24tdGlueS1pY29uLXZlcnRpY2FsLW1hcmdpbjpcbiAqIGJ1dHRvbi10aW55LWljb24tb2Zmc2V0OlxuICogYnV0dG9uLXNtYWxsLXRleHQtZm9udC1zaXplOlxuICogYnV0dG9uLXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBidXR0b24tc21hbGwtaWNvbi1zaXplOlxuICogYnV0dG9uLXNtYWxsLWljb24tdmVydGljYWwtbWFyZ2luOlxuICogYnV0dG9uLXNtYWxsLWljb24tb2Zmc2V0OlxuICogYnV0dG9uLW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGJ1dHRvbi1tZWRpdW0tdGV4dC1saW5lLWhlaWdodDpcbiAqIGJ1dHRvbi1tZWRpdW0taWNvbi1zaXplOlxuICogYnV0dG9uLW1lZGl1bS1pY29uLXZlcnRpY2FsLW1hcmdpbjpcbiAqIGJ1dHRvbi1tZWRpdW0taWNvbi1vZmZzZXQ6XG4gKiBidXR0b24tbGFyZ2UtdGV4dC1mb250LXNpemU6XG4gKiBidXR0b24tbGFyZ2UtdGV4dC1saW5lLWhlaWdodDpcbiAqIGJ1dHRvbi1sYXJnZS1pY29uLXNpemU6XG4gKiBidXR0b24tbGFyZ2UtaWNvbi12ZXJ0aWNhbC1tYXJnaW46XG4gKiBidXR0b24tbGFyZ2UtaWNvbi1vZmZzZXQ6XG4gKiBidXR0b24tZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBidXR0b24tZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGJ1dHRvbi1naWFudC1pY29uLXNpemU6XG4gKiBidXR0b24tZ2lhbnQtaWNvbi12ZXJ0aWNhbC1tYXJnaW46XG4gKiBidXR0b24tZ2lhbnQtaWNvbi1vZmZzZXQ6XG4gKiBidXR0b24tcmVjdGFuZ2xlLWJvcmRlci1yYWRpdXM6XG4gKiBidXR0b24tc2VtaS1yb3VuZC1ib3JkZXItcmFkaXVzOlxuICogYnV0dG9uLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiBidXR0b24tZmlsbGVkLWJvcmRlci1zdHlsZTpcbiAqIGJ1dHRvbi1maWxsZWQtYm9yZGVyLXdpZHRoOlxuICogYnV0dG9uLWZpbGxlZC10ZXh0LXRyYW5zZm9ybTpcbiAqIGJ1dHRvbi1maWxsZWQtdGlueS1wYWRkaW5nOlxuICogYnV0dG9uLWZpbGxlZC1zbWFsbC1wYWRkaW5nOlxuICogYnV0dG9uLWZpbGxlZC1tZWRpdW0tcGFkZGluZzpcbiAqIGJ1dHRvbi1maWxsZWQtbGFyZ2UtcGFkZGluZzpcbiAqIGJ1dHRvbi1maWxsZWQtZ2lhbnQtcGFkZGluZzpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJvcmRlci1zdHlsZTpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJvcmRlci13aWR0aDpcbiAqIGJ1dHRvbi1vdXRsaW5lLXRleHQtdHJhbnNmb3JtOlxuICogYnV0dG9uLW91dGxpbmUtZm9jdXMtaW5zZXQtc2hhZG93LWxlbmd0aDpcbiAqIGJ1dHRvbi1vdXRsaW5lLXRpbnktcGFkZGluZzpcbiAqIGJ1dHRvbi1vdXRsaW5lLXNtYWxsLXBhZGRpbmc6XG4gKiBidXR0b24tb3V0bGluZS1tZWRpdW0tcGFkZGluZzpcbiAqIGJ1dHRvbi1vdXRsaW5lLWxhcmdlLXBhZGRpbmc6XG4gKiBidXR0b24tb3V0bGluZS1naWFudC1wYWRkaW5nOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1ib3JkZXItc3R5bGU6XG4gKiBidXR0b24tZ2hvc3QtYm9yZGVyLXdpZHRoOlxuICogYnV0dG9uLWdob3N0LXRleHQtdHJhbnNmb3JtOlxuICogYnV0dG9uLWdob3N0LWZvY3VzLWluc2V0LXNoYWRvdy1sZW5ndGg6XG4gKiBidXR0b24tZ2hvc3QtdGlueS1wYWRkaW5nOlxuICogYnV0dG9uLWdob3N0LXNtYWxsLXBhZGRpbmc6XG4gKiBidXR0b24tZ2hvc3QtbWVkaXVtLXBhZGRpbmc6XG4gKiBidXR0b24tZ2hvc3QtbGFyZ2UtcGFkZGluZzpcbiAqIGJ1dHRvbi1naG9zdC1naWFudC1wYWRkaW5nOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYm9yZGVyLXN0eWxlOlxuICogYnV0dG9uLWhlcm8tYm9yZGVyLXdpZHRoOlxuICogYnV0dG9uLWhlcm8tdGV4dC10cmFuc2Zvcm06XG4gKiBidXR0b24taGVyby10aW55LXBhZGRpbmc6XG4gKiBidXR0b24taGVyby1zbWFsbC1wYWRkaW5nOlxuICogYnV0dG9uLWhlcm8tbWVkaXVtLXBhZGRpbmc6XG4gKiBidXR0b24taGVyby1sYXJnZS1wYWRkaW5nOlxuICogYnV0dG9uLWhlcm8tZ2lhbnQtcGFkZGluZzpcbiAqIGJ1dHRvbi1oZXJvLXNoYWRvdzpcbiAqIGJ1dHRvbi1oZXJvLXRleHQtc2hhZG93OlxuICogYnV0dG9uLWhlcm8tYmV2ZWwtc2l6ZTpcbiAqIGJ1dHRvbi1oZXJvLWdsb3ctc2l6ZTpcbiAqIGJ1dHRvbi1oZXJvLW91dGxpbmUtY29sb3I6XG4gKiBidXR0b24taGVyby1vdXRsaW5lLXdpZHRoOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtZ2xvdy1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWFjdGl2ZS1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1iZXZlbC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktZ2xvdy1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktYWN0aXZlLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1hY3RpdmUtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tYmV2ZWwtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWdsb3ctY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWFjdGl2ZS1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWFjdGl2ZS1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1iZXZlbC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctZ2xvdy1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctYWN0aXZlLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1iZXZlbC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWFjdGl2ZS1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItYWN0aXZlLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1iZXZlbC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtZ2xvdy1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtYWN0aXZlLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKi9cbmNsYXNzIE5iQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgTmJCdXR0b24ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBob3N0RWxlbWVudCwgY2QsIHpvbmUsIHN0YXR1c1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIsIGhvc3RFbGVtZW50LCBjZCwgem9uZSwgc3RhdHVzU2VydmljZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYGhlcm9gIGFwcGVhcmFuY2VcbiAgICAgKi9cbiAgICBnZXQgaGVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2hlcm8nO1xuICAgIH1cbiAgICBzZXQgaGVybyh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2hlcm8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBLZWVwIHRoaXMgaGFuZGxlciB0byBwYXJ0aWFsbHkgc3VwcG9ydCBhbmNob3IgZGlzYWJsaW5nLlxuICAgICAqIFVubGlrZSBidXR0b24sIGFuY2hvciBkb2Vzbid0IGhhdmUgJ2Rpc2FibGVkJyBET00gcHJvcGVydHksXG4gICAgICogc28gaGFuZGxlciB3aWxsIGJlIGNhbGxlZCBhbnl3YXkuIFdlIHByZXZlbnRpbmcgbmF2aWdhdGlvbiBhbmQgYnViYmxpbmcuXG4gICAgICogRGlzYWJsaW5nIGlzIHBhcnRpYWwgZHVlIHRvIGNsaWNrIGhhbmRsZXJzIHByZWNlZGVuY2UuIENvbnNpZGVyIGV4YW1wbGU6XG4gICAgICogPGEgbmJCdXR0b24gW2Rpc2FibGVkXT1cInRydWVcIiAoY2xpY2spPVwiY2xpY2tIYW5kbGVyKClcIj4uLi48L2E+XG4gICAgICogJ2NsaWNrSGFuZGxlcicgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIG91ciBob3N0IGxpc3RlbmVyIGJlbG93LiBXZSBjYW4ndCBwcmV2ZW50XG4gICAgICogc3VjaCBoYW5kbGVycyBjYWxsLlxuICAgICAqL1xuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iQnV0dG9uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbmJCdXR0b25dLGFbbmJCdXR0b25dLGlucHV0W3R5cGU9XCJidXR0b25cIl1bbmJCdXR0b25dLGlucHV0W3R5cGU9XCJzdWJtaXRcIl1bbmJCdXR0b25dJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkJ1dHRvbiwgdXNlRXhpc3Rpbmc6IE5iQnV0dG9uQ29tcG9uZW50IH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkJ1dHRvbkNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYkJ1dHRvbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBoZXJvOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFwcGVhcmFuY2UtaGVybycsXSB9XSxcbiAgICBwcmltYXJ5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtcHJpbWFyeScsXSB9XSxcbiAgICBpbmZvOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtaW5mbycsXSB9XSxcbiAgICBzdWNjZXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtc3VjY2VzcycsXSB9XSxcbiAgICB3YXJuaW5nOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtd2FybmluZycsXSB9XSxcbiAgICBkYW5nZXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1kYW5nZXInLF0gfV0sXG4gICAgYmFzaWM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1iYXNpYycsXSB9XSxcbiAgICBjb250cm9sOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtY29udHJvbCcsXSB9XSxcbiAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IE5CX0JVVFRPTl9DT01QT05FTlRTID0gW1xuICAgIE5iQnV0dG9uQ29tcG9uZW50LFxuXTtcbmNsYXNzIE5iQnV0dG9uTW9kdWxlIHtcbn1cbk5iQnV0dG9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX0JVVFRPTl9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9CVVRUT05fQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJEYXRlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuREFZU19JTl9XRUVLID0gNztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBob3VycyBpbiBBTS9QTSBkYXkgcGVyaW9kcy5cbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLkhPVVJTX0lOX0RBWV9QRVJJT0QgPSAxMjtcbiAgICB9XG4gICAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkYXRlIGlzIGJldHdlZW4gdGhlIHN0YXJ0IGRhdGUgYW5kIHRoZSBlbmQgZGF0ZS5cbiAgICAgKiAqL1xuICAgIGlzQmV0d2VlbihkYXRlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVEYXRlcyhkYXRlLCBzdGFydCkgPiAwICYmIHRoaXMuY29tcGFyZURhdGVzKGRhdGUsIGVuZCkgPCAwO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlzIHR3byBkYXRlcyBoYXZlIHRoZSBzYW1lIGRheS5cbiAgICAgKiAqL1xuICAgIGlzU2FtZURheVNhZmUoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBkYXRlMSAmJiBkYXRlMiAmJiB0aGlzLmlzU2FtZURheShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlzIHR3byBkYXRlcyBoYXZlIHRoZSBzYW1lIG1vbnRoLlxuICAgICAqICovXG4gICAgaXNTYW1lTW9udGhTYWZlKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEgJiYgZGF0ZTIgJiYgdGhpcy5pc1NhbWVNb250aChkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaXMgdHdvIGRhdGVzIGhhdmUgdGhlIHNhbWUgeWVhci5cbiAgICAgKiAqL1xuICAgIGlzU2FtZVllYXJTYWZlKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEgJiYgZGF0ZTIgJiYgdGhpcy5pc1NhbWVZZWFyKGRhdGUxLCBkYXRlMik7XG4gICAgfVxuICAgIGlzU2FtZUhvdXJBbmRNaW51dGUoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZUhvdXIoZGF0ZTEsIGRhdGUyKSAmJiB0aGlzLmlzU2FtZU1pbnV0ZShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICBpc1NhbWVIb3VyKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIb3VycyhkYXRlMSkgPT09IHRoaXMuZ2V0SG91cnMoZGF0ZTIpO1xuICAgIH1cbiAgICBpc1NhbWVNaW51dGUoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1pbnV0ZXMoZGF0ZTEpID09PSB0aGlzLmdldE1pbnV0ZXMoZGF0ZTIpO1xuICAgIH1cbiAgICBnZXRUd2VudHlGb3VySG91cnNGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiAnSEg6bW0nO1xuICAgIH1cbiAgICBnZXRUd2VudHlGb3VySG91cnNGb3JtYXRXaXRoU2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuICdISDptbTpzcyc7XG4gICAgfVxuICAgIGdldFR3ZWx2ZUhvdXJzRm9ybWF0V2l0aFNlY29uZHMoKSB7XG4gICAgICAgIHJldHVybiAnaGg6bW06c3MgYSc7XG4gICAgfVxuICAgIGdldERheVBlcmlvZChkYXRlKSB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3REYXlQZXJpb2QgPSB0aGlzLmdldEhvdXJzKGRhdGUpIDwgdGhpcy5IT1VSU19JTl9EQVlfUEVSSU9EO1xuICAgICAgICBpZiAoaXNGaXJzdERheVBlcmlvZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQU1cIiAvKiBBTSAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlBNXCIgLyogUE0gKi87XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IGJhdGNoID0gKHRhcmdldCwgYmF0Y2hTaXplLCBvZmZzZXQgPSAwKSA9PiB7XG4gICAgcmV0dXJuIHRhcmdldC5yZWR1Y2UoKHJlcywgaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmtJbmRleCA9IE1hdGguZmxvb3IoKGluZGV4ICsgb2Zmc2V0KSAvIGJhdGNoU2l6ZSk7XG4gICAgICAgIGlmICghcmVzW2NodW5rSW5kZXhdKSB7XG4gICAgICAgICAgICByZXNbY2h1bmtJbmRleF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXNbY2h1bmtJbmRleF0ucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG59O1xuLyoqXG4gKiByZXR1cm5zIGFycmF5IHdpdGggbnVtYmVycyBmcm9tIGZpcnN0IGFyZ3VtZW50IHRvIGJvdW5kLlxuICogKi9cbmNvbnN0IHJhbmdlRnJvbVRvID0gKGZyb20kJDEsIHRvID0gMCwgcHJvZHVjZXIgPSBpID0+IGkpID0+IHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gZnJvbSQkMTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2gocHJvZHVjZXIoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcbi8qKlxuICogcmV0dXJucyBhcnJheSB3aXRoIG51bWJlcnMgZnJvbSB6ZXJvIHRvIGJvdW5kLlxuICogKi9cbmNvbnN0IHJhbmdlID0gKGJvdW5kLCBwcm9kdWNlciA9IGkgPT4gaSkgPT4ge1xuICAgIHJldHVybiByYW5nZUZyb21UbygwLCBib3VuZCwgcHJvZHVjZXIpO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhck1vbnRoTW9kZWxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgfVxuICAgIGNyZWF0ZURheXNHcmlkKGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB3ZWVrcyA9IHRoaXMuY3JlYXRlRGF0ZXMoYWN0aXZlTW9udGgpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoQm91bmRpbmdNb250aHMod2Vla3MsIGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoKTtcbiAgICB9XG4gICAgY3JlYXRlRGF0ZXMoYWN0aXZlTW9udGgpIHtcbiAgICAgICAgY29uc3QgZGF5cyA9IHRoaXMuY3JlYXRlRGF0ZVJhbmdlRm9yTW9udGgoYWN0aXZlTW9udGgpO1xuICAgICAgICBjb25zdCBzdGFydE9mV2Vla0RheURpZmYgPSB0aGlzLmdldFN0YXJ0T2ZXZWVrRGF5RGlmZihhY3RpdmVNb250aCk7XG4gICAgICAgIHJldHVybiBiYXRjaChkYXlzLCB0aGlzLmRhdGVTZXJ2aWNlLkRBWVNfSU5fV0VFSywgc3RhcnRPZldlZWtEYXlEaWZmKTtcbiAgICB9XG4gICAgd2l0aEJvdW5kaW5nTW9udGhzKHdlZWtzLCBhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCkge1xuICAgICAgICBsZXQgd2l0aEJvdW5kaW5nTW9udGhzID0gd2Vla3M7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvdWxkQWRkUHJldkJvdW5kaW5nTW9udGgod2l0aEJvdW5kaW5nTW9udGhzKSkge1xuICAgICAgICAgICAgd2l0aEJvdW5kaW5nTW9udGhzID0gdGhpcy5hZGRQcmV2Qm91bmRpbmdNb250aCh3aXRoQm91bmRpbmdNb250aHMsIGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1Nob3VsZEFkZE5leHRCb3VuZGluZ01vbnRoKHdpdGhCb3VuZGluZ01vbnRocykpIHtcbiAgICAgICAgICAgIHdpdGhCb3VuZGluZ01vbnRocyA9IHRoaXMuYWRkTmV4dEJvdW5kaW5nTW9udGgod2l0aEJvdW5kaW5nTW9udGhzLCBhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhCb3VuZGluZ01vbnRocztcbiAgICB9XG4gICAgYWRkUHJldkJvdW5kaW5nTW9udGgod2Vla3MsIGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0V2VlayA9IHdlZWtzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkSXRlbXMgPSB0aGlzLmRhdGVTZXJ2aWNlLkRBWVNfSU5fV0VFSyAtIGZpcnN0V2Vlay5sZW5ndGg7XG4gICAgICAgIGZpcnN0V2Vlay51bnNoaWZ0KC4uLnRoaXMuY3JlYXRlUHJldkJvdW5kaW5nRGF5cyhhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCwgcmVxdWlyZWRJdGVtcykpO1xuICAgICAgICByZXR1cm4gW2ZpcnN0V2VlaywgLi4ud2Vla3NdO1xuICAgIH1cbiAgICBhZGROZXh0Qm91bmRpbmdNb250aCh3ZWVrcywgYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgpIHtcbiAgICAgICAgY29uc3QgbGFzdFdlZWsgPSB3ZWVrcy5wb3AoKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRJdGVtcyA9IHRoaXMuZGF0ZVNlcnZpY2UuREFZU19JTl9XRUVLIC0gbGFzdFdlZWsubGVuZ3RoO1xuICAgICAgICBsYXN0V2Vlay5wdXNoKC4uLnRoaXMuY3JlYXRlTmV4dEJvdW5kaW5nRGF5cyhhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCwgcmVxdWlyZWRJdGVtcykpO1xuICAgICAgICByZXR1cm4gWy4uLndlZWtzLCBsYXN0V2Vla107XG4gICAgfVxuICAgIGNyZWF0ZVByZXZCb3VuZGluZ0RheXMoYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgsIHJlcXVpcmVkSXRlbXMpIHtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZE1vbnRoKGFjdGl2ZU1vbnRoLCAtMSk7XG4gICAgICAgIGNvbnN0IGRheXNJbk1vbnRoID0gdGhpcy5kYXRlU2VydmljZS5nZXROdW1iZXJPZkRheXNJbk1vbnRoKG1vbnRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGF0ZVJhbmdlRm9yTW9udGgobW9udGgpXG4gICAgICAgICAgICAuc2xpY2UoZGF5c0luTW9udGggLSByZXF1aXJlZEl0ZW1zKVxuICAgICAgICAgICAgLm1hcChkYXRlID0+IGJvdW5kaW5nTW9udGggPyBkYXRlIDogbnVsbCk7XG4gICAgfVxuICAgIGNyZWF0ZU5leHRCb3VuZGluZ0RheXMoYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgsIHJlcXVpcmVkSXRlbXMpIHtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZE1vbnRoKGFjdGl2ZU1vbnRoLCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGF0ZVJhbmdlRm9yTW9udGgobW9udGgpXG4gICAgICAgICAgICAuc2xpY2UoMCwgcmVxdWlyZWRJdGVtcylcbiAgICAgICAgICAgIC5tYXAoZGF0ZSA9PiBib3VuZGluZ01vbnRoID8gZGF0ZSA6IG51bGwpO1xuICAgIH1cbiAgICBnZXRTdGFydE9mV2Vla0RheURpZmYoZGF0ZSkge1xuICAgICAgICBjb25zdCBzdGFydE9mTW9udGggPSB0aGlzLmRhdGVTZXJ2aWNlLmdldE1vbnRoU3RhcnQoZGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdlZWtTdGFydERpZmYoc3RhcnRPZk1vbnRoKTtcbiAgICB9XG4gICAgZ2V0V2Vla1N0YXJ0RGlmZihkYXRlKSB7XG4gICAgICAgIHJldHVybiAoNyAtIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0Rmlyc3REYXlPZldlZWsoKSArIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF5T2ZXZWVrKGRhdGUpKSAlIDc7XG4gICAgfVxuICAgIGlzU2hvdWxkQWRkUHJldkJvdW5kaW5nTW9udGgod2Vla3MpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzWzBdLmxlbmd0aCA8IHRoaXMuZGF0ZVNlcnZpY2UuREFZU19JTl9XRUVLO1xuICAgIH1cbiAgICBpc1Nob3VsZEFkZE5leHRCb3VuZGluZ01vbnRoKHdlZWtzKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc1t3ZWVrcy5sZW5ndGggLSAxXS5sZW5ndGggPCB0aGlzLmRhdGVTZXJ2aWNlLkRBWVNfSU5fV0VFSztcbiAgICB9XG4gICAgY3JlYXRlRGF0ZVJhbmdlRm9yTW9udGgoZGF0ZSkge1xuICAgICAgICBjb25zdCBkYXlzSW5Nb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TnVtYmVyT2ZEYXlzSW5Nb250aChkYXRlKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKGRheXNJbk1vbnRoLCBpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHllYXIgPSB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIoZGF0ZSk7XG4gICAgICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGgoZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5jcmVhdGVEYXRlKHllYXIsIG1vbnRoLCBpICsgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJNb250aE1vZGVsU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJDYWxlbmRhck1vbnRoTW9kZWxTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJEYXRlU2VydmljZSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNpemUgPSBOYkNhbGVuZGFyU2l6ZS5NRURJVU07XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICAgICAgdGhpcy5kYXlDZWxsQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgdG9kYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZURheVNhZmUodGhpcy5kYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCkpO1xuICAgIH1cbiAgICBnZXQgYm91bmRpbmdNb250aCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZU1vbnRoU2FmZSh0aGlzLmRhdGUsIHRoaXMudmlzaWJsZURhdGUpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZURheVNhZmUodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtYWxsZXJUaGFuTWluKCkgfHwgdGhpcy5ncmVhdGVyVGhhbk1heCgpIHx8IHRoaXMuZG9udEZpdEZpbHRlcigpO1xuICAgIH1cbiAgICBnZXQgaXNMYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gTmJDYWxlbmRhclNpemUuTEFSR0U7XG4gICAgfVxuICAgIGdldCBkYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlU2VydmljZS5nZXREYXRlKHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHNtYWxsZXJUaGFuTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWluICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMuZGF0ZSwgdGhpcy5taW4pIDwgMDtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5NYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5tYXggJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICBkb250Rml0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuZmlsdGVyICYmICF0aGlzLmZpbHRlcih0aGlzLmRhdGUpO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1kYXktY2VsbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY2VsbC1jb250ZW50XCI+XG4gICAgICB7eyBkYXkgfX1cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkVmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB0b2RheTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MudG9kYXknLF0gfV0sXG4gICAgYm91bmRpbmdNb250aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYm91bmRpbmctbW9udGgnLF0gfV0sXG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNlbGVjdGVkJyxdIH1dLFxuICAgIGVtcHR5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5lbXB0eScsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZGlzYWJsZWQnLF0gfV0sXG4gICAgaXNMYXJnZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1sYXJnZScsXSB9XSxcbiAgICBkYXlDZWxsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRheS1jZWxsJyxdIH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBjYXBhYmlsaXR5IHBpY2sgZGF5cy5cbiAqICovXG5jbGFzcyBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihtb250aE1vZGVsKSB7XG4gICAgICAgIHRoaXMubW9udGhNb2RlbCA9IG1vbnRoTW9kZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAgICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYm91bmRpbmdNb250aHMgPSB0cnVlO1xuICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgbmV3bHkgc2VsZWN0ZWQgZGF0ZS5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5kYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZGF5IGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHNldCBzZXRDZWxsQ29tcG9uZW50KGNlbGxDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNlbGxDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbENvbXBvbmVudCA9IGNlbGxDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93V2Vla051bWJlcjtcbiAgICB9XG4gICAgc2V0IHNob3dXZWVrTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoeyB2aXNpYmxlRGF0ZSwgYm91bmRpbmdNb250aHMgfSkge1xuICAgICAgICBpZiAodmlzaWJsZURhdGUgfHwgYm91bmRpbmdNb250aHMpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla3MgPSB0aGlzLm1vbnRoTW9kZWwuY3JlYXRlRGF5c0dyaWQodGhpcy52aXNpYmxlRGF0ZSwgdGhpcy5ib3VuZGluZ01vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3QoZGF5KSB7XG4gICAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KGRheSk7XG4gICAgfVxufVxuTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItZGF5LXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2FsZW5kYXItd2Vlay1udW1iZXJzICpuZ0lmPVwic2hvd1dlZWtOdW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtzXT1cIndlZWtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJTeW1ib2xdPVwid2Vla051bWJlclN5bWJvbFwiPlxuICAgIDwvbmItY2FsZW5kYXItd2Vlay1udW1iZXJzPlxuICAgIDxkaXYgY2xhc3M9XCJkYXlzLWNvbnRhaW5lclwiPlxuICAgICAgPG5iLWNhbGVuZGFyLWRheXMtbmFtZXMgW3NpemVdPVwic2l6ZVwiPjwvbmItY2FsZW5kYXItZGF5cy1uYW1lcz5cbiAgICAgIDxuYi1jYWxlbmRhci1waWNrZXJcbiAgICAgICAgICBbZGF0YV09XCJ3ZWVrc1wiXG4gICAgICAgICAgW3Zpc2libGVEYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgICAgICBbc2VsZWN0ZWRWYWx1ZV09XCJkYXRlXCJcbiAgICAgICAgICBbY2VsbENvbXBvbmVudF09XCJjZWxsQ29tcG9uZW50XCJcbiAgICAgICAgICBbbWluXT1cIm1pblwiXG4gICAgICAgICAgW21heF09XCJtYXhcIlxuICAgICAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgICAgICAoc2VsZWN0KT1cIm9uU2VsZWN0KCRldmVudClcIj5cbiAgICAgIDwvbmItY2FsZW5kYXItcGlja2VyPlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4fS5kYXlzLWNvbnRhaW5lcnt3aWR0aDoxMDAlfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJDYWxlbmRhck1vbnRoTW9kZWxTZXJ2aWNlIH1cbl07XG5OYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBib3VuZGluZ01vbnRoczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2V0Q2VsbENvbXBvbmVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnY2VsbENvbXBvbmVudCcsXSB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93V2Vla051bWJlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgd2Vla051bWJlclN5bWJvbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyRGF5c05hbWVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBpc0xhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGRheXMgPSB0aGlzLmNyZWF0ZURheXNOYW1lcygpO1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLnNoaWZ0U3RhcnRPZldlZWsoZGF5cyk7XG4gICAgfVxuICAgIGNyZWF0ZURheXNOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF5T2ZXZWVrTmFtZXMoKVxuICAgICAgICAgICAgLm1hcCh0aGlzLm1hcmtJZkhvbGlkYXkpO1xuICAgIH1cbiAgICBzaGlmdFN0YXJ0T2ZXZWVrKGRheXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGVTZXJ2aWNlLmdldEZpcnN0RGF5T2ZXZWVrKCk7IGkrKykge1xuICAgICAgICAgICAgZGF5cy5wdXNoKGRheXMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRheXM7XG4gICAgfVxuICAgIG1hcmtJZkhvbGlkYXkobmFtZSwgaSkge1xuICAgICAgICByZXR1cm4geyBuYW1lLCBpc0hvbGlkYXk6IGkgJSA2ID09PSAwIH07XG4gICAgfVxufVxuTmJDYWxlbmRhckRheXNOYW1lc0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItZGF5cy1uYW1lcycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiZGF5XCIgKm5nRm9yPVwibGV0IGRheSBvZiBkYXlzXCIgW2NsYXNzLmhvbGlkYXldPVwiZGF5LmlzSG9saWRheVwiPnt7IGRheS5uYW1lIH19PC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59Omhvc3QgLmRheXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJEYXlzTmFtZXNDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH1cbl07XG5OYkNhbGVuZGFyRGF5c05hbWVzQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGlzTGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMubW9udGhDZWxsQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZU1vbnRoU2FmZSh0aGlzLmRhdGUsIHRoaXMuc2VsZWN0ZWRWYWx1ZSk7XG4gICAgfVxuICAgIGdldCB0b2RheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lTW9udGhTYWZlKHRoaXMuZGF0ZSwgdGhpcy5kYXRlU2VydmljZS50b2RheSgpKTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbWFsbGVyVGhhbk1pbigpIHx8IHRoaXMuZ3JlYXRlclRoYW5NYXgoKTtcbiAgICB9XG4gICAgZ2V0IGlzTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBnZXQgbW9udGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldE1vbnRoTmFtZSh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgc21hbGxlclRoYW5NaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5taW4gJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5tb250aEVuZCgpLCB0aGlzLm1pbikgPCAwO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1heCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLm1vbnRoU3RhcnQoKSwgdGhpcy5tYXgpID4gMDtcbiAgICB9XG4gICAgbW9udGhTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhTdGFydCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBtb250aEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhFbmQodGhpcy5kYXRlKTtcbiAgICB9XG59XG5OYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1tb250aC1jZWxsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjZWxsLWNvbnRlbnRcIj5cbiAgICAgIHt7IG1vbnRoIH19XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWRWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zZWxlY3RlZCcsXSB9XSxcbiAgICB0b2RheTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MudG9kYXknLF0gfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRpc2FibGVkJyxdIH1dLFxuICAgIGlzTGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgbW9udGhDZWxsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm1vbnRoLWNlbGwnLF0gfV0sXG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBNT05USFNfSU5fVklFVyA9IDEyO1xuY29uc3QgTU9OVEhTX0lOX0NPTFVNTiA9IDQ7XG5jbGFzcyBOYkNhbGVuZGFyTW9udGhQaWNrZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLm1vbnRoQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50O1xuICAgIH1cbiAgICBzZXQgX2NlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ29tcG9uZW50ID0gY2VsbENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRNb250aHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0TW9udGhzKCkge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlU2VydmljZS5nZXREYXRlKHRoaXMubW9udGgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHRoaXMubW9udGgpO1xuICAgICAgICBjb25zdCBmaXJzdE1vbnRoID0gdGhpcy5kYXRlU2VydmljZS5jcmVhdGVEYXRlKHllYXIsIDAsIGRhdGUpO1xuICAgICAgICBjb25zdCBtb250aHMgPSBbZmlyc3RNb250aF07XG4gICAgICAgIGZvciAobGV0IG1vbnRoSW5kZXggPSAxOyBtb250aEluZGV4IDwgTU9OVEhTX0lOX1ZJRVc7IG1vbnRoSW5kZXgrKykge1xuICAgICAgICAgICAgbW9udGhzLnB1c2godGhpcy5kYXRlU2VydmljZS5hZGRNb250aChmaXJzdE1vbnRoLCBtb250aEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb250aHMgPSBiYXRjaChtb250aHMsIE1PTlRIU19JTl9DT0xVTU4pO1xuICAgIH1cbiAgICBvblNlbGVjdChtb250aCkge1xuICAgICAgICB0aGlzLm1vbnRoQ2hhbmdlLmVtaXQobW9udGgpO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItbW9udGgtcGlja2VyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1jYWxlbmRhci1waWNrZXJcbiAgICAgIFtkYXRhXT1cIm1vbnRoc1wiXG4gICAgICBbbWluXT1cIm1pblwiXG4gICAgICBbbWF4XT1cIm1heFwiXG4gICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICBbc2VsZWN0ZWRWYWx1ZV09XCJkYXRlXCJcbiAgICAgIFt2aXNpYmxlRGF0ZV09XCJtb250aFwiXG4gICAgICBbY2VsbENvbXBvbmVudF09XCJjZWxsQ29tcG9uZW50XCJcbiAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgKHNlbGVjdCk9XCJvblNlbGVjdCgkZXZlbnQpXCI+XG4gICAgPC9uYi1jYWxlbmRhci1waWNrZXI+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJEYXRlU2VydmljZSB9XG5dO1xuTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1vbnRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtb250aENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIF9jZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydjZWxsQ29tcG9uZW50JyxdIH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dXG59O1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMueWVhcnNJblZpZXcgPSAxMjtcbiAgICAgICAgdGhpcy55ZWFyc0luUm93ID0gNDtcbiAgICB9XG4gICAgZ2V0WWVhcnNJblZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXJzSW5WaWV3O1xuICAgIH1cbiAgICBnZXRZZWFyc0luUm93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyc0luUm93O1xuICAgIH1cbiAgICBnZXRWaWV3WWVhcnModmlld1llYXIpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhcih2aWV3WWVhcik7XG4gICAgICAgIGxldCB2aWV3U3RhcnRZZWFyO1xuICAgICAgICBpZiAoeWVhciA+PSAwKSB7XG4gICAgICAgICAgICB2aWV3U3RhcnRZZWFyID0geWVhciAtICh5ZWFyICUgdGhpcy55ZWFyc0luVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3U3RhcnRZZWFyID0geWVhciAtICh5ZWFyICUgdGhpcy55ZWFyc0luVmlldyArIHRoaXMueWVhcnNJblZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHllYXJzID0gcmFuZ2UodGhpcy55ZWFyc0luVmlldykubWFwKGkgPT4gdGhpcy5jb3B5V2l0aFllYXIodmlld1N0YXJ0WWVhciArIGksIHZpZXdZZWFyKSk7XG4gICAgICAgIHJldHVybiBiYXRjaCh5ZWFycywgdGhpcy55ZWFyc0luUm93KTtcbiAgICB9XG4gICAgY29weVdpdGhZZWFyKHllYXIsIGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuY3JlYXRlRGF0ZSh5ZWFyLCB0aGlzLmRhdGVTZXJ2aWNlLmdldE1vbnRoKGRhdGUpLCB0aGlzLmRhdGVTZXJ2aWNlLmdldERhdGUoZGF0ZSkpO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhclZpZXdNb2RlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSwgeWVhck1vZGVsU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMueWVhck1vZGVsU2VydmljZSA9IHllYXJNb2RlbFNlcnZpY2U7XG4gICAgICAgIHRoaXMudmlld01vZGUgPSBOYkNhbGVuZGFyVmlld01vZGUuREFURTtcbiAgICAgICAgdGhpcy5jaGFuZ2VNb2RlID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICB9XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhOYW1lKHRoaXMuZGF0ZSwgVHJhbnNsYXRpb25XaWR0aC5XaWRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHRoaXMuZGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke21vbnRofSAke3llYXJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLk1PTlRIOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIodGhpcy5kYXRlKX1gO1xuICAgICAgICAgICAgY2FzZSBOYkNhbGVuZGFyVmlld01vZGUuWUVBUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRGaXJzdFllYXIoKX0gLSAke3RoaXMuZ2V0TGFzdFllYXIoKX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEljb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdNb2RlID09PSBOYkNhbGVuZGFyVmlld01vZGUuREFURSkge1xuICAgICAgICAgICAgcmV0dXJuICdjaGV2cm9uLWRvd24tb3V0bGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdjaGV2cm9uLXVwLW91dGxpbmUnO1xuICAgIH1cbiAgICBnZXRGaXJzdFllYXIoKSB7XG4gICAgICAgIGNvbnN0IHllYXJzID0gdGhpcy55ZWFyTW9kZWxTZXJ2aWNlLmdldFZpZXdZZWFycyh0aGlzLmRhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHllYXJzWzBdWzBdKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRMYXN0WWVhcigpIHtcbiAgICAgICAgY29uc3QgeWVhcnMgPSB0aGlzLnllYXJNb2RlbFNlcnZpY2UuZ2V0Vmlld1llYXJzKHRoaXMuZGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhc3RSb3cgPSB5ZWFyc1t5ZWFycy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgbGFzdFllYXIgPSBsYXN0Um93W2xhc3RSb3cubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIobGFzdFllYXIpLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuTmJDYWxlbmRhclZpZXdNb2RlQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci12aWV3LW1vZGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiBuYkJ1dHRvbiAoY2xpY2spPVwiY2hhbmdlTW9kZS5lbWl0KClcIiBnaG9zdCBzdGF0dXM9XCJiYXNpY1wiPlxuICAgICAge3sgZ2V0VGV4dCgpIH19XG4gICAgICA8bmItaWNvbiBbaWNvbl09XCJnZXRJY29uKClcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgIDwvYnV0dG9uPlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJWaWV3TW9kZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlIH1cbl07XG5OYkNhbGVuZGFyVmlld01vZGVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmlld01vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoYW5nZU1vZGU6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGlyZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvblNlcnZpY2UgPSBkaXJlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5leHQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucHJldiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGlzTHRyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLmlzTHRyKCk7XG4gICAgfVxufVxuTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcGFnZWFibGUtbmF2aWdhdGlvbicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8YnV0dG9uIG5iQnV0dG9uIChjbGljayk9XCJwcmV2LmVtaXQoKVwiIGdob3N0IHN0YXR1cz1cImJhc2ljXCIgY2xhc3M9XCJwcmV2LW1vbnRoXCI+XG4gICAgICA8bmItaWNvbiBbaWNvbl09XCJpc0x0ciA/ICdjaGV2cm9uLWxlZnQtb3V0bGluZScgOiAnY2hldnJvbi1yaWdodC1vdXRsaW5lJ1wiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiBuYkJ1dHRvbiAoY2xpY2spPVwibmV4dC5lbWl0KClcIiBnaG9zdCBzdGF0dXM9XCJiYXNpY1wiIGNsYXNzPVwibmV4dC1tb250aFwiPlxuICAgICAgPG5iLWljb24gW2ljb25dPVwiaXNMdHIgPyAnY2hldnJvbi1yaWdodC1vdXRsaW5lJyA6ICdjaGV2cm9uLWxlZnQtb3V0bGluZSdcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgIDwvYnV0dG9uPlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSB9XG5dO1xuTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBuZXh0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcHJldjogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGlzTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2FsZW5kYXItcGlja2VyLXJvd1xuICAgICAgKm5nRm9yPVwibGV0IHJvdyBvZiBkYXRhXCJcbiAgICAgIFtyb3ddPVwicm93XCJcbiAgICAgIFt2aXNpYmxlRGF0ZV09XCJ2aXNpYmxlRGF0ZVwiXG4gICAgICBbc2VsZWN0ZWRWYWx1ZV09XCJzZWxlY3RlZFZhbHVlXCJcbiAgICAgIFtjb21wb25lbnRdPVwiY2VsbENvbXBvbmVudFwiXG4gICAgICBbbWluXT1cIm1pblwiXG4gICAgICBbbWF4XT1cIm1heFwiXG4gICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgIChzZWxlY3QpPVwic2VsZWN0LmVtaXQoJGV2ZW50KVwiPlxuICAgIDwvbmItY2FsZW5kYXItcGlja2VyLXJvdz5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGE6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RlZFZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpc0xhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyUGlja2VyUm93Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZnIpIHtcbiAgICAgICAgdGhpcy5jZnIgPSBjZnI7XG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkodGhpcy5jb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclJlZi5jbGVhcigpO1xuICAgICAgICB0aGlzLnJvdy5mb3JFYWNoKChkYXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSk7XG4gICAgICAgICAgICB0aGlzLnBhdGNoV2l0aENvbnRleHQoY29tcG9uZW50Lmluc3RhbmNlLCBkYXRlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXRjaFdpdGhDb250ZXh0KGNvbXBvbmVudCwgZGF0ZSkge1xuICAgICAgICBjb21wb25lbnQudmlzaWJsZURhdGUgPSB0aGlzLnZpc2libGVEYXRlO1xuICAgICAgICBjb21wb25lbnQuc2VsZWN0ZWRWYWx1ZSA9IHRoaXMuc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgY29tcG9uZW50LmRhdGUgPSBkYXRlO1xuICAgICAgICBjb21wb25lbnQubWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbXBvbmVudC5tYXggPSB0aGlzLm1heDtcbiAgICAgICAgY29tcG9uZW50LmZpbHRlciA9IHRoaXMuZmlsdGVyO1xuICAgICAgICBjb21wb25lbnQuc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgY29tcG9uZW50LnNlbGVjdC5zdWJzY3JpYmUodGhpcy5zZWxlY3QuZW1pdC5iaW5kKHRoaXMuc2VsZWN0KSk7XG4gICAgfVxufVxuTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcGlja2VyLXJvdycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctdGVtcGxhdGU+PC9uZy10ZW1wbGF0ZT4nLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW2BcbiAgICA6aG9zdCB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIH1cbiAgYF1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9XG5dO1xuTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByb3c6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkVmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGNvbnRhaW5lclJlZjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbVGVtcGxhdGVSZWYsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0sXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhclllYXJDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgICAgICB0aGlzLnllYXJDZWxsQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZVllYXJTYWZlKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyU2FmZSh0aGlzLmRhdGUsIHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21hbGxlclRoYW5NaW4oKSB8fCB0aGlzLmdyZWF0ZXJUaGFuTWF4KCk7XG4gICAgfVxuICAgIGdldCBpc0xhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHNtYWxsZXJUaGFuTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWluICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMueWVhckVuZCgpLCB0aGlzLm1pbikgPCAwO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1heCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLnllYXJTdGFydCgpLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICB5ZWFyU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXJTdGFydCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICB5ZWFyRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyRW5kKHRoaXMuZGF0ZSk7XG4gICAgfVxufVxuTmJDYWxlbmRhclllYXJDZWxsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci15ZWFyLWNlbGwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNlbGwtY29udGVudFwiPlxuICAgICAge3sgeWVhciB9fVxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWRWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNlbGVjdGVkJyxdIH1dLFxuICAgIHRvZGF5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy50b2RheScsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZGlzYWJsZWQnLF0gfV0sXG4gICAgaXNMYXJnZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1sYXJnZScsXSB9XSxcbiAgICB5ZWFyQ2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy55ZWFyLWNlbGwnLF0gfV0sXG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UsIHllYXJNb2RlbFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnllYXJNb2RlbFNlcnZpY2UgPSB5ZWFyTW9kZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgdGhpcy55ZWFyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBzZXQgX2NlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5jZWxsQ29tcG9uZW50ID0gY2VsbENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy55ZWFycyA9IHRoaXMueWVhck1vZGVsU2VydmljZS5nZXRWaWV3WWVhcnModGhpcy55ZWFyKTtcbiAgICB9XG4gICAgb25TZWxlY3QoeWVhcikge1xuICAgICAgICB0aGlzLnllYXJDaGFuZ2UuZW1pdCh5ZWFyKTtcbiAgICB9XG59XG5OYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXIteWVhci1waWNrZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNhbGVuZGFyLXBpY2tlclxuICAgICAgW2RhdGFdPVwieWVhcnNcIlxuICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgW21heF09XCJtYXhcIlxuICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgW3NlbGVjdGVkVmFsdWVdPVwiZGF0ZVwiXG4gICAgICBbdmlzaWJsZURhdGVdPVwieWVhclwiXG4gICAgICBbY2VsbENvbXBvbmVudF09XCJjZWxsQ29tcG9uZW50XCJcbiAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgKHNlbGVjdCk9XCJvblNlbGVjdCgkZXZlbnQpXCI+XG4gICAgPC9uYi1jYWxlbmRhci1waWNrZXI+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZSB9XG5dO1xuTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpbHRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgX2NlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2NlbGxDb21wb25lbnQnLF0gfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgeWVhcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgeWVhckNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dXG59O1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgfVxuICAgIGdldCBpc0xhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy53ZWVrcykge1xuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVycyA9IHRoaXMuZ2V0V2Vla3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRXZWVrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla3MubWFwKCh3ZWVrKSA9PiB7XG4gICAgICAgICAgICAvLyBGaW5kIGxhc3QgZGVmaW5lZCBkYXkgYXMgd2VlayBjb3VsZCBjb250YWluIG51bGwgZGF5cyBpbiBjYXNlXG4gICAgICAgICAgICAvLyBib3VuZGluZ01vbnRoIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgY29uc3QgbGFzdERheSA9IFsuLi53ZWVrXS5yZXZlcnNlKCkuZmluZCgoZGF5KSA9PiAhIWRheSk7XG4gICAgICAgICAgICAvLyBVc2UgbGFzdCBkYXkgb2YgdGhlIHdlZWsgdG8gZGV0ZXJtaW5lIHdlZWsgbnVtYmVyLlxuICAgICAgICAgICAgLy8gVGhpcyB3YXkgd2Vla3Mgd2hpY2ggc3BhbiBiZXR3ZWVuIHNpYmxpbmcgeWVhcnMgaXMgbWFya2VkIGZpcnN0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRXZWVrTnVtYmVyKGxhc3REYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5OYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItd2Vlay1udW1iZXJzJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJzaWduLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNpZ25cIj57eyB3ZWVrTnVtYmVyU3ltYm9sIH19PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIndlZWstbnVtYmVyXCIgKm5nRm9yPVwibGV0IHdlZWtOdW1iZXIgb2Ygd2Vla051bWJlcnNcIj57eyB3ZWVrTnVtYmVyIH19PC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHdlZWtzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB3ZWVrTnVtYmVyU3ltYm9sOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc0xhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJOYXRpdmVEYXRlU2VydmljZWAgaXMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2YgYE5iRGF0ZVNlcnZpY2VgIHVzaW5nXG4gKiBuYXRpdmUganMgZGF0ZSBvYmplY3RzIGFuZCBhbmd1bGFyIGxvY2FsaXphdGlvbiBzZXJ2aWNlcy5cbiAqICovXG5jbGFzcyBOYk5hdGl2ZURhdGVTZXJ2aWNlIGV4dGVuZHMgTmJEYXRlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgfVxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgc3VwZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuZGF0ZVBpcGUgPSBuZXcgRGF0ZVBpcGUobG9jYWxlKTtcbiAgICB9XG4gICAgc2V0SG91cnMoZGF0ZSwgaG91cikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNsb25lKGRhdGUpO1xuICAgICAgICByZXN1bHQuc2V0SG91cnMoaG91cik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldE1pbnV0ZXMoZGF0ZSwgbWludXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvbmUoZGF0ZSk7XG4gICAgICAgIHJlc3VsdC5zZXRNaW51dGVzKG1pbnV0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldFNlY29uZHMoZGF0ZSwgc2Vjb25kKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvbmUoZGF0ZSk7XG4gICAgICAgIHJlc3VsdC5zZXRTZWNvbmRzKHNlY29uZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNldE1pbGxpc2Vjb25kcyhkYXRlLCBzZWNvbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZShkYXRlKTtcbiAgICAgICAgcmVzdWx0LnNldE1pbGxpc2Vjb25kcyhzZWNvbmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpc1ZhbGlkRGF0ZVN0cmluZyhkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTih0aGlzLnBhcnNlKGRhdGUsIGZvcm1hdCkuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaXNWYWxpZFRpbWVTdHJpbmcoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWREYXRlU3RyaW5nKGRhdGUsIGZvcm1hdCk7XG4gICAgfVxuICAgIHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0TG9jYWxlVGltZUZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldExvY2FsZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIEZvcm1hdFdpZHRoLlNob3J0KTtcbiAgICB9XG4gICAgZ2V0RGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgICB9XG4gICAgZ2V0TW9udGgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICAgIH1cbiAgICBnZXRZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0RGF5T2ZXZWVrKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybnMgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBpdCBjYW4gYmUgMSBpZiB3ZWVrIHN0YXJ0cyBmcm9tIG1vbmRheVxuICAgICAqIGFuZCAwIGlmIGZyb20gc3VuZGF5IGFuZCBzbyBvbi5cbiAgICAgKiAqL1xuICAgIGdldEZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxlRmlyc3REYXlPZldlZWsodGhpcy5sb2NhbGUpO1xuICAgIH1cbiAgICBnZXRNb250aE5hbWUoZGF0ZSwgc3R5bGUkJDEgPSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aE5hbWVCeUluZGV4KGluZGV4LCBzdHlsZSQkMSk7XG4gICAgfVxuICAgIGdldE1vbnRoTmFtZUJ5SW5kZXgoaW5kZXgsIHN0eWxlJCQxID0gVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxlTW9udGhOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLkZvcm1hdCwgc3R5bGUkJDEpW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0RGF5T2ZXZWVrTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4uZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5Gb3JtYXQsIFRyYW5zbGF0aW9uV2lkdGguU2hvcnQpXTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlUGlwZS50cmFuc2Zvcm0oZGF0ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2UgaGF2ZW4ndCBnb3QgY2FwYWJpbGl0eSB0byBwYXJzZSBkYXRlIHVzaW5nIGZvcm1hdHRpbmcgd2l0aG91dCB0aGlyZCBwYXJ0eSBsaWJyYXJpZXMuXG4gICAgICogKi9cbiAgICBwYXJzZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UoZGF0ZSkpO1xuICAgIH1cbiAgICBhZGREYXkoZGF0ZSwgbnVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpICsgbnVtKTtcbiAgICB9XG4gICAgYWRkTW9udGgoZGF0ZSwgbnVtKSB7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgbnVtLCAxKTtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkYXRlIGhhcyBtb3JlIGRheXMgdGhhbiBjYWxjdWxhdGVkIG1vbnRoIGpzIERhdGUgd2lsbCBjaGFuZ2UgdGhhdCBtb250aCB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgZGF0ZSBvdmVyZmxvdy5cbiAgICAgICAgbW9udGguc2V0RGF0ZShNYXRoLm1pbihkYXRlLmdldERhdGUoKSwgdGhpcy5nZXRNb250aEVuZChtb250aCkuZ2V0RGF0ZSgpKSk7XG4gICAgICAgIHJldHVybiBtb250aDtcbiAgICB9XG4gICAgYWRkTWludXRlcyhkYXRlLCBtaW51dGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgIHJlc3VsdC5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgbWludXRlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYWRkSG91cnMoZGF0ZSwgaG91cikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgcmVzdWx0LnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIGhvdXIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRIb3VycyhkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG4gICAgfVxuICAgIGdldE1pbnV0ZXMoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgfVxuICAgIGdldFNlY29uZHMoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgfVxuICAgIGdldE1pbGxpc2Vjb25kcyhkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIH1cbiAgICBhZGRZZWFyKGRhdGUsIG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSArIG51bSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgfVxuICAgIGNsb25lKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgY29tcGFyZURhdGVzKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0VGltZSgpIC0gZGF0ZTIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjcmVhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IGZvciB0aGUgZmFjdCB0aGF0IEpTIG5hdGl2ZSBEYXRlIHRyZWF0cyB5ZWFycyBpbiByYW5nZSBbMCwgOTldIGFzXG4gICAgICAgIC8vIGFiYnJldmlhdGlvbnMgZm9yIDE5eHguXG4gICAgICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHJlc3VsdC5nZXRGdWxsWWVhcigpIC0gMTkwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0TW9udGhFbmQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCk7XG4gICAgfVxuICAgIGdldE1vbnRoU3RhcnQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCAxKTtcbiAgICB9XG4gICAgZ2V0TnVtYmVyT2ZEYXlzSW5Nb250aChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoRW5kKGRhdGUpLmdldERhdGUoKTtcbiAgICB9XG4gICAgZ2V0WWVhckVuZChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAxMSwgMzEpO1xuICAgIH1cbiAgICBnZXRZZWFyU3RhcnQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgfVxuICAgIHZhbHVlT2YoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGlzU2FtZURheShkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lTW9udGgoZGF0ZTEsIGRhdGUyKSAmJlxuICAgICAgICAgICAgZGF0ZTEuZ2V0RGF0ZSgpID09PSBkYXRlMi5nZXREYXRlKCk7XG4gICAgfVxuICAgIGlzU2FtZU1vbnRoKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWVZZWFyKGRhdGUxLCBkYXRlMikgJiZcbiAgICAgICAgICAgIGRhdGUxLmdldE1vbnRoKCkgPT09IGRhdGUyLmdldE1vbnRoKCk7XG4gICAgfVxuICAgIGlzU2FtZVllYXIoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRGdWxsWWVhcigpID09PSBkYXRlMi5nZXRGdWxsWWVhcigpO1xuICAgIH1cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuICduYXRpdmUnO1xuICAgIH1cbiAgICBnZXRXZWVrTnVtYmVyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZGF0ZVBpcGUudHJhbnNmb3JtKGRhdGUsICd3JyksIDEwKTtcbiAgICB9XG4gICAgZ2V0RGF0ZUZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuICd5eXl5LU1NLWRkJztcbiAgICB9XG4gICAgZ2V0VHdlbHZlSG91cnNGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiAnaGg6bW0gYSc7XG4gICAgfVxufVxuTmJOYXRpdmVEYXRlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJOYXRpdmVEYXRlU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTE9DQUxFX0lELF0gfV0gfVxuXTtcblxuY2xhc3MgTmJDYWxlbmRhclRpbWVNb2RlbFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5NSU5VVEVTX0FORF9TRUNPTkRTID0gNjA7XG4gICAgfVxuICAgIGdldEhvdXJzUmFuZ2Uoc3RlcCA9IHRoaXMuTUlOVVRFU19BTkRfU0VDT05EUykge1xuICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZ2V0UmVzZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGVuZERhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZERheShkYXRlLCAxKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyhkYXRlLCBlbmREYXRlKSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGUpO1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTWludXRlcyhkYXRlLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRSZXNldFRpbWUoKSB7XG4gICAgICAgIGxldCB0b2RheSA9IHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKTtcbiAgICAgICAgdG9kYXkgPSB0aGlzLmRhdGVTZXJ2aWNlLnNldEhvdXJzKHRvZGF5LCAwKTtcbiAgICAgICAgdG9kYXkgPSB0aGlzLmRhdGVTZXJ2aWNlLnNldE1pbnV0ZXModG9kYXksIDApO1xuICAgICAgICB0b2RheSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0U2Vjb25kcyh0b2RheSwgMCk7XG4gICAgICAgIHRvZGF5ID0gdGhpcy5kYXRlU2VydmljZS5zZXRNaWxsaXNlY29uZHModG9kYXksIDApO1xuICAgICAgICByZXR1cm4gdG9kYXk7XG4gICAgfVxuICAgIHBhZGRUb1R3b1N5bWJvbHMobikge1xuICAgICAgICBpZiAobiA8IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnICsgbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBidWlsZERhdGVGb3JtYXQodHdlbHZlSG91cnNGb3JtYXQsIHdpdGhTZWNvbmRzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR3ZWx2ZUhvdXJzRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5kYXRlU2VydmljZS5nZXREYXRlRm9ybWF0KCl9ICR7dGhpcy5kYXRlU2VydmljZS5nZXRUd2VsdmVIb3Vyc0Zvcm1hdCgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpdGhTZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5kYXRlU2VydmljZS5nZXREYXRlRm9ybWF0KCl9ICR7dGhpcy5kYXRlU2VydmljZS5nZXRUd2VudHlGb3VySG91cnNGb3JtYXRXaXRoU2Vjb25kcygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF0ZUZvcm1hdCgpfSAke3RoaXMuZGF0ZVNlcnZpY2UuZ2V0VHdlbnR5Rm91ckhvdXJzRm9ybWF0KCl9YDtcbiAgICB9XG59XG5OYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJDYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH1cbl07XG5cbmNsYXNzIE5iQ2FsZW5kYXJBY3Rpb25zQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlCdXR0b25UZXh0ID0gJ29rJztcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWVCdXR0b25UZXh0ID0gJ25vdyc7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFRpbWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2F2ZVZhbHVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBzZXQgYXBwbHlCdXR0b25UZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlCdXR0b25UZXh0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGdldCBhcHBseVRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUJ1dHRvblRleHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgY3VycmVudFRpbWVCdXR0b25UZXh0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWVCdXR0b25UZXh0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUaW1lVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lQnV0dG9uVGV4dDtcbiAgICB9XG4gICAgO1xufVxuTmJDYWxlbmRhckFjdGlvbnNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLWFjdGlvbnMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvblxuICAgICAgbmJCdXR0b25cbiAgICAgIGdob3N0XG4gICAgICBzdGF0dXM9XCJwcmltYXJ5XCJcbiAgICAgIHNpemU9XCJzbWFsbFwiXG4gICAgICAoY2xpY2spPVwic2V0Q3VycmVudFRpbWUuZW1pdCgpXCI+XG4gICAgICB7eyBjdXJyZW50VGltZVRleHQgfX08L2J1dHRvbj5cbiAgICA8YnV0dG9uXG4gICAgICBuYkJ1dHRvblxuICAgICAgc3RhdHVzPVwicHJpbWFyeVwiXG4gICAgICBzaXplPVwic21hbGxcIlxuICAgICAgKGNsaWNrKT1cInNhdmVWYWx1ZS5lbWl0KClcIj5cbiAgICAgIHt7IGFwcGx5VGV4dCB9fTwvYnV0dG9uPlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyQWN0aW9uc0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhcHBseUJ1dHRvblRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGN1cnJlbnRUaW1lQnV0dG9uVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2V0Q3VycmVudFRpbWU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBzYXZlVmFsdWU6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgU0VSVklDRVMgPSBbXG4gICAgeyBwcm92aWRlOiBOYkRhdGVTZXJ2aWNlLCB1c2VDbGFzczogTmJOYXRpdmVEYXRlU2VydmljZSB9LFxuICAgIERhdGVQaXBlLFxuICAgIE5iQ2FsZW5kYXJNb250aE1vZGVsU2VydmljZSxcbiAgICBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZSxcbiAgICBOYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZSxcbl07XG5jb25zdCBDT01QT05FTlRTID0gW1xuICAgIE5iQ2FsZW5kYXJWaWV3TW9kZUNvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyUGFnZWFibGVOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJEYXlzTmFtZXNDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJEYXlQaWNrZXJDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhckFjdGlvbnNDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50LFxuXTtcbi8qKlxuICogYE5iQ2FsZW5kYXJLaXRNb2R1bGVgIGlzIGEgbW9kdWxlIHRoYXQgY29udGFpbnMgbXVsdGlwbGUgdXNlZnVsIGNvbXBvbmVudHMgZm9yIGJ1aWxkaW5nIGN1c3RvbSBjYWxlbmRhcnMuXG4gKiBTbyBpZiB5b3UgdGhpbmsgb3VyIGNhbGVuZGFycyBpcyBub3QgZW5vdWdoIHBvd2VyZnVsIGZvciB5b3UganVzdCB1c2UgY2FsZW5kYXIta2l0IGFuZCBidWlsZCB5b3VyIG93biBjYWxlbmRhciFcbiAqXG4gKiBBdmFpbGFibGUgY29tcG9uZW50czpcbiAqIC0gYE5iQ2FsZW5kYXJEYXlQaWNrZXJgXG4gKiAtIGBOYkNhbGVuZGFyRGF5Q2VsbGBcbiAqIC0gYE5iQ2FsZW5kYXJNb250aFBpY2tlcmBcbiAqIC0gYE5iQ2FsZW5kYXJNb250aENlbGxgXG4gKiAtIGBOYkNhbGVuZGFyWWVhclBpY2tlcmBcbiAqIC0gYE5iQ2FsZW5kYXJZZWFyQ2VsbGBcbiAqIC0gYE5iQ2FsZW5kYXJWaWV3TW9kZUNvbXBvbmVudGBcbiAqIC0gYE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25gXG4gKlxuICogRm9yIGV4YW1wbGUgeW91IGNhbiBlYXNpbHkgYnVpbGQgZnVsbCBjYWxlbmRhcjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRnVsbCBjYWxlbmRhciwgY2FsZW5kYXIta2l0L2NhbGVuZGFyLWtpdC1mdWxsLWNhbGVuZGFyLmNvbXBvbmVudClcbiAqICovXG5jbGFzcyBOYkNhbGVuZGFyS2l0TW9kdWxlIHtcbn1cbk5iQ2FsZW5kYXJLaXRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYlNoYXJlZE1vZHVsZSwgTmJCdXR0b25Nb2R1bGUsIE5iSWNvbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogWy4uLkNPTVBPTkVOVFNdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVFNdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogWy4uLlNFUlZJQ0VTXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogVGhlIGJhc2lzIGZvciBjYWxlbmRhciBhbmQgcmFuZ2UgY2FsZW5kYXIgY29tcG9uZW50cy5cbiAqIEVuY2Fwc3VsYXRlcyBjb21tb24gYmVoYXZpb3IgLSBzdG9yZSBjYWxlbmRhciBzdGF0ZSBhbmQgcGVyZm9ybSBuYXZpZ2F0aW9uXG4gKiBiZXR3ZWVuIHBpY2tlcnMuXG4gKiAqL1xuY2xhc3MgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlLCB5ZWFyTW9kZWxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy55ZWFyTW9kZWxTZXJ2aWNlID0geWVhck1vZGVsU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgICAgICogaW4gdGhlIGN1cnJlbnQgbW9udGggdmlldy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5ib3VuZGluZ01vbnRoID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgYWN0aXZlIHZpZXcgZm9yIGNhbGVuZGFyLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdNb2RlID0gTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgc2hvdyBjYWxlbmRhciBuYXZpZ2F0aW9uIG9yIG5vdC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaG93TmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBkYXRlIHdoZW4gc2VsZWN0ZWQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuZGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5WaWV3TW9kZSA9IE5iQ2FsZW5kYXJWaWV3TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93V2Vla051bWJlcjtcbiAgICB9XG4gICAgc2V0IHNob3dXZWVrTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBzZXRWaWV3TW9kZSh2aWV3TW9kZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdNb2RlID0gdmlld01vZGU7XG4gICAgfVxuICAgIHNldFZpc2libGVEYXRlKHZpc2libGVEYXRlKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB2aXNpYmxlRGF0ZTtcbiAgICB9XG4gICAgcHJldk1vbnRoKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVZpc2libGVNb250aCgtMSk7XG4gICAgfVxuICAgIG5leHRNb250aCgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlTW9udGgoMSk7XG4gICAgfVxuICAgIHByZXZZZWFyKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVZpc2libGVZZWFyKC0xKTtcbiAgICB9XG4gICAgbmV4dFllYXIoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVmlzaWJsZVllYXIoMSk7XG4gICAgfVxuICAgIHByZXZZZWFycygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlWWVhcnMoLTEpO1xuICAgIH1cbiAgICBuZXh0WWVhcnMoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlVmlzaWJsZVllYXJzKDEpO1xuICAgIH1cbiAgICBuYXZpZ2F0ZVByZXYoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmVWaWV3TW9kZSkge1xuICAgICAgICAgICAgY2FzZSBOYkNhbGVuZGFyVmlld01vZGUuREFURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2TW9udGgoKTtcbiAgICAgICAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLk1PTlRIOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZZZWFyKCk7XG4gICAgICAgICAgICBjYXNlIE5iQ2FsZW5kYXJWaWV3TW9kZS5ZRUFSOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZZZWFycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRlTmV4dCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFjdGl2ZVZpZXdNb2RlKSB7XG4gICAgICAgICAgICBjYXNlIE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRNb250aCgpO1xuICAgICAgICAgICAgY2FzZSBOYkNhbGVuZGFyVmlld01vZGUuTU9OVEg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFllYXIoKTtcbiAgICAgICAgICAgIGNhc2UgTmJDYWxlbmRhclZpZXdNb2RlLllFQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFllYXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DaGFuZ2VWaWV3TW9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmlld01vZGUgPT09IE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3TW9kZShOYkNhbGVuZGFyVmlld01vZGUuWUVBUik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRWaWV3TW9kZShOYkNhbGVuZGFyVmlld01vZGUuREFURSk7XG4gICAgfVxuICAgIGNoYW5nZVZpc2libGVNb250aChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy52aXNpYmxlRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTW9udGgodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgY2hhbmdlVmlzaWJsZVllYXIoZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZFllYXIodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgY2hhbmdlVmlzaWJsZVllYXJzKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnZpc2libGVEYXRlID0gdGhpcy5kYXRlU2VydmljZS5hZGRZZWFyKHRoaXMudmlzaWJsZURhdGUsIGRpcmVjdGlvbiAqIHRoaXMueWVhck1vZGVsU2VydmljZS5nZXRZZWFyc0luVmlldygpKTtcbiAgICB9XG59XG5OYkJhc2VDYWxlbmRhckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYmFzZS1jYWxlbmRhcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5iLWNhcmQ+XFxuICA8bmItY2FyZC1oZWFkZXIgKm5nSWY9XFxcInNob3dOYXZpZ2F0aW9uXFxcIiBjbGFzcz1cXFwiY2FsZW5kYXItbmF2aWdhdGlvblxcXCI+XFxuICAgIDxuYi1jYWxlbmRhci12aWV3LW1vZGUgW2RhdGVdPVxcXCJ2aXNpYmxlRGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbdmlld01vZGVdPVxcXCJhY3RpdmVWaWV3TW9kZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlTW9kZSk9XFxcIm9uQ2hhbmdlVmlld01vZGUoKVxcXCI+XFxuICAgIDwvbmItY2FsZW5kYXItdmlldy1tb2RlPlxcblxcbiAgICA8bmItY2FsZW5kYXItcGFnZWFibGUtbmF2aWdhdGlvbiAocHJldik9XFxcIm5hdmlnYXRlUHJldigpXFxcIiAobmV4dCk9XFxcIm5hdmlnYXRlTmV4dCgpXFxcIj5cXG4gICAgPC9uYi1jYWxlbmRhci1wYWdlYWJsZS1uYXZpZ2F0aW9uPlxcbiAgPC9uYi1jYXJkLWhlYWRlcj5cXG5cXG4gIDxuYi1jYXJkLWJvZHkgW25nU3dpdGNoXT1cXFwiYWN0aXZlVmlld01vZGVcXFwiPlxcblxcbiAgICA8bmItY2FsZW5kYXItZGF5LXBpY2tlciAqbmdTd2l0Y2hDYXNlPVxcXCJWaWV3TW9kZS5EQVRFXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYm91bmRpbmdNb250aHNdPVxcXCJib3VuZGluZ01vbnRoXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VsbENvbXBvbmVudF09XFxcImRheUNlbGxDb21wb25lbnRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttaW5dPVxcXCJtaW5cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVxcXCJmaWx0ZXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2aXNpYmxlRGF0ZV09XFxcInZpc2libGVEYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2l6ZV09XFxcInNpemVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRlXT1cXFwiZGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Nob3dXZWVrTnVtYmVyXT1cXFwic2hvd1dlZWtOdW1iZXJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRlQ2hhbmdlKT1cXFwiZGF0ZUNoYW5nZS5lbWl0KCRhbnkoJGV2ZW50KSlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt3ZWVrTnVtYmVyU3ltYm9sXT1cXFwid2Vla051bWJlclN5bWJvbFxcXCI+XFxuICAgIDwvbmItY2FsZW5kYXItZGF5LXBpY2tlcj5cXG5cXG4gICAgPG5iLWNhbGVuZGFyLXllYXItcGlja2VyICpuZ1N3aXRjaENhc2U9XFxcIlZpZXdNb2RlLllFQVJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VsbENvbXBvbmVudF09XFxcInllYXJDZWxsQ29tcG9uZW50XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RhdGVdPVxcXCIkYW55KGRhdGUpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21pbl09XFxcIm1pblxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cXFwiZmlsdGVyXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NpemVdPVxcXCJzaXplXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3llYXJdPVxcXCJ2aXNpYmxlRGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICh5ZWFyQ2hhbmdlKT1cXFwic2V0VmlzaWJsZURhdGUoJGV2ZW50KTsgc2V0Vmlld01vZGUoVmlld01vZGUuTU9OVEgpXFxcIj5cXG4gICAgPC9uYi1jYWxlbmRhci15ZWFyLXBpY2tlcj5cXG5cXG4gICAgPG5iLWNhbGVuZGFyLW1vbnRoLXBpY2tlciAqbmdTd2l0Y2hDYXNlPVxcXCJWaWV3TW9kZS5NT05USFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2VsbENvbXBvbmVudF09XFxcIm1vbnRoQ2VsbENvbXBvbmVudFxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWluXT1cXFwibWluXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XFxcImZpbHRlclxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2l6ZV09XFxcInNpemVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21vbnRoXT1cXFwidmlzaWJsZURhdGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2RhdGVdPVxcXCIkYW55KGRhdGUpXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtb250aENoYW5nZSk9XFxcInNldFZpc2libGVEYXRlKCRldmVudCk7IHNldFZpZXdNb2RlKFZpZXdNb2RlLkRBVEUpXFxcIj5cXG4gICAgPC9uYi1jYWxlbmRhci1tb250aC1waWNrZXI+XFxuXFxuICA8L25iLWNhcmQtYm9keT5cXG5cXG48L25iLWNhcmQ+XFxuXCJcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkNhbGVuZGFyWWVhck1vZGVsU2VydmljZSB9XG5dO1xuTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgYm91bmRpbmdNb250aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aXZlVmlld01vZGU6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ3N0YXJ0VmlldycsXSB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXlDZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtb250aENlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHllYXJDZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXNpYmxlRGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd05hdmlnYXRpb246IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaGFzLW5hdmlnYXRpb24nLF0gfV0sXG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd1dlZWtOdW1iZXI6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaGFzLXdlZWstbnVtYmVyJyxdIH1dLFxuICAgIHdlZWtOdW1iZXJTeW1ib2w6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBsYXJnZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1sYXJnZScsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJCYXNlQ2FsZW5kYXJNb2R1bGUge1xufVxuTmJCYXNlQ2FsZW5kYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYkNhbGVuZGFyS2l0TW9kdWxlLCBOYlNoYXJlZE1vZHVsZSwgTmJDYXJkTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTmJCYXNlQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iQmFzZUNhbGVuZGFyQ29tcG9uZW50XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNhbGVuZGFyTW9kdWxlIHtcbn1cbk5iQ2FsZW5kYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYkJhc2VDYWxlbmRhck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW05iQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQmFzZUNhbGVuZGFyUmFuZ2VDZWxsIHtcbiAgICBnZXQgaGFzUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLnNlbGVjdGVkVmFsdWUgJiYgdGhpcy5zZWxlY3RlZFZhbHVlLnN0YXJ0ICYmIHRoaXMuc2VsZWN0ZWRWYWx1ZS5lbmQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCBleHRlbmRzIE5iQmFzZUNhbGVuZGFyUmFuZ2VDZWxsIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgICAgICB0aGlzLnJhbmdlQ2VsbENsYXNzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXlDZWxsQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaW5SYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZSAmJiB0aGlzLmhhc1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0luUmFuZ2UodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuaGFzUmFuZ2UgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXkodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuaGFzUmFuZ2UgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXkodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuZW5kKTtcbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lRGF5KHRoaXMuZGF0ZSwgdGhpcy5kYXRlU2VydmljZS50b2RheSgpKTtcbiAgICB9XG4gICAgZ2V0IGJvdW5kaW5nTW9udGgoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlU2VydmljZS5pc1NhbWVNb250aFNhZmUodGhpcy5kYXRlLCB0aGlzLnZpc2libGVEYXRlKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXlTYWZlKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtYWxsZXJUaGFuTWluKCkgfHwgdGhpcy5ncmVhdGVyVGhhbk1heCgpIHx8IHRoaXMuZG9udEZpdEZpbHRlcigpO1xuICAgIH1cbiAgICBnZXQgaXNMYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gTmJDYWxlbmRhclNpemUuTEFSR0U7XG4gICAgfVxuICAgIGdldCBkYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlU2VydmljZS5nZXREYXRlKHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHNtYWxsZXJUaGFuTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWluICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMuZGF0ZSwgdGhpcy5taW4pIDwgMDtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5NYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5tYXggJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICBkb250Rml0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuZmlsdGVyICYmICF0aGlzLmZpbHRlcih0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBpc0luUmFuZ2UoZGF0ZSwgeyBzdGFydCwgZW5kIH0pIHtcbiAgICAgICAgY29uc3QgaXNHcmVhdGVyVGhhblN0YXJ0ID0gdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCBzdGFydCkgPj0gMDtcbiAgICAgICAgY29uc3QgaXNMZXNzVGhhbkVuZCA9IHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMuZGF0ZSwgZW5kKSA8PSAwO1xuICAgICAgICByZXR1cm4gaXNHcmVhdGVyVGhhblN0YXJ0ICYmIGlzTGVzc1RoYW5FbmQ7XG4gICAgfVxufVxuTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcmFuZ2UtZGF5LWNlbGwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNlbGwtY29udGVudFwiPnt7IGRheSB9fTwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZURheUNlbGxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH1cbl07XG5OYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkVmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZpc2libGVEYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpblJhbmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5pbi1yYW5nZScsXSB9XSxcbiAgICBzdGFydDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhcnQnLF0gfV0sXG4gICAgZW5kOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5lbmQnLF0gfV0sXG4gICAgcmFuZ2VDZWxsQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnJhbmdlLWNlbGwnLF0gfV0sXG4gICAgZGF5Q2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5kYXktY2VsbCcsXSB9XSxcbiAgICB0b2RheTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MudG9kYXknLF0gfV0sXG4gICAgYm91bmRpbmdNb250aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYm91bmRpbmctbW9udGgnLF0gfV0sXG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNlbGVjdGVkJyxdIH1dLFxuICAgIGVtcHR5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5lbXB0eScsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZGlzYWJsZWQnLF0gfV0sXG4gICAgaXNMYXJnZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1sYXJnZScsXSB9XSxcbiAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50IGV4dGVuZHMgTmJCYXNlQ2FsZW5kYXJSYW5nZUNlbGwge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMueWVhckNlbGxDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucmFuZ2VDZWxsQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaW5SYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUmFuZ2UgJiYgdGhpcy5pc0luUmFuZ2UodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUpO1xuICAgIH1cbiAgICBnZXQgcmFuZ2VTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzUmFuZ2UgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlLnN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0IHJhbmdlRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNSYW5nZSAmJiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZVllYXIodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuZW5kKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyU2FmZSh0aGlzLmRhdGUsIHRoaXMuc2VsZWN0ZWRWYWx1ZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyKHRoaXMuZGF0ZSwgdGhpcy5kYXRlU2VydmljZS50b2RheSgpKTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbWFsbGVyVGhhbk1pbigpIHx8IHRoaXMuZ3JlYXRlclRoYW5NYXgoKTtcbiAgICB9XG4gICAgZ2V0IGlzTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBnZXQgeWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhcih0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgc21hbGxlclRoYW5NaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5taW4gJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy55ZWFyRW5kKCksIHRoaXMubWluKSA8IDA7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuTWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWF4ICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMueWVhclN0YXJ0KCksIHRoaXMubWF4KSA+IDA7XG4gICAgfVxuICAgIHllYXJTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhclN0YXJ0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHllYXJFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXJFbmQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgaXNJblJhbmdlKGRhdGUsIHsgc3RhcnQsIGVuZCB9KSB7XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxZZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKGRhdGUpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRZZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFllYXIgPSB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIoZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBjZWxsWWVhciA+PSBzdGFydFllYXIgJiYgY2VsbFllYXIgPD0gZW5kWWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyKGRhdGUsIHN0YXJ0KTtcbiAgICB9XG59XG5OYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcmFuZ2UteWVhci1jZWxsJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjZWxsLWNvbnRlbnRcIj5cbiAgICAgIHt7IHllYXIgfX1cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RlZFZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpblJhbmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5pbi1yYW5nZScsXSB9XSxcbiAgICByYW5nZVN0YXJ0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGFydCcsXSB9XSxcbiAgICByYW5nZUVuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZW5kJyxdIH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zZWxlY3RlZCcsXSB9XSxcbiAgICB0b2RheTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MudG9kYXknLF0gfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRpc2FibGVkJyxdIH1dLFxuICAgIGlzTGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgeWVhckNlbGxDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MueWVhci1jZWxsJyxdIH1dLFxuICAgIHJhbmdlQ2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5yYW5nZS1jZWxsJyxdIH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDYWxlbmRhclJhbmdlTW9udGhDZWxsQ29tcG9uZW50IGV4dGVuZHMgTmJCYXNlQ2FsZW5kYXJSYW5nZUNlbGwge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMubW9udGhDZWxsQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnJhbmdlQ2VsbENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG1vbnRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRNb250aE5hbWUodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pblJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVNb250aFNhZmUodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpblJhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNJblJhZ2UodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByYW5nZVN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5oYXNSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lTW9udGgodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByYW5nZUVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZU1vbnRoKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlLmVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVNb250aFNhZmUodGhpcy5kYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCkpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtYWxsZXJUaGFuTWluKCkgfHwgdGhpcy5ncmVhdGVyVGhhbk1heCgpO1xuICAgIH1cbiAgICBnZXQgaXNMYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gTmJDYWxlbmRhclNpemUuTEFSR0U7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBzbWFsbGVyVGhhbk1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1pbiAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLm1vbnRoRW5kKCksIHRoaXMubWluKSA8IDA7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuTWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWF4ICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMubW9udGhTdGFydCgpLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICBtb250aFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRNb250aFN0YXJ0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIG1vbnRoRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRNb250aEVuZCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBpc0luUmFnZShkYXRlLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgJiYgcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhTdGFydChkYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRlU2VydmljZS5nZXRNb250aFN0YXJ0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhTdGFydChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgY29uc3QgaXNHcmVhdGVyVGhhblN0YXJ0ID0gdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXMoY2VsbERhdGUsIHN0YXJ0KSA+PSAwO1xuICAgICAgICAgICAgY29uc3QgaXNMZXNzVGhhbkVuZCA9IHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKGNlbGxEYXRlLCBlbmQpIDw9IDA7XG4gICAgICAgICAgICByZXR1cm4gaXNHcmVhdGVyVGhhblN0YXJ0ICYmIGlzTGVzc1RoYW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lTW9udGgoZGF0ZSwgcmFuZ2Uuc3RhcnQpO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJSYW5nZU1vbnRoQ2VsbENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcmFuZ2UtbW9udGgtY2VsbCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY2VsbC1jb250ZW50XCI+XG4gICAgICB7eyBtb250aCB9fVxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZU1vbnRoQ2VsbENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZU1vbnRoQ2VsbENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXNpYmxlRGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWRWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWluOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtYXg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG1vbnRoQ2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5tb250aC1jZWxsJyxdIH1dLFxuICAgIHJhbmdlQ2VsbENsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5yYW5nZS1jZWxsJyxdIH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zZWxlY3RlZCcsXSB9XSxcbiAgICBpblJhbmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5pbi1yYW5nZScsXSB9XSxcbiAgICByYW5nZVN0YXJ0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGFydCcsXSB9XSxcbiAgICByYW5nZUVuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZW5kJyxdIH1dLFxuICAgIHRvZGF5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy50b2RheScsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZGlzYWJsZWQnLF0gfV0sXG4gICAgaXNMYXJnZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1sYXJnZScsXSB9XSxcbiAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ2FsZW5kYXJSYW5nZSBjb21wb25lbnQgcHJvdmlkZXMgYSBjYXBhYmlsaXR5IHRvIGNob29zZSBhIGRhdGUgcmFuZ2UuXG4gKlxuICogYGBgaHRtbFxuICogPG5iLWNhbGVuZGFyIFsoZGF0ZSldPVwiZGF0ZVwiPjwvbmItY2FsZW5kYXI+XG4gKiA8bmItY2FsZW5kYXIgW2RhdGVdPVwiZGF0ZVwiIChkYXRlQ2hhbmdlKT1cImhhbmRsZURhdGVDaGFuZ2UoJGV2ZW50KVwiPjwvbmItY2FsZW5kYXI+XG4gKiBgYGBcbiAqXG4gKiBCYXNpYyB1c2FnZSBleGFtcGxlXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJhbmdlLCBjYWxlbmRhci9jYWxlbmRhci1yYW5nZS1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJDYWxlbmRhclJhbmdlTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkNhbGVuZGFyUmFuZ2VNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDYWxlbmRhclJhbmdlIGNvbXBvbmVudCBzdXBwb3J0cyBhbGwgb2YgdGhlIENhbGVuZGFyIGNvbXBvbmVudCBjdXN0b21pemF0aW9uIHByb3BlcnRpZXMuIE1vcmUgZGVmYWlscyBjYW4gYmUgZm91bmRcbiAqIGluIHRoZSBbQ2FsZW5kYXIgY29tcG9uZW50IGRvY3NdKGRvY3MvY29tcG9uZW50cy9jYWxlbmRhcikuXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNhbGVuZGFyLXdpZHRoOlxuICogY2FsZW5kYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWJvcmRlci1zdHlsZTpcbiAqIGNhbGVuZGFyLWJvcmRlci13aWR0aDpcbiAqIGNhbGVuZGFyLWJvcmRlci1yYWRpdXM6XG4gKiBjYWxlbmRhci10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItdGV4dC1mb250LWZhbWlseTpcbiAqIGNhbGVuZGFyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1waWNrZXItcGFkZGluZy10b3A6XG4gKiBjYWxlbmRhci1waWNrZXItcGFkZGluZy1ib3R0b206XG4gKiBjYWxlbmRhci1waWNrZXItcGFkZGluZy1zdGFydDpcbiAqIGNhbGVuZGFyLXBpY2tlci1wYWRkaW5nLWVuZDpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tdGV4dC1mb250LWZhbWlseTpcbiAqIGNhbGVuZGFyLW5hdmlnYXRpb24tdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1uYXZpZ2F0aW9uLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1uYXZpZ2F0aW9uLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1uYXZpZ2F0aW9uLXBhZGRpbmc6XG4gKiBjYWxlbmRhci1jZWxsLWluYWN0aXZlLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaG92ZXItdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LXNlbGVjdGVkLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1zZWxlY3RlZC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1pbi1yYW5nZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS1pbi1yYW5nZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktaW4tcmFuZ2UtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXRvZGF5LWluLXJhbmdlLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjYWxlbmRhci1kYXktY2VsbC13aWR0aDpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLWhlaWdodDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtd2lkdGg6XG4gKiBjYWxlbmRhci1tb250aC1jZWxsLWhlaWdodDpcbiAqIGNhbGVuZGFyLXllYXItY2VsbC13aWR0aDpcbiAqIGNhbGVuZGFyLXllYXItY2VsbC1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWJhY2tncm91bmQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWRpdmlkZXItY29sb3I6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWRpdmlkZXItd2lkdGg6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItd2Vla2RheS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS1ob2xpZGF5LXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktd2lkdGg6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWJhY2tncm91bmQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWRpdmlkZXItY29sb3I6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWRpdmlkZXItd2lkdGg6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItd2Vla251bWJlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItd2Vla251bWJlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla251bWJlci1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXdpZHRoOlxuICogY2FsZW5kYXItbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1kYXktY2VsbC1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLWxhcmdlLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktbGFyZ2UtaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItbGFyZ2UtaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla251bWJlci1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1tb250aC1jZWxsLWxhcmdlLWhlaWdodDpcbiAqIGNhbGVuZGFyLXllYXItY2VsbC1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLXllYXItY2VsbC1sYXJnZS1oZWlnaHQ6XG4gKiAqL1xuY2xhc3MgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAgICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYm91bmRpbmdNb250aCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHN0YXJ0aW5nIHZpZXcgZm9yIHRoZSBjYWxlbmRhci5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zdGFydFZpZXcgPSBOYkNhbGVuZGFyVmlld01vZGUuREFURTtcbiAgICAgICAgdGhpcy5kYXlDZWxsQ29tcG9uZW50ID0gTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5tb250aENlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyUmFuZ2VNb250aENlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMueWVhckNlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNhbGVuZGFyIGFuZCBlbnRpcmUgY29tcG9uZW50cy5cbiAgICAgICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyBjYWxlbmRhcnMgbmF2aWdhdGlvbiBvciBub3QuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2hvd05hdmlnYXRpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBzeW1ib2wgdXNlZCBhcyBhIGhlYWRlciBmb3Igd2VlayBudW1iZXJzIGNvbHVtblxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLndlZWtOdW1iZXJTeW1ib2wgPSAnIyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyByYW5nZSB3aGVuIHN0YXJ0IHNlbGVjdGVkIGFuZCBlbWl0cyBhZ2FpbiB3aGVuIGVuZCBzZWxlY3RlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5yYW5nZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGRheSBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBzZXQgX2NlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5kYXlDZWxsQ29tcG9uZW50ID0gY2VsbENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXN0b20gbW9udGggY2VsbCBjb21wb25lbnQuIEhhdmUgdG8gaW1wbGVtZW50IGBOYkNhbGVuZGFyQ2VsbGAgaW50ZXJmYWNlLlxuICAgICAqICovXG4gICAgc2V0IF9tb250aENlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5tb250aENlbGxDb21wb25lbnQgPSBjZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB5ZWFyIGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHNldCBfeWVhckNlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy55ZWFyQ2VsbENvbXBvbmVudCA9IGNlbGxDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93V2Vla051bWJlcjtcbiAgICB9XG4gICAgc2V0IHNob3dXZWVrTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgb25DaGFuZ2UoZGF0ZSkge1xuICAgICAgICB0aGlzLmluaXREYXRlSWZOdWxsKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWQoZGF0ZSk7XG4gICAgfVxuICAgIGluaXREYXRlSWZOdWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RFbmQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFN0YXJ0KGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvblN0YXJ0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5yYW5nZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICYmICFlbmQ7XG4gICAgfVxuICAgIHNlbGVjdFN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0UmFuZ2UoeyBzdGFydCB9KTtcbiAgICB9XG4gICAgc2VsZWN0RW5kKGRhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCB9ID0gdGhpcy5yYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKGRhdGUsIHN0YXJ0KSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0UmFuZ2UoeyBzdGFydCwgZW5kOiBkYXRlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSYW5nZSh7IHN0YXJ0OiBkYXRlLCBlbmQ6IHN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy5yYW5nZUNoYW5nZS5lbWl0KHJhbmdlKTtcbiAgICB9XG59XG5OYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXJhbmdlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1iYXNlLWNhbGVuZGFyXG4gICAgICBbZGF0ZV09XCJyYW5nZVwiXG4gICAgICAoZGF0ZUNoYW5nZSk9XCJvbkNoYW5nZSgkYW55KCRldmVudCkpXCJcbiAgICAgIFttaW5dPVwibWluXCJcbiAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgIFtzdGFydFZpZXddPVwic3RhcnRWaWV3XCJcbiAgICAgIFtib3VuZGluZ01vbnRoXT1cImJvdW5kaW5nTW9udGhcIlxuICAgICAgW2RheUNlbGxDb21wb25lbnRdPVwiZGF5Q2VsbENvbXBvbmVudFwiXG4gICAgICBbbW9udGhDZWxsQ29tcG9uZW50XT1cIm1vbnRoQ2VsbENvbXBvbmVudFwiXG4gICAgICBbeWVhckNlbGxDb21wb25lbnRdPVwieWVhckNlbGxDb21wb25lbnRcIlxuICAgICAgW3Zpc2libGVEYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgIFtzaG93TmF2aWdhdGlvbl09XCJzaG93TmF2aWdhdGlvblwiXG4gICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgIFtzaG93V2Vla051bWJlcl09XCJzaG93V2Vla051bWJlclwiXG4gICAgICBbd2Vla051bWJlclN5bWJvbF09XCJ3ZWVrTnVtYmVyU3ltYm9sXCJcbiAgICA+PC9uYi1iYXNlLWNhbGVuZGFyPlxuICBgXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBib3VuZGluZ01vbnRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGFydFZpZXc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1pbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWF4OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWx0ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIF9jZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydkYXlDZWxsQ29tcG9uZW50JyxdIH1dLFxuICAgIF9tb250aENlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ21vbnRoQ2VsbENvbXBvbmVudCcsXSB9XSxcbiAgICBtb250aENlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIF95ZWFyQ2VsbENvbXBvbmVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsneWVhckNlbGxDb21wb25lbnQnLF0gfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmlzaWJsZURhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dOYXZpZ2F0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICByYW5nZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd1dlZWtOdW1iZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdlZWtOdW1iZXJTeW1ib2w6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJhbmdlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ2FsZW5kYXJSYW5nZU1vZHVsZSB7XG59XG5OYkNhbGVuZGFyUmFuZ2VNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYkJhc2VDYWxlbmRhck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW05iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJSYW5nZU1vbnRoQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYkNhbGVuZGFyUmFuZ2VNb250aENlbGxDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfVElNRV9QSUNLRVJfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdOQl9USU1FX1BJQ0tFUl9DT05GSUcnKTtcblxuLyoqXG4gKiBUaGUgVGltZVBpY2tlciBjb21wb25lbnRzIGl0c2VsZi5cbiAqIFByb3ZpZGVzIGEgcHJveHkgdG8gYFRpbWVQaWNrZXJgIG9wdGlvbnMgYXMgd2VsbCBhcyBjdXN0b20gcGlja2VyIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE5iVGltZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBwbGF0Zm9ybVNlcnZpY2UsIGxvY2FsZSwgY2QsIGNhbGVuZGFyVGltZU1vZGVsU2VydmljZSwgZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucGxhdGZvcm1TZXJ2aWNlID0gcGxhdGZvcm1TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlID0gY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuYmx1ciQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmRheVBlcmlvZENvbHVtbk9wdGlvbnMgPSBbXCJBTVwiIC8qIEFNICovLCBcIlBNXCIgLyogUE0gKi9dO1xuICAgICAgICB0aGlzLmlzQU0gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gdGltZXBpY2tlciB2YWx1ZSBzaG91bGQgYmUgYWx3YXlzIHRydWVcbiAgICAgICAgICogSW4gY2FsZW5kYXItd2l0aC10aW1lLmNvbXBvbmVudCAgc2hvdWxkIHNldCB0byBmYWxzZVxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dGb290ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmhvdXJzVGV4dCA9ICdIcic7XG4gICAgICAgIHRoaXMubWludXRlc1RleHQgPSAnTWluJztcbiAgICAgICAgdGhpcy5zZWNvbmRzVGV4dCA9ICdTZWMnO1xuICAgICAgICB0aGlzLmFtcG1UZXh0ID0gJ0FtL1BtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGRhdGUgd2hlbiBzZWxlY3RlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vblNlbGVjdFRpbWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMudHdlbHZlSG91cnNGb3JtYXQgPSBjb25maWcudHdlbHZlSG91cnNGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR3ZWx2ZUhvdXJzRm9ybWF0ID0gZGF0ZVNlcnZpY2UuZ2V0TG9jYWxlVGltZUZvcm1hdCgpLmluY2x1ZGVzKCdoJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0aW1lcGlja2VyIGxvb3NlcyBmb2N1cy5cbiAgICAgKi9cbiAgICBnZXQgYmx1cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1ciQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGltZSBmb3JtYXQgc3RyaW5nLlxuICAgICAqICovXG4gICAgZ2V0IHRpbWVGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lRm9ybWF0O1xuICAgIH1cbiAgICBzZXQgdGltZUZvcm1hdCh0aW1lRm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX3RpbWVGb3JtYXQgPSB0aW1lRm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIDEyIGhvdXJzIGZvcm1hdCAuXG4gICAgICogKi9cbiAgICBnZXQgdHdlbHZlSG91cnNGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90d2VsdmVIb3Vyc0Zvcm1hdDtcbiAgICB9XG4gICAgc2V0IHR3ZWx2ZUhvdXJzRm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R3ZWx2ZUhvdXJzRm9ybWF0ID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNob3cgc2Vjb25kcyBpbiB0aW1lcGlja2VyLlxuICAgICAqIElnbm9yZWQgd2hlbiBzaW5nbGVDb2x1bW4gaXMgdHJ1ZVxuICAgICAqICovXG4gICAgZ2V0IHdpdGhTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aFNlY29uZHM7XG4gICAgfVxuICAgIHNldCB3aXRoU2Vjb25kcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aXRoU2Vjb25kcyA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTaG93IHRpbWVwaWNrZXIgdmFsdWVzIGluIG9uZSBjb2x1bW4gd2l0aCA2MCBtaW51dGVzIHN0ZXAgYnkgZGVmYXVsdC5cbiAgICAgKiAqL1xuICAgIGdldCBzaW5nbGVDb2x1bW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDb2x1bW47XG4gICAgfVxuICAgIHNldCBzaW5nbGVDb2x1bW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2luZ2xlQ29sdW1uID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBtaW51dGVzIG9mZnNldCBmb3Igb3B0aW9ucywgd2hlbiB0aW1lcGlja2VyIGlzIGluIHNpbmdsZSBjb2x1bW4gbW9kZS5cbiAgICAgKiBCeSBkZWZhdWx0IGl04oCZcyA2MCBtaW51dGVzOiAnMTI6MDAsIDEzOjAwOiAxNDowMCwgMTU6MDAuLi4nXG4gICAgICogKi9cbiAgICBzZXQgc3RlcChzdGVwKSB7XG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIH1cbiAgICBnZXQgc3RlcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGUgd2hpY2ggd2lsbCBiZSByZW5kZXJlZCBhcyBzZWxlY3RlZC5cbiAgICAgKiAqL1xuICAgIHNldCBkYXRlKGRhdGUpIHtcbiAgICAgICAgdGhpcy5fZGF0ZSA9IGRhdGU7XG4gICAgICAgIHRoaXMuaXNBTSA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF5UGVyaW9kKHRoaXMuZGF0ZSkgPT09IFwiQU1cIiAvKiBBTSAqLztcbiAgICAgICAgdGhpcy5idWlsZENvbHVtbk9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy50aW1lRm9ybWF0ID0gdGhpcy5zZXR1cFRpbWVGb3JtYXQoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoeyBzdGVwLCB0d2VsdmVIb3Vyc0Zvcm1hdCwgd2l0aFNlY29uZHMsIHNpbmdsZUNvbHVtbiwgfSkge1xuICAgICAgICB0aGlzLnRpbWVGb3JtYXQgPSB0aGlzLnNldHVwVGltZUZvcm1hdCgpO1xuICAgICAgICBjb25zdCBpc0NvbmZpZ0NoYW5nZWQgPSBzdGVwIHx8IHR3ZWx2ZUhvdXJzRm9ybWF0IHx8IHdpdGhTZWNvbmRzIHx8IHNpbmdsZUNvbHVtbjtcbiAgICAgICAgaWYgKGlzQ29uZmlnQ2hhbmdlZCB8fCAhdGhpcy5mdWxsVGltZU9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRDb2x1bW5PcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SG9zdChob3N0UmVmKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgfVxuICAgIGF0dGFjaChob3N0UmVmKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgfVxuICAgIHNldEN1cnJlbnRUaW1lKCkge1xuICAgICAgICB0aGlzLmRhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCk7XG4gICAgICAgIHRoaXMub25TZWxlY3RUaW1lLmVtaXQoe1xuICAgICAgICAgICAgdGltZTogdGhpcy5kYXRlLFxuICAgICAgICAgICAgc2F2ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldEhvdXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmRhdGVTZXJ2aWNlLnNldEhvdXJzKHRoaXMuZGF0ZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgc2V0TWludXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5kYXRlU2VydmljZS5zZXRNaW51dGVzKHRoaXMuZGF0ZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgc2V0U2Vjb25kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5kYXRlU2VydmljZS5zZXRTZWNvbmRzKHRoaXMuZGF0ZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgc2VsZWN0RnVsbFRpbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGNoYW5nZURheVBlcmlvZChkYXlQZXJpb2RUb1NldCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlU2VydmljZS5nZXREYXlQZXJpb2QodGhpcy5kYXRlKSA9PT0gZGF5UGVyaW9kVG9TZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJ0cmFjdCBob3VycyB3aGVuIHN3aXRjaGluZyB0byBBTSAoYmVmb3JlIG1pZGRheSwgMC0xMSBpbiAyNC1ob3VyKSBmcm9tIFBNIChhZnRlciBtaWRkYXksIDEyLTI0IGluIDI0LWhvdXIpLFxuICAgICAgICAvLyBvdGhlcndpc2UgYWRkIGhvdXJzIGJlY2F1c2Ugc3dpdGNoaW5nIHRvIFBNIGZyb20gQU0uXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRheVBlcmlvZFRvU2V0ID09PSBcIkFNXCIgLyogQU0gKi8gPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IGluY3JlbWVudCA9IGRpcmVjdGlvbiAqIHRoaXMuZGF0ZVNlcnZpY2UuSE9VUlNfSU5fREFZX1BFUklPRDtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmRhdGVTZXJ2aWNlLmFkZEhvdXJzKHRoaXMuZGF0ZSwgaW5jcmVtZW50KSk7XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdFRpbWUuZW1pdCh7IHRpbWU6IGRhdGUgfSk7XG4gICAgfVxuICAgIHNhdmVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdFRpbWUuZW1pdCh7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLmRhdGUsXG4gICAgICAgICAgICBzYXZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tCeVRpbWVWYWx1ZXMoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHRyYWNrQnlTaW5nbGVDb2x1bW5WYWx1ZShpbmRleCwgaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS52YWx1ZU9mKGl0ZW0pO1xuICAgIH1cbiAgICB0cmFja0J5RGF5UGVyaW9kKGluZGV4LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBzaG93U2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFNlY29uZHMgJiYgIXRoaXMuc2luZ2xlQ29sdW1uO1xuICAgIH1cbiAgICBpc1NlbGVjdGVkSG91cih2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0SG91cnModGhpcy5kYXRlKSA9PT0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNTZWxlY3RlZE1pbnV0ZSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TWludXRlcyh0aGlzLmRhdGUpID09PSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc1NlbGVjdGVkU2Vjb25kKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRTZWNvbmRzKHRoaXMuZGF0ZSkgPT09IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzU2VsZWN0ZWREYXlQZXJpb2QoZGF5UGVyaW9kKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXlQZXJpb2QgPT09IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF5UGVyaW9kKHRoaXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRGdWxsVGltZVN0cmluZyhpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmZvcm1hdChpdGVtLCB0aGlzLnRpbWVGb3JtYXQpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlzU2VsZWN0ZWRGdWxsVGltZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZUhvdXJBbmRNaW51dGUodmFsdWUsIHRoaXMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBidWlsZENvbHVtbk9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMudGltZUZvcm1hdCA9IHRoaXMuc2V0dXBUaW1lRm9ybWF0KCk7XG4gICAgICAgIHRoaXMuZnVsbFRpbWVPcHRpb25zID0gdGhpcy5zaW5nbGVDb2x1bW5cbiAgICAgICAgICAgID8gdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UuZ2V0SG91cnNSYW5nZSh0aGlzLnN0ZXApXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICB0aGlzLmhvdXJzQ29sdW1uT3B0aW9ucyA9IHRoaXMuZ2VuZXJhdGVIb3VycygpO1xuICAgICAgICB0aGlzLm1pbnV0ZXNDb2x1bW5PcHRpb25zID0gdGhpcy5nZW5lcmF0ZU1pbnV0ZXNPclNlY29uZHMoKTtcbiAgICAgICAgdGhpcy5zZWNvbmRzQ29sdW1uT3B0aW9ucyA9IHRoaXMud2l0aFNlY29uZHMgPyB0aGlzLmdlbmVyYXRlTWludXRlc09yU2Vjb25kcygpIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBpc0ZpcmVmb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXRmb3JtU2VydmljZS5GSVJFRk9YO1xuICAgIH1cbiAgICBnZW5lcmF0ZUhvdXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMudHdlbHZlSG91cnNGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiByYW5nZSgyNCwgKHYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdiwgdGV4dDogdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UucGFkZFRvVHdvU3ltYm9scyh2KSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNBTSkge1xuICAgICAgICAgICAgcmV0dXJuIChyYW5nZSgxMiwgKHYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdiA9PT0gMCA/IDEyIDogdjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdiwgdGV4dDogdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UucGFkZFRvVHdvU3ltYm9scyh0ZXh0KSB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocmFuZ2VGcm9tVG8oMTIsIDI0LCAodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHYgPT09IDEyID8gMTIgOiAodiAtIDEyKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2LCB0ZXh0OiB0aGlzLmNhbGVuZGFyVGltZU1vZGVsU2VydmljZS5wYWRkVG9Ud29TeW1ib2xzKHRleHQpIH07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVNaW51dGVzT3JTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoNjAsICh2KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdiwgdGV4dDogdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UucGFkZFRvVHdvU3ltYm9scyh2KSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0dXBUaW1lRm9ybWF0KCkge1xuICAgICAgICBpZiAoIXRoaXMudGltZUZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmZvcm1hdCB8fCB0aGlzLmJ1aWxkVGltZUZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVGb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFRpbWVGb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnR3ZWx2ZUhvdXJzRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy53aXRoU2Vjb25kcyAmJiAhdGhpcy5zaW5nbGVDb2x1bW4gPyB0aGlzLmRhdGVTZXJ2aWNlLmdldFR3ZWx2ZUhvdXJzRm9ybWF0V2l0aFNlY29uZHMoKVxuICAgICAgICAgICAgICAgIDogdGhpcy5kYXRlU2VydmljZS5nZXRUd2VsdmVIb3Vyc0Zvcm1hdCgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy53aXRoU2Vjb25kcyAmJiAhdGhpcy5zaW5nbGVDb2x1bW4gPyB0aGlzLmRhdGVTZXJ2aWNlLmdldFR3ZW50eUZvdXJIb3Vyc0Zvcm1hdFdpdGhTZWNvbmRzKClcbiAgICAgICAgICAgICAgICA6IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0VHdlbnR5Rm91ckhvdXJzRm9ybWF0KCl9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iVGltZVBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItdGltZXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5iLWNhcmQgKm5iUG9ydGFsXFxuICAgICAgICAgW2NsYXNzLnN1cHBvcnRzLXNjcm9sbGJhci10aGVtaW5nXT1cXFwiIWlzRmlyZWZveCgpXFxcIlxcbiAgICAgICAgIGNsYXNzPVxcXCJuYi10aW1lcGlja2VyLWNvbnRhaW5lclxcXCI+XFxuICA8bmItY2FyZC1oZWFkZXIgY2xhc3M9XFxcImNvbHVtbi1oZWFkZXJcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJzaW5nbGVDb2x1bW47IGVsc2UgZnVsbFRpbWVIZWFkZXJzQmxvY2tcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlci1jZWxsXFxcIj5UaW1lPC9kaXY+XFxuICAgIDwvbmctY29udGFpbmVyPlxcbiAgICA8bmctdGVtcGxhdGUgI2Z1bGxUaW1lSGVhZGVyc0Jsb2NrPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImhlYWRlci1jZWxsXFxcIj57eyBob3Vyc1RleHQgfX08L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXItY2VsbFxcXCI+e3sgbWludXRlc1RleHQgfX08L2Rpdj5cXG4gICAgICA8ZGl2ICpuZ0lmPVxcXCJ3aXRoU2Vjb25kc1xcXCIgY2xhc3M9XFxcImhlYWRlci1jZWxsXFxcIj57eyBzZWNvbmRzVGV4dCB9fTwvZGl2PlxcbiAgICAgIDxkaXYgKm5nSWY9XFxcInR3ZWx2ZUhvdXJzRm9ybWF0XFxcIiBjbGFzcz1cXFwiaGVhZGVyLWNlbGxcXFwiPnt7IGFtcG1UZXh0IH19PC9kaXY+XFxuICAgIDwvbmctdGVtcGxhdGU+XFxuICA8L25iLWNhcmQtaGVhZGVyPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwicGlja2VyLWJvZHlcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJzaW5nbGVDb2x1bW47IGVsc2UgZnVsbFRpbWVDb2x1bW5CbG9ja1xcXCI+XFxuICAgICAgPG5iLWxpc3QgY2xhc3M9XFxcInZhbHVlcy1saXN0XFxcIj5cXG4gICAgICAgIDxuYi1saXN0LWl0ZW1cXG4gICAgICAgICAgY2xhc3M9XFxcImxpc3QtaXRlbVxcXCJcXG4gICAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cXFwiaXNTZWxlY3RlZEZ1bGxUaW1lVmFsdWUoaXRlbSlcXFwiXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgZnVsbFRpbWVPcHRpb25zOyB0cmFja0J5OiB0cmFja0J5U2luZ2xlQ29sdW1uVmFsdWUuYmluZCh0aGlzKVxcXCI+XFxuICAgICAgICAgIDxuYi10aW1lcGlja2VyLWNlbGxcXG4gICAgICAgICAgICBbdmFsdWVdPVxcXCJnZXRGdWxsVGltZVN0cmluZyhpdGVtKVxcXCJcXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkRnVsbFRpbWVWYWx1ZShpdGVtKVxcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwic2VsZWN0RnVsbFRpbWUoaXRlbSlcXFwiPlxcbiAgICAgICAgICA8L25iLXRpbWVwaWNrZXItY2VsbD5cXG4gICAgICAgIDwvbmItbGlzdC1pdGVtPlxcbiAgICAgIDwvbmItbGlzdD5cXG4gICAgPC9uZy1jb250YWluZXI+XFxuXFxuICAgIDxuZy10ZW1wbGF0ZSAjZnVsbFRpbWVDb2x1bW5CbG9jaz5cXG4gICAgICA8bmItbGlzdCBjbGFzcz1cXFwidmFsdWVzLWxpc3RcXFwiPlxcbiAgICAgICAgPG5iLWxpc3QtaXRlbVxcbiAgICAgICAgICBjbGFzcz1cXFwibGlzdC1pdGVtXFxcIlxcbiAgICAgICAgICBbY2xhc3Muc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkSG91cihpdGVtLnZhbHVlKVxcXCJcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgaXRlbSBvZiBob3Vyc0NvbHVtbk9wdGlvbnM7IHRyYWNrQnk6IHRyYWNrQnlUaW1lVmFsdWVzXFxcIj5cXG4gICAgICAgICAgPG5iLXRpbWVwaWNrZXItY2VsbFxcbiAgICAgICAgICAgIFt2YWx1ZV09XFxcIml0ZW0udGV4dFxcXCJcXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkSG91cihpdGVtLnZhbHVlKVxcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwic2V0SG91cihpdGVtLnZhbHVlKVxcXCI+XFxuICAgICAgICAgIDwvbmItdGltZXBpY2tlci1jZWxsPlxcbiAgICAgICAgPC9uYi1saXN0LWl0ZW0+XFxuICAgICAgPC9uYi1saXN0PlxcbiAgICAgIDxuYi1saXN0IGNsYXNzPVxcXCJ2YWx1ZXMtbGlzdFxcXCI+XFxuICAgICAgICA8bmItbGlzdC1pdGVtXFxuICAgICAgICAgIGNsYXNzPVxcXCJsaXN0LWl0ZW1cXFwiXFxuICAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XFxcImlzU2VsZWN0ZWRNaW51dGUoaXRlbS52YWx1ZSlcXFwiXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGl0ZW0gb2YgbWludXRlc0NvbHVtbk9wdGlvbnM7IHRyYWNrQnk6IHRyYWNrQnlUaW1lVmFsdWVzXFxcIj5cXG4gICAgICAgICAgPG5iLXRpbWVwaWNrZXItY2VsbFxcbiAgICAgICAgICAgIFt2YWx1ZV09XFxcIml0ZW0udGV4dFxcXCJcXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkTWludXRlKGl0ZW0udmFsdWUpXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJzZXRNaW51dGUoaXRlbS52YWx1ZSlcXFwiPlxcbiAgICAgICAgICA8L25iLXRpbWVwaWNrZXItY2VsbD5cXG4gICAgICAgIDwvbmItbGlzdC1pdGVtPlxcbiAgICAgIDwvbmItbGlzdD5cXG4gICAgICA8bmItbGlzdCAqbmdJZj1cXFwic2hvd1NlY29uZHMoKVxcXCIgY2xhc3M9XFxcInZhbHVlcy1saXN0XFxcIj5cXG4gICAgICAgIDxuYi1saXN0LWl0ZW1cXG4gICAgICAgICAgY2xhc3M9XFxcImxpc3QtaXRlbVxcXCJcXG4gICAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cXFwiaXNTZWxlY3RlZFNlY29uZChpdGVtLnZhbHVlKVxcXCJcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgaXRlbSBvZiBzZWNvbmRzQ29sdW1uT3B0aW9uczsgdHJhY2tCeTogdHJhY2tCeVRpbWVWYWx1ZXNcXFwiPlxcbiAgICAgICAgICA8bmItdGltZXBpY2tlci1jZWxsXFxuICAgICAgICAgICAgW3ZhbHVlXT1cXFwiaXRlbS50ZXh0XFxcIlxcbiAgICAgICAgICAgIFtzZWxlY3RlZF09XFxcImlzU2VsZWN0ZWRTZWNvbmQoaXRlbS52YWx1ZSlcXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcInNldFNlY29uZChpdGVtLnZhbHVlKVxcXCI+XFxuICAgICAgICAgIDwvbmItdGltZXBpY2tlci1jZWxsPlxcbiAgICAgICAgPC9uYi1saXN0LWl0ZW0+XFxuICAgICAgPC9uYi1saXN0PlxcbiAgICAgIDxuYi1saXN0ICpuZ0lmPVxcXCJ0d2VsdmVIb3Vyc0Zvcm1hdFxcXCIgY2xhc3M9XFxcInZhbHVlcy1saXN0XFxcIj5cXG4gICAgICAgIDxuYi1saXN0LWl0ZW1cXG4gICAgICAgICAgY2xhc3M9XFxcImxpc3QtaXRlbSBhbS1wbS1pdGVtXFxcIlxcbiAgICAgICAgICBbY2xhc3Muc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkRGF5UGVyaW9kKGRheVBlcmlvZClcXFwiXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGRheVBlcmlvZCBvZiBkYXlQZXJpb2RDb2x1bW5PcHRpb25zOyB0cmFja0J5OiB0cmFja0J5RGF5UGVyaW9kXFxcIj5cXG4gICAgICAgICAgPG5iLXRpbWVwaWNrZXItY2VsbFxcbiAgICAgICAgICAgIFt2YWx1ZV09XFxcImRheVBlcmlvZFxcXCJcXG4gICAgICAgICAgICBbc2VsZWN0ZWRdPVxcXCJpc1NlbGVjdGVkRGF5UGVyaW9kKGRheVBlcmlvZClcXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcImNoYW5nZURheVBlcmlvZChkYXlQZXJpb2QpXFxcIj5cXG4gICAgICAgICAgPC9uYi10aW1lcGlja2VyLWNlbGw+XFxuICAgICAgICA8L25iLWxpc3QtaXRlbT5cXG4gICAgICA8L25iLWxpc3Q+XFxuICAgIDwvbmctdGVtcGxhdGU+XFxuICA8L2Rpdj5cXG5cXG4gIDxuYi1jYXJkLWZvb3RlciAqbmdJZj1cXFwic2hvd0Zvb3RlclxcXCIgY2xhc3M9XFxcImFjdGlvbnMtZm9vdGVyXFxcIj5cXG4gICAgPG5iLWNhbGVuZGFyLWFjdGlvbnNcXG4gICAgICBbYXBwbHlCdXR0b25UZXh0XT1cXFwiYXBwbHlCdXR0b25UZXh0XFxcIlxcbiAgICAgIFtjdXJyZW50VGltZUJ1dHRvblRleHRdPVxcXCJjdXJyZW50VGltZUJ1dHRvblRleHRcXFwiXFxuICAgICAgKHNldEN1cnJlbnRUaW1lKT1cXFwic2V0Q3VycmVudFRpbWUoKVxcXCJcXG4gICAgICAoc2F2ZVZhbHVlKT1cXFwic2F2ZVZhbHVlKClcXFwiXFxuICAgID48L25iLWNhbGVuZGFyLWFjdGlvbnM+XFxuICA8L25iLWNhcmQtZm9vdGVyPlxcbjwvbmItY2FyZD5cXG5cIixcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ25iVGltZXBpY2tlcicsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIubmItdGltZXBpY2tlci1jb250YWluZXJ7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1ib3R0b206MH0udmFsdWVzLWxpc3R7d2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47c2Nyb2xsLXNuYXAtdHlwZTp5IHByb3hpbWl0eX0udmFsdWVzLWxpc3Q6aG92ZXJ7b3ZlcmZsb3cteTphdXRvfS5saXN0LWl0ZW17Ym9yZGVyOjA7cGFkZGluZzowO2N1cnNvcjpwb2ludGVyfS5waWNrZXItYm9keXtkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTtmbGV4OjEgMCAwO292ZXJmbG93OmhpZGRlbn0uY29sdW1uLWhlYWRlcnt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtwYWRkaW5nOjB9LmhlYWRlci1jZWxse3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5hY3Rpb25zLWZvb3Rlcnt3aWR0aDoxMDAlfW5iLWNhcmQtaGVhZGVyLG5iLWNhcmQtZm9vdGVye2ZsZXg6MCAwIGF1dG99XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVGltZVBpY2tlckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfVElNRV9QSUNLRVJfQ09ORklHLF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUGxhdGZvcm0gfSxcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTE9DQUxFX0lELF0gfV0gfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBOYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJEYXRlU2VydmljZSB9XG5dO1xuTmJUaW1lUGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRpbWVGb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHR3ZWx2ZUhvdXJzRm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB3aXRoU2Vjb25kczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2luZ2xlQ29sdW1uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGVwOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93Rm9vdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhcHBseUJ1dHRvblRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhvdXJzVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWludXRlc1RleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlY29uZHNUZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhbXBtVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3VycmVudFRpbWVCdXR0b25UZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvblNlbGVjdFRpbWU6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBwb3J0YWw6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iUG9ydGFsRGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9LF0gfV1cbn07XG5cbmNsYXNzIE5iQ2FsZW5kYXJXaXRoVGltZUNvbXBvbmVudCBleHRlbmRzIE5iQ2FsZW5kYXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlLCBjZCwgY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmNhbGVuZGFyVGltZU1vZGVsU2VydmljZSA9IGNhbGVuZGFyVGltZU1vZGVsU2VydmljZTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGUgPSB0aGlzLmNhbGVuZGFyVGltZU1vZGVsU2VydmljZS5nZXRSZXNldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMucG9ydGFsT3V0bGV0LmF0dGFjaFRlbXBsYXRlUG9ydGFsKHRoaXMudGltZXBpY2tlci5wb3J0YWwpO1xuICAgIH1cbiAgICBvbkRhdGVWYWx1ZUNoYW5nZShkYXRlKSB7XG4gICAgICAgIGNvbnN0IGhvdXJzID0gdGhpcy5kYXRlU2VydmljZS5nZXRIb3Vycyh0aGlzLmRhdGUpO1xuICAgICAgICBjb25zdCBtaW51dGVzID0gdGhpcy5kYXRlU2VydmljZS5nZXRNaW51dGVzKHRoaXMuZGF0ZSk7XG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSB0aGlzLmRhdGVTZXJ2aWNlLmdldFNlY29uZHModGhpcy5kYXRlKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWNvbmRzID0gdGhpcy5kYXRlU2VydmljZS5nZXRNaWxsaXNlY29uZHModGhpcy5kYXRlKTtcbiAgICAgICAgbGV0IG5ld0RhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnNldEhvdXJzKGRhdGUsIGhvdXJzKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0TWludXRlcyhuZXdEYXRlLCBtaW51dGVzKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0TWludXRlcyhuZXdEYXRlLCBtaW51dGVzKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0U2Vjb25kcyhuZXdEYXRlLCBzZWNvbmRzKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0TWlsbGlzZWNvbmRzKG5ld0RhdGUsIG1pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG4gICAgfVxuICAgIG9uVGltZUNoYW5nZShzZWxlY3RlZFRpbWUpIHtcbiAgICAgICAgbGV0IG5ld0RhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmNsb25lKHRoaXMuZGF0ZSk7XG4gICAgICAgIG5ld0RhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnNldEhvdXJzKG5ld0RhdGUsIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0SG91cnMoc2VsZWN0ZWRUaW1lLnRpbWUpKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0TWludXRlcyhuZXdEYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLmdldE1pbnV0ZXMoc2VsZWN0ZWRUaW1lLnRpbWUpKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0U2Vjb25kcyhuZXdEYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLmdldFNlY29uZHMoc2VsZWN0ZWRUaW1lLnRpbWUpKTtcbiAgICAgICAgbmV3RGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2Uuc2V0TWlsbGlzZWNvbmRzKG5ld0RhdGUsIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TWlsbGlzZWNvbmRzKHNlbGVjdGVkVGltZS50aW1lKSk7XG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG4gICAgfVxuICAgIHNhdmVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgc2F2ZUN1cnJlbnRUaW1lKCkge1xuICAgICAgICB0aGlzLmRhdGVDaGFuZ2UuZW1pdCh0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXZSBkb24ndCBzaG93IHNlY29uZHMgd2l0aCB0d2VsdmUgaG91cnMgZm9ybWF0XG4gICAgICogKi9cbiAgICBzaG93U2Vjb25kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFNlY29uZHMgJiYgIXRoaXMudHdlbHZlSG91cnNGb3JtYXQ7XG4gICAgfVxuICAgIGlzTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbn1cbk5iQ2FsZW5kYXJXaXRoVGltZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItd2l0aC10aW1lJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1jYXJkIGNsYXNzPVwiY2FsZW5kYXItd2l0aC10aW1lXCI+XG4gICAgICA8bmItY2FyZC1ib2R5IGNsYXNzPVwicGlja2VyLWJvZHlcIj5cbiAgICAgICAgPG5iLWJhc2UtY2FsZW5kYXJcbiAgICAgICAgICBbYm91bmRpbmdNb250aF09XCJib3VuZGluZ01vbnRoXCJcbiAgICAgICAgICBbc3RhcnRWaWV3XT1cInN0YXJ0Vmlld1wiXG4gICAgICAgICAgW2RhdGVdPVwiZGF0ZVwiXG4gICAgICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAgICBbZmlsdGVyXT1cImZpbHRlclwiXG4gICAgICAgICAgW2RheUNlbGxDb21wb25lbnRdPVwiZGF5Q2VsbENvbXBvbmVudFwiXG4gICAgICAgICAgW21vbnRoQ2VsbENvbXBvbmVudF09XCJtb250aENlbGxDb21wb25lbnRcIlxuICAgICAgICAgIFt5ZWFyQ2VsbENvbXBvbmVudF09XCJ5ZWFyQ2VsbENvbXBvbmVudFwiXG4gICAgICAgICAgW3NpemVdPVwic2l6ZVwiXG4gICAgICAgICAgW3Zpc2libGVEYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgICAgICBbc2hvd05hdmlnYXRpb25dPVwic2hvd05hdmlnYXRpb25cIlxuICAgICAgICAgIFtzaG93V2Vla051bWJlcl09XCJzaG93V2Vla051bWJlclwiXG4gICAgICAgICAgW3dlZWtOdW1iZXJTeW1ib2xdPVwid2Vla051bWJlclN5bWJvbFwiXG4gICAgICAgICAgKGRhdGVDaGFuZ2UpPVwib25EYXRlVmFsdWVDaGFuZ2UoJGV2ZW50KVwiPlxuICAgICAgICA8L25iLWJhc2UtY2FsZW5kYXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLXNlY3Rpb25cIlxuICAgICAgICAgICAgIFtjbGFzcy5zaXplLWxhcmdlXT1cImlzTGFyZ2UoKVwiXG4gICAgICAgICAgICAgW2NsYXNzLnRpbWVwaWNrZXItc2luZ2xlLWNvbHVtbi13aWR0aF09XCJzaW5nbGVDb2x1bW5cIlxuICAgICAgICAgICAgIFtjbGFzcy50aW1lcGlja2VyLW11bHRpcGxlLWNvbHVtbi13aWR0aF09XCIhc2luZ2xlQ29sdW1uXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBpY2tlci10aXRsZVwiPnt7IHRpdGxlIH19PC9kaXY+XG4gICAgICAgICAgPG5iLXRpbWVwaWNrZXJcbiAgICAgICAgICAgIChvblNlbGVjdFRpbWUpPVwib25UaW1lQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW2RhdGVdPVwiZGF0ZVwiXG4gICAgICAgICAgICBbdHdlbHZlSG91cnNGb3JtYXRdPVwidHdlbHZlSG91cnNGb3JtYXRcIlxuICAgICAgICAgICAgW3dpdGhTZWNvbmRzXT1cInNob3dTZWNvbmRzKClcIlxuICAgICAgICAgICAgW3Nob3dGb290ZXJdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW3NpbmdsZUNvbHVtbl09XCJzaW5nbGVDb2x1bW5cIlxuICAgICAgICAgICAgW3N0ZXBdPVwic3RlcFwiPlxuICAgICAgICAgIDwvbmItdGltZXBpY2tlcj5cbiAgICAgICAgICA8bmctY29udGFpbmVyIG5iUG9ydGFsT3V0bGV0PjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmItY2FyZC1ib2R5PlxuICAgICAgPG5iLWNhcmQtZm9vdGVyIGNsYXNzPVwicGlja2VyLWZvb3RlclwiPlxuICAgICAgICA8bmItY2FsZW5kYXItYWN0aW9uc1xuICAgICAgICAgIFthcHBseUJ1dHRvblRleHRdPVwiYXBwbHlCdXR0b25UZXh0XCJcbiAgICAgICAgICBbY3VycmVudFRpbWVCdXR0b25UZXh0XT1cImN1cnJlbnRUaW1lQnV0dG9uVGV4dFwiXG4gICAgICAgICAgKHNldEN1cnJlbnRUaW1lKT1cInNhdmVDdXJyZW50VGltZSgpXCJcbiAgICAgICAgICAoc2F2ZVZhbHVlKT1cInNhdmVWYWx1ZSgpXCJcbiAgICAgICAgPjwvbmItY2FsZW5kYXItYWN0aW9ucz5cbiAgICAgIDwvbmItY2FyZC1mb290ZXI+XG4gICAgPC9uYi1jYXJkPlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3QgOjpuZy1kZWVwIG5iLWNhcmQubmItdGltZXBpY2tlci1jb250YWluZXJ7ZmxleDoxIDAgMDtib3JkZXItcmFkaXVzOjA7d2lkdGg6YXV0bztib3JkZXItcmlnaHQ6MDtib3JkZXItYm90dG9tOjB9W2Rpcj1sdHJdIDpob3N0IC5waWNrZXItZm9vdGVye3BhZGRpbmctbGVmdDouNjI1cmVtfVtkaXI9cnRsXSA6aG9zdCAucGlja2VyLWZvb3RlcntwYWRkaW5nLXJpZ2h0Oi42MjVyZW19LnBpY2tlci1ib2R5e2FsaWduLWl0ZW1zOnN0cmV0Y2g7ZGlzcGxheTpmbGV4O3BhZGRpbmc6MH0ucGlja2VyLWJvZHkgbmItYmFzZS1jYWxlbmRhciA6Om5nLWRlZXAgbmItY2FyZHtib3JkZXItcmFkaXVzOjB9LmNhbGVuZGFyLXdpdGgtdGltZXtvdmVyZmxvdzpoaWRkZW59LnRpbWVwaWNrZXItc2VjdGlvbntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNhbGVuZGFyV2l0aFRpbWVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogTmJDYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UgfVxuXTtcbk5iQ2FsZW5kYXJXaXRoVGltZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB2aXNpYmxlRGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdHdlbHZlSG91cnNGb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpdGhTZWNvbmRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaW5nbGVDb2x1bW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0ZXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRpbWVGb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRpdGxlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhcHBseUJ1dHRvblRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGN1cnJlbnRUaW1lQnV0dG9uVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9ydGFsT3V0bGV0OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtOYlBvcnRhbE91dGxldERpcmVjdGl2ZSxdIH1dLFxuICAgIHRpbWVwaWNrZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iVGltZVBpY2tlckNvbXBvbmVudCxdIH1dXG59O1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudCBleHRlbmRzIE5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgYXR0YWNoKHBvcnRhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH1cbn1cbk5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItZGF0ZXBpY2tlci1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLW92ZXJsYXktY29udGFpbmVyPjwvbmItb3ZlcmxheS1jb250YWluZXI+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJEYXRlcGlja2VyQ29udGFpbmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG92ZXJsYXlDb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCwgeyBzdGF0aWM6IHRydWUgfSxdIH1dXG59O1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogVGhlIGBOYkRhdGVwaWNrZXJBZGFwdGVyYCBpbnN0YW5jZXMgcHJvdmlkZSB3YXkgaG93IHRvIHBhcnNlLCBmb3JtYXQgYW5kIHZhbGlkYXRlXG4gKiBkaWZmZXJlbnQgZGF0ZSB0eXBlcy5cbiAqICovXG5jbGFzcyBOYkRhdGVwaWNrZXJBZGFwdGVyIHtcbn1cbi8qKlxuICogRGF0ZXBpY2tlciBpcyBhbiBjb250cm9sIHRoYXQgY2FuIHBpY2sgYW55IHZhbHVlcyBhbnl3YXkuXG4gKiBJdCBoYXMgdG8gYmUgYm91bmQgdG8gdGhlIGRhdGVwaWNrZXIgZGlyZWN0aXZlIHRocm91Z2ggbmJEYXRlcGlja2VyIGlucHV0LlxuICogKi9cbmNsYXNzIE5iRGF0ZXBpY2tlciB7XG59XG5jb25zdCBOQl9EQVRFX0FEQVBURVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0RhdGVwaWNrZXIgQWRhcHRlcicpO1xuY29uc3QgTkJfREFURV9TRVJWSUNFX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0RhdGUgc2VydmljZSBvcHRpb25zJyk7XG4vKipcbiAqIFRoZSBgTmJEYXRlcGlja2VyRGlyZWN0aXZlYCBpcyBmb3JtIGNvbnRyb2wgdGhhdCBnaXZlcyB5b3UgYWJpbGl0eSB0byBzZWxlY3QgZGF0ZXMgYW5kIHJhbmdlcy4gVGhlIGRhdGVwaWNrZXJcbiAqIGlzIHNob3duIHdoZW4gaW5wdXQgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cImRhdGVwaWNrZXJcIj5cbiAqIDxuYi1kYXRlcGlja2VyICNkYXRlcGlja2VyPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJEYXRlcGlja2VyTW9kdWxlLmZvclJvb3QoKWAgdG8geW91ciByb290IG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJEYXRlcGlja2VyTW9kdWxlLmZvclJvb3QoKSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKiBBbmQgYE5iRGF0ZXBpY2tlck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJEYXRlcGlja2VyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogSWYgeW91IHdhbnQgdG8gdXNlIHJhbmdlIHNlbGVjdGlvbiwgeW91IGhhdmUgdG8gdXNlIGBOYlJhbmdlcGlja2VyQ29tcG9uZW50YCBpbnN0ZWFkOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cInJhbmdlcGlja2VyXCI+XG4gKiA8bmItcmFuZ2VwaWNrZXIgI3JhbmdlcGlja2VyPjwvbmItcmFuZ2VwaWNrZXI+XG4gKiBgYGBcbiAqXG4gKiBCb3RoIHJhbmdlIGFuZCBkYXRlIHBpY2tlcnMgc3VwcG9ydCBhbGwgcGFyYW1ldGVycyBhcyBjYWxlbmRhciwgc28sIGNoZWNrIGBOYkNhbGVuZGFyQ29tcG9uZW50YCBmb3IgYWRkaXRpb25hbFxuICogaW5mby5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJhbmdlIHNob3djYXNlLCBkYXRlcGlja2VyL3JhbmdlcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBEYXRlcGlja2VyIGlzIHRoZSBmb3JtIGNvbnRyb2wgc28gaXQgY2FuIGJlIGJvdW5kIHdpdGggYW5ndWxhciBmb3JtcyB0aHJvdWdoIG5nTW9kZWwgYW5kIGZvcm0gY29udHJvbHMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShGb3JtcywgZGF0ZXBpY2tlci9kYXRlcGlja2VyLWZvcm1zLmNvbXBvbmVudClcbiAqXG4gKiBgTmJEYXRlcGlja2VyRGlyZWN0aXZlYCBtYXkgYmUgdmFsaWRhdGVkIHVzaW5nIGBtaW5gIGFuZCBgbWF4YCBkYXRlcyBwYXNzZWQgdG8gdGhlIGRhdGVwaWNrZXIuXG4gKiBBbmQgYGZpbHRlcmAgcHJlZGljYXRlIHRoYXQgcmVjZWl2ZXMgZGF0ZSBvYmplY3QgYW5kIGhhcyB0byByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVmFsaWRhdGlvbiwgZGF0ZXBpY2tlci9kYXRlcGlja2VyLXZhbGlkYXRpb24uY29tcG9uZW50KVxuICpcbiAqIElmIHlvdSBuZWVkIHRvIHBpY2sgYSB0aW1lIGFsb25nIHdpdGggdGhlIGRhdGUsIHlvdSBjYW4gdXNlIG5iLWRhdGUtdGltZXBpY2tlclxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBuYklucHV0IHBsYWNlaG9sZGVyPVwiUGljayBEYXRlXCIgW25iRGF0ZXBpY2tlcl09XCJkYXRlVGltZVBpY2tlclwiPlxuICogPG5iLWRhdGUtdGltZXBpY2tlciB3aXRoU2Vjb25kcyAjZGF0ZVRpbWVQaWNrZXI+PC9uYi1kYXRlLXRpbWVwaWNrZXI+XG4gKiBgYGBcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGF0ZSB0aW1lcGlja2VyLCBkYXRlcGlja2VyL2RhdGUtdGltZXBpY2tlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQSBzaW5nbGUgY29sdW1uIHBpY2tlciB3aXRoIG9wdGlvbnMgdmFsdWUgYXMgdGltZSBhbmQgbWludXRlLCBzbyB1c2VycyB3b27igJl0IGJlIGFibGUgdG8gcGlja1xuICogaG91cnMgYW5kIG1pbnV0ZXMgaW5kaXZpZHVhbGx5LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGF0ZSB0aW1lcGlja2VyIHNpbmdsZSBjb2x1bW4sIGRhdGVwaWNrZXIvZGF0ZS10aW1lcGlja2VyLXNpbmdsZS1jb2x1bW4uY29tcG9uZW50KVxuXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckNvbXBvbmVudGAgc3VwcG9ydHMgZGF0ZSBmb3JtYXR0aW5nOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cImRhdGVwaWNrZXJcIj5cbiAqIDxuYi1kYXRlcGlja2VyICNkYXRlcGlja2VyIGZvcm1hdD1cIk1NXFxkZFxceXl5eVwiPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICogPHNwYW4gaWQ9XCJmb3JtYXR0aW5nLWlzc3VlXCI+PC9zcGFuPlxuICogIyMgRm9ybWF0dGluZyBJc3N1ZVxuICpcbiAqIEJ5IGRlZmF1bHQsIGRhdGVwaWNrZXIgdXNlcyBhbmd1bGFycyBgTE9DQUxFX0lEYCB0b2tlbiBmb3IgbG9jYWxpemF0aW9uIGFuZCBgRGF0ZVBpcGVgIGZvciBkYXRlcyBmb3JtYXR0aW5nLlxuICogQW5kIG5hdGl2ZSBgRGF0ZS5wYXJzZSguLi4pYCBmb3IgZGF0ZXMgcGFyc2luZy4gQnV0IG5hdGl2ZSBgRGF0ZS5wYXJzZWAgZnVuY3Rpb24gZG9lc24ndCBzdXBwb3J0IGZvcm1hdHMuXG4gKiBUbyBwcm92aWRlIGN1c3RvbSBmb3JtYXR0aW5nIHlvdSBoYXZlIHRvIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBwYWNrYWdlczpcbiAqXG4gKiAtIGBAbmVidWxhci9tb21lbnRgIC0gcHJvdmlkZXMgbW9tZW50IGRhdGUgYWRhcHRlciB0aGF0IHVzZXMgbW9tZW50IGZvciBkYXRlIG9iamVjdHMuIFRoaXMgbWVhbnMgZGF0ZXBpY2tlciB0aGFuXG4gKiB3aWxsIG9wZXJhdGUgb25seSBtb21lbnQgZGF0ZSBvYmplY3RzLiBJZiB5b3Ugd2FudCB0byB1c2UgaXQgeW91IGhhdmUgdG8gaW5zdGFsbCBpdDogYG5wbSBpIEBuZWJ1bGFyL21vbWVudGAsIGFuZFxuICogaW1wb3J0IGBOYk1vbWVudERhdGVNb2R1bGVgIGZyb20gdGhpcyBwYWNrYWdlLlxuICpcbiAqIC0gYEBuZWJ1bGFyL2RhdGUtZm5zYCAtIGFkYXB0ZXIgZm9yIHBvcHVsYXIgZGF0ZS1mbnMgbGlicmFyeS4gVGhpcyB3YXkgaXMgcHJlZmVycmVkIGlmIHlvdSBuZWVkIG9ubHkgZGF0ZSBmb3JtYXR0aW5nLlxuICogQmVjYXVzZSBkYXRlLWZucyBpcyB0cmVlc2hha2FibGUsIHRpbnkgYW5kIG9wZXJhdGVzIG5hdGl2ZSBkYXRlIG9iamVjdHMuIElmIHlvdSB3YW50IHRvIHVzZSBpdCB5b3UgaGF2ZSB0b1xuICogaW5zdGFsbCBpdDogYG5wbSBpIEBuZWJ1bGFyL2RhdGUtZm5zYCwgYW5kIGltcG9ydCBgTmJEYXRlRm5zRGF0ZU1vZHVsZWAgZnJvbSB0aGlzIHBhY2thZ2UuXG4gKlxuICogIyMjIE5iRGF0ZUZuc0RhdGVNb2R1bGVcbiAqXG4gKiBGb3JtYXQgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBgTmJEYXRlRm5zRGF0ZU1vZHVsZWAuIFlvdSBjYW4gc2V0IGl0IHZpYSBgZm9ybWF0YCBpbnB1dCBvbiBkYXRlcGlja2VyIGNvbXBvbmVudDpcbiAqIGBgYGh0bWxcbiAqIDxuYi1kYXRlcGlja2VyIGZvcm1hdD1cImRkLk1NLnl5eXlcIj48L25iLWRhdGVwaWNrZXI+XG4gKiBgYGBcbiAqIEFsc28gZm9ybWF0IGNhbiBiZSBzZXQgZ2xvYmFsbHkgd2l0aCBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHsgZm9ybWF0OiAnZGQuTU0ueXl5eScgfSlgIGFuZFxuICogYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yQ2hpbGQoeyBmb3JtYXQ6ICdkZC5NTS55eXl5JyB9KWAgbWV0aG9kcy5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0byB1c2Ugc29tZSBvZiB0aGUgZm9ybWF0dGluZyB0b2tlbnMgeW91IGFsc28gbmVlZCB0byBwYXNzXG4gKiBgeyB1c2VBZGRpdGlvbmFsV2Vla1llYXJUb2tlbnM6IHRydWUsIHVzZUFkZGl0aW9uYWxEYXlPZlllYXJUb2tlbnM6IHRydWUgfWAgdG8gZGF0ZS1mbnMgcGFyc2UgYW5kIGZvcm1hdCBmdW5jdGlvbnMuXG4gKiBZb3UgY2FuIGNvbmZpZ3VyZSBvcHRpb25zIHBhc3NlZCB0aGlzIGZ1bmN0aW9ucyBieSBzZXR0aW5nIGBmb3JtYXRPcHRpb25zYCBhbmRcbiAqIGBwYXJzZU9wdGlvbnNgIG9mIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290YCBhbmQgYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yQ2hpbGRgIG1ldGhvZHMuXG4gKiBgYGB0c1xuICogTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgcGFyc2VPcHRpb25zOiB7IHVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VuczogdHJ1ZSwgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSB9LFxuICogICBmb3JtYXRPcHRpb25zOiB7IHVzZUFkZGl0aW9uYWxXZWVrWWVhclRva2VuczogdHJ1ZSwgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSB9LFxuICogfSlcbiAqIGBgYFxuICogRnVydGhlciBpbmZvIG9uIGBkYXRlLWZuc2AgZm9ybWF0dGluZyB0b2tlbnMgY291bGQgYmUgZm91bmQgYXRcbiAqIFtkYXRlLWZucyBkb2NzXShodHRwczovL2RhdGUtZm5zLm9yZy92Mi4wLjAtYWxwaGEuMjcvZG9jcy9Vbmljb2RlLVRva2VucykuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBgcGFyc2VPcHRpb25zYCBhbmQgYGZvcm1hdE9wdGlvbnNgIHRvIHByb3ZpZGUgbG9jYWxlLlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVvIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgIHBhcnNlT3B0aW9uczogeyBsb2NhbGU6IGVvIH0sXG4gKiAgICAgICBmb3JtYXRPcHRpb25zOiB7IGxvY2FsZTogZW8gfSxcbiAqICAgICB9KSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogZGF0ZXBpY2tlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogZGF0ZXBpY2tlci1ib3JkZXItY29sb3I6XG4gKiBkYXRlcGlja2VyLWJvcmRlci1zdHlsZTpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLXdpZHRoOlxuICogZGF0ZXBpY2tlci1ib3JkZXItcmFkaXVzOlxuICogZGF0ZXBpY2tlci1zaGFkb3c6XG4gKiAqL1xuY2xhc3MgTmJEYXRlcGlja2VyRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgZGF0ZXBpY2tlckFkYXB0ZXJzLCBob3N0UmVmLCBkYXRlU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXJBZGFwdGVycyA9IGRhdGVwaWNrZXJBZGFwdGVycztcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmlzRGF0ZXBpY2tlclJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRvcnMgd2lsbCBiZSBjYWxsZWQgaW4gdmFsaWRhdG9ycyBjb250ZXh0LCBzbywgd2UgbmVlZCB0byBiaW5kIHRoZW0uXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtcbiAgICAgICAgICAgIHRoaXMucGFyc2VWYWxpZGF0b3IsXG4gICAgICAgICAgICB0aGlzLm1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIHRoaXMubWF4VmFsaWRhdG9yLFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJWYWxpZGF0b3IsXG4gICAgICAgIF0ubWFwKGZuID0+IGZuLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPbklucHV0Q2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGRhdGVwaWNrZXIgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgc2V0IHNldFBpY2tlcihwaWNrZXIpIHtcbiAgICAgICAgdGhpcy5waWNrZXIgPSBwaWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBQaWNrZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3N0IGlucHV0IHZhbHVlLlxuICAgICAqICovXG4gICAgZ2V0IGlucHV0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIHZhbHVlIGluIHBpY2tlciBhbmQgaHRtbCBpbnB1dCBlbGVtZW50LlxuICAgICAqICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RhdGVwaWNrZXJSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZVBpY2tlcih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlSW5wdXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm0gY29udHJvbCB2YWxpZGF0aW9uIGJhc2VkIG9uIHBpY2tlciB2YWxpZGF0b3IgY29uZmlnLlxuICAgICAqICovXG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgcGlja2VyLCBmb2N1c2VzIHRoZSBpbnB1dFxuICAgICAqL1xuICAgIGhpZGVQaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5waWNrZXIuaGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB3ZSBjYW4gcGFyc2UgdmFsdWUgY29ycmVjdGx5LlxuICAgICAqICovXG4gICAgcGFyc2VWYWxpZGF0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRlIHNlcnZpY2VzIHRyZWF0IGVtcHR5IHN0cmluZyBhcyBpbnZhbGlkIGRhdGUuXG4gICAgICAgICAqIFRoYXQncyB3aHkgd2UncmUgZ2V0dGluZyBpbnZhbGlkIGZvcm1Db250cm9sIGluIGNhc2Ugb2YgZW1wdHkgaW5wdXQgd2hpY2ggaXMgbm90IHJlcXVpcmVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICBpZiAodGhpcy5pbnB1dFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIuaXNWYWxpZCh0aGlzLmlucHV0VmFsdWUsIHRoaXMucGlja2VyLmZvcm1hdCk7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkID8gbnVsbCA6IHsgbmJEYXRlcGlja2VyUGFyc2U6IHsgdmFsdWU6IHRoaXMuaW5wdXRWYWx1ZSB9IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXNzZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1pbi5cbiAgICAgKiAqL1xuICAgIG1pblZhbGlkYXRvcigpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5waWNrZXIuZ2V0VmFsaWRhdG9yQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVyLnBhcnNlKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuICghY29uZmlnLm1pbiB8fCAhZGF0ZSB8fCB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyhjb25maWcubWluLCBkYXRlKSA8PSAwKSA/XG4gICAgICAgICAgICBudWxsIDogeyBuYkRhdGVwaWNrZXJNaW46IHsgbWluOiBjb25maWcubWluLCBhY3R1YWw6IGRhdGUgfSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFzc2VkIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiBtYXguXG4gICAgICogKi9cbiAgICBtYXhWYWxpZGF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucGlja2VyLmdldFZhbGlkYXRvckNvbmZpZygpO1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlcGlja2VyQWRhcHRlci5wYXJzZSh0aGlzLmlucHV0VmFsdWUsIHRoaXMucGlja2VyLmZvcm1hdCk7XG4gICAgICAgIHJldHVybiAoIWNvbmZpZy5tYXggfHwgIWRhdGUgfHwgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXMoY29uZmlnLm1heCwgZGF0ZSkgPj0gMCkgP1xuICAgICAgICAgICAgbnVsbCA6IHsgbmJEYXRlcGlja2VyTWF4OiB7IG1heDogY29uZmlnLm1heCwgYWN0dWFsOiBkYXRlIH0gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhc3NlZCB2YWx1ZSBzYXRpc2Z5IHRoZSBmaWx0ZXIuXG4gICAgICogKi9cbiAgICBmaWx0ZXJWYWxpZGF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucGlja2VyLmdldFZhbGlkYXRvckNvbmZpZygpO1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlcGlja2VyQWRhcHRlci5wYXJzZSh0aGlzLmlucHV0VmFsdWUsIHRoaXMucGlja2VyLmZvcm1hdCk7XG4gICAgICAgIHJldHVybiAoIWNvbmZpZy5maWx0ZXIgfHwgIWRhdGUgfHwgY29uZmlnLmZpbHRlcihkYXRlKSkgP1xuICAgICAgICAgICAgbnVsbCA6IHsgbmJEYXRlcGlja2VyRmlsdGVyOiB0cnVlIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENob29zZXMgZGF0ZXBpY2tlciBhZGFwdGVyIGJhc2VkIG9uIHBhc3NlZCBwaWNrZXIgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgY2hvb3NlRGF0ZXBpY2tlckFkYXB0ZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIgPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVycy5maW5kKCh7IHBpY2tlciB9KSA9PiB0aGlzLnBpY2tlciBpbnN0YW5jZW9mIHBpY2tlcik7XG4gICAgICAgIGlmICh0aGlzLm5vRGF0ZXBpY2tlckFkYXB0ZXJQcm92aWRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGVwaWNrZXJBZGFwdGVyIHByb3ZpZGVkIGZvciBwaWNrZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBwaWNrZXIgdG8gdGhlIGhvc3QgaW5wdXQgZWxlbWVudCBhbmQgc3Vic2NyaWJlcyBvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqICovXG4gICAgc2V0dXBQaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuY2hvb3NlRGF0ZXBpY2tlckFkYXB0ZXIoKTtcbiAgICAgICAgdGhpcy5waWNrZXIuYXR0YWNoKHRoaXMuaG9zdFJlZik7XG4gICAgICAgIGlmICh0aGlzLmlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnZhbHVlID0gdGhpcy5kYXRlcGlja2VyQWRhcHRlci5wYXJzZSh0aGlzLmlucHV0VmFsdWUsIHRoaXMucGlja2VyLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gY2FzZSBkYXRlcGlja2VyIGNvbXBvbmVudCBwbGFjZWQgYWZ0ZXIgdGhlIGlucHV0IHdpdGggZGF0ZXBpY2tlciBkaXJlY3RpdmUsXG4gICAgICAgIC8vIHdlIGNhbid0IHJlYWQgYHRoaXMucGlja2VyLmZvcm1hdGAgb24gZmlyc3QgY2hhbmdlIGRldGVjdGlvbiBydW4sXG4gICAgICAgIC8vIHNpbmNlIGl0J3Mgbm90IGJvdW5kIHlldCwgc28gd2UgaGF2ZSB0byB3YWl0IGZvciBkYXRlcGlja2VyIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGF0ZXBpY2tlclJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci5pbml0XG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZSgxKSwgdGFwKCgpID0+IHRoaXMuaXNEYXRlcGlja2VyUmVhZHkgPSB0cnVlKSwgZmlsdGVyKCgpID0+ICEhdGhpcy5xdWV1ZSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWUodGhpcy5xdWV1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnF1ZXVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waWNrZXIudmFsdWVDaGFuZ2VcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlUGlja2VyKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbnB1dCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpY2tlci5zaG91bGRIaWRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQaWNrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lcmdlKHRoaXMucGlja2VyLmJsdXIsIGZyb21FdmVudCh0aGlzLmlucHV0LCAnYmx1cicpLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLnBpY2tlci5pc1Nob3duICYmIHRoaXMuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGhpcy5pbnB1dCkpKS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vblRvdWNoZWQoKSk7XG4gICAgfVxuICAgIHdyaXRlUGlja2VyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGlja2VyLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHdyaXRlSW5wdXQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgdGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSBzdHJpbmdSZXByZXNlbnRhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGlmIG5vIGRhdGVwaWNrZXIgYWRhcHRlciBwcm92aWRlZC5cbiAgICAgKiAqL1xuICAgIG5vRGF0ZXBpY2tlckFkYXB0ZXJQcm92aWRlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGVwaWNrZXJBZGFwdGVyIHx8ICEodGhpcy5kYXRlcGlja2VyQWRhcHRlciBpbnN0YW5jZW9mIE5iRGF0ZXBpY2tlckFkYXB0ZXIpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPbklucHV0Q2hhbmdlKCkge1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5pbnB1dCwgJ2lucHV0JylcbiAgICAgICAgICAgIC5waXBlKG1hcCgoKSA9PiB0aGlzLmlucHV0VmFsdWUpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh2YWx1ZSkgPT4gdGhpcy5oYW5kbGVJbnB1dENoYW5nZSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgaW5wdXQgdmFsdWUgYW5kIHdyaXRlIGlmIGl0IGlzbid0IG51bGwuXG4gICAgICogKi9cbiAgICBoYW5kbGVJbnB1dENoYW5nZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5wYXJzZUlucHV0VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKGRhdGUpO1xuICAgICAgICB0aGlzLndyaXRlUGlja2VyKGRhdGUpO1xuICAgIH1cbiAgICBwYXJzZUlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIuaXNWYWxpZCh2YWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIucGFyc2UodmFsdWUsIHRoaXMucGlja2VyLmZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuTmJEYXRlcGlja2VyRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtuYkRhdGVwaWNrZXJdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYkRhdGVwaWNrZXJEaXJlY3RpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYkRhdGVwaWNrZXJEaXJlY3RpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJEYXRlcGlja2VyRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ET0NVTUVOVCxdIH1dIH0sXG4gICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfREFURV9BREFQVEVSLF0gfV0gfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5iRGF0ZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5OYkRhdGVwaWNrZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2V0UGlja2VyOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkRhdGVwaWNrZXInLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBUaGUgYE5iQmFzZVBpY2tlcmAgY29tcG9uZW50IGNvbmNlbnRyYXRlcyBvdmVybGF5IG1hbmlwdWxhdGlvbiBsb2dpYy5cbiAqICovXG5jbGFzcyBOYkJhc2VQaWNrZXIgZXh0ZW5kcyBOYkRhdGVwaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXksIHBvc2l0aW9uQnVpbGRlciwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgY2ZyLCBkYXRlU2VydmljZSwgZGF0ZVNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXIgPSB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyO1xuICAgICAgICB0aGlzLmNmciA9IGNmcjtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlT3B0aW9ucyA9IGRhdGVTZXJ2aWNlT3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNhbGVuZGFyIGFuZCBlbnRpcmUgY29tcG9uZW50cy5cbiAgICAgICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLmluaXQkID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSBvZiBwaWNrZXIgY2hhbmdlcy4gUmVxdWlyZWQgdG8gYmUgdGhlIHN1YmplY3QgYmVjYXVzZSBwaWNrZXIgaGlkZXMgYW5kIHNob3dzIGFuZCBwaWNrZXJcbiAgICAgICAgICogY2hhbmdlIHN0cmVhbSBiZWNvbWVzIHJlY3JlYXRlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm92ZXJsYXlPZmZzZXQgPSA4O1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5ibHVyJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGlja2VyIGluc3RhbmNlLlxuICAgICAqICovXG4gICAgZ2V0IHBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyUmVmICYmIHRoaXMucGlja2VyUmVmLmluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb2YgcGlja2VyIHZhbHVlIGNoYW5nZXMuXG4gICAgICogKi9cbiAgICBnZXQgdmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uQ2hhbmdlJC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZ2V0IGlzU2hvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpO1xuICAgIH1cbiAgICBnZXQgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gZGF0ZXBpY2tlciBsb29zZXMgZm9jdXMuXG4gICAgICovXG4gICAgZ2V0IGJsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXIkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRlcGlja2VyIGtub3dzIG5vdGhpbmcgYWJvdXQgaG9zdCBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogU28sIGF0dGFjaCBtZXRob2QgYXR0YWNoZXMgZGF0ZXBpY2tlciB0byB0aGUgaG9zdCBpbnB1dCBlbGVtZW50LlxuICAgICAqICovXG4gICAgYXR0YWNoKGhvc3RSZWYpIHtcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblRyaWdnZXJzKCk7XG4gICAgfVxuICAgIGdldFZhbGlkYXRvckNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHsgbWluOiB0aGlzLm1pbiwgbWF4OiB0aGlzLm1heCwgZmlsdGVyOiB0aGlzLmZpbHRlciB9O1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5EYXRlcGlja2VyKCk7XG4gICAgfVxuICAgIHNob3VsZEhpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZGVPblNlbGVjdCAmJiAhIXRoaXMudmFsdWU7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSBjdXJyZW50IHZhbHVlIGlmIHBpY2tlciB3YXMgcmVuZGVyZWRcbiAgICAgICAgaWYgKHRoaXMucGlja2VyKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyUmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyUmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVPdmVybGF5KCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMucG9zaXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgb3BlbkRhdGVwaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5yZWYuYXR0YWNoKG5ldyBOYkNvbXBvbmVudFBvcnRhbChOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQsIG51bGwsIG51bGwsIHRoaXMuY2ZyKSk7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGVQaWNrZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblZhbHVlQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSgpO1xuICAgICAgICB0aGlzLnBhdGNoV2l0aElucHV0cygpO1xuICAgICAgICB0aGlzLnBpY2tlclJlZi5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25CdWlsZGVyXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5ob3N0UmVmKVxuICAgICAgICAgICAgLnBvc2l0aW9uKE5iUG9zaXRpb24uQk9UVE9NKVxuICAgICAgICAgICAgLm9mZnNldCh0aGlzLm92ZXJsYXlPZmZzZXQpXG4gICAgICAgICAgICAuYWRqdXN0bWVudChOYkFkanVzdG1lbnQuQ09VTlRFUkNMT0NLV0lTRSk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneS5wb3NpdGlvbkNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocG9zaXRpb24pID0+IHBhdGNoKHRoaXMuY29udGFpbmVyLCB7IHBvc2l0aW9uIH0pKTtcbiAgICB9XG4gICAgY3JlYXRlVHJpZ2dlclN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyXG4gICAgICAgICAgICAudHJpZ2dlcihOYlRyaWdnZXIuRk9DVVMpXG4gICAgICAgICAgICAuaG9zdCh0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgIC5jb250YWluZXIoKCkgPT4gdGhpcy5jb250YWluZXIpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25UcmlnZ2VycygpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5zaG93JC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zaG93KCkpO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5oaWRlJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibHVyJC5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlUGlja2VyKCkge1xuICAgICAgICB0aGlzLnBpY2tlclJlZiA9IHRoaXMuY29udGFpbmVyLmluc3RhbmNlLmF0dGFjaChuZXcgTmJDb21wb25lbnRQb3J0YWwodGhpcy5waWNrZXJDbGFzcywgbnVsbCwgbnVsbCwgdGhpcy5jZnIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyBvbiBwaWNrZXIgdmFsdWUgY2hhbmdlcyBhbmQgZW1pdCBkYXRhIHRocm91Z2ggdGhpcy5vbkNoYW5nZSQgc3ViamVjdC5cbiAgICAgKiAqL1xuICAgIHN1YnNjcmliZU9uVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucGlja2VyVmFsdWVDaGFuZ2Uuc3Vic2NyaWJlKGRhdGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSQubmV4dChkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdGNoV2l0aElucHV0cygpIHtcbiAgICAgICAgdGhpcy5waWNrZXIuYm91bmRpbmdNb250aCA9IHRoaXMuYm91bmRpbmdNb250aDtcbiAgICAgICAgdGhpcy5waWNrZXIuc3RhcnRWaWV3ID0gdGhpcy5zdGFydFZpZXc7XG4gICAgICAgIHRoaXMucGlja2VyLm1pbiA9IHRoaXMubWluO1xuICAgICAgICB0aGlzLnBpY2tlci5tYXggPSB0aGlzLm1heDtcbiAgICAgICAgdGhpcy5waWNrZXIuZmlsdGVyID0gdGhpcy5maWx0ZXI7XG4gICAgICAgIHRoaXMucGlja2VyLl9jZWxsQ29tcG9uZW50ID0gdGhpcy5kYXlDZWxsQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnBpY2tlci5fbW9udGhDZWxsQ29tcG9uZW50ID0gdGhpcy5tb250aENlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMucGlja2VyLl95ZWFyQ2VsbENvbXBvbmVudCA9IHRoaXMueWVhckNlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMucGlja2VyLnNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHRoaXMucGlja2VyLnNob3dOYXZpZ2F0aW9uID0gdGhpcy5zaG93TmF2aWdhdGlvbjtcbiAgICAgICAgdGhpcy5waWNrZXIudmlzaWJsZURhdGUgPSB0aGlzLnZpc2libGVEYXRlO1xuICAgICAgICB0aGlzLnBpY2tlci5zaG93V2Vla051bWJlciA9IHRoaXMuc2hvd1dlZWtOdW1iZXI7XG4gICAgICAgIHRoaXMucGlja2VyLndlZWtOdW1iZXJTeW1ib2wgPSB0aGlzLndlZWtOdW1iZXJTeW1ib2w7XG4gICAgfVxuICAgIGNoZWNrRm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlU2VydmljZS5nZXRJZCgpID09PSAnbmF0aXZlJyAmJiB0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGZvcm1hdCBuYXRpdmUgZGF0ZS4gVG8gdXNlIGN1c3RvbSBmb3JtYXR0aW5nIHlvdSBoYXZlIHRvIGluc3RhbGwgQG5lYnVsYXIvbW9tZW50IG9yICcgK1xuICAgICAgICAgICAgICAgICdAbmVidWxhci9kYXRlLWZucyBwYWNrYWdlIGFuZCBpbXBvcnQgTmJNb21lbnREYXRlTW9kdWxlIG9yIE5iRGF0ZUZuc0RhdGVNb2R1bGUgYWNjb3JkaW5nbHkuJyArXG4gICAgICAgICAgICAgICAgJ01vcmUgaW5mb3JtYXRpb24gYXQgXCJGb3JtYXR0aW5nIGlzc3VlXCIgJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vYWt2ZW8uZ2l0aHViLmlvL25lYnVsYXIvZG9jcy9jb21wb25lbnRzL2RhdGVwaWNrZXIvb3ZlcnZpZXcjbmJkYXRlcGlja2VyY29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNGb3JtYXRTZXQgPSB0aGlzLmZvcm1hdCB8fCAodGhpcy5kYXRlU2VydmljZU9wdGlvbnMgJiYgdGhpcy5kYXRlU2VydmljZU9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlcnZpY2UuZ2V0SWQoKSA9PT0gJ2RhdGUtZm5zJyAmJiAhaXNGb3JtYXRTZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgTmJEYXRlRm5zRGF0ZU1vZHVsZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgTmJCYXNlUGlja2VyQ29tcG9uZW50IGV4dGVuZHMgTmJCYXNlUGlja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcG9zaXRpb25CdWlsZGVyLCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyLCBvdmVybGF5LCBjZnIsIGRhdGVTZXJ2aWNlLCBkYXRlU2VydmljZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3ZlcmxheSwgcG9zaXRpb25CdWlsZGVyLCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyLCBjZnIsIGRhdGVTZXJ2aWNlLCBkYXRlU2VydmljZU9wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgcmVuZGVyIHByZXZpb3VzIGFuZCBuZXh0IG1vbnRoc1xuICAgICAgICAgKiBpbiB0aGUgY3VycmVudCBtb250aCB2aWV3LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmJvdW5kaW5nTW9udGggPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBzdGFydGluZyB2aWV3IGZvciBjYWxlbmRhci5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zdGFydFZpZXcgPSBOYkNhbGVuZGFyVmlld01vZGUuREFURTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNhbGVuZGFyIGFuZCBlbnRpcmUgY29tcG9uZW50cy5cbiAgICAgICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGlkZSBwaWNrZXIgd2hlbiBhIGRhdGUgb3IgYSByYW5nZSBpcyBzZWxlY3RlZCwgYHRydWVgIGJ5IGRlZmF1bHRcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGVPblNlbGVjdCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IGNhbGVuZGFycyBuYXZpZ2F0aW9uIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgc3ltYm9sIHVzZWQgYXMgYSBoZWFkZXIgZm9yIHdlZWsgbnVtYmVycyBjb2x1bW5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyU3ltYm9sID0gJyMnO1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBwaWNrZXIgb3ZlcmxheSBvZmZzZXQgKGluIHBpeGVscykuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMub3ZlcmxheU9mZnNldCA9IDg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgZ2V0IHNob3dXZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1dlZWtOdW1iZXI7XG4gICAgfVxuICAgIHNldCBzaG93V2Vla051bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmNoZWNrRm9ybWF0KCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZm9ybWF0ICYmICFjaGFuZ2VzLmZvcm1hdC5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCQubmV4dCgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuaW5pdCQuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlclN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBpY2tlclZhbHVlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7IH1cbiAgICB3cml0ZVF1ZXVlKCkge1xuICAgIH1cbn1cbk5iQmFzZVBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkJhc2VQaWNrZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0sXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfREFURV9TRVJWSUNFX09QVElPTlMsXSB9XSB9XG5dO1xuTmJCYXNlUGlja2VyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGZvcm1hdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYm91bmRpbmdNb250aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhcnRWaWV3OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtaW46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1heDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXlDZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtb250aENlbGxDb21wb25lbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHllYXJDZWxsQ29tcG9uZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2aXNpYmxlRGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGlkZU9uU2VsZWN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93TmF2aWdhdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgd2Vla051bWJlclN5bWJvbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd1dlZWtOdW1iZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG92ZXJsYXlPZmZzZXQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuLyoqXG4gKiBUaGUgRGF0ZVBpY2tlciBjb21wb25lbnRzIGl0c2VsZi5cbiAqIFByb3ZpZGVzIGEgcHJveHkgdG8gYE5iQ2FsZW5kYXJgIG9wdGlvbnMgYXMgd2VsbCBhcyBjdXN0b20gcGlja2VyIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE5iRGF0ZXBpY2tlckNvbXBvbmVudCBleHRlbmRzIE5iQmFzZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucGlja2VyQ2xhc3MgPSBOYkNhbGVuZGFyQ29tcG9uZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRlIHdoaWNoIHdpbGwgYmUgcmVuZGVyZWQgYXMgc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICBzZXQgZGF0ZShkYXRlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBkYXRlIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICBnZXQgZGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDaGFuZ2U7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZGF0ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IGRhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5waWNrZXIudmlzaWJsZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5waWNrZXIuZGF0ZSA9IGRhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHBpY2tlclZhbHVlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXIuZGF0ZUNoYW5nZTtcbiAgICB9XG4gICAgd3JpdGVRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iRGF0ZXBpY2tlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItZGF0ZXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iRGF0ZXBpY2tlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG4vKipcbiAqIFRoZSBSYW5nZURhdGVQaWNrZXIgY29tcG9uZW50cyBpdHNlbGYuXG4gKiBQcm92aWRlcyBhIHByb3h5IHRvIGBOYkNhbGVuZGFyUmFuZ2VgIG9wdGlvbnMgYXMgd2VsbCBhcyBjdXN0b20gcGlja2VyIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE5iUmFuZ2VwaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBOYkJhc2VQaWNrZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBpY2tlckNsYXNzID0gTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSYW5nZSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSByYW5nZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgcmFuZ2Ugd2hlbiBzdGFydCBzZWxlY3RlZCBhbmQgZW1pdHMgYWdhaW4gd2hlbiBlbmQgc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICBnZXQgcmFuZ2VDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2hhbmdlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlciA/IHRoaXMucGlja2VyLnJhbmdlIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgdmFsdWUocmFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IHJhbmdlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZURhdGUgPSByYW5nZSAmJiByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB2aXNpYmxlRGF0ZTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnZpc2libGVEYXRlID0gdmlzaWJsZURhdGU7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwaWNrZXJWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyLnJhbmdlQ2hhbmdlO1xuICAgIH1cbiAgICBzaG91bGRIaWRlKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2hvdWxkSGlkZSgpICYmICEhKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5zdGFydCAmJiB0aGlzLnZhbHVlLmVuZCk7XG4gICAgfVxuICAgIHdyaXRlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMucXVldWU7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSByYW5nZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iUmFuZ2VwaWNrZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXJhbmdlcGlja2VyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJSYW5nZXBpY2tlckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByYW5nZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcmFuZ2VDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuY2xhc3MgTmJEYXRlVGltZVBpY2tlckNvbXBvbmVudCBleHRlbmRzIE5iQmFzZVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHBvc2l0aW9uQnVpbGRlciwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgb3ZlcmxheSwgY2ZyLCBkYXRlU2VydmljZSwgZGF0ZVNlcnZpY2VPcHRpb25zLCBjYWxlbmRhcldpdGhUaW1lTW9kZWxTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBwb3NpdGlvbkJ1aWxkZXIsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXIsIG92ZXJsYXksIGNmciwgZGF0ZVNlcnZpY2UsIGRhdGVTZXJ2aWNlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJXaXRoVGltZU1vZGVsU2VydmljZSA9IGNhbGVuZGFyV2l0aFRpbWVNb2RlbFNlcnZpY2U7XG4gICAgICAgIHRoaXMucGlja2VyQ2xhc3MgPSBOYkNhbGVuZGFyV2l0aFRpbWVDb21wb25lbnQ7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZGF0ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKGRhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IGRhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5waWNrZXIudmlzaWJsZURhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5waWNrZXIuZGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdHdlbHZlSG91cnNGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90d2VsdmVIb3Vyc0Zvcm1hdDtcbiAgICB9XG4gICAgc2V0IHR3ZWx2ZUhvdXJzRm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R3ZWx2ZUhvdXJzRm9ybWF0ID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHdpdGhTZWNvbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aFNlY29uZHM7XG4gICAgfVxuICAgIHNldCB3aXRoU2Vjb25kcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aXRoU2Vjb25kcyA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBzaW5nbGVDb2x1bW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVDb2x1bW47XG4gICAgfVxuICAgIHNldCBzaW5nbGVDb2x1bW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2luZ2xlQ29sdW1uID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQgfHwgdGhpcy5idWlsZFRpbWVGb3JtYXQoKTtcbiAgICB9XG4gICAgcGF0Y2hXaXRoSW5wdXRzKCkge1xuICAgICAgICB0aGlzLnBpY2tlci5zaW5nbGVDb2x1bW4gPSB0aGlzLnNpbmdsZUNvbHVtbjtcbiAgICAgICAgdGhpcy5waWNrZXIudHdlbHZlSG91cnNGb3JtYXQgPSB0aGlzLnR3ZWx2ZUhvdXJzRm9ybWF0O1xuICAgICAgICB0aGlzLnBpY2tlci53aXRoU2Vjb25kcyA9IHRoaXMud2l0aFNlY29uZHM7XG4gICAgICAgIHRoaXMucGlja2VyLnN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgICAgIHRoaXMucGlja2VyLnRpdGxlID0gdGhpcy50aXRsZTtcbiAgICAgICAgdGhpcy5waWNrZXIuYXBwbHlCdXR0b25UZXh0ID0gdGhpcy5hcHBseUJ1dHRvblRleHQ7XG4gICAgICAgIHRoaXMucGlja2VyLmN1cnJlbnRUaW1lQnV0dG9uVGV4dCA9IHRoaXMuY3VycmVudFRpbWVCdXR0b25UZXh0O1xuICAgICAgICBpZiAodGhpcy50d2VsdmVIb3Vyc0Zvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXIudGltZUZvcm1hdCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0VHdlbHZlSG91cnNGb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnRpbWVGb3JtYXQgPSB0aGlzLndpdGhTZWNvbmRzID8gdGhpcy5kYXRlU2VydmljZS5nZXRUd2VudHlGb3VySG91cnNGb3JtYXRXaXRoU2Vjb25kcygpIDpcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlLmdldFR3ZW50eUZvdXJIb3Vyc0Zvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBhdGNoV2l0aElucHV0cygpO1xuICAgICAgICB0aGlzLnBpY2tlci5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IHBpY2tlclZhbHVlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXIuZGF0ZUNoYW5nZTtcbiAgICB9XG4gICAgd3JpdGVRdWV1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZFRpbWVGb3JtYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZUNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJXaXRoVGltZU1vZGVsU2VydmljZS5idWlsZERhdGVGb3JtYXQodGhpcy50d2VsdmVIb3Vyc0Zvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhcldpdGhUaW1lTW9kZWxTZXJ2aWNlLmJ1aWxkRGF0ZUZvcm1hdCh0aGlzLnR3ZWx2ZUhvdXJzRm9ybWF0LCB0aGlzLndpdGhTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWRhdGUtdGltZXBpY2tlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6ICcnLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0sXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfREFURV9TRVJWSUNFX09QVElPTlMsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJDYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UgfVxuXTtcbk5iRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc3RlcDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFwcGx5QnV0dG9uVGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY3VycmVudFRpbWVCdXR0b25UZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0d2VsdmVIb3Vyc0Zvcm1hdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgd2l0aFNlY29uZHM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpbmdsZUNvbHVtbjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGlzVXJsUGF0aEVxdWFsKHBhdGgsIGxpbmspIHtcbiAgICBjb25zdCBsb2NhdGlvblBhdGggPSBnZXRQYXRoUGFydE9mVXJsKHBhdGgpO1xuICAgIHJldHVybiBsaW5rID09PSBsb2NhdGlvblBhdGg7XG59XG5mdW5jdGlvbiBpc1VybFBhdGhDb250YWluKHBhdGgsIGxpbmspIHtcbiAgICBjb25zdCBsb2NhdGlvblBhdGggPSBnZXRQYXRoUGFydE9mVXJsKHBhdGgpO1xuICAgIGNvbnN0IGVuZE9mVXJsU2VnbWVudFJlZ0V4cCA9IC9cXC98XiQvO1xuICAgIHJldHVybiBsb2NhdGlvblBhdGguc3RhcnRzV2l0aChsaW5rKSAmJlxuICAgICAgICBsb2NhdGlvblBhdGguc2xpY2UobGluay5sZW5ndGgpLmNoYXJBdCgwKS5zZWFyY2goZW5kT2ZVcmxTZWdtZW50UmVnRXhwKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBnZXRQYXRoUGFydE9mVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwubWF0Y2goLy4qPyg/PVs/OyNdfCQpLylbMF07XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudFBhcnRPZlVybCh1cmwpIHtcbiAgICBjb25zdCBtYXRjaGVkID0gdXJsLm1hdGNoKC8jKC4rKS8pO1xuICAgIHJldHVybiBtYXRjaGVkID8gbWF0Y2hlZFsxXSA6ICcnO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudEVxdWFsKHBhdGgsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGdldEZyYWdtZW50UGFydE9mVXJsKHBhdGgpID09PSBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnRDb250YWluKHBhdGgsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGdldEZyYWdtZW50UGFydE9mVXJsKHBhdGgpLmluY2x1ZGVzKGZyYWdtZW50KTtcbn1cblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgZGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBzY3JvbGwgdGhlIGxheW91dCBiYWNrIHRvIHRvcC5cbiAqIFRoaXMgb2NjdXJzIHdoZW4gdGhlIHBhZ2UgaXMgY2hhbmdlZCwgc28gd2hlbiBjdXJyZW50IHVybCBQQVRIIGlzIG5vdCBlcXVhbCB0byB0aGUgcHJldmlvdXMgb25lLlxuICpcbiAqICBUT0RPOiB0aGlzIGlzIG1vc3QgbGlrZWx5IGEgdGVtcG9yYXJ5IHNvbHV0aW9ucyBhcyByZWNlbnRseSBBbmd1bGFyIGludHJvZHVjZXMgVmlld3BvcnRTY3JvbGxcbiAqICBhbmQgc2Nyb2xsIHJlc3RvcmF0aW9uIHByb2Nlc3NcbiAqL1xuY2xhc3MgTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgfVxuICAgIHNob3VsZFJlc3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aChudWxsKSwgZmlsdGVyKGV2ZW50ID0+IGV2ZW50ID09PSBudWxsIHx8IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksIHBhaXJ3aXNlKCksIG1hcCgoW3ByZXYsIGN1cnJlbnRdKSA9PiB0aGlzLnBhZ2VDaGFuZ2VkKHByZXYsIGN1cnJlbnQpKSwgZmlsdGVyKHJlcyA9PiAhIXJlcykpO1xuICAgIH1cbiAgICBwYWdlQ2hhbmdlZChwcmV2LCBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiAhcHJldiB8fCBnZXRQYXRoUGFydE9mVXJsKHByZXYudXJsKSAhPT0gZ2V0UGF0aFBhcnRPZlVybChjdXJyZW50LnVybCk7XG4gICAgfVxufVxuTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBSb3V0ZXIgfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBMYXlvdXQgY29udGFpbmVyIGNvbXBvbmVudC5cbiAqIFdoZW4gdXNpbmcgd2l0aCBOZWJ1bGFyIFRoZW1lIFN5c3RlbSBpdCBpcyByZXF1aXJlZCB0aGF0IGFsbCBjaGlsZCBjb21wb25lbnRzIHNob3VsZCBiZSBwbGFjZWQgaW5zaWRlLlxuICpcbiAqIEJhc2ljIGV4YW1wbGUgb2YgdHdvIGNvbHVtbiBsYXlvdXQgd2l0aCBoZWFkZXI6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgbGF5b3V0L2xheW91dC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQ2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBjb21wb25lbnRzIGluc2lkZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItbGF5b3V0PlxuICogIDxuYi1sYXlvdXQtaGVhZGVyPjwvbmItbGF5b3V0LWhlYWRlcj5cbiAqICA8bmItbGF5b3V0LWZvb3Rlcj48L25iLWxheW91dC1mb290ZXI+XG4gKiAgPG5iLWxheW91dC1jb2x1bW4+PC9uYi1sYXlvdXQtY29sdW1uPlxuICogIDxuYi1zaWRlYmFyPjwvbmItc2lkZWJhcj5cbiAqIDwvbmItbGF5b3V0PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkxheW91dE1vZHVsZWAgdG8geW91ciBhcHAgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkxheW91dE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqIEJ5IGRlZmF1bHQgdGhlIGxheW91dCBmaWxscyB1cCB0aGUgd2hvbGUgdmlldy1wb3J0LlxuICogVGhlIHdpbmRvdyBzY3JvbGxiYXJzIGFyZSBkaXNhYmxlZCBvbiB0aGUgYm9keSBhbmQgbW92ZWQgaW5zaWRlIG9mIHRoZSBuYi1sYXlvdXQsIHNvIHRoYXQgdGhlIHNjcm9sbGJhcnNcbiAqIHdvbid0IG1lc3Mgd2l0aCB0aGUgZml4ZWQgbmItaGVhZGVyLlxuICpcbiAqIFRoZSBjaGlsZCBjb21wb25lbnRzIGFyZSBwcm9qZWN0ZWQgaW50byBhIGZsZXhpYmxlIGxheW91dCBzdHJ1Y3R1cmUgYWxsb3dpbmcgdG8gYWRqdXN0IHRoZSBsYXlvdXQgYmVoYXZpb3JcbiAqIGJhc2VkIG9uIHRoZSBzZXR0aW5ncyBwcm92aWRlZC5cbiAqXG4gKiBUaGUgbGF5b3V0IGNvbnRlbnQgKGNvbHVtbnMpIGJlY29tZXMgY2VudGVyZWQgd2hlbiB0aGUgd2luZG93IHdpZHRoIGlzIG1vcmUgdGhhblxuICogdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgdGhlbWUgdmFyaWFibGUgYGxheW91dC1jb250ZW50LXdpZHRoYC5cbiAqXG4gKiBUaGUgbGF5b3V0IGFsc28gY29udGFpbnMgdGhlIGFyZWEgb24gdGhlIHZlcnkgdG9wICh0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIG5iLWxheW91dCksIHdoaWNoIGNvdWxkIGJlIHVzZWRcbiAqIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBzb21lIGNvbXBvbmVudHMgbGlrZSBtb2RhbHMgb3Igc3Bpbm5lcnMvbG9hZGVyc1xuICogc28gdGhhdCB0aGV5IGFyZSBsb2NhdGVkIG9uIHRvcCBvZiB0aGUgZWxlbWVudHMgaGllcmFyY2h5LlxuICogTW9yZSBkZXRhaWxzIGFyZSB1bmRlciB0aGUgYFRoZW1lU2VydmljZWAgc2VjdGlvbi5cbiAqXG4gKiBUaGUgbGF5b3V0IGNvbXBvbmVudCBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBjaGFuZ2luZyBhcHBsaWNhdGlvbiB0aGVtZXMuXG4gKiBJdCBsaXN0ZW5zIHRvIHRoZSBgdGhlbWVDaGFuZ2VgIGV2ZW50IGFuZCBjaGFuZ2UgYSB0aGVtZSBDU1MgY2xhc3MgYXBwZW5kZWQgdG8gYm9keS5cbiAqIEJhc2VkIG9uIHRoZSBjbGFzcyBhcHBlbmRlZCwgc3BlY2lmaWMgQ1NTLXRoZW1lIGlzIGFwcGxpZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICogTW9yZSBkZXRhaWxzIG9mIHRoZSBUaGVtZSBTeXN0ZW0gY291bGQgYmUgZm91bmQgaGVyZSBbRW5hYmxpbmcgVGhlbWUgU3lzdGVtXSgjL2RvY3MvY29uY2VwdHMvdGhlbWUtc3lzdGVtKVxuICpcbiAqIEEgc2ltcGxlIGxheW91dCB3aXRoIGZvb3RlcjpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKExheW91dCBXaXRoIEZvb3RlciwgbGF5b3V0L2xheW91dC13LWZvb3Rlci5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXNrIHRoZSBsYXlvdXQgdG8gY2VudGVyIHRoZSBjb2x1bW5zIChub3RpY2U6IHdlIGFkZGVkIGEgYGNlbnRlcmAgYXR0cmlidXRlXG4gKiB0byB0aGUgbGF5b3V0OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1sYXlvdXQgY2VudGVyPlxuICogICA8bmItbGF5b3V0LWhlYWRlcj5Bd2Vzb21lIENvbXBhbnk8L25iLWxheW91dC1oZWFkZXI+XG4gKlxuICogICA8bmItbGF5b3V0LWNvbHVtbj5cbiAqICAgICBIZWxsbyBXb3JsZCFcbiAqICAgPC9uYi1sYXlvdXQtY29sdW1uPlxuICpcbiAqICAgPG5iLWxheW91dC1mb290ZXI+Q29udGFjdCB1czwvbmItbGF5b3V0LWZvb3Rlcj5cbiAqIDwvbmItbGF5b3V0PlxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGxheW91dC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbGF5b3V0LXRleHQtY29sb3I6XG4gKiBsYXlvdXQtdGV4dC1mb250LWZhbWlseTpcbiAqIGxheW91dC10ZXh0LWZvbnQtc2l6ZTpcbiAqIGxheW91dC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogbGF5b3V0LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBsYXlvdXQtbWluLWhlaWdodDpcbiAqIGxheW91dC1jb250ZW50LXdpZHRoOlxuICogbGF5b3V0LXdpbmRvdy1tb2RlLW1pbi13aWR0aDpcbiAqIGxheW91dC13aW5kb3ctbW9kZS1tYXgtd2lkdGg6XG4gKiBsYXlvdXQtd2luZG93LW1vZGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGxheW91dC13aW5kb3ctbW9kZS1wYWRkaW5nLXRvcDpcbiAqIGxheW91dC13aW5kb3ctc2hhZG93OlxuICogbGF5b3V0LXBhZGRpbmc6XG4gKiBsYXlvdXQtbWVkaXVtLXBhZGRpbmc6XG4gKiBsYXlvdXQtc21hbGwtcGFkZGluZzpcbiAqIGxheW91dC1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGxheW91dC1zY3JvbGxiYXItY29sb3I6XG4gKiBsYXlvdXQtc2Nyb2xsYmFyLXdpZHRoOlxuICovXG5jbGFzcyBOYkxheW91dENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IodGhlbWVTZXJ2aWNlLCBzcGlubmVyU2VydmljZSwgZWxlbWVudFJlZiwgcmVuZGVyZXIsIHdpbmRvdywgZG9jdW1lbnQsIHBsYXRmb3JtSWQsIGxheW91dERpcmVjdGlvblNlcnZpY2UsIHNjcm9sbFNlcnZpY2UsIHJ1bGVyU2VydmljZSwgc2Nyb2xsVG9wLCBvdmVybGF5Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlID0gdGhlbWVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNwaW5uZXJTZXJ2aWNlID0gc3Bpbm5lclNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy5sYXlvdXREaXJlY3Rpb25TZXJ2aWNlID0gbGF5b3V0RGlyZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICAgICAgdGhpcy5ydWxlclNlcnZpY2UgPSBydWxlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIgPSBvdmVybGF5Q29udGFpbmVyO1xuICAgICAgICB0aGlzLnNjcm9sbEJsb2NrQ2xhc3MgPSAnbmItZ2xvYmFsLXNjcm9sbGJsb2NrJztcbiAgICAgICAgdGhpcy5pc1Njcm9sbEJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZW50ZXJWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc3RvcmVTY3JvbGxUb3BWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2luZG93TW9kZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2l0aFNjcm9sbFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2l0aFN1YmhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFmdGVyVmlld0luaXQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJBc092ZXJsYXlDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2Uub25UaGVtZUNoYW5nZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh0aGVtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgICAgIGlmICh0aGVtZS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoYm9keSwgYG5iLXRoZW1lLSR7dGhlbWUucHJldmlvdXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGJvZHksIGBuYi10aGVtZS0ke3RoZW1lLm5hbWV9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5vbkFwcGVuZExheW91dENsYXNzKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLm9uUmVtb3ZlTGF5b3V0Q2xhc3MoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zcGlubmVyU2VydmljZS5yZWdpc3RlckxvYWRlcihuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyVmlld0luaXQkXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKF8pID0+IHJlc29sdmUoKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zcGlubmVyU2VydmljZS5sb2FkKCk7XG4gICAgICAgIHRoaXMucnVsZXJTZXJ2aWNlLm9uR2V0RGltZW5zaW9ucygpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGxpc3RlbmVyIH0pID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm5leHQodGhpcy5nZXREaW1lbnNpb25zKCkpO1xuICAgICAgICAgICAgbGlzdGVuZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZVxuICAgICAgICAgICAgLm9uU2Nyb2xsYWJsZUNoYW5nZSgpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy53aXRoU2Nyb2xsVmFsdWUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoc2Nyb2xsYWJsZSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbiBjYXNlIHdoZW4gTmVidWxhciBMYXlvdXQgY3VzdG9tIHNjcm9sbCBgd2l0aFNjcm9sbGAgbW9kZSBpcyBlbmFibGVkXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIGRpc2FibGUgZGVmYXVsdCBDREsgc2Nyb2xsIGJsb2NrZXIgKEBsaW5rIE5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIpIG9uIEhUTUwgZWxlbWVudFxuICAgICAgICAgICAgICogc28gdGhhdCBpdCB3b24ndCBhZGQgYWRkaXRpb25hbCBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1Njcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgZmlyc3QgdGltZSBzbyB0aGF0IGFmdGVyIHRoZSBjaGFuZ2Ugd2UgaGF2ZSB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UuY2hhbmdlV2luZG93V2lkdGgodGhpcy53aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsYXlvdXQgY29sdW1ucyB3aWxsIGJlIGNlbnRlcmVkIGFmdGVyIHNvbWUgd2lkdGhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCBjZW50ZXIodmFsKSB7XG4gICAgICAgIHRoaXMuY2VudGVyVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsYXlvdXQgZW50ZXJzIGEgJ3dpbmRvdycgbW9kZSwgd2hlbiB0aGUgbGF5b3V0IGNvbnRlbnQgKGluY2x1ZGluZyBzaWRlYmFycyBhbmQgZml4ZWQgaGVhZGVyKVxuICAgICAqIGJlY29tZXMgY2VudGVyZWQgYnkgd2lkdGggd2l0aCBhIG1hcmdpbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbiwgbGlrZSBhIGZsb2F0aW5nIHdpbmRvdy5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGVuYWJsZXMgYHdpdGhTY3JvbGxgIG1vZGUsIGFzIGluIHRoZSB3aW5kb3cgbW9kZSBzY3JvbGwgbXVzdCBiZSBpbnNpZGUgdGhlIGxheW91dCBhbmQgY2Fubm90IGJlIG9uXG4gICAgICogd2luZG93LiAoVE9ETzogY2hlY2sgdGhpcylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCB3aW5kb3dNb2RlKHZhbCkge1xuICAgICAgICB0aGlzLndpbmRvd01vZGVWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLndpdGhTY3JvbGwgPSB0aGlzLndpbmRvd01vZGVWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRvIG1vdmUgdGhlIHNjcm9sbGJhcnMgdG8gbGF5b3V0IG9yIGxlYXZlIGl0IGF0IHRoZSBib2R5IGxldmVsLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgc2V0IHRvIHRydWUgd2hlbiBgd2luZG93TW9kZWAgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCB3aXRoU2Nyb2xsKHZhbCkge1xuICAgICAgICB0aGlzLndpdGhTY3JvbGxWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHRoZSBiZXN0IHdheSBvZiBkb2luZyBpdD8gYXMgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gYm9keSBmcm9tIHRoZW1lIHN0eWxlc1xuICAgICAgICAvLyBUT0RPOiBhZGQgZTJlIHRlc3RcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgaWYgKHRoaXMud2l0aFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGJvZHksICdvdmVyZmxvdycsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoYm9keSwgJ292ZXJmbG93JywgJ2luaXRpYWwnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBhZnRlciBuYXZpZ2F0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgcmVzdG9yZVNjcm9sbFRvcCh2YWwpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlU2Nyb2xsVG9wVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uub25HZXRQb3NpdGlvbigpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGxpc3RlbmVyIH0pID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm5leHQodGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcC5zaG91bGRSZXN0b3JlKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLnJlc3RvcmVTY3JvbGxUb3BWYWx1ZSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zY3JvbGwoMCwgMCkpO1xuICAgICAgICB0aGlzLmxheW91dERpcmVjdGlvblNlcnZpY2Uub25EaXJlY3Rpb25DaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkaXJlY3Rpb24gPT4gdGhpcy5kb2N1bWVudC5kaXIgPSBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uub25NYW51YWxTY3JvbGwoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyB4LCB5IH0pID0+IHRoaXMuc2Nyb2xsKHgsIHkpKTtcbiAgICAgICAgdGhpcy5hZnRlclZpZXdJbml0JC5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyQXNPdmVybGF5Q29udGFpbmVyKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKCRldmVudCkge1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2UuZmlyZVNjcm9sbENoYW5nZSgkZXZlbnQpO1xuICAgIH1cbiAgICBvblJlc2l6ZShldmVudCkge1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5jaGFuZ2VXaW5kb3dXaWR0aChldmVudC50YXJnZXQuaW5uZXJXaWR0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2Nyb2xsIGFuZCBjbGllbnQgaGVpZ2h0L3dpZHRoXG4gICAgICpcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgc2Nyb2xsIG1vZGUgKGB3aXRoU2Nyb2xsPXRydWVgKSByZXR1cm5zIHNpemVzIGZyb20gdGhlIGJvZHkgZWxlbWVudFxuICAgICAqIG9yIGZyb20gdGhlIGAuc2Nyb2xsYWJsZS1jb250YWluZXJgXG4gICAgICogQHJldHVybnMge05iTGF5b3V0RGltZW5zaW9uc31cbiAgICAgKi9cbiAgICBnZXREaW1lbnNpb25zKCkge1xuICAgICAgICBsZXQgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsV2lkdGgsIHNjcm9sbEhlaWdodCA9IDA7XG4gICAgICAgIGlmICh0aGlzLndpdGhTY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBzY3JvbGxXaWR0aCA9IGNvbnRhaW5lci5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCwgYm9keSB9ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGJvZHkuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGJvZHkuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgc2Nyb2xsV2lkdGggPSBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggfHwgYm9keS5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IGRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2Nyb2xsIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2Nyb2xsIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIElmIGB3aXRoU2Nyb2xsYCA9IHRydWUsIHJldHVybnMgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBgLnNjcm9sbGFibGUtY29udGFpbmVyYCBlbGVtZW50LFxuICAgICAqIG90aGVyd2lzZSAtIG9mIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgb2YgdGhlIHdpbmRvdyAod2hpY2ggbWF5IGJlIGRpZmZlcmVudCBkZXBlbmRpbmcgb2YgYSBicm93c2VyKVxuICAgICAqXG4gICAgICogQHJldHVybnMge05iU2Nyb2xsUG9zaXRpb259XG4gICAgICovXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpdGhTY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBjb250YWluZXIuc2Nyb2xsTGVmdCwgeTogY29udGFpbmVyLnNjcm9sbFRvcCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50UmVjdCA9IHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB4ID0gLWRvY3VtZW50UmVjdC5sZWZ0IHx8IHRoaXMuZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IHRoaXMud2luZG93LnNjcm9sbFggfHxcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgY29uc3QgeSA9IC1kb2N1bWVudFJlY3QudG9wIHx8IHRoaXMuZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgdGhpcy53aW5kb3cuc2Nyb2xsWSB8fFxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJBc092ZXJsYXlDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlDb250YWluZXIuc2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIuc2V0Q29udGFpbmVyKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZ2lzdGVyQXNPdmVybGF5Q29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5Q29udGFpbmVyLmNsZWFyQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIuY2xlYXJDb250YWluZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGwoeCA9IG51bGwsIHkgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgeDogY3VycmVudFgsIHk6IGN1cnJlbnRZIH0gPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgIHggPSB4ID09IG51bGwgPyBjdXJyZW50WCA6IHg7XG4gICAgICAgIHkgPSB5ID09IG51bGwgPyBjdXJyZW50WSA6IHk7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpdGhTY3JvbGxWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZSA9IHRoaXMuc2Nyb2xsYWJsZUNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGFibGUuc2Nyb2xsVG8pIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbFRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0ID0geDtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbFRvcCA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiBFeHRyYWN0IGludG8gYmxvY2sgc2Nyb2xsIHN0cmF0ZWd5XG4gICAgYmxvY2tTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2Nyb2xsQmxvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTY3JvbGxCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5zY3JvbGxCbG9ja0NsYXNzKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUNvbnRhaW5lckVsZW1lbnQgPSB0aGlzLnNjcm9sbGFibGVDb250YWluZXJSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgbGF5b3V0RWxlbWVudCA9IHRoaXMubGF5b3V0Q29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGxheW91dFdpdGhTY3JvbGxXaWR0aCA9IGxheW91dEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZUNvbnRhaW5lck92ZXJmbG93T2xkVmFsdWUgPSBzY3JvbGxhYmxlQ29udGFpbmVyRWxlbWVudC5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgc2Nyb2xsYWJsZUNvbnRhaW5lckVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgY29uc3QgbGF5b3V0V2l0aG91dFNjcm9sbFdpZHRoID0gbGF5b3V0RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsV2lkdGggPSBsYXlvdXRXaXRob3V0U2Nyb2xsV2lkdGggLSBsYXlvdXRXaXRoU2Nyb2xsV2lkdGg7XG4gICAgICAgIGlmICghc2Nyb2xsV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxheW91dFBhZGRpbmdPbGRWYWx1ZSA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGxheW91dEVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQsXG4gICAgICAgICAgICByaWdodDogbGF5b3V0RWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmxheW91dERpcmVjdGlvblNlcnZpY2UuaXNMdHIoKSkge1xuICAgICAgICAgICAgbGF5b3V0RWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtzY3JvbGxXaWR0aH1weGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXlvdXRFbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7c2Nyb2xsV2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuYWJsZVNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxCbG9ja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy5zY3JvbGxCbG9ja0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsYWJsZUNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyT3ZlcmZsb3dPbGRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dFBhZGRpbmdPbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheW91dEVsZW1lbnQgPSB0aGlzLmxheW91dENvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGxheW91dEVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSB0aGlzLmxheW91dFBhZGRpbmdPbGRWYWx1ZS5sZWZ0O1xuICAgICAgICAgICAgICAgIGxheW91dEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gdGhpcy5sYXlvdXRQYWRkaW5nT2xkVmFsdWUucmlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRQYWRkaW5nT2xkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuTmJMYXlvdXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWxheW91dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwic2Nyb2xsYWJsZS1jb250YWluZXJcIiAjc2Nyb2xsYWJsZUNvbnRhaW5lciAoc2Nyb2xsKT1cIm9uU2Nyb2xsKCRldmVudClcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJsYXlvdXRcIiAjbGF5b3V0Q29udGFpbmVyPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1sYXlvdXQtaGVhZGVyOm5vdChbc3ViaGVhZGVyXSlcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsYXlvdXQtY29udGFpbmVyXCI+XG4gICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItc2lkZWJhclwiPjwvbmctY29udGVudD5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiIFtjbGFzcy5jZW50ZXJdPVwiY2VudGVyVmFsdWVcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWxheW91dC1oZWFkZXJbc3ViaGVhZGVyXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWxheW91dC1jb2x1bW5cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWxheW91dC1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkfVtkaXI9bHRyXSA6aG9zdHt0ZXh0LWFsaWduOmxlZnR9W2Rpcj1ydGxdIDpob3N0e3RleHQtYWxpZ246cmlnaHR9Omhvc3QgLmxheW91dHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0IDo6bmctZGVlcCBuYi1sYXlvdXQtaGVhZGVye2Rpc3BsYXk6YmxvY2t9Omhvc3QgOjpuZy1kZWVwIG5iLWxheW91dC1oZWFkZXIgbmF2e2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtkaXNwbGF5OmZsZXh9Omhvc3QgOjpuZy1kZWVwIG5iLWxheW91dC1oZWFkZXIuZml4ZWR7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7ei1pbmRleDoxMDQwfTpob3N0IC5sYXlvdXQtY29udGFpbmVye2Rpc3BsYXk6ZmxleDtmbGV4OjE7LW1zLWZsZXg6MSAxIGF1dG87ZmxleC1kaXJlY3Rpb246cm93fVtkaXI9bHRyXSA6aG9zdCAubGF5b3V0LWNvbnRhaW5lciA6Om5nLWRlZXAgbmItc2lkZWJhci5sZWZ0e29yZGVyOjB9W2Rpcj1ydGxdIDpob3N0IC5sYXlvdXQtY29udGFpbmVyIDo6bmctZGVlcCBuYi1zaWRlYmFyLmxlZnR7b3JkZXI6Mn1bZGlyPWx0cl0gOmhvc3QgLmxheW91dC1jb250YWluZXIgOjpuZy1kZWVwIG5iLXNpZGViYXIucmlnaHR7b3JkZXI6Mn1bZGlyPXJ0bF0gOmhvc3QgLmxheW91dC1jb250YWluZXIgOjpuZy1kZWVwIG5iLXNpZGViYXIucmlnaHR7b3JkZXI6MH06aG9zdCAubGF5b3V0LWNvbnRhaW5lciA6Om5nLWRlZXAgbmItc2lkZWJhci5lbmR7b3JkZXI6Mn06aG9zdCAubGF5b3V0LWNvbnRhaW5lciA6Om5nLWRlZXAgbmItc2lkZWJhciAuZml4ZWR7cG9zaXRpb246Zml4ZWQ7d2lkdGg6MTAwJTtvdmVyZmxvdy15OmF1dG87aGVpZ2h0OjEwMCV9Omhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnR7ZGlzcGxheTpmbGV4O2ZsZXg6MTstbXMtZmxleDoxIDEgYXV0bztmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWluLXdpZHRoOjB9Omhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnQuY2VudGVye21heC13aWR0aDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99Omhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnQgLmNvbHVtbnN7ZGlzcGxheTpmbGV4O2ZsZXg6MTstbXMtZmxleDoxIDEgYXV0bztmbGV4LWRpcmVjdGlvbjpyb3c7d2lkdGg6MTAwJX06aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudCAuY29sdW1ucyA6Om5nLWRlZXAgbmItbGF5b3V0LWNvbHVtbntvcmRlcjoxO2ZsZXg6MSAwO21pbi13aWR0aDowfVtkaXI9bHRyXSA6aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudCAuY29sdW1ucyA6Om5nLWRlZXAgbmItbGF5b3V0LWNvbHVtbi5sZWZ0e29yZGVyOjB9W2Rpcj1ydGxdIDpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IC5jb2x1bW5zIDo6bmctZGVlcCBuYi1sYXlvdXQtY29sdW1uLmxlZnR7b3JkZXI6Mn06aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudCAuY29sdW1ucyA6Om5nLWRlZXAgbmItbGF5b3V0LWNvbHVtbi5zdGFydHtvcmRlcjowfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IDo6bmctZGVlcCBuYi1sYXlvdXQtZm9vdGVye2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDphdXRvfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IDo6bmctZGVlcCBuYi1sYXlvdXQtZm9vdGVyIG5hdntqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2Rpc3BsYXk6ZmxleH1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMYXlvdXRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlRoZW1lU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJTcGlubmVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX1dJTkRPVyxdIH1dIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE9iamVjdCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkxheW91dFNjcm9sbFNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iTGF5b3V0UnVsZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIgfSxcbiAgICB7IHR5cGU6IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgfVxuXTtcbk5iTGF5b3V0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHdpbmRvd01vZGVWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Mud2luZG93LW1vZGUnLF0gfV0sXG4gICAgd2l0aFNjcm9sbFZhbHVlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy53aXRoLXNjcm9sbCcsXSB9XSxcbiAgICB3aXRoU3ViaGVhZGVyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy53aXRoLXN1YmhlYWRlcicsXSB9XSxcbiAgICBjZW50ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpbmRvd01vZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdpdGhTY3JvbGw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlc3RvcmVTY3JvbGxUb3A6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZlcnlUb3BSZWY6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWydsYXlvdXRUb3BEeW5hbWljQXJlYScsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9LF0gfV0sXG4gICAgc2Nyb2xsYWJsZUNvbnRhaW5lclJlZjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3Njcm9sbGFibGVDb250YWluZXInLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSxdIH1dLFxuICAgIGxheW91dENvbnRhaW5lclJlZjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2xheW91dENvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiB9LF0gfV0sXG4gICAgb25TY3JvbGw6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWyd3aW5kb3c6c2Nyb2xsJywgWyckZXZlbnQnXSxdIH1dLFxuICAgIG9uUmVzaXplOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10sXSB9XVxufTtcbi8qKlxuICogQSBjb250YWluZXIgY29tcG9uZW50IHdoaWNoIGRldGVybWluZXMgYSBjb250ZW50IHBvc2l0aW9uIGluc2lkZSBvZiB0aGUgbGF5b3V0LlxuICogVGhlIGxheW91dCBjb3VsZCBjb250YWluIHVubGltaXRlZCBjb2x1bW5zIChub3QgaW5jbHVkaW5nIHRoZSBzaWRlYmFycykuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgY29sdW1ucyBhcmUgb3JkZXJlZCBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCxcbiAqIGJ1dCBpdCdzIGFsc28gcG9zc2libGUgdG8gb3ZlcndyaXRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyBhIGBsZWZ0YCBhdHRyaWJ1dGUgdG8gdGhlIGNvbHVtbixcbiAqIG1vdmluZyBpdCB0byB0aGUgdmVyeSBmaXJzdCBwb3NpdGlvbjpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbHVtbiBMZWZ0LCBsYXlvdXQvbGF5b3V0LWNvbHVtbi1sZWZ0LmNvbXBvbmVudClcbiAqL1xuY2xhc3MgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGNvbHVtbiB0byB0aGUgdmVyeSBsZWZ0IHBvc2l0aW9uIGluIHRoZSBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgbGVmdCh2YWwpIHtcbiAgICAgICAgdGhpcy5sZWZ0VmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgY29sdW1uIGZpcnN0IGluIHRoZSBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgc3RhcnQodmFsKSB7XG4gICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLmxlZnRWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbn1cbk5iTGF5b3V0Q29sdW1uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1sYXlvdXQtY29sdW1uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkxheW91dENvbHVtbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBsZWZ0VmFsdWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmxlZnQnLF0gfV0sXG4gICAgc3RhcnRWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhcnQnLF0gfV0sXG4gICAgbGVmdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhcnQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuLyoqXG4gKiBQYWdlIGhlYWRlciBjb21wb25lbnQuXG4gKiBMb2NhdGVkIG9uIHRvcCBvZiB0aGUgcGFnZSBhYm92ZSB0aGUgbGF5b3V0IGNvbHVtbnMgYW5kIHNpZGViYXJzLlxuICogQ291bGQgYmUgbWFkZSBgZml4ZWRgIGJ5IHNldHRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkuIEluIHRoZSBmaXhlZCBtb2RlIHRoZSBoZWFkZXIgYmVjb21lc1xuICogc3RpY2t5IHRvIHRoZSB0b3Agb2YgdGhlIG5iLWxheW91dCAodG8gb2YgdGhlIHBhZ2UpLiBIZXJlJ3MgYW4gZXhhbXBsZTpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEZpeGVkIEhlYWRlciwgbGF5b3V0L2xheW91dC1maXhlZC1oZWFkZXIuY29tcG9uZW50KVxuICpcbiAqIEluIGEgcGFpciB3aXRoIHNpZGViYXIgaXQgaXMgcG9zc2libGUgdG8gc2V0dXAgYSBjb25maWd1cmF0aW9uIHdoZW4gaGVhZGVyIGlzIHBsYWNlZCBvbiBhIHNpZGUgb2YgdGhlIHNpZGViYXJcbiAqIGFuZCBub3Qgb24gdG9wIG9mIGl0LiBUbyBhY2hpZXZlIHRoaXMgc2ltcGx5IHB1dCBhIGBzdWJoZWFkZXJgIHByb3BlcnR5IHRvIHRoZSBoZWFkZXIgbGlrZSB0aGlzOlxuICogYGBgaHRtbFxuICogPG5iLWxheW91dC1oZWFkZXIgc3ViaGVhZGVyPjwvbmItbGF5b3V0LWhlYWRlcj5cbiAqIGBgYFxuICogQHN0YWNrZWQtZXhhbXBsZShTdWJoZWFkZXIsIGxheW91dC9sYXlvdXQtc2lkZWJhci1zdWJoZWFkZXIuY29tcG9uZW50KVxuICogTm90ZSB0aGF0IGluIHN1Y2ggY29uZmlndXJhdGlvbiBzaWRlYmFyIHNoYWRvdyBpcyByZW1vdmVkIGFuZCBoZWFkZXIgY2Fubm90IGJlIG1ha2UgYGZpeGVkYC5cbiAqXG4gKiBTYW1lIHdheSB5b3UgY2FuIHB1dCBib3RoIGBmaXhlZGAgYW5kIGBjbGlwcGVkYCBoZWFkZXJzIGFkZGluZyBjcmVhdGluZyBhIHN1Yi1oZWFkZXIgZm9yIHlvdXIgYXBwOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3ViaGVhZGVyLCBsYXlvdXQvbGF5b3V0LXN1YmhlYWRlci5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaGVhZGVyLXRleHQtY29sb3I6XG4gKiBoZWFkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIGhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaGVhZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBoZWFkZXItaGVpZ2h0OlxuICogaGVhZGVyLXBhZGRpbmc6XG4gKiBoZWFkZXItc2hhZG93OlxuICovXG5jbGFzcyBOYkxheW91dEhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgaGVhZGVyIHN0aWNreSB0byB0aGUgdG9wIG9mIHRoZSBuYi1sYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgZml4ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgaGVhZGVyIG9uIGEgc2lkZSBvZiB0aGUgc2lkZWJhciwgYW5kIG5vdCBhYm92ZS5cbiAgICAgKiBEaXNhYmxlcyBmaXhlZCBtb2RlIGZvciB0aGlzIGhlYWRlciBhbmQgcmVtb3ZlIGEgc2hhZG93IGZyb20gdGhlIHNpZGViYXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgc3ViaGVhZGVyKHZhbCkge1xuICAgICAgICB0aGlzLnN1YmhlYWRlclZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxheW91dC53aXRoU3ViaGVhZGVyID0gdGhpcy5zdWJoZWFkZXJWYWx1ZTtcbiAgICB9XG59XG5OYkxheW91dEhlYWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItbGF5b3V0LWhlYWRlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmF2IFtjbGFzcy5maXhlZF09XCJmaXhlZFZhbHVlXCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9uYXY+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMYXlvdXRIZWFkZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkxheW91dENvbXBvbmVudCB9XG5dO1xuTmJMYXlvdXRIZWFkZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZml4ZWRWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZml4ZWQnLF0gfV0sXG4gICAgc3ViaGVhZGVyVmFsdWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN1YmhlYWRlcicsXSB9XSxcbiAgICBmaXhlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3ViaGVhZGVyOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbi8qKlxuICogUGFnZSBmb290ZXIuXG4gKiBMb2NhdGVkIHVuZGVyIHRoZSBuYi1sYXlvdXQgY29udGVudCAoc3BlY2lmaWNhbGx5LCB1bmRlciB0aGUgY29sdW1ucykuXG4gKiBDb3VsZCBiZSBtYWRlIGBmaXhlZGAsIGJlY29taW5nIHN0aWNreSB0byB0aGUgYm90dG9tIG9mIHRoZSB2aWV3IHBvcnQgKHdpbmRvdykuXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGZvb3Rlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogZm9vdGVyLXRleHQtY29sb3I6XG4gKiBmb290ZXItdGV4dC1mb250LWZhbWlseTpcbiAqIGZvb3Rlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGZvb3Rlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogZm9vdGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBmb290ZXItdGV4dC1oaWdobGlnaHQtY29sb3I6XG4gKiBmb290ZXItaGVpZ2h0OlxuICogZm9vdGVyLXBhZGRpbmc6XG4gKiBmb290ZXItZGl2aWRlci1jb2xvcjpcbiAqIGZvb3Rlci1kaXZpZGVyLXN0eWxlOlxuICogZm9vdGVyLWRpdmlkZXItd2lkdGg6XG4gKiBmb290ZXItc2hhZG93OlxuICovXG5jbGFzcyBOYkxheW91dEZvb3RlckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIGZvb3RlciBzdGlja3kgdG8gdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGZpeGVkKHZhbCkge1xuICAgICAgICB0aGlzLmZpeGVkVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG59XG5OYkxheW91dEZvb3RlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItbGF5b3V0LWZvb3RlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmF2IFtjbGFzcy5maXhlZF09XCJmaXhlZFZhbHVlXCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9uYXY+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMYXlvdXRGb290ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZml4ZWRWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZml4ZWQnLF0gfV0sXG4gICAgZml4ZWQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9MQVlPVVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYkxheW91dENvbXBvbmVudCxcbiAgICBOYkxheW91dENvbHVtbkNvbXBvbmVudCxcbiAgICBOYkxheW91dEZvb3RlckNvbXBvbmVudCxcbiAgICBOYkxheW91dEhlYWRlckNvbXBvbmVudCxcbl07XG5jbGFzcyBOYkxheW91dE1vZHVsZSB7XG59XG5OYkxheW91dE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9MQVlPVVRfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX0xBWU9VVF9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgaXRlbUNsaWNrJCA9IG5ldyBTdWJqZWN0KCk7XG5jb25zdCBhZGRJdGVtcyQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbmNvbnN0IG5hdmlnYXRlSG9tZSQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbmNvbnN0IGdldFNlbGVjdGVkSXRlbSQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbmNvbnN0IGl0ZW1TZWxlY3QkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5jb25zdCBpdGVtSG92ZXIkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5jb25zdCBzdWJtZW51VG9nZ2xlJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuY29uc3QgY29sbGFwc2VBbGwkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4vLyBUT0RPOiBjaGVjayBpZiB3ZSBuZWVkIGJvdGggVVJMIGFuZCBMSU5LXG4vKipcbiAqXG4gKlxuICogTWVudSBJdGVtIG9wdGlvbnMgZXhhbXBsZVxuICogQHN0YWNrZWQtZXhhbXBsZShNZW51IExpbmsgUGFyYW1ldGVycywgbWVudS9tZW51LWxpbmstcGFyYW1zLmNvbXBvbmVudClcbiAqXG4gKlxuICovXG5jbGFzcyBOYk1lbnVJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZW0gaXMgc2VsZWN0ZWQgd2hlbiBwYXJ0bHkgb3IgZnVsbHkgZXF1YWwgdG8gdGhlIGN1cnJlbnQgdXJsXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhNYXRjaCA9ICdmdWxsJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgaXRlbSBwYXJlbnRzIGluIHRvcC1kb3duIG9yZGVyXG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcmVudHMoaXRlbSkge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgIGxldCBwYXJlbnQgPSBpdGVtLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50cy51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQYXJlbnQoaXRlbSwgcG9zc2libGVDaGlsZCkge1xuICAgICAgICByZXR1cm4gcG9zc2libGVDaGlsZC5wYXJlbnRcbiAgICAgICAgICAgID8gcG9zc2libGVDaGlsZC5wYXJlbnQgPT09IGl0ZW0gfHwgdGhpcy5pc1BhcmVudChpdGVtLCBwb3NzaWJsZUNoaWxkLnBhcmVudClcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuLy8gVE9ETzogbWFwIHNlbGVjdCBldmVudHMgdG8gcm91dGVyIGNoYW5nZSBldmVudHNcbi8vIFRPRE86IHJldmlldyB0aGUgaW50ZXJmYWNlXG4vKipcbiAqXG4gKlxuICogTWVudSBTZXJ2aWNlLiBBbGxvd3MgeW91IHRvIGxpc3RlbiB0byBtZW51IGV2ZW50cywgb3IgdG8gaW50ZXJhY3Qgd2l0aCBhIG1lbnUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1lbnUgU2VydmljZSwgbWVudS9tZW51LXNlcnZpY2UuY29tcG9uZW50KVxuICpcbiAqXG4gKi9cbmNsYXNzIE5iTWVudVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEFkZCBpdGVtcyB0byB0aGUgZW5kIG9mIHRoZSBtZW51IGl0ZW1zIGxpc3RcbiAgICAgKiBAcGFyYW0ge0xpc3Q8TmJNZW51SXRlbT59IGl0ZW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqL1xuICAgIGFkZEl0ZW1zKGl0ZW1zLCB0YWcpIHtcbiAgICAgICAgYWRkSXRlbXMkLm5leHQoeyB0YWcsIGl0ZW1zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYWxsIG1lbnUgaXRlbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICovXG4gICAgY29sbGFwc2VBbGwodGFnKSB7XG4gICAgICAgIGNvbGxhcHNlQWxsJC5uZXh0KHsgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byB0aGUgaG9tZSBtZW51IGl0ZW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICovXG4gICAgbmF2aWdhdGVIb21lKHRhZykge1xuICAgICAgICBuYXZpZ2F0ZUhvbWUkLm5leHQoeyB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0uIFdvbid0IHN1YnNjcmliZSB0byB0aGUgZnV0dXJlIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8e3RhZzogc3RyaW5nOyBpdGVtOiBOYk1lbnVJdGVtfT59XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRJdGVtKHRhZykge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIGdldFNlbGVjdGVkSXRlbSQubmV4dCh7IHRhZywgbGlzdGVuZXIgfSk7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgb25JdGVtQ2xpY2soKSB7XG4gICAgICAgIHJldHVybiBpdGVtQ2xpY2skLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIG9uSXRlbVNlbGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1TZWxlY3QkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIG9uSXRlbUhvdmVyKCkge1xuICAgICAgICByZXR1cm4gaXRlbUhvdmVyJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICBvblN1Ym1lbnVUb2dnbGUoKSB7XG4gICAgICAgIHJldHVybiBzdWJtZW51VG9nZ2xlJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbn1cbk5iTWVudVNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbmNsYXNzIE5iTWVudUludGVybmFsU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIH1cbiAgICBwcmVwYXJlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEl0ZW0gPSBuZXcgTmJNZW51SXRlbSgpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBseURlZmF1bHRzKGksIGRlZmF1bHRJdGVtKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KGkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VsZWN0RnJvbVVybChpdGVtcywgdGFnLCBjb2xsYXBzZU90aGVyID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJdGVtID0gdGhpcy5maW5kSXRlbUJ5VXJsKGl0ZW1zKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKHNlbGVjdGVkSXRlbSwgaXRlbXMsIGNvbGxhcHNlT3RoZXIsIHRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0SXRlbShpdGVtLCBpdGVtcywgY29sbGFwc2VPdGhlciA9IGZhbHNlLCB0YWcpIHtcbiAgICAgICAgY29uc3QgdW5zZWxlY3RlZEl0ZW1zID0gdGhpcy5yZXNldFNlbGVjdGlvbihpdGVtcyk7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZEl0ZW1zID0gY29sbGFwc2VPdGhlciA/IHRoaXMuY29sbGFwc2VJdGVtcyhpdGVtcykgOiBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgTmJNZW51SXRlbS5nZXRQYXJlbnRzKGl0ZW0pKSB7XG4gICAgICAgICAgICBwYXJlbnQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZW1pdCBldmVudCBvbmx5IGZvciBpdGVtcyB0aGF0IHdlcmVuJ3Qgc2VsZWN0ZWQgYmVmb3JlICgndW5zZWxlY3RlZEl0ZW1zJyBjb250YWlucyBpdGVtcyB0aGF0IHdlcmUgc2VsZWN0ZWQpXG4gICAgICAgICAgICBpZiAoIXVuc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtU2VsZWN0KHBhcmVudCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc05vdEV4cGFuZGVkID0gIXBhcmVudC5leHBhbmRlZDtcbiAgICAgICAgICAgIHBhcmVudC5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBpID0gY29sbGFwc2VkSXRlbXMuaW5kZXhPZihwYXJlbnQpO1xuICAgICAgICAgICAgLy8gZW1pdCBldmVudCBvbmx5IGZvciBpdGVtcyB0aGF0IHdlcmVuJ3QgZXhwYW5kZWQgYmVmb3JlLlxuICAgICAgICAgICAgLy8gJ2NvbGxhcHNlZEl0ZW1zJyBjb250YWlucyBpdGVtcyB0aGF0IHdlcmUgZXhwYW5kZWQsIHNvIG5vIG5lZWQgdG8gZW1pdCBldmVudC5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgJ2NvbGxhcHNlT3RoZXInIGlzIGZhbHNlLCAnY29sbGFwc2VkSXRlbXMnIHdpbGwgYmUgZW1wdHksXG4gICAgICAgICAgICAvLyBzbyBhbHNvIGNoZWNrIGlmIGl0ZW0gaXNuJ3QgZXhwYW5kZWQgYWxyZWFkeSAoJ3dhc05vdEV4cGFuZGVkJykuXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEgJiYgd2FzTm90RXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1lbnVUb2dnbGUocGFyZW50LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sbGFwc2VkSXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBlbWl0IGV2ZW50IG9ubHkgZm9yIGl0ZW1zIHRoYXQgd2VyZW4ndCBzZWxlY3RlZCBiZWZvcmUgKCd1bnNlbGVjdGVkSXRlbXMnIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBzZWxlY3RlZClcbiAgICAgICAgaWYgKCF1bnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbVNlbGVjdChpdGVtLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbWFpbmluZyBpdGVtcyB3aGljaCB3YXNuJ3QgZXhwYW5kZWQgYmFjayBhZnRlciBleHBhbmRpbmcgYWxsIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtc1xuICAgICAgICBmb3IgKGNvbnN0IGNvbGxhcHNlZEl0ZW0gb2YgY29sbGFwc2VkSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VibWVudVRvZ2dsZShjb2xsYXBzZWRJdGVtLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlQWxsKGl0ZW1zLCB0YWcsIGV4Y2VwdCkge1xuICAgICAgICBjb25zdCBjb2xsYXBzZWRJdGVtcyA9IHRoaXMuY29sbGFwc2VJdGVtcyhpdGVtcywgZXhjZXB0KTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxhcHNlZEl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLnN1Ym1lbnVUb2dnbGUoaXRlbSwgdGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkFkZEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBhZGRJdGVtcyQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgb25OYXZpZ2F0ZUhvbWUoKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0ZUhvbWUkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIG9uQ29sbGFwc2VBbGwoKSB7XG4gICAgICAgIHJldHVybiBjb2xsYXBzZUFsbCQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgb25HZXRTZWxlY3RlZEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBnZXRTZWxlY3RlZEl0ZW0kLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIGl0ZW1Ib3ZlcihpdGVtLCB0YWcpIHtcbiAgICAgICAgaXRlbUhvdmVyJC5uZXh0KHsgdGFnLCBpdGVtIH0pO1xuICAgIH1cbiAgICBzdWJtZW51VG9nZ2xlKGl0ZW0sIHRhZykge1xuICAgICAgICBzdWJtZW51VG9nZ2xlJC5uZXh0KHsgdGFnLCBpdGVtIH0pO1xuICAgIH1cbiAgICBpdGVtU2VsZWN0KGl0ZW0sIHRhZykge1xuICAgICAgICBpdGVtU2VsZWN0JC5uZXh0KHsgdGFnLCBpdGVtIH0pO1xuICAgIH1cbiAgICBpdGVtQ2xpY2soaXRlbSwgdGFnKSB7XG4gICAgICAgIGl0ZW1DbGljayQubmV4dCh7IHRhZywgaXRlbSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zZWxlY3QgYWxsIGdpdmVuIGl0ZW1zIGRlZXBseS5cbiAgICAgKiBAcGFyYW0gaXRlbXMgYXJyYXkgb2YgaXRlbXMgdG8gdW5zZWxlY3QuXG4gICAgICogQHJldHVybnMgaXRlbXMgd2hpY2ggc2VsZWN0ZWQgdmFsdWUgd2FzIGNoYW5nZWQuXG4gICAgICovXG4gICAgcmVzZXRTZWxlY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgY29uc3QgdW5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdGVkSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdW5zZWxlY3RlZEl0ZW1zLnB1c2goLi4udGhpcy5yZXNldFNlbGVjdGlvbihpdGVtLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuc2VsZWN0ZWRJdGVtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2UgYWxsIGdpdmVuIGl0ZW1zIGRlZXBseS5cbiAgICAgKiBAcGFyYW0gaXRlbXMgYXJyYXkgb2YgaXRlbXMgdG8gY29sbGFwc2UuXG4gICAgICogQHBhcmFtIGV4Y2VwdCBtZW51IGl0ZW0gd2hpY2ggc2hvdWxkbid0IGJlIGNvbGxhcHNlZCwgYWxzbyBkaXNhYmxlcyBjb2xsYXBzaW5nIGZvciBwYXJlbnRzIG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAcmV0dXJucyBpdGVtcyB3aGljaCBleHBhbmRlZCB2YWx1ZSB3YXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBjb2xsYXBzZUl0ZW1zKGl0ZW1zLCBleGNlcHQpIHtcbiAgICAgICAgY29uc3QgY29sbGFwc2VkSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoZXhjZXB0ICYmIChpdGVtID09PSBleGNlcHQgfHwgTmJNZW51SXRlbS5pc1BhcmVudChpdGVtLCBleGNlcHQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWRJdGVtcy5wdXNoKC4uLnRoaXMuY29sbGFwc2VJdGVtcyhpdGVtLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlZEl0ZW1zO1xuICAgIH1cbiAgICBhcHBseURlZmF1bHRzKGl0ZW0sIGRlZmF1bHRJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oaXRlbSwgZGVmYXVsdEl0ZW0sIG1lbnVJdGVtKTtcbiAgICAgICAgaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHBseURlZmF1bHRzKGNoaWxkLCBkZWZhdWx0SXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRQYXJlbnQoaXRlbSkge1xuICAgICAgICBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBkZWVwZXN0IGl0ZW0gd2hpY2ggbGluayBtYXRjaGVzIGN1cnJlbnQgVVJMIHBhdGguXG4gICAgICogQHBhcmFtIGl0ZW1zIGFycmF5IG9mIGl0ZW1zIHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJucyBmb3VuZCBpdGVtIG9mIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBmaW5kSXRlbUJ5VXJsKGl0ZW1zKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZEl0ZW07XG4gICAgICAgIGl0ZW1zLnNvbWUoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbSA9IHRoaXMuZmluZEl0ZW1CeVVybChpdGVtLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWRJdGVtICYmIHRoaXMuaXNTZWxlY3RlZEluVXJsKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRJdGVtO1xuICAgIH1cbiAgICBpc1NlbGVjdGVkSW5VcmwoaXRlbSkge1xuICAgICAgICBjb25zdCBleGFjdCA9IGl0ZW0ucGF0aE1hdGNoID09PSAnZnVsbCc7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBpdGVtLmxpbms7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRJblBhdGggPSBleGFjdFxuICAgICAgICAgICAgPyBpc1VybFBhdGhFcXVhbCh0aGlzLmxvY2F0aW9uLnBhdGgoKSwgbGluaylcbiAgICAgICAgICAgIDogaXNVcmxQYXRoQ29udGFpbih0aGlzLmxvY2F0aW9uLnBhdGgoKSwgbGluayk7XG4gICAgICAgIGlmIChpc1NlbGVjdGVkSW5QYXRoICYmIGl0ZW0uZnJhZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YWN0XG4gICAgICAgICAgICAgICAgPyBpc0ZyYWdtZW50RXF1YWwodGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpLCBpdGVtLmZyYWdtZW50KVxuICAgICAgICAgICAgICAgIDogaXNGcmFnbWVudENvbnRhaW4odGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpLCBpdGVtLmZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZEluUGF0aDtcbiAgICB9XG59XG5OYk1lbnVJbnRlcm5hbFNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iTWVudUludGVybmFsU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IExvY2F0aW9uIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBOYlRvZ2dsZVN0YXRlcztcbihmdW5jdGlvbiAoTmJUb2dnbGVTdGF0ZXMpIHtcbiAgICBOYlRvZ2dsZVN0YXRlc1tcIkV4cGFuZGVkXCJdID0gXCJleHBhbmRlZFwiO1xuICAgIE5iVG9nZ2xlU3RhdGVzW1wiQ29sbGFwc2VkXCJdID0gXCJjb2xsYXBzZWRcIjtcbn0pKE5iVG9nZ2xlU3RhdGVzIHx8IChOYlRvZ2dsZVN0YXRlcyA9IHt9KSk7XG5jbGFzcyBOYk1lbnVJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihtZW51U2VydmljZSwgZGlyZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLm1lbnVTZXJ2aWNlID0gbWVudVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uU2VydmljZSA9IGRpcmVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWVudUl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmhvdmVySXRlbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy50b2dnbGVTdWJNZW51ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaXRlbUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlID0gdGhpcy5tZW51SXRlbS5leHBhbmRlZCA/IE5iVG9nZ2xlU3RhdGVzLkV4cGFuZGVkIDogTmJUb2dnbGVTdGF0ZXMuQ29sbGFwc2VkO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMubWVudVNlcnZpY2Uub25TdWJtZW51VG9nZ2xlKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBpdGVtIH0pID0+IGl0ZW0gPT09IHRoaXMubWVudUl0ZW0pLCBtYXAoKHsgaXRlbSB9KSA9PiBpdGVtLmV4cGFuZGVkKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpc0V4cGFuZGVkID0+IHRoaXMudG9nZ2xlU3RhdGUgPSBpc0V4cGFuZGVkID8gTmJUb2dnbGVTdGF0ZXMuRXhwYW5kZWQgOiBOYlRvZ2dsZVN0YXRlcy5Db2xsYXBzZWQpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgb25Ub2dnbGVTdWJNZW51KGl0ZW0pIHtcbiAgICAgICAgdGhpcy50b2dnbGVTdWJNZW51LmVtaXQoaXRlbSk7XG4gICAgfVxuICAgIG9uSG92ZXJJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5ob3Zlckl0ZW0uZW1pdChpdGVtKTtcbiAgICB9XG4gICAgb25TZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJdGVtLmVtaXQoaXRlbSk7XG4gICAgfVxuICAgIG9uSXRlbUNsaWNrKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pdGVtQ2xpY2suZW1pdChpdGVtKTtcbiAgICB9XG4gICAgZ2V0RXhwYW5kU3RhdGVJY29uKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51SXRlbS5leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICdjaGV2cm9uLWRvd24tb3V0bGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uU2VydmljZS5pc0x0cigpXG4gICAgICAgICAgICA/ICdjaGV2cm9uLWxlZnQtb3V0bGluZSdcbiAgICAgICAgICAgIDogJ2NoZXZyb24tcmlnaHQtb3V0bGluZSc7XG4gICAgfVxufVxuTmJNZW51SXRlbUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iTWVudUl0ZW1dJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiAqbmdJZj1cXFwibWVudUl0ZW0uZ3JvdXBcXFwiPlxcbiAgPG5iLWljb24gY2xhc3M9XFxcIm1lbnUtaWNvblxcXCIgW2NvbmZpZ109XFxcIm1lbnVJdGVtLmljb25cXFwiICpuZ0lmPVxcXCJtZW51SXRlbS5pY29uXFxcIj48L25iLWljb24+XFxuICB7eyBtZW51SXRlbS50aXRsZSB9fVxcbjwvc3Bhbj5cXG48YSAqbmdJZj1cXFwibWVudUl0ZW0ubGluayAmJiAhbWVudUl0ZW0udXJsICYmICFtZW51SXRlbS5jaGlsZHJlbiAmJiAhbWVudUl0ZW0uZ3JvdXBcXFwiXFxuICAgW3JvdXRlckxpbmtdPVxcXCJtZW51SXRlbS5saW5rXFxcIlxcbiAgIFtxdWVyeVBhcmFtc109XFxcIm1lbnVJdGVtLnF1ZXJ5UGFyYW1zXFxcIlxcbiAgIFtmcmFnbWVudF09XFxcIm1lbnVJdGVtLmZyYWdtZW50XFxcIlxcbiAgIFtxdWVyeVBhcmFtc0hhbmRsaW5nXT1cXFwibWVudUl0ZW0ucXVlcnlQYXJhbXNIYW5kbGluZ1xcXCJcXG4gICBbcHJlc2VydmVGcmFnbWVudF09XFxcIm1lbnVJdGVtLnByZXNlcnZlRnJhZ21lbnRcXFwiXFxuICAgW3NraXBMb2NhdGlvbkNoYW5nZV09XFxcIm1lbnVJdGVtLnNraXBMb2NhdGlvbkNoYW5nZVxcXCJcXG4gICBbYXR0ci50YXJnZXRdPVxcXCJtZW51SXRlbS50YXJnZXRcXFwiXFxuICAgW2F0dHIudGl0bGVdPVxcXCJtZW51SXRlbS50aXRsZVxcXCJcXG4gICBbY2xhc3MuYWN0aXZlXT1cXFwibWVudUl0ZW0uc2VsZWN0ZWRcXFwiXFxuICAgKG1vdXNlZW50ZXIpPVxcXCJvbkhvdmVySXRlbShtZW51SXRlbSlcXFwiXFxuICAgKGNsaWNrKT1cXFwib25JdGVtQ2xpY2sobWVudUl0ZW0pO1xcXCI+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwibWVudS1pY29uXFxcIiBbY29uZmlnXT1cXFwibWVudUl0ZW0uaWNvblxcXCIgKm5nSWY9XFxcIm1lbnVJdGVtLmljb25cXFwiPjwvbmItaWNvbj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZW51LXRpdGxlXFxcIj57eyBtZW51SXRlbS50aXRsZSB9fTwvc3Bhbj5cXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XFxcImJhZGdlXFxcIiBbbmdUZW1wbGF0ZU91dGxldF09XFxcImJhZGdlVGVtcGxhdGVcXFwiPjwvbmctY29udGFpbmVyPlxcbjwvYT5cXG48YSAqbmdJZj1cXFwibWVudUl0ZW0udXJsICYmICFtZW51SXRlbS5jaGlsZHJlbiAmJiAhbWVudUl0ZW0ubGluayAmJiAhbWVudUl0ZW0uZ3JvdXBcXFwiXFxuICAgW2F0dHIuaHJlZl09XFxcIm1lbnVJdGVtLnVybFxcXCJcXG4gICBbYXR0ci50YXJnZXRdPVxcXCJtZW51SXRlbS50YXJnZXRcXFwiXFxuICAgW2F0dHIudGl0bGVdPVxcXCJtZW51SXRlbS50aXRsZVxcXCJcXG4gICBbY2xhc3MuYWN0aXZlXT1cXFwibWVudUl0ZW0uc2VsZWN0ZWRcXFwiXFxuICAgKG1vdXNlZW50ZXIpPVxcXCJvbkhvdmVySXRlbShtZW51SXRlbSlcXFwiXFxuICAgKGNsaWNrKT1cXFwib25TZWxlY3RJdGVtKG1lbnVJdGVtKVxcXCI+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwibWVudS1pY29uXFxcIiBbY29uZmlnXT1cXFwibWVudUl0ZW0uaWNvblxcXCIgKm5nSWY9XFxcIm1lbnVJdGVtLmljb25cXFwiPjwvbmItaWNvbj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZW51LXRpdGxlXFxcIj57eyBtZW51SXRlbS50aXRsZSB9fTwvc3Bhbj5cXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XFxcImJhZGdlXFxcIiBbbmdUZW1wbGF0ZU91dGxldF09XFxcImJhZGdlVGVtcGxhdGVcXFwiPjwvbmctY29udGFpbmVyPlxcbjwvYT5cXG48YSAqbmdJZj1cXFwiIW1lbnVJdGVtLmNoaWxkcmVuICYmICFtZW51SXRlbS5saW5rICYmICFtZW51SXRlbS51cmwgJiYgIW1lbnVJdGVtLmdyb3VwXFxcIlxcbiAgIFthdHRyLnRhcmdldF09XFxcIm1lbnVJdGVtLnRhcmdldFxcXCJcXG4gICBbYXR0ci50aXRsZV09XFxcIm1lbnVJdGVtLnRpdGxlXFxcIlxcbiAgIFtjbGFzcy5hY3RpdmVdPVxcXCJtZW51SXRlbS5zZWxlY3RlZFxcXCJcXG4gICAobW91c2VlbnRlcik9XFxcIm9uSG92ZXJJdGVtKG1lbnVJdGVtKVxcXCJcXG4gICAoY2xpY2spPVxcXCIkZXZlbnQucHJldmVudERlZmF1bHQoKTsgb25JdGVtQ2xpY2sobWVudUl0ZW0pO1xcXCI+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwibWVudS1pY29uXFxcIiBbY29uZmlnXT1cXFwibWVudUl0ZW0uaWNvblxcXCIgKm5nSWY9XFxcIm1lbnVJdGVtLmljb25cXFwiPjwvbmItaWNvbj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZW51LXRpdGxlXFxcIj57eyBtZW51SXRlbS50aXRsZSB9fTwvc3Bhbj5cXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XFxcImJhZGdlXFxcIiBbbmdUZW1wbGF0ZU91dGxldF09XFxcImJhZGdlVGVtcGxhdGVcXFwiPjwvbmctY29udGFpbmVyPlxcbjwvYT5cXG48YSAqbmdJZj1cXFwibWVudUl0ZW0uY2hpbGRyZW5cXFwiXFxuICAgKGNsaWNrKT1cXFwiJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uVG9nZ2xlU3ViTWVudShtZW51SXRlbSk7XFxcIlxcbiAgIFthdHRyLnRhcmdldF09XFxcIm1lbnVJdGVtLnRhcmdldFxcXCJcXG4gICBbYXR0ci50aXRsZV09XFxcIm1lbnVJdGVtLnRpdGxlXFxcIlxcbiAgIFtjbGFzcy5hY3RpdmVdPVxcXCJtZW51SXRlbS5zZWxlY3RlZFxcXCJcXG4gICAobW91c2VlbnRlcik9XFxcIm9uSG92ZXJJdGVtKG1lbnVJdGVtKVxcXCJcXG4gICBocmVmPVxcXCIjXFxcIj5cXG4gIDxuYi1pY29uIGNsYXNzPVxcXCJtZW51LWljb25cXFwiIFtjb25maWddPVxcXCJtZW51SXRlbS5pY29uXFxcIiAqbmdJZj1cXFwibWVudUl0ZW0uaWNvblxcXCI+PC9uYi1pY29uPlxcbiAgPHNwYW4gY2xhc3M9XFxcIm1lbnUtdGl0bGVcXFwiPnt7IG1lbnVJdGVtLnRpdGxlIH19PC9zcGFuPlxcbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwiYmFkZ2VcXFwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwiYmFkZ2VUZW1wbGF0ZVxcXCI+PC9uZy1jb250YWluZXI+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwiZXhwYW5kLXN0YXRlXFxcIiBbaWNvbl09XFxcImdldEV4cGFuZFN0YXRlSWNvbigpXFxcIiBwYWNrPVxcXCJuZWJ1bGFyLWVzc2VudGlhbHNcXFwiPjwvbmItaWNvbj5cXG48L2E+XFxuPHVsICpuZ0lmPVxcXCJtZW51SXRlbS5jaGlsZHJlblxcXCJcXG4gICAgW2NsYXNzLmNvbGxhcHNlZF09XFxcIiEobWVudUl0ZW0uY2hpbGRyZW4gJiYgbWVudUl0ZW0uZXhwYW5kZWQpXFxcIlxcbiAgICBbY2xhc3MuZXhwYW5kZWRdPVxcXCJtZW51SXRlbS5leHBhbmRlZFxcXCJcXG4gICAgW0B0b2dnbGVdPVxcXCJ0b2dnbGVTdGF0ZVxcXCJcXG4gICAgY2xhc3M9XFxcIm1lbnUtaXRlbXNcXFwiPlxcbiAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCBpdGVtIG9mIG1lbnVJdGVtLmNoaWxkcmVuXFxcIj5cXG4gICAgPGxpIG5iTWVudUl0ZW0gKm5nSWY9XFxcIiFpdGVtLmhpZGRlblxcXCJcXG4gICAgICAgIFttZW51SXRlbV09XFxcIml0ZW1cXFwiXFxuICAgICAgICBbYmFkZ2VdPVxcXCJpdGVtLmJhZGdlXFxcIlxcbiAgICAgICAgW2NsYXNzLm1lbnUtZ3JvdXBdPVxcXCJpdGVtLmdyb3VwXFxcIlxcbiAgICAgICAgKGhvdmVySXRlbSk9XFxcIm9uSG92ZXJJdGVtKCRldmVudClcXFwiXFxuICAgICAgICAodG9nZ2xlU3ViTWVudSk9XFxcIm9uVG9nZ2xlU3ViTWVudSgkZXZlbnQpXFxcIlxcbiAgICAgICAgKHNlbGVjdEl0ZW0pPVxcXCJvblNlbGVjdEl0ZW0oJGV2ZW50KVxcXCJcXG4gICAgICAgIChpdGVtQ2xpY2spPVxcXCJvbkl0ZW1DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcIm1lbnUtaXRlbVxcXCI+XFxuICAgIDwvbGk+XFxuICA8L25nLWNvbnRhaW5lcj5cXG48L3VsPlxcblxcbjxuZy10ZW1wbGF0ZSAjYmFkZ2VUZW1wbGF0ZT5cXG4gIDxuYi1iYWRnZSBbdGV4dF09XFxcImJhZGdlLnRleHRcXFwiIFtkb3RNb2RlXT1cXFwiYmFkZ2UuZG90TW9kZVxcXCIgW3N0YXR1c109XFxcImJhZGdlLnN0YXR1c1xcXCI+XFxuICA8L25iLWJhZGdlPlxcbjwvbmctdGVtcGxhdGU+XFxuXCIsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCd0b2dnbGUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZShOYlRvZ2dsZVN0YXRlcy5Db2xsYXBzZWQsIHN0eWxlKHsgaGVpZ2h0OiAnMCcsIG1hcmdpbjogJzAnIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKE5iVG9nZ2xlU3RhdGVzLkV4cGFuZGVkLCBzdHlsZSh7IGhlaWdodDogJyonIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oYCR7TmJUb2dnbGVTdGF0ZXMuQ29sbGFwc2VkfSA8PT4gJHtOYlRvZ2dsZVN0YXRlcy5FeHBhbmRlZH1gLCBhbmltYXRlKDMwMCkpLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iTWVudUl0ZW1Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYk1lbnVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkxheW91dERpcmVjdGlvblNlcnZpY2UgfVxuXTtcbk5iTWVudUl0ZW1Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbWVudUl0ZW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJhZGdlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBob3Zlckl0ZW06IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB0b2dnbGVTdWJNZW51OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc2VsZWN0SXRlbTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGl0ZW1DbGljazogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuLyoqXG4gKiBWZXJ0aWNhbCBtZW51IGNvbXBvbmVudC5cbiAqXG4gKiBBY2NlcHRzIGEgbGlzdCBvZiBtZW51IGl0ZW1zIGFuZCByZW5kZXJzIHRoZW0gYWNjb3JkaW5nbHkuIFN1cHBvcnRzIG11bHRpLWxldmVsIG1lbnVzLlxuICpcbiAqIEJhc2ljIGV4YW1wbGVcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIG1lbnUvbWVudS1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogYGBgdHNcbiAqIC8vIC4uLlxuICogaXRlbXM6IE5iTWVudUl0ZW1bXSA9IFtcbiAqICB7XG4gKiAgICB0aXRsZTogaG9tZSxcbiAqICAgIGxpbms6ICcvJ1xuICogIH0sXG4gKiAge1xuICogICAgdGl0bGU6IGRhc2hib2FyZCxcbiAqICAgIGxpbms6ICdkYXNoYm9hcmQnXG4gKiAgfVxuICogXTtcbiAqIC8vIC4uLlxuICogPG5iLW1lbnUgW2l0ZW1zXT1cIml0ZW1zXCI+PC9uYi1tZW51PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYk1lbnVNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIGFwcCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTWVudU1vZHVsZS5mb3JSb290KCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICogYW5kIGBOYk1lbnVNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUgd2hlcmUgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgc2hvd246XG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTWVudU1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogVHdvLWxldmVsIG1lbnUgZXhhbXBsZVxuICogQHN0YWNrZWQtZXhhbXBsZShUd28gTGV2ZWxzLCBtZW51L21lbnUtY2hpbGRyZW4uY29tcG9uZW50KVxuICpcbiAqXG4gKiBBdXRvY29sbGFwc2UgbWVudSBleGFtcGxlXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF1dG9jb2xsYXBzZSBNZW51LCBtZW51L21lbnUtYXV0b2NvbGxhcHNlLmNvbXBvbmVudClcbiAqXG4gKiBNZW51IGJhZGdlXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1lbnUgaXRlbSBiYWRnZSwgbWVudS9tZW51LWJhZGdlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogbWVudS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbWVudS10ZXh0LWNvbG9yOlxuICogbWVudS10ZXh0LWZvbnQtZmFtaWx5OlxuICogbWVudS10ZXh0LWZvbnQtc2l6ZTpcbiAqIG1lbnUtdGV4dC1mb250LXdlaWdodDpcbiAqIG1lbnUtdGV4dC1saW5lLWhlaWdodDpcbiAqIG1lbnUtZ3JvdXAtdGV4dC1jb2xvcjpcbiAqIG1lbnUtaXRlbS1ib3JkZXItcmFkaXVzOlxuICogbWVudS1pdGVtLXBhZGRpbmc6XG4gKiBtZW51LWl0ZW0taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtaXRlbS1ob3Zlci1jdXJzb3I6XG4gKiBtZW51LWl0ZW0taG92ZXItdGV4dC1jb2xvcjpcbiAqIG1lbnUtaXRlbS1pY29uLWhvdmVyLWNvbG9yOlxuICogbWVudS1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbWVudS1pdGVtLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogbWVudS1pdGVtLWljb24tYWN0aXZlLWNvbG9yOlxuICogbWVudS1pdGVtLWljb24tY29sb3I6XG4gKiBtZW51LWl0ZW0taWNvbi1tYXJnaW46XG4gKiBtZW51LWl0ZW0taWNvbi13aWR0aDpcbiAqIG1lbnUtaXRlbS1kaXZpZGVyLWNvbG9yOlxuICogbWVudS1pdGVtLWRpdmlkZXItc3R5bGU6XG4gKiBtZW51LWl0ZW0tZGl2aWRlci13aWR0aDpcbiAqIG1lbnUtc3VibWVudS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbWVudS1zdWJtZW51LXRleHQtY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtbWFyZ2luOlxuICogbWVudS1zdWJtZW51LXBhZGRpbmc6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ib3JkZXItY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ib3JkZXItc3R5bGU6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ib3JkZXItd2lkdGg6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ib3JkZXItcmFkaXVzOlxuICogbWVudS1zdWJtZW51LWl0ZW0tcGFkZGluZzpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ob3Zlci10ZXh0LWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0taWNvbi1ob3Zlci1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0taWNvbi1hY3RpdmUtY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1hY3RpdmUtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWFjdGl2ZS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1hY3RpdmUtaG92ZXItdGV4dC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWljb24tYWN0aXZlLWhvdmVyLWNvbG9yOlxuICovXG5jbGFzcyBOYk1lbnVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHdpbmRvdywgcGxhdGZvcm1JZCwgbWVudUludGVybmFsU2VydmljZSwgcm91dGVyKSB7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLnBsYXRmb3JtSWQgPSBwbGF0Zm9ybUlkO1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2UgPSBtZW51SW50ZXJuYWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fYXV0b0NvbGxhcHNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSBhbGwgb3BlbmVkIHN1Ym1lbnVzIG9uIHRoZSB0b2dnbGUgZXZlbnRcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFwiZmFsc2VcIlxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBnZXQgYXV0b0NvbGxhcHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b0NvbGxhcHNlO1xuICAgIH1cbiAgICBzZXQgYXV0b0NvbGxhcHNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F1dG9Db2xsYXBzZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2UucHJlcGFyZUl0ZW1zKHRoaXMuaXRlbXMpO1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2VcbiAgICAgICAgICAgIC5vbkFkZEl0ZW0oKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChkYXRhKSA9PiB0aGlzLmNvbXBhcmVUYWcoZGF0YS50YWcpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkYXRhID0+IHRoaXMub25BZGRJdGVtKGRhdGEpKTtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlXG4gICAgICAgICAgICAub25OYXZpZ2F0ZUhvbWUoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChkYXRhKSA9PiB0aGlzLmNvbXBhcmVUYWcoZGF0YS50YWcpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm5hdmlnYXRlSG9tZSgpKTtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlXG4gICAgICAgICAgICAub25HZXRTZWxlY3RlZEl0ZW0oKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChkYXRhKSA9PiB0aGlzLmNvbXBhcmVUYWcoZGF0YS50YWcpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgZGF0YS5saXN0ZW5lci5uZXh0KHsgdGFnOiB0aGlzLnRhZywgaXRlbTogdGhpcy5nZXRTZWxlY3RlZEl0ZW0odGhpcy5pdGVtcykgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2VcbiAgICAgICAgICAgIC5vbkNvbGxhcHNlQWxsKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoZGF0YSkgPT4gdGhpcy5jb21wYXJlVGFnKGRhdGEudGFnKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb2xsYXBzZUFsbCgpKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2Uuc2VsZWN0RnJvbVVybCh0aGlzLml0ZW1zLCB0aGlzLnRhZywgdGhpcy5hdXRvQ29sbGFwc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubWVudUludGVybmFsU2VydmljZS5zZWxlY3RGcm9tVXJsKHRoaXMuaXRlbXMsIHRoaXMudGFnLCB0aGlzLmF1dG9Db2xsYXBzZSkpO1xuICAgIH1cbiAgICBvbkFkZEl0ZW0oZGF0YSkge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goLi4uZGF0YS5pdGVtcyk7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5wcmVwYXJlSXRlbXModGhpcy5pdGVtcyk7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5zZWxlY3RGcm9tVXJsKHRoaXMuaXRlbXMsIHRoaXMudGFnLCB0aGlzLmF1dG9Db2xsYXBzZSk7XG4gICAgfVxuICAgIG9uSG92ZXJJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLml0ZW1Ib3ZlcihpdGVtLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIG9uVG9nZ2xlU3ViTWVudShpdGVtKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9Db2xsYXBzZSkge1xuICAgICAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLmNvbGxhcHNlQWxsKHRoaXMuaXRlbXMsIHRoaXMudGFnLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmV4cGFuZGVkID0gIWl0ZW0uZXhwYW5kZWQ7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5zdWJtZW51VG9nZ2xlKGl0ZW0sIHRoaXMudGFnKTtcbiAgICB9XG4gICAgLy8gVE9ETzogaXMgbm90IGZpcmVkIG9uIHBhZ2UgcmVsb2FkXG4gICAgb25TZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLnNlbGVjdEl0ZW0oaXRlbSwgdGhpcy5pdGVtcywgdGhpcy5hdXRvQ29sbGFwc2UsIHRoaXMudGFnKTtcbiAgICB9XG4gICAgb25JdGVtQ2xpY2soaXRlbSkge1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2UuaXRlbUNsaWNrKGl0ZW0sIHRoaXMudGFnKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIG5hdmlnYXRlSG9tZSgpIHtcbiAgICAgICAgY29uc3QgaG9tZUl0ZW0gPSB0aGlzLmdldEhvbWVJdGVtKHRoaXMuaXRlbXMpO1xuICAgICAgICBpZiAoaG9tZUl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChob21lSXRlbS5saW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFzID0ge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogaG9tZUl0ZW0ucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zSGFuZGxpbmc6IGhvbWVJdGVtLnF1ZXJ5UGFyYW1zSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBob21lSXRlbS5mcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVGcmFnbWVudDogaG9tZUl0ZW0ucHJlc2VydmVGcmFnbWVudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtob21lSXRlbS5saW5rXSwgZXh0cmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob21lSXRlbS51cmwgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2luZG93LmxvY2F0aW9uLmhyZWYgPSBob21lSXRlbS51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGFwc2VBbGwoKSB7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5jb2xsYXBzZUFsbCh0aGlzLml0ZW1zLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIGdldEhvbWVJdGVtKGl0ZW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaG9tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaG9tZUl0ZW0gPSBpdGVtLmNoaWxkcmVuICYmIHRoaXMuZ2V0SG9tZUl0ZW0oaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoaG9tZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9tZUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGFyZVRhZyh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgfHwgdGFnID09PSB0aGlzLnRhZztcbiAgICB9XG4gICAgZ2V0U2VsZWN0ZWRJdGVtKGl0ZW1zKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRJdGVtKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbn1cbk5iTWVudUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItbWVudScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8dWwgY2xhc3M9XCJtZW51LWl0ZW1zXCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICAgIDxsaSBuYk1lbnVJdGVtICpuZ0lmPVwiIWl0ZW0uaGlkZGVuXCJcbiAgICAgICAgICAgIFttZW51SXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgIFtiYWRnZV09XCJpdGVtLmJhZGdlXCJcbiAgICAgICAgICAgIFtjbGFzcy5tZW51LWdyb3VwXT1cIml0ZW0uZ3JvdXBcIlxuICAgICAgICAgICAgKGhvdmVySXRlbSk9XCJvbkhvdmVySXRlbSgkZXZlbnQpXCJcbiAgICAgICAgICAgICh0b2dnbGVTdWJNZW51KT1cIm9uVG9nZ2xlU3ViTWVudSgkZXZlbnQpXCJcbiAgICAgICAgICAgIChzZWxlY3RJdGVtKT1cIm9uU2VsZWN0SXRlbSgkZXZlbnQpXCJcbiAgICAgICAgICAgIChpdGVtQ2xpY2spPVwib25JdGVtQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgICAgICBjbGFzcz1cIm1lbnUtaXRlbVwiPlxuICAgICAgICA8L2xpPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC91bD5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IDo6bmctZGVlcHtkaXNwbGF5OmJsb2NrfTpob3N0IDo6bmctZGVlcCAubWVudS1pdGVtcyw6aG9zdCA6Om5nLWRlZXAgLm1lbnUtaXRlbT4ubWVudS1pdGVtc3tsaXN0LXN0eWxlLXR5cGU6bm9uZTtvdmVyZmxvdzpoaWRkZW59Omhvc3QgOjpuZy1kZWVwIC5tZW51LWl0ZW0gYXtkaXNwbGF5OmZsZXg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7YWxpZ24taXRlbXM6Y2VudGVyfTpob3N0IDo6bmctZGVlcCAubWVudS1pdGVtIGEgLm1lbnUtdGl0bGV7ZmxleDoxIDAgYXV0b31bZGlyPXJ0bF0gOmhvc3QgOjpuZy1kZWVwIC5tZW51LWl0ZW0gYSAubWVudS10aXRsZXt0ZXh0LWFsaWduOnJpZ2h0fTpob3N0IDo6bmctZGVlcCAubWVudS1pdGVtIG5iLWJhZGdle3Bvc2l0aW9uOnN0YXRpY306aG9zdCA6Om5nLWRlZXAgLm1lbnUtZ3JvdXAgc3BhbntkaXNwbGF5OmZsZXh9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iTWVudUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfV0lORE9XLF0gfV0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJNZW51SW50ZXJuYWxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSb3V0ZXIgfVxuXTtcbk5iTWVudUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0YWc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGl0ZW1zOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhdXRvQ29sbGFwc2U6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIEJhZGdlIGlzIGEgc2ltcGxlIGxhYmVsaW5nIGNvbXBvbmVudC5cbiAqIEl0IGNhbiBiZSB1c2VkIHRvIGFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGFueSBjb250ZW50IG9yIGhpZ2hsaWdodCB1bnJlYWQgaXRlbXMuXG4gKlxuICogRWxlbWVudCBpcyBhYnNvbHV0ZSBwb3NpdGlvbmVkLCBzbyBwYXJlbnQgc2hvdWxkIGJlXG4gKiBbcG9zaXRpb25lZCBlbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvcG9zaXRpb24pLlxuICogSXQgbWVhbnMgcGFyZW50IGBwb3NpdGlvbmAgc2hvdWxkIGJlIHNldCB0byBhbnl0aGluZyBleGNlcHQgYHN0YXRpY2AsIGUuZy4gYHJlbGF0aXZlYCxcbiAqIGBhYnNvbHV0ZWAsIGBmaXhlZGAsIG9yIGBzdGlja3lgLlxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQmFkZ2VNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQmFkZ2VNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEJhZGdlIHdpdGggZGVmYXVsdCBwb3NpdGlvbiBhbmQgc3RhdHVzKGNvbG9yKTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItYmFkZ2UgdGV4dD1cImJhZGdlVGV4dFwiPjwvbmItYmFkZ2U+XG4gKiBgYGBcbiAqXG4gKiBGb3IgZXhhbXBsZSwgYmFkZ2UgY2FuIGJlIHBsYWNlZCBpbnRvIG5iLWNhcmQgaGVhZGVyOlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgYmFkZ2UvYmFkZ2Utc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEJhZGdlIGxvY2F0ZWQgb24gdGhlIGJvdHRvbSByaWdodCB3aXRoIHdhcm5pbmcgc3RhdHVzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1iYWRnZSB0ZXh0PVwiYmFkZ2VUZXh0XCIgc3RhdHVzPVwid2FybmluZ1wiIHBvc2l0aW9uPVwiYm90dG9tIHJpZ2h0XCI+XG4gKiA8L25iLWJhZGdlPlxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGJhZGdlLWJvcmRlci1yYWRpdXM6XG4gKiBiYWRnZS10ZXh0LWZvbnQtZmFtaWx5OlxuICogYmFkZ2UtdGV4dC1mb250LXNpemU6XG4gKiBiYWRnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYmFkZ2UtdGV4dC1saW5lLWhlaWdodDpcbiAqIGJhZGdlLXBhZGRpbmc6XG4gKiBiYWRnZS1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYmFkZ2UtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIGJhZGdlLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGJhZGdlLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGJhZGdlLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLWluZm8tdGV4dC1jb2xvcjpcbiAqIGJhZGdlLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGJhZGdlLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYmFkZ2UtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBiYWRnZS1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBiYWRnZS1jb250cm9sLXRleHQtY29sb3I6XG4gKi9cbmNsYXNzIE5iQmFkZ2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgdG8gZGlzcGxheVxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl9kZWZhdWx0UG9zaXRpb24gPSAndG9wIHJpZ2h0JztcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWZhdWx0UG9zaXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWRnZSBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogJ2Jhc2ljJywgJ3ByaW1hcnknLCAnaW5mbycsICdzdWNjZXNzJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJywgJ2NvbnRyb2wnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdiYXNpYyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhZGdlIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBDYW4gYmUgc2V0IHRvIGFueSBjbGFzcyBvciB0byBvbmUgb2YgcHJlZGVmaW5lZCBwb3NpdGlvbnM6XG4gICAgICogJ3RvcCBsZWZ0JywgJ3RvcCByaWdodCcsICdib3R0b20gbGVmdCcsICdib3R0b20gcmlnaHQnLFxuICAgICAqICd0b3Agc3RhcnQnLCAndG9wIGVuZCcsICdib3R0b20gc3RhcnQnLCAnYm90dG9tIGVuZCdcbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9XG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWUgfHwgdGhpcy5fZGVmYXVsdFBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBiYWRnZSBhcyBhIGRvdC4gTm8gdGV4dCBpcyBzaG93bi5cbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgZ2V0IGRvdE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb3RNb2RlO1xuICAgIH1cbiAgICBzZXQgZG90TW9kZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kb3RNb2RlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIH1cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmluY2x1ZGVzKCdyaWdodCcpO1xuICAgIH1cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJyk7XG4gICAgfVxuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIH1cbiAgICBnZXQgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmluY2x1ZGVzKCdzdGFydCcpO1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnZW5kJyk7XG4gICAgfVxuICAgIGdldCBjZW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmluY2x1ZGVzKCdjZW50ZXInKTtcbiAgICB9XG59XG5OYkJhZGdlQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1iYWRnZScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGB7e2RvdE1vZGUgPyAnJyA6IHRleHR9fWAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9Omhvc3QoLnBvc2l0aW9uLXRvcCl7dG9wOjB9Omhvc3QoLnBvc2l0aW9uLXJpZ2h0KXtyaWdodDowfTpob3N0KC5wb3NpdGlvbi1ib3R0b20pe2JvdHRvbTowfTpob3N0KC5wb3NpdGlvbi1sZWZ0KXtsZWZ0OjB9Omhvc3QoLnBvc2l0aW9uLWNlbnRlcil7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1bZGlyPWx0cl0gOmhvc3QoLnBvc2l0aW9uLXN0YXJ0KXtsZWZ0OjB9W2Rpcj1ydGxdIDpob3N0KC5wb3NpdGlvbi1zdGFydCl7cmlnaHQ6MH1bZGlyPWx0cl0gOmhvc3QoLnBvc2l0aW9uLWVuZCl7cmlnaHQ6MH1bZGlyPXJ0bF0gOmhvc3QoLnBvc2l0aW9uLWVuZCl7bGVmdDowfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkJhZGdlQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYkJhZGdlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkb3RNb2RlOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRvdC1tb2RlJyxdIH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIHRvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MucG9zaXRpb24tdG9wJyxdIH1dLFxuICAgIHJpZ2h0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5wb3NpdGlvbi1yaWdodCcsXSB9XSxcbiAgICBib3R0b206IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnBvc2l0aW9uLWJvdHRvbScsXSB9XSxcbiAgICBsZWZ0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5wb3NpdGlvbi1sZWZ0JyxdIH1dLFxuICAgIHN0YXJ0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5wb3NpdGlvbi1zdGFydCcsXSB9XSxcbiAgICBlbmQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnBvc2l0aW9uLWVuZCcsXSB9XSxcbiAgICBjZW50ZXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnBvc2l0aW9uLWNlbnRlcicsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJCYWRnZU1vZHVsZSB7XG59XG5OYkJhZGdlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTmJCYWRnZUNvbXBvbmVudF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJCYWRnZUNvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgbmJNZW51Q29tcG9uZW50cyA9IFtOYk1lbnVDb21wb25lbnQsIE5iTWVudUl0ZW1Db21wb25lbnRdO1xuY29uc3QgTkJfTUVOVV9QUk9WSURFUlMgPSBbTmJNZW51U2VydmljZSwgTmJNZW51SW50ZXJuYWxTZXJ2aWNlXTtcbmNsYXNzIE5iTWVudU1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJNZW51TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgLi4uTkJfTUVOVV9QUk9WSURFUlMsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk5iTWVudU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkJhZGdlTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbLi4ubmJNZW51Q29tcG9uZW50c10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogWy4uLm5iTWVudUNvbXBvbmVudHNdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogUm91dGUgdGFic2V0IGNvbXBvbmVudHMuXG4gKiBSZW5kZXJzIHRhYnMgaW5zaWRlIG9mIGEgcm91dGVyLW91dGxldC5cbiAqXG4gKiBgYGB0c1xuICogIHRhYnMgPSBbXG4gKiAge1xuICogICAgdGl0bGU6ICdSb3V0ZSB0YWIgIzEnLFxuICogICAgcm91dGU6ICcvcGFnZXMvZGVzY3JpcHRpb24nLFxuICogICAgaWNvbjogJ2hvbWUnLFxuICogICAgcmVzcG9uc2l2ZTogdHJ1ZSwgLy8gaGlkZSB0aXRsZSBiZWZvcmUgYHJvdXRlLXRhYnMtaWNvbi1vbmx5LW1heC13aWR0aGAgdmFsdWVcbiAqICB9LFxuICogIHtcbiAqICAgIHRpdGxlOiAnUm91dGUgdGFiICMyJyxcbiAqICAgIHJvdXRlOiAnL3BhZ2VzL2ltYWdlcycsXG4gKiAgICB9XG4gKiAgXTtcbiAqXG4gKiAgPG5iLXJvdXRlLXRhYnNldCBbdGFic109XCJ0YWJzXCI+PC9uYi1yb3V0ZS10YWJzZXQ+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iUm91dGVUYWJzZXRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUm91dGVUYWJzZXRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFJvdXRlIFRhYnNldCwgdGFic2V0L3JvdXRlLXRhYnNldC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHJvdXRlLXRhYnNldC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcm91dGUtdGFic2V0LWJvcmRlci1yYWRpdXM6XG4gKiByb3V0ZS10YWJzZXQtc2hhZG93OlxuICogcm91dGUtdGFic2V0LXRhYi1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1wYWRkaW5nOlxuICogcm91dGUtdGFic2V0LXRhYi10ZXh0LWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi10ZXh0LWZvbnQtZmFtaWx5OlxuICogcm91dGUtdGFic2V0LXRhYi10ZXh0LWZvbnQtc2l6ZTpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1mb250LXdlaWdodDpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1saW5lLWhlaWdodDpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC10cmFuc2Zvcm06XG4gKiByb3V0ZS10YWJzZXQtdGFiLXVuZGVybGluZS13aWR0aDpcbiAqIHJvdXRlLXRhYnNldC10YWItdW5kZXJsaW5lLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItYWN0aXZlLXRleHQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWFjdGl2ZS11bmRlcmxpbmUtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWZvY3VzLXRleHQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWZvY3VzLXVuZGVybGluZS1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItaG92ZXItdGV4dC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItaG92ZXItdW5kZXJsaW5lLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1kaXNhYmxlZC11bmRlcmxpbmUtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtZGl2aWRlci1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC1kaXZpZGVyLXN0eWxlOlxuICogcm91dGUtdGFic2V0LWRpdmlkZXItd2lkdGg6XG4gKiByb3V0ZS10YWJzZXQtc2Nyb2xsYmFyLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXNjcm9sbGJhci13aWR0aDpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1oaWRlLWJyZWFrcG9pbnQ6XG4gKi9cbmNsYXNzIE5iUm91dGVUYWJzZXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFZhbHVlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zIHBhc3NlZCB0byBgcm91dGVyTGlua0FjdGl2ZU9wdGlvbnNgIGRpcmVjdGl2ZSB3aGljaCBzZXQgb24gdGFiIGxpbmtzLlxuICAgICAgICAgKiBgeyBleGFjdDogdHJ1ZSB9YCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVMaW5rT3B0aW9ucyA9IHsgZXhhY3Q6IHRydWUgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gdGFiIGlzIHNlbGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8YW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlVGFiID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlIGZ1bGwgd2lkdGggb2YgYSBwYXJlbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCBmdWxsV2lkdGgodmFsKSB7XG4gICAgICAgIHRoaXMuZnVsbFdpZHRoVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgc2VsZWN0VGFiKHRhYikge1xuICAgICAgICB0aGlzLmNoYW5nZVRhYi5lbWl0KHRhYik7XG4gICAgfVxufVxuTmJSb3V0ZVRhYnNldENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItcm91dGUtdGFic2V0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDx1bCBjbGFzcz1cInJvdXRlLXRhYnNldFwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNcIj5cbiAgICAgICAgPGxpICpuZ0lmPVwidGFiLmRpc2FibGVkOyBlbHNlIGVuYWJsZWRcIlxuICAgICAgICAgICAgW2NsYXNzLnJlc3BvbnNpdmVdPVwidGFiLnJlc3BvbnNpdmVcIlxuICAgICAgICAgICAgY2xhc3M9XCJyb3V0ZS10YWIgZGlzYWJsZWRcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgICAgIDxhIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cInRhYi1saW5rXCI+XG4gICAgICAgICAgICA8bmItaWNvbiAqbmdJZj1cInRhYi5pY29uXCIgW2NvbmZpZ109XCJ0YWIuaWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwidGFiLnRpdGxlXCIgY2xhc3M9XCJ0YWItdGV4dFwiPnt7IHRhYi50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNlbmFibGVkPlxuICAgICAgICAgIDxsaSAoY2xpY2spPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IHNlbGVjdFRhYih0YWIpXCJcbiAgICAgICAgICAgICAgW3JvdXRlckxpbmtdPVwidGFiLnJvdXRlXCJcbiAgICAgICAgICAgICAgcm91dGVyTGlua0FjdGl2ZT1cImFjdGl2ZVwiXG4gICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XCJhY3RpdmVMaW5rT3B0aW9uc1wiXG4gICAgICAgICAgICAgIFtjbGFzcy5yZXNwb25zaXZlXT1cInRhYi5yZXNwb25zaXZlXCJcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJyb3V0ZS10YWJcIj5cbiAgICAgICAgICAgIDxhIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cInRhYi1saW5rXCI+XG4gICAgICAgICAgICAgIDxuYi1pY29uICpuZ0lmPVwidGFiLmljb25cIiBbaWNvbl09XCJ0YWIuaWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJ0YWIudGl0bGVcIiBjbGFzcz1cInRhYi10ZXh0XCI+e3sgdGFiLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3VsPlxuICAgIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIi5yb3V0ZS10YWJzZXR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdztsaXN0LXN0eWxlLXR5cGU6bm9uZTttYXJnaW46MDtwYWRkaW5nOjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFie21hcmdpbi1ib3R0b206LTFweDt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFiLmFjdGl2ZSBhOjpiZWZvcmV7ZGlzcGxheTpibG9ja30ucm91dGUtdGFic2V0IC5yb3V0ZS10YWIgYXtwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1ibG9ja30ucm91dGUtdGFic2V0IC5yb3V0ZS10YWIgYTo6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6Jyc7d2lkdGg6MTAwJTtib3JkZXItcmFkaXVzOjNweDtib3R0b206LTJweDtsZWZ0OjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFiIGEgbmItaWNvbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9W2Rpcj1sdHJdIDpob3N0IC50YWItbGluayBuYi1pY29uK3NwYW57bWFyZ2luLWxlZnQ6LjVyZW19W2Rpcj1ydGxdIDpob3N0IC50YWItbGluayBuYi1pY29uK3NwYW57bWFyZ2luLXJpZ2h0Oi41cmVtfTpob3N0KC5mdWxsLXdpZHRoKSAucm91dGUtdGFic2V0e2p1c3RpZnktY29udGVudDpzcGFjZS1hcm91bmR9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iUm91dGVUYWJzZXRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZnVsbFdpZHRoVmFsdWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmZ1bGwtd2lkdGgnLF0gfV0sXG4gICAgdGFiczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWN0aXZlTGlua09wdGlvbnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZ1bGxXaWR0aDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hhbmdlVGFiOiBbeyB0eXBlOiBPdXRwdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iUm91dGVUYWJzZXRNb2R1bGUge1xufVxuTmJSb3V0ZVRhYnNldE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iUm91dGVUYWJzZXRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iUm91dGVUYWJzZXRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBnZXRTaWRlYmFyU3RhdGUkID0gbmV3IFN1YmplY3QoKTtcbmNvbnN0IGdldFNpZGViYXJSZXNwb25zaXZlU3RhdGUkID0gbmV3IFN1YmplY3QoKTtcbi8qKlxuICogU2lkZWJhciBzZXJ2aWNlLlxuICpcbiAqIFJvb3QgbW9kdWxlIHNlcnZpY2UgdG8gY29udHJvbCB0aGUgc2lkZWJhciBmcm9tIGFueSBwYXJ0IG9mIHRoZSBhcHAuXG4gKlxuICogQWxsb3dzIHlvdSB0byBjaGFuZ2Ugc2lkZWJhciBzdGF0ZSBkeW5hbWljYWxseSBmcm9tIGFueSBwYXJ0IG9mIHRoZSBhcHA6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpZGViYXIgU3RhdGUsIHNpZGViYXIvc2lkZWJhci10b2dnbGUuY29tcG9uZW50KVxuICovXG5jbGFzcyBOYlNpZGViYXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b2dnbGUkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5leHBhbmQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNvbXBhY3QkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRvZ2dsZSBldmVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGU8eyBjb21wYWN0OiBib29sZWFuLCB0YWc6IHN0cmluZyB9PlxuICAgICAqL1xuICAgIG9uVG9nZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBleHBhbmQgZXZlbnRzXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7IHRhZzogc3RyaW5nIH0+XG4gICAgICovXG4gICAgb25FeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZCQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGNvbGxhcHNlIGV2ZW5zXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7IHRhZzogc3RyaW5nIH0+XG4gICAgICovXG4gICAgb25Db2xsYXBzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2UkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBjb21wYWN0IGV2ZW5zXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7IHRhZzogc3RyaW5nIH0+XG4gICAgICovXG4gICAgb25Db21wYWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYWN0JC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYSBzaWRlYmFyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb21wYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBzaWRlYmFycyBvbiB0aGUgcGFnZSwgbWFyayB0aGVtIHdpdGggYHRhZ2AgaW5wdXQgcHJvcGVydHkgYW5kIHBhc3MgaXQgaGVyZVxuICAgICAqIHRvIHNwZWNpZnkgd2hpY2ggc2lkZWJhciB5b3Ugd2FudCB0byBjb250cm9sXG4gICAgICovXG4gICAgdG9nZ2xlKGNvbXBhY3QgPSBmYWxzZSwgdGFnKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlJC5uZXh0KHsgY29tcGFjdCwgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGEgc2lkZWJhclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSWYgeW91IGhhdmUgbXVsdGlwbGUgc2lkZWJhcnMgb24gdGhlIHBhZ2UsIG1hcmsgdGhlbSB3aXRoIGB0YWdgIGlucHV0IHByb3BlcnR5IGFuZCBwYXNzIGl0IGhlcmVcbiAgICAgKiB0byBzcGVjaWZ5IHdoaWNoIHNpZGViYXIgeW91IHdhbnQgdG8gY29udHJvbFxuICAgICAqL1xuICAgIGV4cGFuZCh0YWcpIHtcbiAgICAgICAgdGhpcy5leHBhbmQkLm5leHQoeyB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhIHNpZGViYXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIElmIHlvdSBoYXZlIG11bHRpcGxlIHNpZGViYXJzIG9uIHRoZSBwYWdlLCBtYXJrIHRoZW0gd2l0aCBgdGFnYCBpbnB1dCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBoZXJlXG4gICAgICogdG8gc3BlY2lmeSB3aGljaCBzaWRlYmFyIHlvdSB3YW50IHRvIGNvbnRyb2xcbiAgICAgKi9cbiAgICBjb2xsYXBzZSh0YWcpIHtcbiAgICAgICAgdGhpcy5jb2xsYXBzZSQubmV4dCh7IHRhZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgc2lkZWJhciBjb21wYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBzaWRlYmFycyBvbiB0aGUgcGFnZSwgbWFyayB0aGVtIHdpdGggYHRhZ2AgaW5wdXQgcHJvcGVydHkgYW5kIHBhc3MgaXQgaGVyZVxuICAgICAqIHRvIHNwZWNpZnkgd2hpY2ggc2lkZWJhciB5b3Ugd2FudCB0byBjb250cm9sXG4gICAgICovXG4gICAgY29tcGFjdCh0YWcpIHtcbiAgICAgICAgdGhpcy5jb21wYWN0JC5uZXh0KHsgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNpZGViYXIgc3RhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIElmIHlvdSBoYXZlIG11bHRpcGxlIHNpZGViYXJzIG9uIHRoZSBwYWdlLCBtYXJrIHRoZW0gd2l0aCBgdGFnYCBpbnB1dCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBoZXJlXG4gICAgICogdG8gc3BlY2lmeSB3aGljaCBzaWRlYmFyIHN0YXRlIHlvdSBuZWVkXG4gICAgICovXG4gICAgZ2V0U2lkZWJhclN0YXRlKHRhZykge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIGdldFNpZGViYXJTdGF0ZSQubmV4dCh7IG9ic2VydmVyLCB0YWcgfSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlci5waXBlKHJlZkNvdW50KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNpZGViYXIgcmVzcG9uc2l2ZSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSWYgeW91IGhhdmUgbXVsdGlwbGUgc2lkZWJhcnMgb24gdGhlIHBhZ2UsIG1hcmsgdGhlbSB3aXRoIGB0YWdgIGlucHV0IHByb3BlcnR5IGFuZCBwYXNzIGl0IGhlcmVcbiAgICAgKiB0byBzcGVjaWZ5IHdoaWNoIHNpZGViYXIgcmVzcG9uc2l2ZSBzdGF0ZSB5b3UgbmVlZFxuICAgICAqL1xuICAgIGdldFNpZGViYXJSZXNwb25zaXZlU3RhdGUodGFnKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgZ2V0U2lkZWJhclJlc3BvbnNpdmVTdGF0ZSQubmV4dCh7IG9ic2VydmVyLCB0YWcgfSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlci5waXBlKHJlZkNvdW50KCkpO1xuICAgIH1cbn1cbk5iU2lkZWJhclNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBTaWRlYmFyIGhlYWRlciBjb250YWluZXIuXG4gKlxuICogUGxhY2Vob2xkZXIgd2hpY2ggY29udGFpbnMgYSBzaWRlYmFyIGhlYWRlciBjb250ZW50LFxuICogcGxhY2VkIGF0IHRoZSB2ZXJ5IHRvcCBvZiB0aGUgc2lkZWJhciBvdXRzaWRlIG9mIHRoZSBzY3JvbGwgYXJlYS5cbiAqL1xuY2xhc3MgTmJTaWRlYmFySGVhZGVyQ29tcG9uZW50IHtcbn1cbk5iU2lkZWJhckhlYWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItc2lkZWJhci1oZWFkZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICBgXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKlxuICogU2lkZWJhciBmb290ZXIgY29udGFpbmVyLlxuICpcbiAqIFBsYWNlaG9sZGVyIHdoaWNoIGNvbnRhaW5zIGEgc2lkZWJhciBmb290ZXIgY29udGVudCxcbiAqIHBsYWNlZCBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHNpZGViYXIgb3V0c2lkZSBvZiB0aGUgc2Nyb2xsIGFyZWEuXG4gKi9cbmNsYXNzIE5iU2lkZWJhckZvb3RlckNvbXBvbmVudCB7XG59XG5OYlNpZGViYXJGb290ZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXNpZGViYXItZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYFxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKipcbiAqIExheW91dCBzaWRlYmFyIGNvbXBvbmVudC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBzaWRlYmFyL3NpZGViYXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iU2lkZWJhck1vZHVsZS5mb3JSb290KClgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJTaWRlYmFyTW9kdWxlLmZvclJvb3QoKSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKiBhbmQgYE5iU2lkZWJhck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZSB3aGVyZSB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBzaG93bjpcbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJTaWRlYmFyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBTaWRlYmFyIGNhbiBiZSBwbGFjZWQgb24gdGhlIGxlZnQgb3IgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxheW91dCxcbiAqIG9yIG9uIHN0YXJ0L2VuZCBwb3NpdGlvbiBvZiBsYXlvdXQgKGRlcGVuZHMgb24gZG9jdW1lbnQgZGlyZWN0aW9uLCBsZWZ0IHRvIHJpZ2h0IG9yIHJpZ2h0IHRvIGxlZnQpXG4gKiBJdCBjYW4gYmUgZml4ZWQgKHNob3duIGFib3ZlIHRoZSBjb250ZW50KSBvciBjYW4gcHVzaCB0aGUgbGF5b3V0IHdoZW4gb3BlbmVkLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBzdGF0ZXMgLSBgZXhwYW5kZWRgLCBgY29sbGFwc2VkYCwgYGNvbXBhY3RlZGAuXG4gKiBCeSBkZWZhdWx0IHNpZGViYXIgY29udGVudCBpcyBmaXhlZCBhbmQgc2F2ZXMgaXRzIHBvc2l0aW9uIHdoaWxlIHRoZSBwYWdlIGlzIGJlaW5nIHNjcm9sbGVkLlxuICpcbiAqIENvbXBhY3RlZCBzaWRlYmFyIGV4YW1wbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbXBhY3RlZCBTaWRlYmFyLCBzaWRlYmFyL3NpZGViYXItY29tcGFjdGVkLmNvbXBvbmVudClcbiAqXG4gKiBTaWRlYmFyIGFsc28gc3VwcG9ydHMgYSBgcmVzcG9uc2l2ZWAgYmVoYXZpb3IsIGxpc3RlbmluZyB0byB3aW5kb3cgc2l6ZSBjaGFuZ2UgYW5kIGNoYW5naW5nIGl0cyBzaXplIHJlc3BlY3RhYmx5LlxuICpcbiAqIEluIGEgcGFpciB3aXRoIGhlYWRlciBpdCBpcyBwb3NzaWJsZSB0byBzZXR1cCBhIGNvbmZpZ3VyYXRpb24gd2hlbiBoZWFkZXIgaXMgcGxhY2VkIG9uIGEgc2lkZSBvZiB0aGUgc2lkZWJhclxuICogYW5kIG5vdCBvbiB0b3Agb2YgaXQuIFRvIGFjaGlldmUgdGhpcyBzaW1wbHkgcHV0IGEgYHN1YmhlYWRlcmAgcHJvcGVydHkgdG8gdGhlIGhlYWRlciBsaWtlIHRoaXM6XG4gKiBgYGBodG1sXG4gKiA8bmItbGF5b3V0LWhlYWRlciBzdWJoZWFkZXI+PC9uYi1sYXlvdXQtaGVhZGVyPlxuICogYGBgXG4gKiBAc3RhY2tlZC1leGFtcGxlKFN1YmhlYWRlciwgbGF5b3V0L2xheW91dC1zaWRlYmFyLXN1YmhlYWRlci5jb21wb25lbnQpXG4gKiBOb3RlIHRoYXQgaW4gc3VjaCBjb25maWd1cmF0aW9uIHNpZGViYXIgc2hhZG93IGlzIHJlbW92ZWQgYW5kIGhlYWRlciBjYW5ub3QgYmUgbWFrZSBgZml4ZWRgLlxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoUmlnaHQgU2lkZWJhciwgc2lkZWJhci9zaWRlYmFyLXJpZ2h0LmNvbXBvbmVudClcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoRml4ZWQgU2lkZWJhciwgc2lkZWJhci9zaWRlYmFyLWZpeGVkLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogc2lkZWJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2lkZWJhci10ZXh0LWNvbG9yOlxuICogc2lkZWJhci10ZXh0LWZvbnQtZmFtaWx5OlxuICogc2lkZWJhci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNpZGViYXItdGV4dC1mb250LXdlaWdodDpcbiAqIHNpZGViYXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHNpZGViYXItaGVpZ2h0OlxuICogc2lkZWJhci13aWR0aDpcbiAqIHNpZGViYXItd2lkdGgtY29tcGFjdDpcbiAqIHNpZGViYXItcGFkZGluZzpcbiAqIHNpZGViYXItaGVhZGVyLWhlaWdodDpcbiAqIHNpZGViYXItZm9vdGVyLWhlaWdodDpcbiAqIHNpZGViYXItc2hhZG93OlxuICogc2lkZWJhci1tZW51LWl0ZW0taGlnaGxpZ2h0LWNvbG9yOlxuICogc2lkZWJhci1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNpZGViYXItc2Nyb2xsYmFyLWNvbG9yOlxuICogc2lkZWJhci1zY3JvbGxiYXItd2lkdGg6XG4gKi9cbmNsYXNzIE5iU2lkZWJhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2lkZWJhclNlcnZpY2UsIHRoZW1lU2VydmljZSwgZWxlbWVudCwgY2QpIHtcbiAgICAgICAgdGhpcy5zaWRlYmFyU2VydmljZSA9IHNpZGViYXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZSA9IHRoZW1lU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVTdGF0ZSA9ICdwYyc7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckZpeGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpeGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yaWdodFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZSA9IGZhbHNlO1xuICAgICAgICAvLyBUT0RPOiBnZXQgd2lkdGggYnkgdGhlIGtleSBhbmQgZGVmaW5lIG9ubHkgbWF4IHdpZHRoIGZvciB0aGUgdGFibGV0cyBhbmQgbW9iaWxlc1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgb24gd2hpY2ggc2NyZWVuIHNpemVzIHNpZGViYXIgc2hvdWxkIGJlIHN3aXRjaGVkIHRvIGNvbXBhY3RlZCBzdGF0ZS5cbiAgICAgICAgICogV29ya3Mgb25seSB3aGVuIHJlc3BvbnNpdmUgbW9kZSBpcyBvbi5cbiAgICAgICAgICogRGVmYXVsdCB2YWx1ZXMgYXJlIGBbJ3hzJywgJ2lzJywgJ3NtJywgJ21kJywgJ2xnJ11gLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wYWN0ZWRCcmVha3BvaW50cyA9IFsneHMnLCAnaXMnLCAnc20nLCAnbWQnLCAnbGcnXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIG9uIHdoaWNoIHNjcmVlbiBzaXplcyBzaWRlYmFyIHNob3VsZCBiZSBzd2l0Y2hlZCB0byBjb2xsYXBzZWQgc3RhdGUuXG4gICAgICAgICAqIFdvcmtzIG9ubHkgd2hlbiByZXNwb25zaXZlIG1vZGUgaXMgb24uXG4gICAgICAgICAqIERlZmF1bHQgdmFsdWVzIGFyZSBgWyd4cycsICdpcyddYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgc3RyaW5nW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29sbGFwc2VkQnJlYWtwb2ludHMgPSBbJ3hzJywgJ2lzJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuZXZlciBzaWRlYmFyIHN0YXRlIGNoYW5nZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuZXZlciBzaWRlYmFyIHJlc3BvbnNpdmUgc3RhdGUgY2hhbmdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNwb25zaXZlU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBleHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdleHBhbmRlZCc7XG4gICAgfVxuICAgIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnY29sbGFwc2VkJztcbiAgICB9XG4gICAgZ2V0IGNvbXBhY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09ICdjb21wYWN0ZWQnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgc2lkZWJhciBvbiB0aGUgcmlnaHQgc2lkZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCByaWdodCh2YWwpIHtcbiAgICAgICAgdGhpcy5yaWdodFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gIXRoaXMucmlnaHRWYWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHNpZGViYXIgb24gdGhlIGxlZnQgc2lkZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBsZWZ0KHZhbCkge1xuICAgICAgICB0aGlzLmxlZnRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLnJpZ2h0VmFsdWUgPSAhdGhpcy5sZWZ0VmFsdWU7XG4gICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYWNlcyBzaWRlYmFyIG9uIHRoZSBzdGFydCBlZGdlIG9mIGxheW91dFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBzdGFydCh2YWwpIHtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSAhdGhpcy5zdGFydFZhbHVlO1xuICAgICAgICB0aGlzLmxlZnRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJpZ2h0VmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHNpZGViYXIgb24gdGhlIGVuZCBlZGdlIG9mIGxheW91dFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBlbmQodmFsKSB7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gIXRoaXMuZW5kVmFsdWU7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmlnaHRWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzaWRlYmFyIGZpeGVkIChzaG93biBhYm92ZSB0aGUgbGF5b3V0IGNvbnRlbnQpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGZpeGVkKHZhbCkge1xuICAgICAgICB0aGlzLmZpeGVkVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgc2lkZWJhciBjb250YWluZXIgZml4ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgY29udGFpbmVyRml4ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRml4ZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHNpZGViYXIgc3RhdGUsIGBleHBhbmRlZGB8YGNvbGxhcHNlZGB8YGNvbXBhY3RlZGBcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBzZXQgc3RhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgc2lkZWJhciBsaXN0ZW4gdG8gbWVkaWEgcXVlcnkgZXZlbnRzIGFuZCBjaGFuZ2UgaXRzIGJlaGF2aW91clxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCByZXNwb25zaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2l2ZTtcbiAgICB9XG4gICAgc2V0IHJlc3BvbnNpdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNpZGViYXJTZXJ2aWNlLm9uVG9nZ2xlKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyB0YWcgfSkgPT4gIXRoaXMudGFnIHx8IHRoaXMudGFnID09PSB0YWcpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGNvbXBhY3QgfSkgPT4gdGhpcy50b2dnbGUoY29tcGFjdCkpO1xuICAgICAgICB0aGlzLnNpZGViYXJTZXJ2aWNlLm9uRXhwYW5kKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyB0YWcgfSkgPT4gIXRoaXMudGFnIHx8IHRoaXMudGFnID09PSB0YWcpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuZXhwYW5kKCkpO1xuICAgICAgICB0aGlzLnNpZGViYXJTZXJ2aWNlLm9uQ29sbGFwc2UoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IHRhZyB9KSA9PiAhdGhpcy50YWcgfHwgdGhpcy50YWcgPT09IHRhZyksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb2xsYXBzZSgpKTtcbiAgICAgICAgdGhpcy5zaWRlYmFyU2VydmljZS5vbkNvbXBhY3QoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IHRhZyB9KSA9PiAhdGhpcy50YWcgfHwgdGhpcy50YWcgPT09IHRhZyksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb21wYWN0KCkpO1xuICAgICAgICBnZXRTaWRlYmFyU3RhdGUkXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsgdGFnIH0pID0+ICF0aGlzLnRhZyB8fCB0aGlzLnRhZyA9PT0gdGFnKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgb2JzZXJ2ZXIgfSkgPT4gb2JzZXJ2ZXIubmV4dCh0aGlzLnN0YXRlKSk7XG4gICAgICAgIGdldFNpZGViYXJSZXNwb25zaXZlU3RhdGUkXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsgdGFnIH0pID0+ICF0aGlzLnRhZyB8fCB0aGlzLnRhZyA9PT0gdGFnKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgb2JzZXJ2ZXIgfSkgPT4gb2JzZXJ2ZXIubmV4dCh0aGlzLnJlc3BvbnNpdmVTdGF0ZSkpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvTWVkaWFRdWVyeUNoYW5nZSgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLy8gVE9ETzogdGhpcyBpcyBtb3JlIG9mIGEgd29ya2Fyb3VuZCwgc2hvdWxkIGJlIGEgYmV0dGVyIHdheSB0byBtYWtlIGNvbXBvbmVudHMgY29tbXVuaWNhdGUgdG8gZWFjaCBvdGhlclxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbWVudSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ25iLW1lbnUnKTtcbiAgICAgICAgaWYgKG1lbnUgJiYgbWVudS5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRNZW51TGluayhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGxpbmsgJiYgbGluay5uZXh0RWxlbWVudFNpYmxpbmcgJiYgbGluay5uZXh0RWxlbWVudFNpYmxpbmcuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZW51LWl0ZW1zJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZGViYXJTZXJ2aWNlLmV4cGFuZCh0aGlzLnRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgY29sbGFwc2UoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnY29sbGFwc2VkJztcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgZXhwYW5kKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ2V4cGFuZGVkJztcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYWN0cyB0aGUgc2lkZWJhciAobWluaW1pemVzKVxuICAgICAqL1xuICAgIGNvbXBhY3QoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnY29tcGFjdGVkJztcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHNpZGViYXIgc3RhdGUgKGV4cGFuZGVkfGNvbGxhcHNlZHxjb21wYWN0ZWQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb21wYWN0IElmIHRydWUsIHRoZW4gc2lkZWJhciBzdGF0ZSB3aWxsIGJlIGNoYW5nZWQgYmV0d2VlbiBleHBhbmRlZCAmIGNvbXBhY3RlZCxcbiAgICAgKiBvdGhlcndpc2UgLSBiZXR3ZWVuIGV4cGFuZGVkICYgY29sbGFwc2VkLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogVG9nZ2xlIHNpZGViYXIgc3RhdGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdGhpcy5zaWRlYmFyLnRvZ2dsZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0b2dnbGUoY29tcGFjdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3BvbnNpdmVTdGF0ZSA9PT0gJ21vYmlsZScpIHtcbiAgICAgICAgICAgICAgICBjb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb21wYWN0ZWQnIHx8IHRoaXMuc3RhdGUgPT09ICdjb2xsYXBzZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ2V4cGFuZGVkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjb21wYWN0ID8gJ2NvbXBhY3RlZCcgOiAnY29sbGFwc2VkJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvTWVkaWFRdWVyeUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2Uub25NZWRpYVF1ZXJ5Q2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLnJlc3BvbnNpdmUpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChbcHJldiwgY3VycmVudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gdGhpcy5jb2xsYXBzZWRCcmVha3BvaW50cy5pbmNsdWRlcyhjdXJyZW50Lm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNDb21wYWN0ZWQgPSB0aGlzLmNvbXBhY3RlZEJyZWFrcG9pbnRzLmluY2x1ZGVzKGN1cnJlbnQubmFtZSk7XG4gICAgICAgICAgICBsZXQgbmV3UmVzcG9uc2l2ZVN0YXRlO1xuICAgICAgICAgICAgaWYgKGlzQ29tcGFjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXhlZCA9IHRoaXMuY29udGFpbmVyRml4ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBhY3QoKTtcbiAgICAgICAgICAgICAgICBuZXdSZXNwb25zaXZlU3RhdGUgPSAndGFibGV0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgICAgICBuZXdSZXNwb25zaXZlU3RhdGUgPSAnbW9iaWxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb2xsYXBzZWQgJiYgIWlzQ29tcGFjdGVkICYmIHByZXYud2lkdGggPCBjdXJyZW50LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV3UmVzcG9uc2l2ZVN0YXRlID0gJ3BjJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdSZXNwb25zaXZlU3RhdGUgJiYgbmV3UmVzcG9uc2l2ZVN0YXRlICE9PSB0aGlzLnJlc3BvbnNpdmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2l2ZVN0YXRlID0gbmV3UmVzcG9uc2l2ZVN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2l2ZVN0YXRlQ2hhbmdlLmVtaXQodGhpcy5yZXNwb25zaXZlU3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRNZW51TGluayhlbGVtZW50KSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ25iLW1lbnUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lbnVMaW5rKGVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgcmVzcG9uc2l2ZWAgcHJvcGVydHkgaW5zdGVhZFxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA4LjAuMFxuICAgICAqL1xuICAgIHRvZ2dsZVJlc3BvbnNpdmUoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmUgPSBlbmFibGVkO1xuICAgIH1cbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIE5iU2lkZWJhclN0YXRlIHR5cGUgaW5zdGVhZFxuICogQGJyZWFraW5nLWNoYW5nZSBSZW1vdmUgQDguMC4wXG4gKi9cbk5iU2lkZWJhckNvbXBvbmVudC5TVEFURV9FWFBBTkRFRCA9ICdleHBhbmRlZCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBOYlNpZGViYXJTdGF0ZSB0eXBlIGluc3RlYWRcbiAqIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA4LjAuMFxuICovXG5OYlNpZGViYXJDb21wb25lbnQuU1RBVEVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBOYlNpZGViYXJTdGF0ZSB0eXBlIGluc3RlYWRcbiAqIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA4LjAuMFxuICovXG5OYlNpZGViYXJDb21wb25lbnQuU1RBVEVfQ09NUEFDVEVEID0gJ2NvbXBhY3RlZCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBOYlNpZGViYXJSZXNwb25zaXZlU3RhdGUgdHlwZSBpbnN0ZWFkXG4gKiBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBAOC4wLjBcbiAqL1xuTmJTaWRlYmFyQ29tcG9uZW50LlJFU1BPTlNJVkVfU1RBVEVfTU9CSUxFID0gJ21vYmlsZSc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBOYlNpZGViYXJSZXNwb25zaXZlU3RhdGUgdHlwZSBpbnN0ZWFkXG4gKiBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBAOC4wLjBcbiAqL1xuTmJTaWRlYmFyQ29tcG9uZW50LlJFU1BPTlNJVkVfU1RBVEVfVEFCTEVUID0gJ3RhYmxldCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBOYlNpZGViYXJSZXNwb25zaXZlU3RhdGUgdHlwZSBpbnN0ZWFkXG4gKiBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBAOC4wLjBcbiAqL1xuTmJTaWRlYmFyQ29tcG9uZW50LlJFU1BPTlNJVkVfU1RBVEVfUEMgPSAncGMnO1xuTmJTaWRlYmFyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1zaWRlYmFyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJtYWluLWNvbnRhaW5lclwiXG4gICAgICAgICBbY2xhc3MubWFpbi1jb250YWluZXItZml4ZWRdPVwiY29udGFpbmVyRml4ZWRWYWx1ZVwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItc2lkZWJhci1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8ZGl2IGNsYXNzPVwic2Nyb2xsYWJsZVwiIChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1zaWRlYmFyLWZvb3RlclwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6YXV0bztvcmRlcjowfTpob3N0IC5zY3JvbGxhYmxle292ZXJmbG93LXk6YXV0bztvdmVyZmxvdy14OmhpZGRlbjtmbGV4OjF9Omhvc3QgLm1haW4tY29udGFpbmVye3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAwLCAwKTtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0IC5tYWluLWNvbnRhaW5lci1maXhlZHtwb3NpdGlvbjpmaXhlZH06aG9zdC5yaWdodHttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDphdXRvfVtkaXI9bHRyXSA6aG9zdC5yaWdodHtvcmRlcjo0fVtkaXI9cnRsXSA6aG9zdC5yaWdodHtvcmRlcjowfTpob3N0LmVuZHtvcmRlcjo0fVtkaXI9bHRyXSA6aG9zdC5lbmR7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6YXV0b31bZGlyPXJ0bF0gOmhvc3QuZW5ke21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OmF1dG99Omhvc3QuZml4ZWR7cG9zaXRpb246Zml4ZWQ7aGVpZ2h0OjEwMCU7ei1pbmRleDo5OTk7dG9wOjA7Ym90dG9tOjA7bGVmdDowfTpob3N0LmZpeGVkLnJpZ2h0e3JpZ2h0OjB9W2Rpcj1sdHJdIDpob3N0LmZpeGVkLnN0YXJ0e2xlZnQ6MH1bZGlyPXJ0bF0gOmhvc3QuZml4ZWQuc3RhcnR7cmlnaHQ6MH1bZGlyPWx0cl0gOmhvc3QuZml4ZWQuZW5ke3JpZ2h0OjB9W2Rpcj1ydGxdIDpob3N0LmZpeGVkLmVuZHtsZWZ0OjB9Omhvc3QgOjpuZy1kZWVwIG5iLXNpZGViYXItZm9vdGVye21hcmdpbi10b3A6YXV0bztkaXNwbGF5OmJsb2NrfTpob3N0IDo6bmctZGVlcCBuYi1zaWRlYmFyLWhlYWRlcntkaXNwbGF5OmJsb2NrfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlNpZGViYXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlNpZGViYXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlRoZW1lU2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk5iU2lkZWJhckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmaXhlZFZhbHVlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5maXhlZCcsXSB9XSxcbiAgICByaWdodFZhbHVlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5yaWdodCcsXSB9XSxcbiAgICBsZWZ0VmFsdWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmxlZnQnLF0gfV0sXG4gICAgc3RhcnRWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhcnQnLF0gfV0sXG4gICAgZW5kVmFsdWU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmVuZCcsXSB9XSxcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZXhwYW5kZWQnLF0gfV0sXG4gICAgY29sbGFwc2VkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5jb2xsYXBzZWQnLF0gfV0sXG4gICAgY29tcGFjdGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5jb21wYWN0ZWQnLF0gfV0sXG4gICAgcmlnaHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxlZnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXJ0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBlbmQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZpeGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb250YWluZXJGaXhlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJlc3BvbnNpdmU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29tcGFjdGVkQnJlYWtwb2ludHM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbGxhcHNlZEJyZWFrcG9pbnRzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHJlc3BvbnNpdmVTdGF0ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9TSURFQkFSX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJTaWRlYmFyQ29tcG9uZW50LFxuICAgIE5iU2lkZWJhckZvb3RlckNvbXBvbmVudCxcbiAgICBOYlNpZGViYXJIZWFkZXJDb21wb25lbnQsXG5dO1xuY29uc3QgTkJfU0lERUJBUl9QUk9WSURFUlMgPSBbXG4gICAgTmJTaWRlYmFyU2VydmljZSxcbl07XG5jbGFzcyBOYlNpZGViYXJNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iU2lkZWJhck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIC4uLk5CX1NJREVCQVJfUFJPVklERVJTLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5OYlNpZGViYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfU0lERUJBUl9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9TSURFQkFSX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFNwZWNpZmljIHRhYiBjb250YWluZXIuXG4gKlxuICogYGBgdHNcbiAqIDxuYi10YWIgdGFiVGl0bGU9XCJVc2Vyc1wiXG4gKiAgIGJhZGdlVGV4dD1cIjk5K1wiXG4gKiAgIGJhZGdlU3RhdHVzPVwiZGFuZ2VyXCI+XG4gKiAgIDxwPkxpc3Qgb2YgPHN0cm9uZz51c2Vyczwvc3Ryb25nPi48L3A+XG4gKiA8L25iLXRhYj5cbiBgYGBcbiAqL1xuY2xhc3MgTmJUYWJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFkZ2Ugc3RhdHVzIChhZGRzIHNwZWNpZmljIHN0eWxlcyk6XG4gICAgICAgICAqICdwcmltYXJ5JywgJ2luZm8nLCAnc3VjY2VzcycsICd3YXJuaW5nJywgJ2RhbmdlcidcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYWRnZVN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIHRoaXMuaW5pdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgYmFkZ2UgZG90IG1vZGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYmFkZ2VEb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWRnZURvdDtcbiAgICB9XG4gICAgc2V0IGJhZGdlRG90KHZhbCkge1xuICAgICAgICB0aGlzLl9iYWRnZURvdCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVtIGlzIGRpc2FibGVkIGFuZCBjYW5ub3QgYmUgb3BlbmVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRWYWx1ZTtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBvbmx5IGljb25zIHdoZW4gd2lkdGggaXMgc21hbGxlciB0aGFuIGB0YWJzLWljb24tb25seS1tYXgtd2lkdGhgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHJlc3BvbnNpdmUodmFsKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZVZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIGdldCByZXNwb25zaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zaXZlVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhY3RpdmUgdGFiXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmFsdWU7XG4gICAgfVxuICAgIHNldCBhY3RpdmUodmFsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6eSBsb2FkIGNvbnRlbnQgYmVmb3JlIHRhYiBzZWxlY3Rpb25cbiAgICAgKiBUT0RPOiByZW5hbWUsIGFzIGxhenkgaXMgYnkgZGVmYXVsdCwgYW5kIHRoaXMgaXMgbW9yZSBgaW5zdGFudCBsb2FkYFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGxhenlMb2FkKHZhbCkge1xuICAgICAgICB0aGlzLmluaXQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG59XG5OYlRhYkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItdGFiJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpbml0XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUYWJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGFiVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYklkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZURvdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGFiSWNvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZGlzYWJsZWQnLF0gfV0sXG4gICAgcmVzcG9uc2l2ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm91dGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFjdGl2ZVZhbHVlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5jb250ZW50LWFjdGl2ZScsXSB9XSxcbiAgICBhY3RpdmU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhenlMb2FkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZVRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJhZGdlU3RhdHVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZVBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbi8vIFRPRE86IENvbWJpbmUgdGFic2V0IHdpdGggcm91dGUtdGFic2V0LCBzbyB0aGF0IHdlIGNhbjpcbi8vIC0gaGF2ZSBzaW1pbGFyIGludGVyZmFjZVxuLy8gLSBlYXN5IHRvIG1pZ3JhdGUgZnJvbSBvbmUgdG8gYW5vdGhlclxuLy8gLSBjYW4gbWl4IHRoZW0gYm90aCAocm91dGUvY29udGVudCB0YWIpXG4vKipcbiAqXG4gKiBEeW5hbWljIHRhYnNldCBjb21wb25lbnQuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0YWJzZXQvdGFic2V0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYXNpYyB0YWJzZXQgZXhhbXBsZVxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi10YWJzZXQ+XG4gKiAgPG5iLXRhYiB0YWJUaXRsZT1cIlNpbXBsZSBUYWIgIzFcIj5cbiAqICAgIFRhYiBjb250ZW50IDFcbiAqICA8L25iLXRhYj5cbiAqICA8bmItdGFiIHRhYlRpdGxlPVwiU2ltcGxlIFRhYiAjMlwiPlxuICogICAgVGFiIGNvbnRlbnQgMlxuICogIDwvbmItdGFiPlxuICogPC9uYi10YWJzZXQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRhYnNldE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUYWJzZXRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gc2V0IGEgYmFkZ2UgdG8gYSBwYXJ0aWN1bGFyIHRhYjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVGFiIFdpdGggQmFkZ2UsIHRhYnNldC90YWJzZXQtYmFkZ2UuY29tcG9uZW50KVxuICpcbiAqIGFuZCB3ZSBjYW4gc2V0IGl0IHRvIGZ1bGwgYSB3aWR0aCBvZiBhIHBhcmVudCBjb21wb25lbnRcbiAqIEBzdGFja2VkLWV4YW1wbGUoRnVsbCBXaWR0aCwgdGFic2V0L3RhYnNldC13aWR0aC5jb21wb25lbnQpXG4gKlxuICogYHRhYkljb25gIHNob3VsZCBiZSB1c2VkIHRvIGFkZCBhbiBpY29uIHRvIHRoZSB0YWIuIEljb24gY2FuIGFsc28gYmUgY29tYmluZWQgd2l0aCB0aXRsZS5cbiAqIGByZXNwb25zaXZlYCB0YWIgcHJvcGVydHkgaWYgc2V0IGFsbG93cyB5b3UgdG8gaGlkZSB0aGUgdGl0bGUgb24gc21hbGxlciBzY3JlZW5zXG4gKiAoYHRhYnMtaWNvbi1vbmx5LW1heC13aWR0aGAgcHJvcGVydHkpIGZvciBiZXR0ZXIgcmVzcG9uc2l2ZSBiZWhhdmlvdXIuIFlvdSBjYW4gb3BlbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUgYW5kIG1ha2VcbiAqIHlvdXIgc2NyZWVuIHNtYWxsZXIgLSB0aXRsZXMgd2lsbCBiZSBoaWRkZW4gaW4gdGhlIGxhc3QgdGFic2V0IGluIHRoZSBsaXN0OlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSWNvbiwgdGFic2V0L3RhYnNldC1pY29uLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGRpc2FibGUgYSB0YWIgdXNpbmcgYGRpc2FibGVkYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQgVGFiLCB0YWJzZXQvdGFic2V0LWRpc2FibGVkLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogdGFic2V0LWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtYm9yZGVyLXJhZGl1czpcbiAqIHRhYnNldC1zaGFkb3c6XG4gKiB0YWJzZXQtdGFiLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLXBhZGRpbmc6XG4gKiB0YWJzZXQtdGFiLXRleHQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0YWJzZXQtdGFiLXRleHQtZm9udC1zaXplOlxuICogdGFic2V0LXRhYi10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGFic2V0LXRhYi10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFic2V0LXRhYi10ZXh0LXRyYW5zZm9ybTpcbiAqIHRhYnNldC10YWItdW5kZXJsaW5lLXdpZHRoOlxuICogdGFic2V0LXRhYi11bmRlcmxpbmUtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFic2V0LXRhYi1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC10YWItYWN0aXZlLXVuZGVybGluZS1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtdW5kZXJsaW5lLWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci10ZXh0LWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci11bmRlcmxpbmUtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLXVuZGVybGluZS1jb2xvcjpcbiAqIHRhYnNldC1kaXZpZGVyLWNvbG9yOlxuICogdGFic2V0LWRpdmlkZXItc3R5bGU6XG4gKiB0YWJzZXQtZGl2aWRlci13aWR0aDpcbiAqIHRhYnNldC1jb250ZW50LWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtY29udGVudC1wYWRkaW5nOlxuICogdGFic2V0LWNvbnRlbnQtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC1jb250ZW50LXRleHQtZm9udC1mYW1pbHk6XG4gKiB0YWJzZXQtY29udGVudC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRhYnNldC1jb250ZW50LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0YWJzZXQtY29udGVudC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFic2V0LXNjcm9sbGJhci1jb2xvcjpcbiAqIHRhYnNldC1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhYnNldC1zY3JvbGxiYXItd2lkdGg6XG4gKiB0YWJzZXQtdGFiLXRleHQtaGlkZS1icmVha3BvaW50OlxuICovXG5jbGFzcyBOYlRhYnNldENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iocm91dGUsIGNoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFZhbHVlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIHRhYiBpcyBzZWxlY3RlZFxuICAgICAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8YW55PlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VUYWIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2UgZnVsbCB3aWR0aCBvZiBhIHBhcmVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGZ1bGxXaWR0aCh2YWwpIHtcbiAgICAgICAgdGhpcy5mdWxsV2lkdGhWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZWZhY3RvcmluZyB0aGlzIGNvbXBvbmVudCwgYXZvaWQgY2hhbmdlIGRldGVjdGlvbiBsb29wXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnJvdXRlLnBhcmFtc1xuICAgICAgICAgICAgLnBpcGUobWFwKChwYXJhbXMpID0+IHRoaXMudGFicy5maW5kKCh0YWIpID0+IHRoaXMucm91dGVQYXJhbSA/IHRhYi5yb3V0ZSA9PT0gcGFyYW1zW3RoaXMucm91dGVQYXJhbV0gOiB0YWIuYWN0aXZlKSksIGRlbGF5KDApLCBtYXAoKHRhYikgPT4gdGFiIHx8IHRoaXMudGFicy5maXJzdCksIGZpbHRlcigodGFiKSA9PiAhIXRhYikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh0YWJUb1NlbGVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWIodGFiVG9TZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IG5hdmlnYXRlIHRvIHJvdXRlUGFyYW1cbiAgICBzZWxlY3RUYWIoc2VsZWN0ZWRUYWIpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50YWJzLmZvckVhY2godGFiID0+IHRhYi5hY3RpdmUgPSB0YWIgPT09IHNlbGVjdGVkVGFiKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGFiLmVtaXQoc2VsZWN0ZWRUYWIpO1xuICAgICAgICB9XG4gICAgfVxufVxuTmJUYWJzZXRDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRhYnNldCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8dWwgY2xhc3M9XCJ0YWJzZXRcIj5cbiAgICAgIDxsaSAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNcIlxuICAgICAgICAgIChjbGljayk9XCJzZWxlY3RUYWIodGFiKVwiXG4gICAgICAgICAgKGtleXVwLnNwYWNlKT1cInNlbGVjdFRhYih0YWIpXCJcbiAgICAgICAgICAoa2V5dXAuZW50ZXIpPVwic2VsZWN0VGFiKHRhYilcIlxuICAgICAgICAgIFtjbGFzcy5yZXNwb25zaXZlXT1cInRhYi5yZXNwb25zaXZlXCJcbiAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRhYi5hY3RpdmVcIlxuICAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxuICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cInRhYi5kaXNhYmxlZCA/IC0xIDogMFwiXG4gICAgICAgICAgY2xhc3M9XCJ0YWJcIj5cbiAgICAgICAgPGEgaHJlZiAoY2xpY2spPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIiB0YWJpbmRleD1cIi0xXCIgY2xhc3M9XCJ0YWItbGlua1wiPlxuICAgICAgICAgIDxuYi1pY29uICpuZ0lmPVwidGFiLnRhYkljb25cIiBbY29uZmlnXT1cInRhYi50YWJJY29uXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDxzcGFuICpuZ0lmPVwidGFiLnRhYlRpdGxlXCIgY2xhc3M9XCJ0YWItdGV4dFwiPnt7IHRhYi50YWJUaXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgPC9hPlxuICAgICAgICA8bmItYmFkZ2UgKm5nSWY9XCJ0YWIuYmFkZ2VUZXh0IHx8IHRhYi5iYWRnZURvdFwiXG4gICAgICAgICAgW3RleHRdPVwidGFiLmJhZGdlVGV4dFwiXG4gICAgICAgICAgW2RvdE1vZGVdPVwidGFiLmJhZGdlRG90XCJcbiAgICAgICAgICBbc3RhdHVzXT1cInRhYi5iYWRnZVN0YXR1c1wiXG4gICAgICAgICAgW3Bvc2l0aW9uXT1cInRhYi5iYWRnZVBvc2l0aW9uXCI+XG4gICAgICAgIDwvbmItYmFkZ2U+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItdGFiXCI+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9ja306aG9zdC5mdWxsLXdpZHRoIC50YWJzZXR7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH06aG9zdCA6Om5nLWRlZXAgbmItdGFie2ZsZXg6MTstbXMtZmxleDoxIDEgYXV0bztvdmVyZmxvdzphdXRvO2Rpc3BsYXk6bm9uZX06aG9zdCA6Om5nLWRlZXAgbmItdGFiLmNvbnRlbnQtYWN0aXZle2Rpc3BsYXk6YmxvY2t9Omhvc3QgLnRhYnNldHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O2xpc3Qtc3R5bGUtdHlwZTpub25lO21hcmdpbjowO3BhZGRpbmc6MH06aG9zdCAudGFic2V0IC50YWJ7bWFyZ2luLWJvdHRvbTotMXB4O3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0IC50YWJzZXQgLnRhYi5hY3RpdmUgYTo6YmVmb3Jle2Rpc3BsYXk6YmxvY2t9Omhvc3QgLnRhYnNldCAudGFiIGF7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtZGVjb3JhdGlvbjpub25lfTpob3N0IC50YWJzZXQgLnRhYiBhOjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7Y29udGVudDonJzt3aWR0aDoxMDAlO2JvcmRlci1yYWRpdXM6M3B4O2JvdHRvbTotMnB4O2xlZnQ6MH06aG9zdCAudGFic2V0IC50YWIgYSBuYi1pY29ue3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1bZGlyPWx0cl0gOmhvc3QgLnRhYnNldCAudGFiIGEgbmItaWNvbitzcGFue21hcmdpbi1sZWZ0Oi41cmVtfVtkaXI9cnRsXSA6aG9zdCAudGFic2V0IC50YWIgYSBuYi1pY29uK3NwYW57bWFyZ2luLXJpZ2h0Oi41cmVtfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRhYnNldENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEFjdGl2YXRlZFJvdXRlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuTmJUYWJzZXRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGFiczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmJUYWJDb21wb25lbnQsXSB9XSxcbiAgICBmdWxsV2lkdGhWYWx1ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZnVsbC13aWR0aCcsXSB9XSxcbiAgICBmdWxsV2lkdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJvdXRlUGFyYW06IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoYW5nZVRhYjogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9UQUJTRVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYlRhYnNldENvbXBvbmVudCxcbiAgICBOYlRhYkNvbXBvbmVudCxcbl07XG5jbGFzcyBOYlRhYnNldE1vZHVsZSB7XG59XG5OYlRhYnNldE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJCYWRnZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX1RBQlNFVF9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9UQUJTRVRfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbXBvbmVudCBzaG93aW5nIGEgdXNlciBhdmF0YXIgKHBpY3R1cmUpIHdpdGggYSB1c2VyIG5hbWUgb24gdGhlIHJpZ2h0LlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdXNlci91c2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgYGB0c1xuICogICA8bmItdXNlciBuYW1lPVwiSm9obiBEb2VcIiB0aXRsZT1cIkVuZ2luZWVyXCI+PC9uYi11c2VyPlxuICogYGBgXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJVc2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlVzZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEF2YWlsYWJsZSBpbiBtdWx0aXBsZSBzaXplczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIHVzZXIvdXNlci1zaXplcy5jb21wb25lbnQpXG4gKlxuICpcbiAqIFlvdSBjYW4gaGlkZSB1bm5lY2Vzc2FyeSBjYXB0aW9ucyAobmFtZSwgdGl0bGUgb3IgYm90aCk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEhpZGUgY2FwdGlvbnMgaW4gdXNlciBjb21wb25lbnQsIHVzZXIvdXNlci1oaWRlLWNhcHRpb25zLmNvbXBvbmVudClcbiAqXG4gKlxuICogWW91IGNhbiBzZXQgY3VzdG9tIGF2YXRhciBiYWNrZ3JvdW5kLWNvbG9yLCB1c2VyIGltYWdlIChhcyBsaW5rIG9yIEJBU0U2NCBzdHJpbmcpIGFuZCBkaXNhYmxlIHVzZXIgaW5pdGlhbHM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YXRhciBpbWFnZSBzZXR0aW5ncywgdXNlci91c2VyLWF2YXRhci1zZXR0aW5ncy5jb21wb25lbnQpXG4gKlxuICogQ29tcG9uZW50IHNoYXBlIGNvdWxkIGJlIGNvbnRyb2xsZWQgd2l0aCBgc2hhcGVgIGlucHV0LlxuICogQHN0YWNrZWQtZXhhbXBsZShTaGFwZXMsIHVzZXIvdXNlci1zaGFwZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHVzZXItcGljdHVyZS1ib3gtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHVzZXItcGljdHVyZS1ib3gtYm9yZGVyLWNvbG9yOlxuICogdXNlci1waWN0dXJlLWJveC1ib3JkZXItd2lkdGg6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtY29sb3I6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtZm9udC1mYW1pbHk6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLW5hbWUtdGV4dC1jb2xvcjpcbiAqIHVzZXItbmFtZS10ZXh0LWZvbnQtZmFtaWx5OlxuICogdXNlci1uYW1lLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLXRpdGxlLXRleHQtY29sb3I6XG4gKiB1c2VyLXRpdGxlLXRleHQtZm9udC1mYW1pbHk6XG4gKiB1c2VyLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogdXNlci1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiB1c2VyLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiB1c2VyLXRpbnktaGVpZ2h0OlxuICogdXNlci10aW55LXdpZHRoOlxuICogdXNlci10aW55LWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci10aW55LWluaXRpYWxzLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXRpbnktbmFtZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItdGlueS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXRpbnktdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXRpbnktdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItc21hbGwtaGVpZ2h0OlxuICogdXNlci1zbWFsbC13aWR0aDpcbiAqIHVzZXItc21hbGwtaW5pdGlhbHMtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLWluaXRpYWxzLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXNtYWxsLW5hbWUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLW5hbWUtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItc21hbGwtdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS13aWR0aDpcbiAqIHVzZXItbWVkaXVtLWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci1tZWRpdW0taW5pdGlhbHMtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItbWVkaXVtLW5hbWUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLW1lZGl1bS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItbWVkaXVtLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLWxhcmdlLWhlaWdodDpcbiAqIHVzZXItbGFyZ2Utd2lkdGg6XG4gKiB1c2VyLWxhcmdlLWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS1pbml0aWFscy10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1sYXJnZS1uYW1lLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLWxhcmdlLXRpdGxlLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS10aXRsZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1naWFudC1oZWlnaHQ6XG4gKiB1c2VyLWdpYW50LXdpZHRoOlxuICogdXNlci1naWFudC1pbml0aWFscy10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtaW5pdGlhbHMtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItZ2lhbnQtbmFtZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtbmFtZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1naWFudC10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqL1xuY2xhc3MgTmJVc2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihkb21TYW5pdGl6ZXIpIHtcbiAgICAgICAgdGhpcy5kb21TYW5pdGl6ZXIgPSBkb21TYW5pdGl6ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgYSBuYW1lIHRvIGJlIHNob3duIG9uIHRoZSByaWdodCBvZiBhIHVzZXIgcGljdHVyZVxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBbm9ueW1vdXMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2l6ZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBQb3NzaWJsZSB2YWx1ZXM6IGB0aW55YCwgYHNtYWxsYCwgYG1lZGl1bWAgKGRlZmF1bHQpLCBgbGFyZ2VgLCAnZ2lhbnQnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaGFwZSBvZiB0aGUgcGljdHVyZSBib3guXG4gICAgICAgICAqIFBvc3NpYmxlIHZhbHVlczogYHJlY3RhbmdsZWAsIGBzZW1pLXJvdW5kYCwgYHJvdW5kYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hhcGUgPSAncm91bmQnO1xuICAgICAgICB0aGlzLl9zaG93TmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dUaXRsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dJbml0aWFscyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWRnZSBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhZGdlU3RhdHVzID0gJ2Jhc2ljJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgcGF0aCB0byBhIHVzZXIgcGljdHVyZSBvciBiYXNlNjQgaW1hZ2UuXG4gICAgICogVXNlciBuYW1lIGluaXRpYWxzIHdpbGwgYmUgc2hvd24gaWYgbm8gcGljdHVyZSBzcGVjaWZpZWQgKEpEIGZvciBKb2huIERvZSkuXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgc2V0IHBpY3R1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJhY2tncm91bmRTdHlsZSA9IHZhbHVlID8gdGhpcy5kb21TYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdFN0eWxlKGB1cmwoJHt2YWx1ZX0pYCkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgYSB1c2VyIG5hbWUgb3Igbm90XG4gICAgICovXG4gICAgZ2V0IHNob3dOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd05hbWU7XG4gICAgfVxuICAgIHNldCBzaG93TmFtZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fc2hvd05hbWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IGEgdXNlciB0aXRsZSBvciBub3RcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgZ2V0IHNob3dUaXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dUaXRsZTtcbiAgICB9XG4gICAgc2V0IHNob3dUaXRsZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fc2hvd1RpdGxlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBhIHVzZXIgaW5pdGlhbHMgKGlmIG5vIHBpY3R1cmUgc3BlY2lmaWVkKSBvciBub3RcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgZ2V0IHNob3dJbml0aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dJbml0aWFscztcbiAgICB9XG4gICAgc2V0IHNob3dJbml0aWFscyh2YWwpIHtcbiAgICAgICAgdGhpcy5fc2hvd0luaXRpYWxzID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBvbmx5IGEgcGljdHVyZSBvciBhbHNvIHNob3cgdGhlIG5hbWUgYW5kIHRpdGxlXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIGdldCBvbmx5UGljdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNob3dOYW1lICYmICF0aGlzLnNob3dUaXRsZTtcbiAgICB9XG4gICAgc2V0IG9ubHlQaWN0dXJlKHZhbCkge1xuICAgICAgICB0aGlzLnNob3dOYW1lID0gdGhpcy5zaG93VGl0bGUgPSAhY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJztcbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnZ2lhbnQnO1xuICAgIH1cbiAgICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICAgIGdldCBzZW1pUm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAnc2VtaS1yb3VuZCc7XG4gICAgfVxuICAgIGdldCByb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyb3VuZCc7XG4gICAgfVxuICAgIGdldEluaXRpYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IHRoaXMubmFtZS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLm1hcChuID0+IG4uY2hhckF0KDApKS5zcGxpY2UoMCwgMikuam9pbignJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuTmJVc2VyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi11c2VyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJ1c2VyLWNvbnRhaW5lclxcXCI+XFxuICA8ZGl2ICpuZ0lmPVxcXCJpbWFnZUJhY2tncm91bmRTdHlsZVxcXCIgY2xhc3M9XFxcInVzZXItcGljdHVyZSBpbWFnZVxcXCIgW3N0eWxlLmJhY2tncm91bmQtaW1hZ2VdPVxcXCJpbWFnZUJhY2tncm91bmRTdHlsZVxcXCI+XFxuICAgIDxuYi1iYWRnZSAqbmdJZj1cXFwiYmFkZ2VUZXh0XFxcIiBbdGV4dF09XFxcImJhZGdlVGV4dFxcXCIgW3N0YXR1c109XFxcImJhZGdlU3RhdHVzXFxcIiBbcG9zaXRpb25dPVxcXCJiYWRnZVBvc2l0aW9uXFxcIj48L25iLWJhZGdlPlxcbiAgPC9kaXY+XFxuICA8ZGl2ICpuZ0lmPVxcXCIhaW1hZ2VCYWNrZ3JvdW5kU3R5bGVcXFwiIGNsYXNzPVxcXCJ1c2VyLXBpY3R1cmUgaW5pdGlhbHNcXFwiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cXFwiY29sb3JcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJzaG93SW5pdGlhbHNcXFwiPlxcbiAgICAgIHt7IGdldEluaXRpYWxzKCkgfX1cXG4gICAgPC9uZy1jb250YWluZXI+XFxuICAgIDxuYi1iYWRnZSAqbmdJZj1cXFwiYmFkZ2VUZXh0XFxcIiBbdGV4dF09XFxcImJhZGdlVGV4dFxcXCIgW3N0YXR1c109XFxcImJhZGdlU3RhdHVzXFxcIiBbcG9zaXRpb25dPVxcXCJiYWRnZVBvc2l0aW9uXFxcIj48L25iLWJhZGdlPlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJpbmZvLWNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgKm5nSWY9XFxcInNob3dOYW1lICYmIG5hbWVcXFwiIGNsYXNzPVxcXCJ1c2VyLW5hbWVcXFwiPnt7IG5hbWUgfX08L2Rpdj5cXG4gICAgPGRpdiAqbmdJZj1cXFwic2hvd1RpdGxlICYmIHRpdGxlXFxcIiBjbGFzcz1cXFwidXNlci10aXRsZVxcXCI+e3sgdGl0bGUgfX08L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4fTpob3N0IC51c2VyLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfTpob3N0IC51c2VyLXBpY3R1cmV7cG9zaXRpb246cmVsYXRpdmU7ZmxleC1zaHJpbms6MH06aG9zdCAudXNlci1waWN0dXJlLmltYWdle2JhY2tncm91bmQtc2l6ZTpjb3ZlcjtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXR9Omhvc3QgLnVzZXItcGljdHVyZS5pbml0aWFsc3tkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9W2Rpcj1ydGxdIDpob3N0IC51c2VyLW5hbWUsW2Rpcj1ydGxdIDpob3N0IC51c2VyLXRpdGxle3RleHQtYWxpZ246cmlnaHR9W2Rpcj1sdHJdIDpob3N0IC5pbmZvLWNvbnRhaW5lcnttYXJnaW4tbGVmdDouNXJlbX1bZGlyPXJ0bF0gOmhvc3QgLmluZm8tY29udGFpbmVye21hcmdpbi1yaWdodDouNXJlbX1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJVc2VyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH1cbl07XG5OYlVzZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbmFtZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBpY3R1cmU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbG9yOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaGFwZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd05hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dUaXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hvd0luaXRpYWxzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvbmx5UGljdHVyZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYmFkZ2VUZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZVN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYmFkZ2VQb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcmVjdGFuZ2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yZWN0YW5nbGUnLF0gfV0sXG4gICAgc2VtaVJvdW5kOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1zZW1pLXJvdW5kJyxdIH1dLFxuICAgIHJvdW5kOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yb3VuZCcsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfVVNFUl9DT01QT05FTlRTID0gW1xuICAgIE5iVXNlckNvbXBvbmVudCxcbl07XG5jbGFzcyBOYlVzZXJNb2R1bGUge1xufVxuTmJVc2VyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkJhZGdlTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX1VTRVJfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfVVNFUl9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBBY3Rpb24gaXRlbSwgZGlzcGxheSBhIGxpbmsgd2l0aCBhbiBpY29uLCBvciBhbnkgb3RoZXIgY29udGVudCBwcm92aWRlZCBpbnN0ZWFkLlxuICovXG5jbGFzcyBOYkFjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCB0aXRsZSBmb3IgbW91c2VvdmVyXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICcnO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFkZ2Ugc3RhdHVzIChhZGRzIHNwZWNpZmljIHN0eWxlcyk6XG4gICAgICAgICAqICdiYXNpYycsICdwcmltYXJ5JywgJ2luZm8nLCAnc3VjY2VzcycsICd3YXJuaW5nJywgJ2RhbmdlcicsICdjb250cm9sJ1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhZGdlU3RhdHVzID0gJ2Jhc2ljJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmlzdWFsbHkgZGlzYWJsZXMgdGhlIGl0ZW1cbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBiYWRnZSBkb3QgbW9kZVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBnZXQgYmFkZ2VEb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWRnZURvdDtcbiAgICB9XG4gICAgc2V0IGJhZGdlRG90KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2JhZGdlRG90ID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG59XG5OYkFjdGlvbkNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYWN0aW9uJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpY29uOyBlbHNlIHByb2plY3RlZENvbnRlbnRcIj5cbiAgICAgIDxhIGNsYXNzPVwiaWNvbi1jb250YWluZXJcIlxuICAgICAgICAgW3JvdXRlckxpbmtdPVwibGlua1wiXG4gICAgICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgKm5nSWY9XCJsaW5rXCI+XG4gICAgICAgIDxuYi1pY29uIFtjb25maWddPVwiaWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJiYWRnZVRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L2E+XG4gICAgICA8YSBjbGFzcz1cImljb24tY29udGFpbmVyXCJcbiAgICAgICAgIFtocmVmXT1cImhyZWZcIlxuICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAgICAgICAgICpuZ0lmPVwiaHJlZiAmJiAhbGlua1wiPlxuICAgICAgICA8bmItaWNvbiBbY29uZmlnXT1cImljb25cIj48L25iLWljb24+XG4gICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiYmFkZ2VUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgPC9hPlxuICAgICAgPGEgY2xhc3M9XCJpY29uLWNvbnRhaW5lclwiXG4gICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgKm5nSWY9XCIhaHJlZiAmJiAhbGlua1wiXG4gICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgPG5iLWljb24gW2NvbmZpZ109XCJpY29uXCI+PC9uYi1pY29uPlxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImJhZGdlVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvYT5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDxuZy10ZW1wbGF0ZSAjcHJvamVjdGVkQ29udGVudD5cbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiYmFkZ2VUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLXRlbXBsYXRlICNiYWRnZVRlbXBsYXRlPlxuICAgICAgPG5iLWJhZGdlICpuZ0lmPVwiYmFkZ2VUZXh0IHx8IGJhZGdlRG90XCJcbiAgICAgICAgICAgICAgICBbdGV4dF09XCJiYWRnZVRleHRcIlxuICAgICAgICAgICAgICAgIFtkb3RNb2RlXT1cImJhZGdlRG90XCJcbiAgICAgICAgICAgICAgICBbc3RhdHVzXT1cImJhZGdlU3RhdHVzXCJcbiAgICAgICAgICAgICAgICBbcG9zaXRpb25dPVwiYmFkZ2VQb3NpdGlvblwiPlxuICAgICAgPC9uYi1iYWRnZT5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0KC5kaXNhYmxlZCl7Y3Vyc29yOm5vdC1hbGxvd2VkfTpob3N0KC5kaXNhYmxlZCkgYSw6aG9zdCguZGlzYWJsZWQpIG5iLWljb257Y3Vyc29yOm5vdC1hbGxvd2VkfTpob3N0LWNvbnRleHQobmItYWN0aW9ucy5mdWxsLXdpZHRoKXtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjEwMCV9YS5pY29uLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX1hLmljb24tY29udGFpbmVyOmhvdmVyLGEuaWNvbi1jb250YWluZXI6Zm9jdXN7dGV4dC1kZWNvcmF0aW9uOm5vbmV9bmItaWNvbjpob3ZlcntjdXJzb3I6cG9pbnRlcn1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJBY3Rpb25Db21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbGluazogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaHJlZjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRpc2FibGVkJyxdIH1dLFxuICAgIGJhZGdlRG90OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZVRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJhZGdlU3RhdHVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBiYWRnZVBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbi8qKlxuICogU2hvd3MgYSBob3Jpem9udGFsIGxpc3Qgb2YgYWN0aW9ucywgYXZhaWxhYmxlIGluIG11bHRpcGxlIHNpemVzLlxuICogQWxpZ25zIGl0ZW1zIHZlcnRpY2FsbHkuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgYWN0aW9uL2FjdGlvbi1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQmFzaWMgYWN0aW9ucyBzZXR1cDpcbiAqIGBgYGh0bWxcbiAqIDxuYi1hY3Rpb25zIHNpemU9XCJzbWFsbFwiPlxuICogICA8bmItYWN0aW9uIGljb249XCJuYi1zZWFyY2hcIj48L25iLWFjdGlvbj5cbiAqICAgPG5iLWFjdGlvbiBpY29uPVwibmItcG93ZXItY2lyY2xlZFwiPjwvbmItYWN0aW9uPlxuICogICA8bmItYWN0aW9uIGljb249XCJuYi1wZXJzb25cIj48L25iLWFjdGlvbj5cbiAqIDwvbmItYWN0aW9ucz5cbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJBY3Rpb25zTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkFjdGlvbnNNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIE11bHRpcGxlIHNpemVzIGV4YW1wbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCBhY3Rpb24vYWN0aW9uLXNpemVzLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBgYmFkZ2VgIHZhbHVlOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWN0aW9uIEJhZGdlLCBhY3Rpb24vYWN0aW9uLWJhZGdlLmNvbXBvbmVudClcbiAqXG4gKiBhbmQgd2UgY2FuIHNldCBpdCB0byBmdWxsIGEgd2lkdGggb2YgYSBwYXJlbnQgY29tcG9uZW50XG4gKiBAc3RhY2tlZC1leGFtcGxlKEZ1bGwgV2lkdGgsIGFjdGlvbi9hY3Rpb24td2lkdGguY29tcG9uZW50KVxuICpcbiAqIEFjdGlvbiBkb3QgbW9kZVxuICogQHN0YWNrZWQtZXhhbXBsZShBY3Rpb24gYmFkZ2UgaW4gZG90IG1vZGUsIGFjdGlvbi9hY3Rpb24tZG90LW1vZGUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBhY3Rpb25zLWJhY2tncm91bmQtY29sb3I6XG4gKiBhY3Rpb25zLWRpdmlkZXItY29sb3I6XG4gKiBhY3Rpb25zLWRpdmlkZXItc3R5bGU6XG4gKiBhY3Rpb25zLWRpdmlkZXItd2lkdGg6XG4gKiBhY3Rpb25zLWljb24tY29sb3I6XG4gKiBhY3Rpb25zLXRleHQtY29sb3I6XG4gKiBhY3Rpb25zLXRleHQtZm9udC1mYW1pbHk6XG4gKiBhY3Rpb25zLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBhY3Rpb25zLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBhY3Rpb25zLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBhY3Rpb25zLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBhY3Rpb25zLXRpbnktaGVpZ2h0OlxuICogYWN0aW9ucy10aW55LWljb24taGVpZ2h0OlxuICogYWN0aW9ucy10aW55LXBhZGRpbmc6XG4gKiBhY3Rpb25zLXRpbnktdGV4dC1mb250LXNpemU6XG4gKiBhY3Rpb25zLXNtYWxsLWhlaWdodDpcbiAqIGFjdGlvbnMtc21hbGwtaWNvbi1oZWlnaHQ6XG4gKiBhY3Rpb25zLXNtYWxsLXBhZGRpbmc6XG4gKiBhY3Rpb25zLXNtYWxsLXRleHQtZm9udC1zaXplOlxuICogYWN0aW9ucy1tZWRpdW0taGVpZ2h0OlxuICogYWN0aW9ucy1tZWRpdW0taWNvbi1oZWlnaHQ6XG4gKiBhY3Rpb25zLW1lZGl1bS1wYWRkaW5nOlxuICogYWN0aW9ucy1tZWRpdW0tdGV4dC1mb250LXNpemU6XG4gKiBhY3Rpb25zLWxhcmdlLWhlaWdodDpcbiAqIGFjdGlvbnMtbGFyZ2UtaWNvbi1oZWlnaHQ6XG4gKiBhY3Rpb25zLWxhcmdlLXBhZGRpbmc6XG4gKiBhY3Rpb25zLWxhcmdlLXRleHQtZm9udC1zaXplOlxuICogYWN0aW9ucy1naWFudC1oZWlnaHQ6XG4gKiBhY3Rpb25zLWdpYW50LWljb24taGVpZ2h0OlxuICogYWN0aW9ucy1naWFudC1wYWRkaW5nOlxuICogYWN0aW9ucy1naWFudC10ZXh0LWZvbnQtc2l6ZTpcbiAqL1xuY2xhc3MgTmJBY3Rpb25zQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICdzbWFsbCc7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBjb21wb25lbnQ6ICd0aW55JywgJ3NtYWxsJyAoZGVmYXVsdCksICdtZWRpdW0nLCAnbGFyZ2UnLCAnZ2lhbnQnXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBzZXQgc2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaXplID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCB3aWxsIGZpbGwgZnVsbCB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG4gICAgICovXG4gICAgZ2V0IGZ1bGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGxXaWR0aDtcbiAgICB9XG4gICAgc2V0IGZ1bGxXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mdWxsV2lkdGggPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG59XG5OYkFjdGlvbnNDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWFjdGlvbnMnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItYWN0aW9uXCI+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJBY3Rpb25zQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGZ1bGxXaWR0aDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5mdWxsLXdpZHRoJyxdIH1dLFxuICAgIHRpbnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtdGlueScsXSB9XSxcbiAgICBzbWFsbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1zbWFsbCcsXSB9XSxcbiAgICBtZWRpdW06IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbWVkaXVtJyxdIH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dLFxuICAgIGdpYW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWdpYW50JyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9BQ1RJT05TX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJBY3Rpb25Db21wb25lbnQsXG4gICAgTmJBY3Rpb25zQ29tcG9uZW50LFxuXTtcbmNsYXNzIE5iQWN0aW9uc01vZHVsZSB7XG59XG5OYkFjdGlvbnNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQmFkZ2VNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAuLi5OQl9BQ1RJT05TX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX0FDVElPTlNfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogU2VhcmNoIGNvbXBvbmVudCBzZXJ2aWNlLCBjb25uZWN0cyB5b3VyIGNvZGUgdG8gYSBwYWdlLWxldmVsIHNlYXJjaCBjb21wb25lbnQuXG4gKi9cbmNsYXNzIE5iU2VhcmNoU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoU3VibWl0dGluZ3MkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hBY3RpdmF0aW9ucyQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnNlYXJjaERlYWN0aXZhdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dCQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKioqXG4gICAgICogQWN0aXZhdGUgKG9wZW4pIHNlYXJjaCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKi9cbiAgICBhY3RpdmF0ZVNlYXJjaChzZWFyY2hUeXBlLCB0YWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hBY3RpdmF0aW9ucyQubmV4dCh7IHNlYXJjaFR5cGUsIHRhZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpYmF0ZSAoY2xvc2UpIHNlYXJjaCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoVHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlU2VhcmNoKHNlYXJjaFR5cGUsIHRhZykge1xuICAgICAgICB0aGlzLnNlYXJjaERlYWN0aXZhdGlvbnMkLm5leHQoeyBzZWFyY2hUeXBlLCB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgc2VhcmNoIHN1Ym1pdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqL1xuICAgIHN1Ym1pdFNlYXJjaCh0ZXJtLCB0YWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTdWJtaXR0aW5ncyQubmV4dCh7IHRlcm0sIHRhZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBzZWFyY2ggc3VibWl0IGJ5IGlucHV0IGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICovXG4gICAgc2VhcmNoSW5wdXQodGVybSwgdGFnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQkLm5leHQoeyB0ZXJtLCB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byAnYWN0aXZhdGUnIGV2ZW50XG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7c2VhcmNoVHlwZTogc3RyaW5nOyB0YWc/OiBzdHJpbmd9PlxuICAgICAqL1xuICAgIG9uU2VhcmNoQWN0aXZhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEFjdGl2YXRpb25zJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gJ2RlYWN0aXZhdGUnIGV2ZW50XG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7c2VhcmNoVHlwZTogc3RyaW5nOyB0YWc/OiBzdHJpbmd9PlxuICAgICAqL1xuICAgIG9uU2VhcmNoRGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoRGVhY3RpdmF0aW9ucyQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvICdzdWJtaXQnIGV2ZW50ICh3aGVuIHN1Ym1pdCBidXR0b24gY2xpY2tlZClcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPHt0ZXJtOiBzdHJpbmc7IHRhZz86IHN0cmluZ30+XG4gICAgICovXG4gICAgb25TZWFyY2hTdWJtaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFN1Ym1pdHRpbmdzJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gaW5wdXQgZXZlbnRcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPHt0ZXJtOiBzdHJpbmc7IHRhZz86IHN0cmluZ30+XG4gICAgICovXG4gICAgb25TZWFyY2hJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoSW5wdXQkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxufVxuTmJTZWFyY2hTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogc2VhcmNoLWZpZWxkLWNvbXBvbmVudCBpcyB1c2VkIHVuZGVyIHRoZSBob29kIGJ5IG5iLXNlYXJjaCBjb21wb25lbnRcbiAqIGNhbid0IGJlIHVzZWQgaXRzZWxmXG4gKi9cbmNsYXNzIE5iU2VhcmNoRmllbGRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBzaG93Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3c7XG4gICAgfVxuICAgIGdldCBtb2RhbFpvb21pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX01PREFMX1pPT01JTjtcbiAgICB9XG4gICAgZ2V0IHJvdGF0ZUxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX1JPVEFURV9MQVlPVVQ7XG4gICAgfVxuICAgIGdldCBtb2RhbE1vdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9NT0RBTF9NT1ZFO1xuICAgIH1cbiAgICBnZXQgY3VydGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX0NVUlRBSU47XG4gICAgfVxuICAgIGdldCBjb2x1bW5DdXJ0YWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LlRZUEVfQ09MVU1OX0NVUlRBSU47XG4gICAgfVxuICAgIGdldCBtb2RhbERyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9NT0RBTF9EUk9QO1xuICAgIH1cbiAgICBnZXQgbW9kYWxIYWxmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LlRZUEVfTU9EQUxfSEFMRjtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoeyBzaG93IH0pIHtcbiAgICAgICAgY29uc3QgYmVjYW1lSGlkZGVuID0gIXNob3cuaXNGaXJzdENoYW5nZSgpICYmIHNob3cuY3VycmVudFZhbHVlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKGJlY2FtZUhpZGRlbiAmJiB0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnQubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgIH1cbiAgICBlbWl0Q2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgIH1cbiAgICBzdWJtaXRTZWFyY2godGVybSkge1xuICAgICAgICBpZiAodGVybSkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2guZW1pdCh0ZXJtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0U2VhcmNoSW5wdXQodGVybSkge1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmVtaXQodGVybSk7XG4gICAgfVxuICAgIGZvY3VzSW5wdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3cgJiYgdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9NT0RBTF9aT09NSU4gPSAnbW9kYWwtem9vbWluJztcbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9ST1RBVEVfTEFZT1VUID0gJ3JvdGF0ZS1sYXlvdXQnO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX01PREFMX01PVkUgPSAnbW9kYWwtbW92ZSc7XG5OYlNlYXJjaEZpZWxkQ29tcG9uZW50LlRZUEVfQ1VSVEFJTiA9ICdjdXJ0YWluJztcbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9DT0xVTU5fQ1VSVEFJTiA9ICdjb2x1bW4tY3VydGFpbic7XG5OYlNlYXJjaEZpZWxkQ29tcG9uZW50LlRZUEVfTU9EQUxfRFJPUCA9ICdtb2RhbC1kcm9wJztcbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9NT0RBTF9IQUxGID0gJ21vZGFsLWhhbGYnO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItc2VhcmNoLWZpZWxkJyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJzZWFyY2hcIiAoa2V5dXAuZXNjKT1cImVtaXRDbG9zZSgpXCI+XG4gICAgICA8YnV0dG9uIChjbGljayk9XCJlbWl0Q2xvc2UoKVwiIG5iQnV0dG9uIGdob3N0IGNsYXNzPVwiY2xvc2UtYnV0dG9uXCI+XG4gICAgICAgIDxuYi1pY29uIGljb249XCJjbG9zZS1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGRpdiBjbGFzcz1cImZvcm0td3JhcHBlclwiPlxuICAgICAgICA8Zm9ybSBjbGFzcz1cImZvcm1cIiAoa2V5dXAuZW50ZXIpPVwic3VibWl0U2VhcmNoKHNlYXJjaElucHV0LnZhbHVlKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cInNlYXJjaC1pbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgI3NlYXJjaElucHV0XG4gICAgICAgICAgICAgICAgICAgKGlucHV0KT1cImVtaXRTZWFyY2hJbnB1dChzZWFyY2hJbnB1dC52YWx1ZSlcIlxuICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICAgICAgICAgICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgICAgIChibHVyKT1cImZvY3VzSW5wdXQoKVwiLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImluZm9cIj57eyBoaW50IH19PC9zcGFuPlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IGJ1dHRvbnttYXJnaW46MDtwYWRkaW5nOjA7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDpub25lfTpob3N0IGJ1dHRvbjpmb2N1c3tib3gtc2hhZG93Om5vbmU7b3V0bGluZTpub25lfTpob3N0IGlucHV0e2JvcmRlci10b3A6MDtib3JkZXItcmlnaHQ6MDtib3JkZXItbGVmdDowO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0OjE7ZGlzcGxheTppbmxpbmUtYmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MC4wNXJlbSAwOy13ZWJraXQtYXBwZWFyYW5jZTpub25lfTpob3N0IGlucHV0OmZvY3Vze291dGxpbmU6bm9uZX06aG9zdCBpbnB1dDo6cGxhY2Vob2xkZXJ7b3BhY2l0eTowLjN9Omhvc3Qgc3Bhbntmb250LXNpemU6OTAlO2ZvbnQtd2VpZ2h0OmJvbGQ7ZGlzcGxheTpibG9jazt3aWR0aDo3NSU7bWFyZ2luOjAgYXV0bztwYWRkaW5nOjAuODVyZW0gMDt0ZXh0LWFsaWduOnJpZ2h0fTpob3N0Lm1vZGFsLXpvb21pbntkaXNwbGF5OmJsb2NrfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDUwO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC41c306aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaDo6YmVmb3JlLDpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoOjphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOmNhbGMoMTAwJSArIDE1cHgpO2hlaWdodDpjYWxjKDEwMCUgKyAxNXB4KTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoOjpiZWZvcmV7dG9wOjA7bGVmdDowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci1ib3R0b20td2lkdGg6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTE1cHgsIC0xNXB4LCAwKX06aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaDo6YWZ0ZXJ7cmlnaHQ6MDtib3R0b206MDtib3JkZXItdG9wLXdpZHRoOjA7Ym9yZGVyLWxlZnQtd2lkdGg6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTVweCwgMTVweCwgMCl9Omhvc3QubW9kYWwtem9vbWluIC5zZWFyY2ggYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2ZvbnQtc2l6ZToyLjVyZW19W2Rpcj1sdHJdIDpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoIGJ1dHRvbntyaWdodDozcmVtfVtkaXI9cnRsXSA6aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoIGlucHV0e2ZvbnQtc2l6ZToxMHZ3O3dpZHRoOjc1JX06aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaCBidXR0b257b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC41cywgdHJhbnNmb3JtIDAuNXN9Omhvc3QubW9kYWwtem9vbWluIC5zZWFyY2ggZm9ybXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoe3BvaW50ZXItZXZlbnRzOmF1dG87b3BhY2l0eToxfTpob3N0Lm1vZGFsLXpvb21pbi5zaG93IC5zZWFyY2g6OmJlZm9yZSw6aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoOjphZnRlcnt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoIGJ1dHRvbntvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9Omhvc3QubW9kYWwtem9vbWluLnNob3cgLnNlYXJjaCBmb3Jte29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUzZCgxLCAxLCAxKX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QubW9kYWwtem9vbWluIGZvcm17bWFyZ2luOjVyZW0gMCAxcmVtfTpob3N0Lm1vZGFsLXpvb21pbiBzcGFue3RleHQtYWxpZ246bGVmdH19XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5yb3RhdGUtbGF5b3V0e3Bvc2l0aW9uOmZpeGVkO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlfTo6bmctZGVlcCBuYi1sYXlvdXQucm90YXRlLWxheW91dCAuc2Nyb2xsYWJsZS1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxMDAwMTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSl9OjpuZy1kZWVwIG5iLWxheW91dC5yb3RhdGUtbGF5b3V0LndpdGgtc2VhcmNoIC5zY3JvbGxhYmxlLWNvbnRhaW5lcnt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSk7dHJhbnNmb3JtLW9yaWdpbjo1MHZ3IDUwdmg7dHJhbnNmb3JtOnBlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoMCwgNTB2aCwgMCkgcm90YXRlM2QoMSwgMCwgMCwgMzBkZWcpO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3Qucm90YXRlLWxheW91dHtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uLXByb3BlcnR5Om9wYWNpdHk7dHJhbnNpdGlvbi1kZWxheTowLjRzfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3RleHQtYWxpZ246Y2VudGVyO3otaW5kZXg6MTA1MDtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6NTB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC41czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfVtkaXI9bHRyXSA6aG9zdC5yb3RhdGUtbGF5b3V0IC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjNyZW19W2Rpcj1ydGxdIDpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBmb3Jte21hcmdpbjo1cmVtIDA7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuNywgMC43LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC41cywgdHJhbnNmb3JtIDAuNXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKX06aG9zdC5yb3RhdGUtbGF5b3V0IC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjd2dzt3aWR0aDo3NSV9Omhvc3Qucm90YXRlLWxheW91dC5zaG93e29wYWNpdHk6MTt0cmFuc2l0aW9uLWRlbGF5OjBzfTpob3N0LnJvdGF0ZS1sYXlvdXQuc2hvdyAuc2VhcmNoe3BvaW50ZXItZXZlbnRzOmF1dG87b3BhY2l0eToxfTpob3N0LnJvdGF0ZS1sYXlvdXQuc2hvdyAuc2VhcmNoIGJ1dHRvbntvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9Omhvc3Qucm90YXRlLWxheW91dC5zaG93IC5zZWFyY2ggZm9ybXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5tb2RhbC1tb3ZlIC5sYXlvdXR7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41c306Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLW1vdmUud2l0aC1zZWFyY2ggLmxheW91dHt0cmFuc2Zvcm06c2NhbGUzZCgwLjgsIDAuOCwgMSk7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1tb3ZlIC5zZWFyY2h7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMHZoO3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzfTpob3N0Lm1vZGFsLW1vdmUgLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXN9W2Rpcj1sdHJdIDpob3N0Lm1vZGFsLW1vdmUgLnNlYXJjaCBidXR0b257cmlnaHQ6M3JlbX1bZGlyPXJ0bF0gOmhvc3QubW9kYWwtbW92ZSAuc2VhcmNoIGJ1dHRvbntsZWZ0OjNyZW19Omhvc3QubW9kYWwtbW92ZSAuc2VhcmNoIGZvcm17bWFyZ2luOjVyZW0gMDtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC1tb3ZlIC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjEwdnc7d2lkdGg6NzUlO3RyYW5zZm9ybTpzY2FsZTNkKDAsIDEsIDEpO3RyYW5zZm9ybS1vcmlnaW46MCA1MCU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdC5tb2RhbC1tb3ZlLnNob3cgLnNlYXJjaHtwb2ludGVyLWV2ZW50czphdXRvO29wYWNpdHk6MX06aG9zdC5tb2RhbC1tb3ZlLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxfTpob3N0Lm1vZGFsLW1vdmUuc2hvdyAuc2VhcmNoIGZvcm17b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0Lm1vZGFsLW1vdmUuc2hvdyAuc2VhcmNoIGlucHV0e3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpO3RyYW5zaXRpb24tZHVyYXRpb246MC41c31AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QubW9kYWwtbW92ZSBzcGFue3RleHQtYWxpZ246bGVmdH19XFxuXCIsIFwiOmhvc3QuY3VydGFpbiAuc2VhcmNoe3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTA1MDt0b3A6MDtsZWZ0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO2hlaWdodDoxMDB2aDt3aWR0aDoxMDAlO3BhZGRpbmc6M3JlbTtwb2ludGVyLWV2ZW50czpub25lO3RyYW5zaXRpb246dHJhbnNmb3JtIDAuM3M7dHJhbnNpdGlvbi1kZWxheTowLjRzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTpob3N0LmN1cnRhaW4gLnNlYXJjaDo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjNzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTpob3N0LmN1cnRhaW4gLnNlYXJjaCBidXR0b257Zm9udC1zaXplOjIuNXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6M3JlbTt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xczt0cmFuc2l0aW9uLWRlbGF5OjAuM3N9W2Rpcj1sdHJdIDpob3N0LmN1cnRhaW4gLnNlYXJjaCBidXR0b257cmlnaHQ6M3JlbX1bZGlyPXJ0bF0gOmhvc3QuY3VydGFpbiAuc2VhcmNoIGJ1dHRvbntsZWZ0OjNyZW19Omhvc3QuY3VydGFpbiAuc2VhcmNoIGZvcm17d2lkdGg6NTAlO29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUzZCgwLjgsIDAuOCwgMSk7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXMsIHRyYW5zZm9ybSAwLjVzfTpob3N0LmN1cnRhaW4gLnNlYXJjaCBpbnB1dHt3aWR0aDoxMDAlO2ZvbnQtc2l6ZTo2dnd9Omhvc3QuY3VydGFpbi5zaG93IC5zZWFyY2h7d2lkdGg6MTAwJTtwb2ludGVyLWV2ZW50czphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7dHJhbnNpdGlvbi1kZWxheTowc306aG9zdC5jdXJ0YWluLnNob3cgLnNlYXJjaDo6YWZ0ZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApO3RyYW5zaXRpb24tZGVsYXk6MC40c306aG9zdC5jdXJ0YWluLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0LmN1cnRhaW4uc2hvdyAuc2VhcmNoIGZvcm17b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQwZW0pezpob3N0LmN1cnRhaW4gc3Bhbnt3aWR0aDo5MCV9Omhvc3QuY3VydGFpbiBpbnB1dHtmb250LXNpemU6MmVtO3dpZHRoOjkwJX19OjpuZy1kZWVwIG5iLWxheW91dC5jdXJ0YWluIC5zY3JvbGxhYmxlLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjB9XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5jb2x1bW4tY3VydGFpbi53aXRoLXNlYXJjaCAubGF5b3V0e3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QuY29sdW1uLWN1cnRhaW57ZGlzcGxheTpibG9jaztwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDo1MCU7b3ZlcmZsb3c6aGlkZGVuO3dpZHRoOjUwJTtoZWlnaHQ6MTAwdmg7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5jb2x1bW4tY3VydGFpbjo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7dHJhbnNmb3JtOnNjYWxlM2QoMCwgMSwgMSk7dHJhbnNmb3JtLW9yaWdpbjowIDUwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjNzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoe3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6Mi41cmVtIDEuNXJlbSAwO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9Omhvc3QuY29sdW1uLWN1cnRhaW4gLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjJyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXN9W2Rpcj1sdHJdIDpob3N0LmNvbHVtbi1jdXJ0YWluIC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjJyZW19W2Rpcj1ydGxdIDpob3N0LmNvbHVtbi1jdXJ0YWluIC5zZWFyY2ggYnV0dG9ue2xlZnQ6MnJlbX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIGZvcm17d2lkdGg6ODUlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTUwJSwgMCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIGlucHV0e2ZvbnQtc2l6ZToyLjVyZW07d2lkdGg6MTAwJX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIHNwYW57Zm9udC1zaXplOjg1JX06aG9zdC5jb2x1bW4tY3VydGFpbi5zaG93e3BvaW50ZXItZXZlbnRzOmF1dG99Omhvc3QuY29sdW1uLWN1cnRhaW4uc2hvdzo6YmVmb3Jle3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0LmNvbHVtbi1jdXJ0YWluLnNob3cgLnNlYXJjaCBmb3Jte3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAwLCAwKTt0cmFuc2l0aW9uLWRlbGF5OjAuMTVzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKX06aG9zdC5jb2x1bW4tY3VydGFpbi5zaG93IC5zZWFyY2ggYnV0dG9ue29wYWNpdHk6MTt6LWluZGV4OjEwMH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QuY29sdW1uLWN1cnRhaW4gc3Bhbnt3aWR0aDo5MCV9Omhvc3QuY29sdW1uLWN1cnRhaW4gaW5wdXR7Zm9udC1zaXplOjJyZW07d2lkdGg6OTAlfX1cXG5cIiwgXCI6Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLWRyb3AgLmxheW91dHtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjRzLCBvcGFjaXR5IDAuNHM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKX06Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLWRyb3Aud2l0aC1zZWFyY2ggLmxheW91dHtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC45LCAwLjksIDEpO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QubW9kYWwtZHJvcCAuc2VhcmNoe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7ei1pbmRleDoxMDUwO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOm5vbmU7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2g6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNHN9Omhvc3QubW9kYWwtZHJvcCAuc2VhcmNoIGJ1dHRvbntmb250LXNpemU6Mi41cmVtO3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2Rpc3BsYXk6YmxvY2s7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjRzfVtkaXI9bHRyXSA6aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjNyZW19W2Rpcj1ydGxdIDpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCBmb3Jte3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjo1cmVtIDAgMnJlbX06aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjZ2dzt3aWR0aDo2MCU7cGFkZGluZzowLjI1cmVtO3RleHQtYWxpZ246Y2VudGVyO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC40c306aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggc3Bhbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4Ojk7ZGlzcGxheTpibG9jazt3aWR0aDo2MCU7cGFkZGluZzowLjg1cmVtIDA7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCk7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNHMsIHRyYW5zZm9ybSAwLjRzfTpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCAuZm9ybS1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MTA7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC40c306aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggLmZvcm0tY29udGVudDo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjIwJTt3aWR0aDo2MCU7aGVpZ2h0OjEwNSU7b3BhY2l0eTowO3RyYW5zZm9ybS1vcmlnaW46NTAlIDB9Omhvc3QubW9kYWwtZHJvcC5zaG93IC5zZWFyY2h7cG9pbnRlci1ldmVudHM6YXV0b306aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaDo6YmVmb3Jle29wYWNpdHk6MX06aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxfTpob3N0Lm1vZGFsLWRyb3Auc2hvdyAuc2VhcmNoIC5mb3JtLWNvbnRlbnR7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApO3RyYW5zaXRpb246bm9uZX06aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCAuZm9ybS1jb250ZW50OjphZnRlcnthbmltYXRpb246c2NhbGVVcERvd24gMC44cyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpIGZvcndhcmRzfTpob3N0Lm1vZGFsLWRyb3Auc2hvdyAuc2VhcmNoIGlucHV0e29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgMHMgMC40c306aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCBzcGFue29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7dHJhbnNpdGlvbi1kZWxheTowLjRzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fUBrZXlmcmFtZXMgc2NhbGVVcERvd257MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDAsIDEpfTUwJXt0cmFuc2Zvcm06c2NhbGUzZCgxLCAxLCAxKTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSAwO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTUwLjEle3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXR9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMCwgMSk7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDByZW0pezpob3N0Lm1vZGFsLWRyb3AgZm9ybXttYXJnaW46MnJlbSAwfTpob3N0Lm1vZGFsLWRyb3AgaW5wdXR7d2lkdGg6MTAwJTtsZWZ0OjB9fVxcblwiLCBcIjo6bmctZGVlcCBuYi1sYXlvdXQubW9kYWwtaGFsZiAubGF5b3V0e3RyYW5zaXRpb246dHJhbnNmb3JtIDAuNnMsIG9wYWNpdHkgMC42czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfTo6bmctZGVlcCBuYi1sYXlvdXQubW9kYWwtaGFsZi53aXRoLXNlYXJjaCAubGF5b3V0e3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaHt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDowO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOm5vbmU7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2g6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjZzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSl9Omhvc3QubW9kYWwtaGFsZiAuc2VhcmNoIGJ1dHRvbntmb250LXNpemU6Mi41cmVtO3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2Rpc3BsYXk6YmxvY2s7ei1pbmRleDoxMDA7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC42cywgdHJhbnNmb3JtIDAuNnM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKX1bZGlyPWx0cl0gOmhvc3QubW9kYWwtaGFsZiAuc2VhcmNoIGJ1dHRvbntyaWdodDozcmVtfVtkaXI9cnRsXSA6aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2ggYnV0dG9ue2xlZnQ6M3JlbX06aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2ggLmZvcm0td3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6MTAwJTtoZWlnaHQ6NTAlO3RyYW5zaXRpb246dHJhbnNmb3JtIDAuNnM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaCBmb3Jte3dpZHRoOjc1JTttYXJnaW46MCBhdXRvfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaCBpbnB1dHtmb250LXNpemU6N3Z3O3dpZHRoOjEwMCV9Omhvc3QubW9kYWwtaGFsZi5zaG93IC5zZWFyY2h7cG9pbnRlci1ldmVudHM6YXV0b306aG9zdC5tb2RhbC1oYWxmLnNob3cgLnNlYXJjaDo6YmVmb3Jle29wYWNpdHk6MX06aG9zdC5tb2RhbC1oYWxmLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0Lm1vZGFsLWhhbGYuc2hvdyAuc2VhcmNoIC5mb3JtLXdyYXBwZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlNlYXJjaEZpZWxkQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHR5cGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBsYWNlaG9sZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBoaW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlYXJjaDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHNlYXJjaElucHV0OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaW5wdXRFbGVtZW50OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnc2VhcmNoSW5wdXQnLF0gfV0sXG4gICAgc2hvd0NsYXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaG93JyxdIH1dLFxuICAgIG1vZGFsWm9vbWluOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5tb2RhbC16b29taW4nLF0gfV0sXG4gICAgcm90YXRlTGF5b3V0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5yb3RhdGUtbGF5b3V0JyxdIH1dLFxuICAgIG1vZGFsTW92ZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubW9kYWwtbW92ZScsXSB9XSxcbiAgICBjdXJ0YWluOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5jdXJ0YWluJyxdIH1dLFxuICAgIGNvbHVtbkN1cnRhaW46IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmNvbHVtbi1jdXJ0YWluJyxdIH1dLFxuICAgIG1vZGFsRHJvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubW9kYWwtZHJvcCcsXSB9XSxcbiAgICBtb2RhbEhhbGY6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm1vZGFsLWhhbGYnLF0gfV1cbn07XG4vKipcbiAqIEJlYXV0aWZ1bCBmdWxsLXBhZ2Ugc2VhcmNoIGNvbnRyb2wuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgc2VhcmNoL3NlYXJjaC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQmFzaWMgc2V0dXA6XG4gKlxuICogYGBgdHNcbiAqICA8bmItc2VhcmNoIHR5cGU9XCJyb3RhdGUtbGF5b3V0XCI+PC9uYi1zZWFyY2g+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iU2VhcmNoTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlNlYXJjaE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogU2V2ZXJhbCBhbmltYXRpb24gdHlwZXMgYXJlIGF2YWlsYWJsZTpcbiAqIG1vZGFsLXpvb21pbiwgcm90YXRlLWxheW91dCwgbW9kYWwtbW92ZSwgY3VydGFpbiwgY29sdW1uLWN1cnRhaW4sIG1vZGFsLWRyb3AsIG1vZGFsLWhhbGZcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGhhbmRsZSBzZWFyY2ggZXZlbnQgdXNpbmcgYE5iU2VhcmNoU2VydmljZWA6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWFyY2ggRXZlbnQsIHNlYXJjaC9zZWFyY2gtZXZlbnQuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBzZWFyY2gtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlYXJjaC1kaXZpZGVyLWNvbG9yOlxuICogc2VhcmNoLWRpdmlkZXItc3R5bGU6XG4gKiBzZWFyY2gtZGl2aWRlci13aWR0aDpcbiAqIHNlYXJjaC1leHRyYS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VhcmNoLXRleHQtY29sb3I6XG4gKiBzZWFyY2gtdGV4dC1mb250LWZhbWlseTpcbiAqIHNlYXJjaC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlYXJjaC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc2VhcmNoLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzZWFyY2gtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlYXJjaC1pbmZvLXRleHQtY29sb3I6XG4gKiBzZWFyY2gtaW5mby10ZXh0LWZvbnQtZmFtaWx5OlxuICogc2VhcmNoLWluZm8tdGV4dC1mb250LXNpemU6XG4gKiBzZWFyY2gtaW5mby10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc2VhcmNoLWluZm8tdGV4dC1saW5lLWhlaWdodDpcbiAqL1xuY2xhc3MgTmJTZWFyY2hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlYXJjaFNlcnZpY2UsIHRoZW1lU2VydmljZSwgcm91dGVyLCBvdmVybGF5U2VydmljZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlID0gc2VhcmNoU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlID0gb3ZlcmxheVNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2hvd1NlYXJjaEZpZWxkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2ggaW5wdXQgcGxhY2Vob2xkZXJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSAnU2VhcmNoLi4uJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhpbnQgc2hvd2luZyB1bmRlciB0aGUgaW5wdXQgZmllbGQgdG8gaW1wcm92ZSB1c2VyIGV4cGVyaWVuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGludCA9ICdIaXQgZW50ZXIgdG8gc2VhcmNoJztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMucm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oaWRlU2VhcmNoKCkpO1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2Uub25TZWFyY2hBY3RpdmF0ZSgpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoZGF0YSA9PiAhdGhpcy50YWcgfHwgZGF0YS50YWcgPT09IHRoaXMudGFnKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9wZW5TZWFyY2goKSk7XG4gICAgICAgIHRoaXMuc2VhcmNoU2VydmljZS5vblNlYXJjaERlYWN0aXZhdGUoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGRhdGEgPT4gIXRoaXMudGFnIHx8IGRhdGEudGFnID09PSB0aGlzLnRhZyksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oaWRlU2VhcmNoKCkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVJlZiAmJiB0aGlzLm92ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzc2VzKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgb3BlblNlYXJjaCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZiA9IHRoaXMub3ZlcmxheVNlcnZpY2UuY3JlYXRlKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuc2VhcmNoRmllbGRQb3J0YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLmFwcGVuZExheW91dENsYXNzKHRoaXMudHlwZSk7XG4gICAgICAgIG9mKG51bGwpLnBpcGUoZGVsYXkoMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5hcHBlbmRMYXlvdXRDbGFzcygnd2l0aC1zZWFyY2gnKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1NlYXJjaEZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGlkZVNlYXJjaCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuc2hvd1NlYXJjaEZpZWxkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB0aGlzLnNlYXJjaEJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIHNlYXJjaCh0ZXJtKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoU2VydmljZS5zdWJtaXRTZWFyY2godGVybSwgdGhpcy50YWcpO1xuICAgICAgICB0aGlzLmhpZGVTZWFyY2goKTtcbiAgICB9XG4gICAgZW1pdElucHV0KHRlcm0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlLnNlYXJjaElucHV0KHRlcm0sIHRoaXMudGFnKTtcbiAgICB9XG4gICAgZW1pdEFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2UuYWN0aXZhdGVTZWFyY2godGhpcy50eXBlLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIGVtaXREZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2UuZGVhY3RpdmF0ZVNlYXJjaCh0aGlzLnR5cGUsIHRoaXMudGFnKTtcbiAgICB9XG4gICAgcmVtb3ZlTGF5b3V0Q2xhc3NlcygpIHtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UucmVtb3ZlTGF5b3V0Q2xhc3MoJ3dpdGgtc2VhcmNoJyk7XG4gICAgICAgIG9mKG51bGwpLnBpcGUoZGVsYXkoNTAwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLnJlbW92ZUxheW91dENsYXNzKHRoaXMudHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk5iU2VhcmNoQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1zZWFyY2gnLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiAjc2VhcmNoQnV0dG9uIGNsYXNzPVwic3RhcnQtc2VhcmNoXCIgKGNsaWNrKT1cImVtaXRBY3RpdmF0ZSgpXCIgbmJCdXR0b24gZ2hvc3Q+XG4gICAgICA8bmItaWNvbiBpY29uPVwic2VhcmNoLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxuYi1zZWFyY2gtZmllbGRcbiAgICAgICpuYlBvcnRhbFxuICAgICAgW3Nob3ddPVwic2hvd1NlYXJjaEZpZWxkXCJcbiAgICAgIFt0eXBlXT1cInR5cGVcIlxuICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgIFtoaW50XT1cImhpbnRcIlxuICAgICAgKHNlYXJjaCk9XCJzZWFyY2goJGV2ZW50KVwiXG4gICAgICAoc2VhcmNoSW5wdXQpPVwiZW1pdElucHV0KCRldmVudClcIlxuICAgICAgKGNsb3NlKT1cImVtaXREZWFjdGl2YXRlKClcIj5cbiAgICA8L25iLXNlYXJjaC1maWVsZD5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IGJ1dHRvbntmb250LXNpemU6MnJlbTttYXJnaW46MCBhdXRvO3BhZGRpbmc6MDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6bm9uZTtiYWNrZ3JvdW5kOm5vbmV9Omhvc3QgYnV0dG9uOmZvY3Vze2JveC1zaGFkb3c6bm9uZTtvdXRsaW5lOm5vbmV9OjpuZy1kZWVwIG5iLWxheW91dC53aXRoLXNlYXJjaCAuc2Nyb2xsYWJsZS1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDowfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlNlYXJjaENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iU2VhcmNoU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUaGVtZVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJvdXRlciB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk5iU2VhcmNoQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRhZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGhpbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHR5cGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlYXJjaEZpZWxkUG9ydGFsOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtOYlBvcnRhbERpcmVjdGl2ZSxdIH1dLFxuICAgIHNlYXJjaEJ1dHRvbjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3NlYXJjaEJ1dHRvbicsIHsgcmVhZDogRWxlbWVudFJlZiB9LF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iU2VhcmNoTW9kdWxlIHtcbn1cbk5iU2VhcmNoTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYk92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJCdXR0b25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTZWFyY2hDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iU2VhcmNoRmllbGRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2VhcmNoQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2VhcmNoU2VydmljZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBTdHlsZWQgY2hlY2tib3ggY29tcG9uZW50XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgY2hlY2tib3gvY2hlY2tib3gtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ2hlY2tib3hDb21wb25lbnRgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2hlY2tib3hNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIENoZWNrYm94IGlzIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBjb2xvcnMgdXNpbmcgYHN0YXR1c2AgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgQ2hlY2tib3hlcywgY2hlY2tib3gvY2hlY2tib3gtc3RhdHVzLmNvbXBvbmVudClcbiAqXG4gKiBJbmRldGVybWluYXRlIHN0YXRlIGlzIGFsc28gc3VwcG9ydGVkOlxuICogQHN0YWNrZWQtZXhhbXBsZShJbmRldGVybWluYXRlIENoZWNrYm94LCBjaGVja2JveC9jaGVja2JveC1pbmRldGVybWluYXRlLmNvbXBvbmVudClcbiAqXG4gKiBDaGVja2JveCBjYW4gYmUgZGlzYWJsZWQgdmlhIGBkaXNhYmxlZGAgYXR0cmlidXRlLlxuICogQHN0YWNrZWQtZXhhbXBsZShEaXNhYmxlZCBDaGVja2JveCwgY2hlY2tib3gvY2hlY2tib3gtZGlzYWJsZWQuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBjaGVja2JveC1oZWlnaHQ6XG4gKiBjaGVja2JveC13aWR0aDpcbiAqIGNoZWNrYm94LWJvcmRlci1zdHlsZTpcbiAqIGNoZWNrYm94LWJvcmRlci13aWR0aDpcbiAqIGNoZWNrYm94LWJvcmRlci1yYWRpdXM6XG4gKiBjaGVja2JveC1vdXRsaW5lLXdpZHRoOlxuICogY2hlY2tib3gtb3V0bGluZS1jb2xvcjpcbiAqIGNoZWNrYm94LXRleHQtZm9udC1mYW1pbHk6XG4gKiBjaGVja2JveC10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNoZWNrYm94LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjaGVja2JveC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2hlY2tib3gtdGV4dC1zcGFjZTpcbiAqIGNoZWNrYm94LXBhZGRpbmc6XG4gKiBjaGVja2JveC1mb2N1cy1pbnNldC1zaGFkb3ctbGVuZ3RoOlxuICogY2hlY2tib3gtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWNoZWNrZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaW5kZXRlcm1pbmF0ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaW5kZXRlcm1pbmF0ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1pbmRldGVybWluYXRlLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZGlzYWJsZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaW5kZXRlcm1pbmF0ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1pbmRldGVybWluYXRlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWNoZWNrZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1pbmRldGVybWluYXRlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWluZGV0ZXJtaW5hdGUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1pbmRldGVybWluYXRlLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtaG92ZXItY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1hY3RpdmUtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tY2hlY2tlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWluZGV0ZXJtaW5hdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8taW5kZXRlcm1pbmF0ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8taG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1kaXNhYmxlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaW5kZXRlcm1pbmF0ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1pbmRldGVybWluYXRlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWNoZWNrZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWluZGV0ZXJtaW5hdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1pbmRldGVybWluYXRlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1pbmRldGVybWluYXRlLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZGlzYWJsZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWNoZWNrZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1pbmRldGVybWluYXRlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWluZGV0ZXJtaW5hdGUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1pbmRldGVybWluYXRlLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtaG92ZXItY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1hY3RpdmUtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZGlzYWJsZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKi9cbmNsYXNzIE5iQ2hlY2tib3hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZURldGVjdG9yLCByZW5kZXJlciwgaG9zdEVsZW1lbnQsIHpvbmUsIHN0YXR1c1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrYm94IHN0YXR1cy5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIGFyZTogYGJhc2ljYCwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBpbmZvYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdXRwdXQgd2hlbiBjaGVja2VkIHN0YXRlIGlzIGNoYW5nZWQgYnkgYSB1c2VyXG4gICAgICAgICAqIEB0eXBlIEV2ZW50RW1pdHRlcjxib29sZWFuPlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgfVxuICAgIHNldCBjaGVja2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBpbnB1dCBkaXNhYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBjaGVja2JveCBpbmRldGVybWluYXRlIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgIH1cbiAgICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgYWRkaXRpb25hbENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1NlcnZpY2UuaXNDdXN0b21TdGF0dXModGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RhdHVzU2VydmljZS5nZXRTdGF0dXNDbGFzcyh0aGlzLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBUT0RPOiAjMjI1NFxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ25iLXRyYW5zaXRpb24nKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IHZhbDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgc2V0RGlzYWJsZWRTdGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBzZXRUb3VjaGVkKCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgIH1cbiAgICB1cGRhdGVWYWx1ZUFuZEluZGV0ZXJtaW5hdGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5jaGVja2VkKTtcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gaW5wdXQuaW5kZXRlcm1pbmF0ZTtcbiAgICB9XG59XG5OYkNoZWNrYm94Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jaGVja2JveCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlxuICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwibmF0aXZlLWlucHV0IHZpc3VhbGx5LWhpZGRlblwiXG4gICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICBbY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgICAoY2hhbmdlKT1cInVwZGF0ZVZhbHVlQW5kSW5kZXRlcm1pbmF0ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAoYmx1cik9XCJzZXRUb3VjaGVkKClcIlxuICAgICAgICAgICAgIChjbGljayk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIj5cbiAgICAgIDxzcGFuIFtjbGFzcy5pbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIiBbY2xhc3MuY2hlY2tlZF09XCJjaGVja2VkXCIgY2xhc3M9XCJjdXN0b20tY2hlY2tib3hcIj5cbiAgICAgICAgPG5iLWljb24gKm5nSWY9XCJpbmRldGVybWluYXRlXCIgaWNvbj1cIm1pbnVzLWJvbGQtb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgIDxuYi1pY29uICpuZ0lmPVwiY2hlY2tlZCAmJiAhaW5kZXRlcm1pbmF0ZVwiIGljb249XCJjaGVja21hcmstYm9sZC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgIDwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L3NwYW4+XG4gICAgPC9sYWJlbD5cbiAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iQ2hlY2tib3hDb21wb25lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3QgLmxhYmVse3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO21hcmdpbjowO21pbi1oZWlnaHQ6aW5oZXJpdH06aG9zdCAuY3VzdG9tLWNoZWNrYm94e2ZsZXgtc2hyaW5rOjB9Omhvc3QoLm5iLXRyYW5zaXRpb24pIC5jdXN0b20tY2hlY2tib3h7dHJhbnNpdGlvbi1kdXJhdGlvbjowLjE1czt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsYm9yZGVyLGJveC1zaGFkb3c7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbn06aG9zdCgubmItdHJhbnNpdGlvbikgLnRleHR7dHJhbnNpdGlvbi1kdXJhdGlvbjowLjE1czt0cmFuc2l0aW9uLXByb3BlcnR5OmNvbG9yO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW59XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2hlY2tib3hDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IE5iU3RhdHVzU2VydmljZSB9XG5dO1xuTmJDaGVja2JveENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjaGVja2VkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhdHVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpbmRldGVybWluYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjaGVja2VkQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNoZWNrYm94TW9kdWxlIHtcbn1cbk5iQ2hlY2tib3hNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iQ2hlY2tib3hDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYkNoZWNrYm94Q29tcG9uZW50XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG5jbGFzcyBOYkR5bmFtaWNPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihvdmVybGF5LCBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIHpvbmUsIG92ZXJsYXlDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lciA9IG92ZXJsYXlDb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLm92ZXJsYXlDb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5Q2hhbmdlJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuaXNTaG93biQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMub3ZlcmxheURlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgZ2V0IGlzQXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpO1xuICAgIH1cbiAgICBnZXQgaXNTaG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTaG93biQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICB9XG4gICAgY3JlYXRlKGNvbXBvbmVudFR5cGUsIGNvbnRlbnQsIGNvbnRleHQsIHBvc2l0aW9uU3RyYXRlZ3ksIG92ZXJsYXlDb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnNldENvbnRlbnRBbmRDb250ZXh0KGNvbnRlbnQsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnNldENvbXBvbmVudChjb21wb25lbnRUeXBlKTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvblN0cmF0ZWd5KHBvc2l0aW9uU3RyYXRlZ3kpO1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlDb25maWcob3ZlcmxheUNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHNldENvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gICAgc2V0Q29udGVudEFuZENvbnRleHQoY29udGVudCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgY29tcG9uZW50IGlzIHNob3duIHdlIHJlY3JlYXRlIGl0IGFuZCBzaG93IGl0IGJhY2tcbiAgICAgICAgY29uc3Qgd2FzQXR0YWNoZWQgPSB0aGlzLmlzQXR0YWNoZWQ7XG4gICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgaWYgKHdhc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQb3NpdGlvblN0cmF0ZWd5KHBvc2l0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5Q2hhbmdlJC5uZXh0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneSA9IHBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneS5wb3NpdGlvbkNoYW5nZVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+ICEhdGhpcy5jb250YWluZXIpLCB0YWtlVW50aWwobWVyZ2UodGhpcy5wb3NpdGlvblN0cmF0ZWd5Q2hhbmdlJCwgdGhpcy5kZXN0cm95JCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFwcGxpZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgcGF0Y2godGhpcy5jb250YWluZXIsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLnVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kodGhpcy5wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPdmVybGF5Q29uZmlnKG92ZXJsYXlDb25maWcpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29uZmlnID0gb3ZlcmxheUNvbmZpZztcbiAgICAgICAgY29uc3Qgd2FzQXR0YWNoZWQgPSB0aGlzLmlzQXR0YWNoZWQ7XG4gICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgaWYgKHdhc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckNvbnRhaW5lcigpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3ZlcmxheUluQ29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIC8vIERpc3Bvc2Ugb3ZlcmxheSByZWYgYXMgaXQgcmVmZXJzIHRvIHRoZSBvbGQgb3ZlcmxheSBjb250YWluZXIgYW5kIGNyZWF0ZSBuZXcgYnkgY2FsbGluZyBgc2hvd2BcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU2hvd24kLm5leHQodHJ1ZSk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZi5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2hvd24kLm5leHQoZmFsc2UpO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgdGhpcy5pc1Nob3duJC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3lDaGFuZ2UkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheURlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGdldENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgICBjcmVhdGVPdmVybGF5KCkge1xuICAgICAgICB0aGlzLnJlZiA9IHRoaXMub3ZlcmxheS5jcmVhdGUoT2JqZWN0LmFzc2lnbih7IHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMucG9zaXRpb25TdHJhdGVneSwgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKSB9LCB0aGlzLm92ZXJsYXlDb25maWcpKTtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbldoZW5TdGFibGUodGhpcy5yZWYpO1xuICAgIH1cbiAgICByZW5kZXJDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckNvbnRleHQgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lckNvbnRleHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBjcmVhdGVDb250YWluZXIodGhpcy5yZWYsIHRoaXMuY29tcG9uZW50VHlwZSwgY29udGFpbmVyQ29udGV4dCwgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc3RhbmNlLnJlbmRlckNvbnRlbnQoKTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQ29udGV4dCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyQ29udGV4dCgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGFpbmVyLmluc3RhbmNlLCBjb250YWluZXJDb250ZXh0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zdGFuY2UucmVuZGVyQ29udGVudCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICBjZnI6IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGFzdEFwcGxpZWRQb3NpdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGltZW5zaW9ucyBvZiB0aGUgY29udGFpbmVyIG1heSBjaGFuZ2UgYWZ0ZXIgY29udGVudCB1cGRhdGUuIFNvIHdlIGxpc3RlbiB0byB6b25lLnN0YWJsZSBldmVudCB0b1xuICAgICAqIHJlcG9zaXRpb24gdGhlIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbldoZW5TdGFibGUob3ZlcmxheSkge1xuICAgICAgICBjb25zdCBvdmVybGF5RGVzdHJveSQgPSB0aGlzLm92ZXJsYXlEZXN0cm95JC5waXBlKGZpbHRlcigoZGVzdHJveWVkT3ZlcmxheSkgPT4gZGVzdHJveWVkT3ZlcmxheSA9PT0gb3ZlcmxheSkpO1xuICAgICAgICB0aGlzLnpvbmUub25TdGFibGVcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbChtZXJnZSh0aGlzLmRlc3Ryb3kkLCBvdmVybGF5RGVzdHJveSQpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNPdmVybGF5SW5Db250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXIuZ2V0Q29udGFpbmVyRWxlbWVudCgpLmNvbnRhaW5zKHRoaXMucmVmLmhvc3RFbGVtZW50KTtcbiAgICB9XG4gICAgZGlzcG9zZU92ZXJsYXlSZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5RGVzdHJveSQubmV4dCh0aGlzLnJlZik7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5OYkR5bmFtaWNPdmVybGF5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYkR5bmFtaWNPdmVybGF5LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IE5iT3ZlcmxheUNvbnRhaW5lciB9XG5dO1xuXG5jbGFzcyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlIGV4dGVuZHMgU2ltcGxlQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0Q2hhbmdlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlLCBmaXJzdENoYW5nZSk7XG4gICAgfVxuICAgIGlzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZhbHVlICE9PSB0aGlzLnByZXZpb3VzVmFsdWU7XG4gICAgfVxufVxuY2xhc3MgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uQnVpbGRlciwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgZHluYW1pY092ZXJsYXlTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXIgPSB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5U2VydmljZSA9IGR5bmFtaWNPdmVybGF5U2VydmljZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLl90cmlnZ2VyID0gTmJUcmlnZ2VyLk5PT1A7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gTmJQb3NpdGlvbi5UT1A7XG4gICAgICAgIHRoaXMuX2FkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuTk9PUDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMTU7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0ge307XG4gICAgfVxuICAgIGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuaG9zdCA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX2hvc3QsIGhvc3QpO1xuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRyaWdnZXIodHJpZ2dlciQkMSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMudHJpZ2dlciA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX3RyaWdnZXIsIHRyaWdnZXIkJDEpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyID0gdHJpZ2dlciQkMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5wb3NpdGlvbiA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX3Bvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGp1c3RtZW50KGFkanVzdG1lbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmFkanVzdG1lbnQgPSBuZXcgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSh0aGlzLl9hZGp1c3RtZW50LCBhZGp1c3RtZW50KTtcbiAgICAgICAgdGhpcy5fYWRqdXN0bWVudCA9IGFkanVzdG1lbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb21wb25lbnRUeXBlKGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmNvbXBvbmVudFR5cGUgPSBuZXcgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSh0aGlzLl9jb21wb25lbnRUeXBlLCBjb21wb25lbnRUeXBlKTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZSA9IGNvbXBvbmVudFR5cGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmNvbnRlbnQgPSBuZXcgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSh0aGlzLl9jb250ZW50LCBjb250ZW50KTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmNvbnRleHQgPSBuZXcgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSh0aGlzLl9jb250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5vZmZzZXQgPSBuZXcgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSh0aGlzLl9vZmZzZXQsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG92ZXJsYXlDb25maWcob3ZlcmxheUNvbmZpZykge1xuICAgICAgICB0aGlzLmNoYW5nZXMub3ZlcmxheUNvbmZpZyA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX292ZXJsYXlDb25maWcsIG92ZXJsYXlDb25maWcpO1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29uZmlnID0gb3ZlcmxheUNvbmZpZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudFR5cGUgfHwgIXRoaXMuX2hvc3QpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcjogYXQgbGVhc3QgJ2NvbXBvbmVudFR5cGUnIGFuZCAnaG9zdCcgc2hvdWxkIGJlXG4gICAgICBwYXNzZWQgYmVmb3JlIGJ1aWxkaW5nIGEgZHluYW1pYyBvdmVybGF5LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkgPSB0aGlzLmR5bmFtaWNPdmVybGF5U2VydmljZS5jcmVhdGUodGhpcy5fY29tcG9uZW50VHlwZSwgdGhpcy5fY29udGVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCksIHRoaXMuX292ZXJsYXlDb25maWcpO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5jbGVhckNoYW5nZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHluYW1pY092ZXJsYXk7XG4gICAgfVxuICAgIHJlYnVpbGQoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3ZSBzaG91bGQgbm90IHRocm93IGhlcmVcbiAgICAgICAgICogYXMgd2UgdXNlIHJlYnVpbHQgaW4gbGlmZWN5Y2xlIGhvb2tzXG4gICAgICAgICAqIHdoaWNoIGl0IGNvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGJ1aWxkXG4gICAgICAgICAqIHNvIHdlIGp1c3QgaWdub3JlIHRoaXMgY2FsbFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmR5bmFtaWNPdmVybGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNQb3NpdGlvblN0cmF0ZWd5VXBkYXRlUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zZXRQb3NpdGlvblN0cmF0ZWd5KHRoaXMuY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1RyaWdnZXJTdHJhdGVneVVwZGF0ZVJlcXVpcmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ29udGFpbmVyUmVyZW5kZXJSZXF1aXJlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnNldENvbnRlbnRBbmRDb250ZXh0KHRoaXMuX2NvbnRlbnQsIHRoaXMuX2NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50VHlwZVVwZGF0ZVJlcXVpcmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuc2V0Q29tcG9uZW50KHRoaXMuX2NvbXBvbmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzT3ZlcmxheUNvbmZpZ1VwZGF0ZVJlcXVpcmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuc2V0T3ZlcmxheUNvbmZpZyh0aGlzLl9vdmVybGF5Q29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQ2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmR5bmFtaWNPdmVybGF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5iRHluYW1pY092ZXJsYXlIYW5kbGVyOiBjYW5ub3QgY29ubmVjdCB0byBEeW5hbWljT3ZlcmxheVxuICAgICAgYXMgaXQgaXMgbm90IGNyZWF0ZWQgeWV0LiBDYWxsIGJ1aWxkKCkgZmlyc3RgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblRyaWdnZXJzKHRoaXMuZHluYW1pY092ZXJsYXkpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5jbGVhckNoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY092ZXJsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uQnVpbGRlclxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuX2hvc3QpXG4gICAgICAgICAgICAucG9zaXRpb24odGhpcy5fcG9zaXRpb24pXG4gICAgICAgICAgICAuYWRqdXN0bWVudCh0aGlzLl9hZGp1c3RtZW50KVxuICAgICAgICAgICAgLm9mZnNldCh0aGlzLl9vZmZzZXQpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblRyaWdnZXJzKGR5bmFtaWNPdmVybGF5KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5ID0gdGhpcy50cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyXG4gICAgICAgICAgICAudHJpZ2dlcih0aGlzLl90cmlnZ2VyKVxuICAgICAgICAgICAgLmhvc3QodGhpcy5faG9zdC5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgLmNvbnRhaW5lcigoKSA9PiBkeW5hbWljT3ZlcmxheS5nZXRDb250YWluZXIoKSlcbiAgICAgICAgICAgIC5idWlsZCgpO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5zaG93JC5zdWJzY3JpYmUoKCkgPT4gZHluYW1pY092ZXJsYXkuc2hvdygpKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuaGlkZSQuc3Vic2NyaWJlKCgpID0+IGR5bmFtaWNPdmVybGF5LmhpZGUoKSk7XG4gICAgfVxuICAgIGlzQ29udGFpbmVyUmVyZW5kZXJSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZW50VXBkYXRlZCgpXG4gICAgICAgICAgICB8fCB0aGlzLmlzQ29udGV4dFVwZGF0ZWQoKVxuICAgICAgICAgICAgfHwgdGhpcy5pc1Bvc2l0aW9uU3RyYXRlZ3lVcGRhdGVSZXF1aXJlZCgpO1xuICAgIH1cbiAgICBpc1Bvc2l0aW9uU3RyYXRlZ3lVcGRhdGVSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBZGp1c3RtZW50VXBkYXRlZCgpIHx8IHRoaXMuaXNQb3NpdGlvblVwZGF0ZWQoKSB8fCB0aGlzLmlzT2Zmc2V0VXBkYXRlZCgpIHx8IHRoaXMuaXNIb3N0VXBkYXRlZCgpO1xuICAgIH1cbiAgICBpc1RyaWdnZXJTdHJhdGVneVVwZGF0ZVJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RyaWdnZXJVcGRhdGVkKCkgfHwgdGhpcy5pc0hvc3RVcGRhdGVkKCk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50VHlwZVVwZGF0ZVJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBvbmVudFR5cGVVcGRhdGVkKCk7XG4gICAgfVxuICAgIGlzT3ZlcmxheUNvbmZpZ1VwZGF0ZVJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc092ZXJsYXlDb25maWdVcGRhdGVkKCk7XG4gICAgfVxuICAgIGlzQ29tcG9uZW50VHlwZVVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMuY29tcG9uZW50VHlwZSAmJiB0aGlzLmNoYW5nZXMuY29tcG9uZW50VHlwZS5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgaXNDb250ZW50VXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5jb250ZW50ICYmIHRoaXMuY2hhbmdlcy5jb250ZW50LmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc0NvbnRleHRVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLmNvbnRleHQgJiYgdGhpcy5jaGFuZ2VzLmNvbnRleHQuaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlzQWRqdXN0bWVudFVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMuYWRqdXN0bWVudCAmJiB0aGlzLmNoYW5nZXMuYWRqdXN0bWVudC5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgaXNQb3NpdGlvblVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMucG9zaXRpb24gJiYgdGhpcy5jaGFuZ2VzLnBvc2l0aW9uLmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc0hvc3RVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLmhvc3QgJiYgdGhpcy5jaGFuZ2VzLmhvc3QuaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlzVHJpZ2dlclVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMudHJpZ2dlciAmJiB0aGlzLmNoYW5nZXMudHJpZ2dlci5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgaXNPZmZzZXRVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLm9mZnNldCAmJiB0aGlzLmNoYW5nZXMub2Zmc2V0LmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc092ZXJsYXlDb25maWdVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLm92ZXJsYXlDb25maWcgJiYgdGhpcy5jaGFuZ2VzLm92ZXJsYXlDb25maWcuaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGNsZWFyQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0ge307XG4gICAgfVxufVxuTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iRHluYW1pY092ZXJsYXlIYW5kbGVyLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkR5bmFtaWNPdmVybGF5IH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogT3ZlcmxheSBjb250YWluZXIuXG4gKiBSZW5kZXJzIHByb3ZpZGVkIGNvbnRlbnQgaW5zaWRlLlxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBwb3BvdmVyLXRleHQtY29sb3I6XG4gKiBwb3BvdmVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBwb3BvdmVyLXRleHQtZm9udC1zaXplOlxuICogcG9wb3Zlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcG9wb3Zlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogcG9wb3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcG9wb3Zlci1ib3JkZXItd2lkdGg6XG4gKiBwb3BvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHBvcG92ZXItYm9yZGVyLXJhZGl1czpcbiAqIHBvcG92ZXItc2hhZG93OlxuICogcG9wb3Zlci1hcnJvdy1zaXplOlxuICogcG9wb3Zlci1wYWRkaW5nOlxuICogKi9cbmNsYXNzIE5iUG9wb3ZlckNvbXBvbmVudCBleHRlbmRzIE5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudCB7XG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hDb250ZW50KCk7XG4gICAgICAgIHRoaXMuYXR0YWNoQ29udGVudCgpO1xuICAgIH1cbiAgICBkZXRhY2hDb250ZW50KCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIGF0dGFjaENvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hUZW1wbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudCBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFN0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRlbXBsYXRlKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXJcbiAgICAgICAgICAgIC5hdHRhY2hUZW1wbGF0ZVBvcnRhbChuZXcgTmJUZW1wbGF0ZVBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIHsgJGltcGxpY2l0OiB0aGlzLmNvbnRleHQgfSkpO1xuICAgIH1cbiAgICBhdHRhY2hDb21wb25lbnQoKSB7XG4gICAgICAgIGNvbnN0IHBvcnRhbCA9IG5ldyBOYkNvbXBvbmVudFBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIG51bGwsIHRoaXMuY2ZyKTtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGF0dGFjaFN0cmluZygpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaFN0cmluZ0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICB9XG59XG5OYlBvcG92ZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXBvcG92ZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gY2xhc3M9XCJhcnJvd1wiPjwvc3Bhbj5cbiAgICA8bmItb3ZlcmxheS1jb250YWluZXI+PC9uYi1vdmVybGF5LWNvbnRhaW5lcj5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IC5hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlBvcG92ZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgb3ZlcmxheUNvbnRhaW5lcjogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50LF0gfV0sXG4gICAgY29udGVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29udGV4dDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2ZyOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBQb3dlcmZ1bCBwb3BvdmVyIGRpcmVjdGl2ZSwgd2hpY2ggcHJvdmlkZXMgdGhlIGJlc3QgVVggZm9yIHlvdXIgdXNlcnMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgcG9wb3Zlci9wb3BvdmVyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBQb3BvdmVyIGNhbiBhY2NlcHQgZGlmZmVyZW50IGNvbnRlbnQgc3VjaCBhczpcbiAqIFRlbXBsYXRlUmVmXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJQb3BvdmVyXT1cInRlbXBsYXRlUmVmXCI+PC9idXR0b24+XG4gKiA8bmctdGVtcGxhdGUgI3RlbXBsYXRlUmVmPlxuICogICA8c3Bhbj5IZWxsbywgUG9wb3ZlciE8L3NwYW4+XG4gKiA8L25nLXRlbXBsYXRlPlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlBvcG92ZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUG9wb3Zlck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ3VzdG9tIGNvbXBvbmVudHNcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYlBvcG92ZXJdPVwiTXlQb3BvdmVyQ29tcG9uZW50XCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBCb3RoIGN1c3RvbSBjb21wb25lbnRzIGFuZCB0ZW1wbGF0ZVJlZiBwb3BvdmVycyBjYW4gcmVjZWl2ZSAqY29udGVudENvbnRleHQqIHByb3BlcnR5XG4gKiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjb250ZW50IHByb3BzLlxuICpcbiAqIFByaW1pdGl2ZSB0eXBlc1xuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBQb3BvdmVyIGhhcyBkaWZmZXJlbnQgcGxhY2VtZW50cywgc3VjaCBhczogdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBzdGFydCBhbmQgZW5kXG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBmb2xsb3dpbmc6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQbGFjZW1lbnRzLCBwb3BvdmVyL3BvcG92ZXItcGxhY2VtZW50cy5jb21wb25lbnQpXG4gKlxuICogQnkgZGVmYXVsdCBwb3BvdmVyIHdpbGwgdHJ5IHRvIGFkanVzdCBpdHNlbGYgdG8gbWF4aW1hbGx5IGZpdCB2aWV3cG9ydFxuICogYW5kIHByb3ZpZGUgdGhlIGJlc3QgdXNlciBleHBlcmllbmNlLiBJdCB3aWxsIHRyeSB0byBjaGFuZ2UgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgY29udGFpbmVyLlxuICogSWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBzZXQgaXQgYG5vb3BgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCIgbmJQb3BvdmVyQWRqdXN0bWVudD1cIm5vb3BcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIFBvcG92ZXIgaGFzIGEgbnVtYmVyIG9mIHRyaWdnZXJzIHdoaWNoIHByb3ZpZGVzIGFuIGFiaWxpdHkgdG8gc2hvdyBhbmQgaGlkZSB0aGUgY29tcG9uZW50IGluIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gQ2xpY2sgbW9kZSBzaG93cyB0aGUgY29tcG9uZW50IHdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBoaWRlcyB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogc29tZXdoZXJlIG9uIHRoZSBkb2N1bWVudCBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gKiAtIEhpbnQgcHJvdmlkZXMgY2FwYWJpbGl0eSB0byBzaG93IHRoZSBjb21wb25lbnQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50XG4gKiBhbmQgaGlkZSB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdXQgb2YgdGhlIGhvc3QuXG4gKiAtIEhvdmVyIHdvcmtzIGxpa2UgaGludCBtb2RlIHdpdGggb25lIGV4Y2VwdGlvbiAtIHdoZW4gdGhlIHVzZXIgbW92ZXMgbW91c2UgZnJvbSBob3N0IGVsZW1lbnQgdG9cbiAqIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGUgY29tcG9uZW50IHJlbWFpbnMgb3Blbiwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0IGNvbnRlbnQuXG4gKiAtIEZvY3VzIG1vZGUgaXMgYXBwbGllZCB3aGVuIHVzZXIgZm9jdXNlcyB0aGUgZWxlbWVudC5cbiAqIC0gTm9vcCBtb2RlIC0gdGhlIGNvbXBvbmVudCB3b24ndCByZWFjdCB0byB0aGUgdXNlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YWlsYWJsZSBUcmlnZ2VycywgcG9wb3Zlci9wb3BvdmVyLW1vZGVzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIE5vb3AgbW9kZSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNvbnRyb2wgUG9wb3ZlciBwcm9ncmFtbWF0aWNhbGx5LCBmb3IgZXhhbXBsZSBzaG93L2hpZGVcbiAqIGFzIGEgcmVzdWx0IG9mIHNvbWUgdGhpcmQtcGFydHkgYWN0aW9uLCBsaWtlIEhUVFAgcmVxdWVzdCBvciB2YWxpZGF0aW9uIGNoZWNrOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWFudWFsIENvbnRyb2wsIHBvcG92ZXIvcG9wb3Zlci1ub29wLmNvbXBvbmVudClcbiAqXG4gKiBCZWxvdyBhcmUgZXhhbXBsZXMgZm9yIG1hbnVhbCBwb3BvdmVyIHNldHRpbmdzIGNvbnRyb2wsIGJvdGggdmlhIHRlbXBsYXRlIGJpbmRpbmcgYW5kIGNvZGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvcG92ZXIgU2V0dGluZ3MsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLmNvbXBvbmVudClcbiAqXG4gKiBQbGVhc2Ugbm90ZSwgd2hpbGUgbWFuaXB1bGF0aW5nIFBvcG92ZXIgc2V0dGluZyB2aWEgY29kZSwgeW91IG5lZWQgdG8gY2FsbCBgcmVidWlsZCgpYCBtZXRob2QgdG8gYXBwbHkgdGhlIHNldHRpbmdzXG4gKiBjaGFuZ2VkLlxuICogQHN0YWNrZWQtZXhhbXBsZShQb3BvdmVyIFNldHRpbmdzIENvZGUsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLWNvZGUuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoVGVtcGxhdGUgUmVmLCBwb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUtcmVmLmNvbXBvbmVudClcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoQ3VzdG9tIENvbXBvbmVudCwgcG9wb3Zlci9wb3BvdmVyLWN1c3RvbS1jb21wb25lbnQuY29tcG9uZW50KVxuICogKi9cbmNsYXNzIE5iUG9wb3ZlckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZiwgZHluYW1pY092ZXJsYXlIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyID0gZHluYW1pY092ZXJsYXlIYW5kbGVyO1xuICAgICAgICB0aGlzLnBvcG92ZXJDb21wb25lbnQgPSBOYlBvcG92ZXJDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbmVyIGNvbnRlbnQgY29udGV4dC4gV2lsbCBiZSBhcHBsaWVkIHRvIHRoZSByZW5kZXJlZCBjb21wb25lbnQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICAgICAgICogQ2FuIGJlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQgb3IgZW5kLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gTmJQb3NpdGlvbi5UT1A7XG4gICAgICAgIHRoaXMuX2FkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuQ0xPQ0tXSVNFO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHdoZW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBBdmFpbGFibGUgb3B0aW9uczogYGNsaWNrYCwgYGhvdmVyYCwgYGhpbnRgLCBgZm9jdXNgIGFuZCBgbm9vcGBcbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyID0gTmJUcmlnZ2VyLkNMSUNLO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBwb3BvdmVyIG9mZnNldFxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDE1O1xuICAgICAgICB0aGlzLl9wb3BvdmVyQ2xhc3MgPSAnJztcbiAgICAgICAgdGhpcy5uYlBvcG92ZXJTaG93U3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbmZpZyA9IHsgcGFuZWxDbGFzczogdGhpcy5wb3BvdmVyQ2xhc3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgYmUgY2hhbmdlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgc3RyYXRlZ3kgaWYgY29udGFpbmVyIGNhbid0IGZpdCB2aWV3IHBvcnQuXG4gICAgICogU2V0IHRoaXMgcHJvcGVydHkgdG8gYG5vb3BgIHZhbHVlIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgYXV0b21hdGljYWxseSBhZGp1c3RtZW50LlxuICAgICAqIEF2YWlsYWJsZSB2YWx1ZXM6IGBjbG9ja3dpc2VgIChkZWZhdWx0KSwgYGNvdW50ZXJjbG9ja3dpc2VgLCBgdmVydGljYWxgLCBgaG9yaXpvbnRhbGAsIGBub29wYC5cbiAgICAgKiAqL1xuICAgIGdldCBhZGp1c3RtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRqdXN0bWVudDtcbiAgICB9XG4gICAgc2V0IGFkanVzdG1lbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYWRqdXN0bWVudCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcG9wb3ZlckNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9wb3ZlckNsYXNzO1xuICAgIH1cbiAgICBzZXQgcG9wb3ZlckNsYXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5wb3BvdmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcG92ZXJDbGFzcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5Q29uZmlnID0geyBwYW5lbENsYXNzOiB0aGlzLnBvcG92ZXJDbGFzcyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1Nob3duKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5keW5hbWljT3ZlcmxheSAmJiB0aGlzLmR5bmFtaWNPdmVybGF5LmlzQXR0YWNoZWQpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5ob3N0KHRoaXMuaG9zdFJlZilcbiAgICAgICAgICAgIC5jb21wb25lbnRUeXBlKHRoaXMucG9wb3ZlckNvbXBvbmVudCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5ID0gdGhpcy5jb25maWd1cmVEeW5hbWljT3ZlcmxheSgpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5pc1Nob3duXG4gICAgICAgICAgICAucGlwZShza2lwKDEpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChpc1Nob3duKSA9PiB0aGlzLm5iUG9wb3ZlclNob3dTdGF0ZUNoYW5nZS5lbWl0KHsgaXNTaG93biB9KSk7XG4gICAgfVxuICAgIHJlYnVpbGQoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkgPSB0aGlzLmNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KClcbiAgICAgICAgICAgIC5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LmhpZGUoKTtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnRvZ2dsZSgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBjb25maWd1cmVEeW5hbWljT3ZlcmxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyXG4gICAgICAgICAgICAucG9zaXRpb24odGhpcy5wb3NpdGlvbilcbiAgICAgICAgICAgIC50cmlnZ2VyKHRoaXMudHJpZ2dlcilcbiAgICAgICAgICAgIC5vZmZzZXQodGhpcy5vZmZzZXQpXG4gICAgICAgICAgICAuYWRqdXN0bWVudCh0aGlzLmFkanVzdG1lbnQpXG4gICAgICAgICAgICAuY29udGVudCh0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICAuY29udGV4dCh0aGlzLmNvbnRleHQpXG4gICAgICAgICAgICAub3ZlcmxheUNvbmZpZyh0aGlzLm92ZXJsYXlDb25maWcpO1xuICAgIH1cbn1cbk5iUG9wb3ZlckRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iUG9wb3Zlcl0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmJQb3BvdmVyJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOYkR5bmFtaWNPdmVybGF5SGFuZGxlciwgTmJEeW5hbWljT3ZlcmxheV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iUG9wb3ZlckRpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyIH1cbl07XG5OYlBvcG92ZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29udGVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJQb3BvdmVyJyxdIH1dLFxuICAgIGNvbnRleHQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iUG9wb3ZlckNvbnRleHQnLF0gfV0sXG4gICAgcG9zaXRpb246IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iUG9wb3ZlclBsYWNlbWVudCcsXSB9XSxcbiAgICBhZGp1c3RtZW50OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlBvcG92ZXJBZGp1c3RtZW50JyxdIH1dLFxuICAgIHRyaWdnZXI6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iUG9wb3ZlclRyaWdnZXInLF0gfV0sXG4gICAgb2Zmc2V0OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlBvcG92ZXJPZmZzZXQnLF0gfV0sXG4gICAgcG9wb3ZlckNsYXNzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlBvcG92ZXJDbGFzcycsXSB9XSxcbiAgICBuYlBvcG92ZXJTaG93U3RhdGVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJQb3BvdmVyTW9kdWxlIHtcbn1cbk5iUG9wb3Zlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW05iT3ZlcmxheU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJQb3BvdmVyRGlyZWN0aXZlLCBOYlBvcG92ZXJDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYlBvcG92ZXJEaXJlY3RpdmVdLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW05iUG9wb3ZlckNvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBDb250ZXh0IG1lbnUgY29tcG9uZW50IHVzZWQgYXMgY29udGVudCB3aXRoaW4gTmJDb250ZXh0TWVudURpcmVjdGl2ZS5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY29udGV4dC1tZW51LWJhY2tncm91bmQtY29sb3I6XG4gKiBjb250ZXh0LW1lbnUtYm9yZGVyLWNvbG9yOlxuICogY29udGV4dC1tZW51LWJvcmRlci1zdHlsZTpcbiAqIGNvbnRleHQtbWVudS1ib3JkZXItd2lkdGg6XG4gKiBjb250ZXh0LW1lbnUtYm9yZGVyLXJhZGl1czpcbiAqIGNvbnRleHQtbWVudS10ZXh0LWFsaWduOlxuICogY29udGV4dC1tZW51LW1pbi13aWR0aDpcbiAqIGNvbnRleHQtbWVudS1tYXgtd2lkdGg6XG4gKiBjb250ZXh0LW1lbnUtc2hhZG93OlxuICogKi9cbmNsYXNzIE5iQ29udGV4dE1lbnVDb21wb25lbnQgZXh0ZW5kcyBOYlBvc2l0aW9uZWRDb250YWluZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHsgaXRlbXM6IFtdIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgaXMgZW1wdHkgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBhZGRpdGlvbmFsbHlcbiAgICAgKiByZW5kZXIgaXMgaGFuZGxlZCBieSBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICovXG4gICAgcmVuZGVyQ29udGVudCgpIHsgfVxufVxuTmJDb250ZXh0TWVudUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY29udGV4dC1tZW51JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1tZW51IGNsYXNzPVwiY29udGV4dC1tZW51XCIgW2l0ZW1zXT1cImNvbnRleHQuaXRlbXNcIiBbdGFnXT1cImNvbnRleHQudGFnXCI+PC9uYi1tZW51PlxuICBgXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ29udGV4dE1lbnVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaXRlbXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhZzogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29udGV4dDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogRnVsbCBmZWF0dXJlZCBjb250ZXh0IG1lbnUgZGlyZWN0aXZlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEp1c3QgcGFzcyBtZW51IGl0ZW1zIGFycmF5OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gW25iQ29udGV4dE1lbnVdPVwiaXRlbXNcIj48L2J1dHRvbj5cbiAqIC4uLlxuICogaXRlbXMgPSBbeyB0aXRsZTogJ1Byb2ZpbGUnIH0sIHsgdGl0bGU6ICdMb2cgb3V0JyB9XTtcbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJDb250ZXh0TWVudU1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJDb250ZXh0TWVudU1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogQWxzbyBtYWtlIHN1cmUgYE5iTWVudU1vZHVsZWAgaXMgaW1wb3J0ZWQgdG8geW91ciBgYXBwLm1vZHVsZWAuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTWVudU1vZHVsZS5mb3JSb290KCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBjb250ZXh0IG1lbnUgY2xpY2tzIHlvdSBoYXZlIHRvIHBhc3MgYG5iQ29udGV4dE1lbnVUYWdgXG4gKiBwYXJhbSBhbmQgcmVnaXN0ZXIgdG8gZXZlbnRzIHVzaW5nIE5iTWVudVNlcnZpY2UuXG4gKiBgTmJDb250ZXh0TWVudWAgcmVuZGVycyBwbGFpbiBgTmJNZW51YCBpbnNpZGUsIHNvXG4gKiB5b3UgaGF2ZSB0byB3b3JrIHdpdGggaXQganVzdCBsaWtlIHdpdGggYE5iTWVudWAgY29tcG9uZW50OlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWVudSBpdGVtIGNsaWNrLCBjb250ZXh0LW1lbnUvY29udGV4dC1tZW51LWNsaWNrLmNvbXBvbmVudClcbiAqXG4gKiBDb250ZXh0IG1lbnUgaGFzIGRpZmZlcmVudCBwbGFjZW1lbnRzLCBzdWNoIGFzOiB0b3AsIGJvdHRvbSwgbGVmdCBhbmQgcmlnaHRcbiAqIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGZvbGxvd2luZzpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYkNvbnRleHRNZW51XT1cIml0ZW1zXCIgbmJDb250ZXh0TWVudVBsYWNlbWVudD1cInJpZ2h0XCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICogaXRlbXMgPSBbeyB0aXRsZTogJ1Byb2ZpbGUnIH0sIHsgdGl0bGU6ICdMb2cgb3V0JyB9XTtcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgY29udGV4dCBtZW51IHdpbGwgdHJ5IHRvIGFkanVzdCBpdHNlbGYgdG8gbWF4aW1hbGx5IGZpdCB2aWV3cG9ydFxuICogYW5kIHByb3ZpZGUgdGhlIGJlc3QgdXNlciBleHBlcmllbmNlLiBJdCB3aWxsIHRyeSB0byBjaGFuZ2UgcG9zaXRpb24gb2YgdGhlIGNvbnRleHQgbWVudS5cbiAqIElmIHlvdSB3YW5uYSBkaXNhYmxlIHRoaXMgYmVoYXZpb3VyIGp1c3Qgc2V0IGl0IGZhbHN5IHZhbHVlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gW25iQ29udGV4dE1lbnVdPVwiaXRlbXNcIiBuYkNvbnRleHRNZW51QWRqdXN0bWVudD1cImNvdW50ZXJjbG9ja3dpc2VcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiBpdGVtcyA9IFt7IHRpdGxlOiAnUHJvZmlsZScgfSwgeyB0aXRsZTogJ0xvZyBvdXQnIH1dO1xuICogYGBgXG4gKiBDb250ZXh0IG1lbnUgaGFzIGEgbnVtYmVyIG9mIHRyaWdnZXJzIHdoaWNoIHByb3ZpZGVzIGFuIGFiaWxpdHkgdG8gc2hvdyBhbmQgaGlkZSB0aGUgY29tcG9uZW50IGluIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gQ2xpY2sgbW9kZSBzaG93cyB0aGUgY29tcG9uZW50IHdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBoaWRlcyB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogc29tZXdoZXJlIG9uIHRoZSBkb2N1bWVudCBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gKiAtIEhpbnQgcHJvdmlkZXMgY2FwYWJpbGl0eSB0byBzaG93IHRoZSBjb21wb25lbnQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50XG4gKiBhbmQgaGlkZSB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdXQgb2YgdGhlIGhvc3QuXG4gKiAtIEhvdmVyIHdvcmtzIGxpa2UgaGludCBtb2RlIHdpdGggb25lIGV4Y2VwdGlvbiAtIHdoZW4gdGhlIHVzZXIgbW92ZXMgbW91c2UgZnJvbSBob3N0IGVsZW1lbnQgdG9cbiAqIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGUgY29tcG9uZW50IHJlbWFpbnMgb3Blbiwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0IGNvbnRlbnQuXG4gKiAtIEZvY3VzIG1vZGUgaXMgYXBwbGllZCB3aGVuIHVzZXIgZm9jdXNlcyB0aGUgZWxlbWVudC5cbiAqIC0gTm9vcCBtb2RlIC0gdGhlIGNvbXBvbmVudCB3b24ndCByZWFjdCB0byB0aGUgdXNlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YWlsYWJsZSBUcmlnZ2VycywgY29udGV4dC1tZW51L2NvbnRleHQtbWVudS1tb2Rlcy5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBOb29wIG1vZGUgaXMgZXNwZWNpYWxseSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBjb250cm9sIFBvcG92ZXIgcHJvZ3JhbW1hdGljYWxseSwgZm9yIGV4YW1wbGUgc2hvdy9oaWRlXG4gKiBhcyBhIHJlc3VsdCBvZiBzb21lIHRoaXJkLXBhcnR5IGFjdGlvbiwgbGlrZSBIVFRQIHJlcXVlc3Qgb3IgdmFsaWRhdGlvbiBjaGVjazpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1hbnVhbCBDb250cm9sLCBjb250ZXh0LW1lbnUvY29udGV4dC1tZW51LW5vb3AuY29tcG9uZW50KVxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWFudWFsIENvbnRyb2wsIGNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtcmlnaHQtY2xpY2suY29tcG9uZW50KVxuICogKi9cbmNsYXNzIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYsIG1lbnVTZXJ2aWNlLCBkeW5hbWljT3ZlcmxheUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5tZW51U2VydmljZSA9IG1lbnVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlciA9IGR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUhvc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IE5iUG9zaXRpb24uQk9UVE9NO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgYmUgY2hhbmdlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgc3RyYXRlZ3kgaWYgY29udGFpbmVyIGNhbid0IGZpdCB2aWV3IHBvcnQuXG4gICAgICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGFueSBmYWxzeSB2YWx1ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgYWRqdXN0bWVudC5cbiAgICAgICAgICogQXZhaWxhYmxlIHZhbHVlczogY2xvY2t3aXNlLCBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmFkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuQ0xPQ0tXSVNFO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHdoZW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBBdmFpbGFibGUgb3B0aW9uczogYGNsaWNrYCwgYGhvdmVyYCwgYGhpbnRgLCBgZm9jdXNgIGFuZCBgbm9vcGBcbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyID0gTmJUcmlnZ2VyLkNMSUNLO1xuICAgICAgICB0aGlzLl9jb250ZXh0TWVudUNsYXNzID0gJyc7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbmZpZyA9IHsgcGFuZWxDbGFzczogdGhpcy5jb250ZXh0TWVudUNsYXNzIH07XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRleHQgPSB7IGl0ZW1zOiB0aGlzLml0ZW1zLCB0YWc6IHRoaXMudGFnLCBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbiB9O1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICAgKiBDYW4gYmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0LlxuICAgICAqICovXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfVxuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXlDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IE5iTWVudSB0YWcsIHdoaWNoIGhlbHBzIGlkZW50aWZ5IG1lbnUgd2hlbiB3b3JraW5nIHdpdGggTmJNZW51U2VydmljZS5cbiAgICAgKiAqL1xuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuICAgIHNldCB0YWcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRhZykge1xuICAgICAgICAgICAgdGhpcy5fdGFnID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXlDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzaWMgbWVudSBpdGVtcywgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGludGVybmFsIE5iTWVudUNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cbiAgICBzZXQgaXRlbXMoaXRlbXMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUl0ZW1zKGl0ZW1zKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5Q29udGV4dCgpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGNvbnRleHRNZW51Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0TWVudUNsYXNzO1xuICAgIH1cbiAgICBzZXQgY29udGV4dE1lbnVDbGFzcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuY29udGV4dE1lbnVDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnVDbGFzcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5Q29uZmlnID0geyBwYW5lbENsYXNzOiB0aGlzLmNvbnRleHRNZW51Q2xhc3MgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5ob3N0KHRoaXMuaG9zdFJlZilcbiAgICAgICAgICAgIC5jb21wb25lbnRUeXBlKE5iQ29udGV4dE1lbnVDb21wb25lbnQpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25JdGVtQ2xpY2soKTtcbiAgICB9XG4gICAgcmVidWlsZCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKVxuICAgICAgICAgICAgLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zaG93KCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuaGlkZSgpO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkudG9nZ2xlKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5wb3NpdGlvbih0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgLnRyaWdnZXIodGhpcy50cmlnZ2VyKVxuICAgICAgICAgICAgLmFkanVzdG1lbnQodGhpcy5hZGp1c3RtZW50KVxuICAgICAgICAgICAgLmNvbnRleHQodGhpcy5vdmVybGF5Q29udGV4dClcbiAgICAgICAgICAgIC5vdmVybGF5Q29uZmlnKHRoaXMub3ZlcmxheUNvbmZpZyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogTmJNZW51Q29tcG9uZW50IHdpbGwgY3Jhc2ggaWYgZG9uJ3QgcGFzcyBtZW51IGl0ZW1zIHRvIGl0LlxuICAgICAqIFNvLCB3ZSBqdXN0IHZhbGlkYXRpbmcgdGhlbSBhbmQgdGhyb3cgY3VzdG9tIG9idmlvdXMgZXJyb3IuXG4gICAgICogKi9cbiAgICB2YWxpZGF0ZUl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYExpc3Qgb2YgbWVudSBpdGVtcyBleHBlY3RlZCwgYnV0IGdpdmVuOiAke2l0ZW1zfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZU9uSXRlbUNsaWNrKCkge1xuICAgICAgICB0aGlzLm1lbnVTZXJ2aWNlLm9uSXRlbUNsaWNrKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyB0YWcgfSkgPT4gdGFnID09PSB0aGlzLnRhZyksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5oaWRlKCkpO1xuICAgIH1cbiAgICB1cGRhdGVPdmVybGF5Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGV4dCA9IHsgaXRlbXM6IHRoaXMuaXRlbXMsIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLCB0YWc6IHRoaXMudGFnIH07XG4gICAgfVxufVxuTmJDb250ZXh0TWVudURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iQ29udGV4dE1lbnVdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOYkR5bmFtaWNPdmVybGF5SGFuZGxlciwgTmJEeW5hbWljT3ZlcmxheV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ29udGV4dE1lbnVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOYk1lbnVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkR5bmFtaWNPdmVybGF5SGFuZGxlciB9XG5dO1xuTmJDb250ZXh0TWVudURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb250ZXh0TWVudUhvc3Q6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmNvbnRleHQtbWVudS1ob3N0JyxdIH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkNvbnRleHRNZW51UGxhY2VtZW50JyxdIH1dLFxuICAgIGFkanVzdG1lbnQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iQ29udGV4dE1lbnVBZGp1c3RtZW50JyxdIH1dLFxuICAgIHRhZzogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJDb250ZXh0TWVudVRhZycsXSB9XSxcbiAgICBpdGVtczogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJDb250ZXh0TWVudScsXSB9XSxcbiAgICB0cmlnZ2VyOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkNvbnRleHRNZW51VHJpZ2dlcicsXSB9XSxcbiAgICBjb250ZXh0TWVudUNsYXNzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkNvbnRleHRNZW51Q2xhc3MnLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iQ29udGV4dE1lbnVNb2R1bGUge1xufVxuTmJDb250ZXh0TWVudU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTmJPdmVybGF5TW9kdWxlLCBOYk1lbnVNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYkNvbnRleHRNZW51RGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYkNvbnRleHRNZW51RGlyZWN0aXZlLCBOYkNvbnRleHRNZW51Q29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYkNvbnRleHRNZW51Q29tcG9uZW50XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFByb2dyZXNzIEJhciBpcyBhIGNvbXBvbmVudCBmb3IgaW5kaWNhdGluZyBwcm9ncmVzcy5cbiAqXG4gKiBTaW1wbGUgdXNhZ2U6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLXByb2dyZXNzLWJhciBbdmFsdWVdPVwiNTBcIj48L25iLXByb2dyZXNzLWJhcj5cbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJQcm9ncmVzc0Jhck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJQcm9ncmVzc0Jhck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogUHJvZ3Jlc3MgYmFyIGFjY2VwdHMgcHJvcGVydHkgYHZhbHVlYCBpbiByYW5nZSAwLTEwMFxuICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFByb2dyZXNzIGJhciBiYWNrZ3JvdW5kIGNvdWxkIGJlIGNvbmZpZ3VyZWQgYnkgcHJvdmlkaW5nIGEgYHN0YXR1c2AgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFByb2dyZXNzIGJhciBzdGF0dXMsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItc3RhdHVzLmNvbXBvbmVudClcbiAqXG4gKiBQcm9ncmVzcyBiYXIgc2l6ZSAoaGVpZ2h0IGFuZCBmb250LXNpemUpIGNvdWxkIGJlIGNvbmZpZ3VyZWQgYnkgcHJvdmlkaW5nIGEgYHNpemVgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIgc2l6ZSwgcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci1zaXplLmNvbXBvbmVudClcbiAqXG4gKiBgZGlzcGxheVZhbHVlYCBwcm9wZXJ0eSBzaG93cyBjdXJyZW50IHZhbHVlIGluc2lkZSBwcm9ncmVzcyBiYXIuIEl0J3MgYWxzbyBwb3NzaWJsZSB0byBhZGQgY3VzdG9tIHRleHQgaW5zaWRlOlxuICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIgdmFsdWUsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItdmFsdWUuY29tcG9uZW50KVxuICpcbiAqIFByb2dyZXNzIGJhciBzdXBwb3J0cyBgd2lkdGhgIGFuZCBgYmFja2dyb3VuZC1jb2xvcmAgdHJhbnNpdGlvbjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUHJvZ3Jlc3MgYmFyIGludGVyYWN0aXZlLCBwcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLWludGVyYWN0aXZlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogcHJvZ3Jlc3MtYmFyLWFuaW1hdGlvbi1kdXJhdGlvbjpcbiAqIHByb2dyZXNzLWJhci1ib3JkZXItcmFkaXVzOlxuICogcHJvZ3Jlc3MtYmFyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBwcm9ncmVzcy1iYXItdGlueS1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItdGlueS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHByb2dyZXNzLWJhci10aW55LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItdGlueS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLXNtYWxsLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHByb2dyZXNzLWJhci1zbWFsbC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItbWVkaXVtLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1tZWRpdW0tdGV4dC1mb250LXNpemU6XG4gKiBwcm9ncmVzcy1iYXItbWVkaXVtLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItbWVkaXVtLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItbGFyZ2UtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLWxhcmdlLXRleHQtZm9udC1zaXplOlxuICogcHJvZ3Jlc3MtYmFyLWxhcmdlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItbGFyZ2UtdGV4dC1saW5lLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1naWFudC1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBwcm9ncmVzcy1iYXItZ2lhbnQtdGV4dC1mb250LXdlaWdodDpcbiAqIHByb2dyZXNzLWJhci1naWFudC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItYmFzaWMtZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItcHJpbWFyeS1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3MtZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1pbmZvLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWluZm8tdGV4dC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItd2FybmluZy1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItZGFuZ2VyLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWRhbmdlci10ZXh0LWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1jb250cm9sLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJQcm9ncmVzc0JhckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZ3Jlc3MgYmFyIHZhbHVlIGluIHBlcmNlbnQgKDAgLSAxMDApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2dyZXNzIGJhciBiYWNrZ3JvdW5kIChgYmFzaWNgIChkZWZhdWx0KSwgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZ3Jlc3MgYmFyIHNpemUgKGB0aW55YCwgYHNtYWxsYCwgYG1lZGl1bWAgKGRlZmF1bHQpLCBgbGFyZ2VgLCBgZ2lhbnRgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gJ21lZGl1bSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5cyB2YWx1ZSBpbnNpZGUgcHJvZ3Jlc3MgYmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgYWRkaXRpb25hbENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1NlcnZpY2UuaXNDdXN0b21TdGF0dXModGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RhdHVzU2VydmljZS5nZXRTdGF0dXNDbGFzcyh0aGlzLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5OYlByb2dyZXNzQmFyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1wcm9ncmVzcy1iYXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLXZhbHVlXCIgW3N0eWxlLndpZHRoLiVdPVwidmFsdWVcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJkaXNwbGF5VmFsdWVcIj57eyB2YWx1ZSB9fSU8L3NwYW4+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9ja30ucHJvZ3Jlc3MtY29udGFpbmVye292ZXJmbG93OmhpZGRlbn0ucHJvZ3Jlc3MtdmFsdWV7aGVpZ2h0OjEwMCU7dGV4dC1hbGlnbjpjZW50ZXI7b3ZlcmZsb3c6aGlkZGVufVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlByb2dyZXNzQmFyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlByb2dyZXNzQmFyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc3BsYXlWYWx1ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYlByb2dyZXNzQmFyTW9kdWxlIHtcbn1cbk5iUHJvZ3Jlc3NCYXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlByb2dyZXNzQmFyQ29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTmJQcm9ncmVzc0JhckNvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBBbGVydCBjb21wb25lbnQuXG4gKlxuICogQmFzaWMgYWxlcnQgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGFsZXJ0L2FsZXJ0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBBbGVydCBjb25maWd1cmF0aW9uOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1hbGVydCBzdGF0dXM9XCJzdWNjZXNzXCI+XG4gKiAgIFlvdSBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IGF1dGhlbnRpY2F0ZWQhXG4gKiA8L25iLWFsZXJ0PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkFsZXJ0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkFsZXJ0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBBbGVydCBjb3VsZCBhZGRpdGlvbmFsbHkgaGF2ZSBhIGBjbG9zZWAgYnV0dG9uIHdoZW4gYGNsb3NhYmxlYCBwcm9wZXJ0eSBpcyBzZXQ6XG4gKiBgYGBodG1sXG4gKiA8bmItYWxlcnQgc3RhdHVzPVwic3VjY2Vzc1wiIGNsb3NhYmxlIChjbG9zZSk9XCJvbkNsb3NlKClcIj5cbiAqICAgWW91IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlZCFcbiAqIDwvbmItYWxlcnQ+XG4gKiBgYGBcbiAqXG4gKiBDb2xvcmVkIGFsZXJ0cyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWxlcnQgc3RhdHVzLCBhbGVydC9hbGVydC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXNzaWduIGFuIGBhY2NlbnRgIHByb3BlcnR5IGZvciBhIHNsaWdodCBhbGVydCBoaWdobGlnaHRcbiAqIGFzIHdlbGwgYXMgY29tYmluZSBpdCB3aXRoIGBzdGF0dXNgOlxuICogQHN0YWNrZWQtZXhhbXBsZShBbGVydCBhY2NlbnQsIGFsZXJ0L2FsZXJ0LWFjY2VudHMuY29tcG9uZW50KVxuICpcbiAqIEFuZCBgb3V0bGluZWAgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKE91dGxpbmUgQWxlcnQsIGFsZXJ0L2FsZXJ0LW91dGxpbmUuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIGFsZXJ0L2FsZXJ0LXNpemVzLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogYWxlcnQtYm9yZGVyLXJhZGl1czpcbiAqIGFsZXJ0LWJvdHRvbS1tYXJnaW46XG4gKiBhbGVydC1wYWRkaW5nOlxuICogYWxlcnQtc2Nyb2xsYmFyLWNvbG9yOlxuICogYWxlcnQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1zY3JvbGxiYXItd2lkdGg6XG4gKiBhbGVydC1zaGFkb3c6XG4gKiBhbGVydC10ZXh0LWZvbnQtZmFtaWx5OlxuICogYWxlcnQtdGV4dC1mb250LXNpemU6XG4gKiBhbGVydC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYWxlcnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGFsZXJ0LWNsb3NhYmxlLXN0YXJ0LXBhZGRpbmc6XG4gKiBhbGVydC10aW55LWhlaWdodDpcbiAqIGFsZXJ0LXNtYWxsLWhlaWdodDpcbiAqIGFsZXJ0LW1lZGl1bS1oZWlnaHQ6XG4gKiBhbGVydC1tZWRpdW0tcGFkZGluZzpcbiAqIGFsZXJ0LWxhcmdlLWhlaWdodDpcbiAqIGFsZXJ0LWdpYW50LWhlaWdodDpcbiAqIGFsZXJ0LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1iYXNpYy10ZXh0LWNvbG9yOlxuICogYWxlcnQtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogYWxlcnQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogYWxlcnQtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtaW5mby10ZXh0LWNvbG9yOlxuICogYWxlcnQtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtd2FybmluZy10ZXh0LWNvbG9yOlxuICogYWxlcnQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGFsZXJ0LWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGFsZXJ0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1iYXNpYy1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1wcmltYXJ5LWNvbG9yOlxuICogYWxlcnQtYWNjZW50LWluZm8tY29sb3I6XG4gKiBhbGVydC1hY2NlbnQtc3VjY2Vzcy1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC13YXJuaW5nLWNvbG9yOlxuICogYWxlcnQtYWNjZW50LWRhbmdlci1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1jb250cm9sLWNvbG9yOlxuICogYWxlcnQtb3V0bGluZS13aWR0aDpcbiAqIGFsZXJ0LW91dGxpbmUtYmFzaWMtY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXByaW1hcnktY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLWluZm8tY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXN1Y2Nlc3MtY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXdhcm5pbmctY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLWRhbmdlci1jb2xvcjpcbiAqIGFsZXJ0LW91dGxpbmUtY29udHJvbC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJBbGVydENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxlcnQgc2l6ZSwgYXZhaWxhYmxlIHNpemVzOlxuICAgICAgICAgKiBgdGlueWAsIGBzbWFsbGAsIGBtZWRpdW1gLCBgbGFyZ2VgLCBgZ2lhbnRgXG4gICAgICAgICAqIFVuc2V0IGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsZXJ0IHN0YXR1cyAoYWRkcyBzcGVjaWZpYyBzdHlsZXMpOlxuICAgICAgICAgKiBgYmFzaWNgIChkZWZhdWx0KSwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxlcnQgYWNjZW50IChjb2xvciBvZiB0aGUgdG9wIGJvcmRlcik6XG4gICAgICAgICAqIGBiYXNpY2AsIGBwcmltYXJ5YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYC5cbiAgICAgICAgICogVW5zZXQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZW50ID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGVydCBvdXRsaW5lIChjb2xvciBvZiB0aGUgYm9yZGVyKTpcbiAgICAgICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKiBVbnNldCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdXRsaW5lID0gJyc7XG4gICAgICAgIHRoaXMuX2Nsb3NhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGNoaXAgaXMgcmVtb3ZlZFxuICAgICAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8YW55PlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgYGNsb3NlYCBpY29uXG4gICAgICovXG4gICAgZ2V0IGNsb3NhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2FibGU7XG4gICAgfVxuICAgIHNldCBjbG9zYWJsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jbG9zYWJsZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRoZSByZW1vdmVkIGNoaXAgZXZlbnRcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnlBY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgc3VjY2Vzc0FjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCBpbmZvQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmdBY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWNBY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xBY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeU91dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmUgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3NPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCBpbmZvT3V0bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZSA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZ091dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmUgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlck91dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmUgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWNPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbE91dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmUgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuTmJBbGVydENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYWxlcnQnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiAqbmdJZj1cImNsb3NhYmxlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIiAoY2xpY2spPVwib25DbG9zZSgpXCI+XG4gICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47cG9zaXRpb246cmVsYXRpdmV9W2Rpcj1sdHJdIDpob3N0IC5jbG9zZXtyaWdodDowfVtkaXI9cnRsXSA6aG9zdCAuY2xvc2V7bGVmdDowfS5jbG9zZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtjb2xvcjppbmhlcml0O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjA7YXBwZWFyYW5jZTpub25lfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkFsZXJ0Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYkFsZXJ0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYWNjZW50OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvdXRsaW5lOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjbG9zYWJsZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5jbG9zYWJsZScsXSB9XSxcbiAgICBjbG9zZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHRpbnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtdGlueScsXSB9XSxcbiAgICBzbWFsbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1zbWFsbCcsXSB9XSxcbiAgICBtZWRpdW06IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbWVkaXVtJyxdIH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dLFxuICAgIGdpYW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWdpYW50JyxdIH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIHByaW1hcnlBY2NlbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY2VudC1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3NBY2NlbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY2VudC1zdWNjZXNzJyxdIH1dLFxuICAgIGluZm9BY2NlbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY2VudC1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmdBY2NlbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY2VudC13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlckFjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LWRhbmdlcicsXSB9XSxcbiAgICBiYXNpY0FjY2VudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWNjZW50LWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2xBY2NlbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY2VudC1jb250cm9sJyxdIH1dLFxuICAgIHByaW1hcnlPdXRsaW5lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5vdXRsaW5lLXByaW1hcnknLF0gfV0sXG4gICAgc3VjY2Vzc091dGxpbmU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm91dGxpbmUtc3VjY2VzcycsXSB9XSxcbiAgICBpbmZvT3V0bGluZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Mub3V0bGluZS1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmdPdXRsaW5lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5vdXRsaW5lLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyT3V0bGluZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Mub3V0bGluZS1kYW5nZXInLF0gfV0sXG4gICAgYmFzaWNPdXRsaW5lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5vdXRsaW5lLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2xPdXRsaW5lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5vdXRsaW5lLWNvbnRyb2wnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkFsZXJ0TW9kdWxlIHtcbn1cbk5iQWxlcnRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJBbGVydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJBbGVydENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ2hhdCBmb3JtIGNvbXBvbmVudC5cbiAqXG4gKiBTaG93IGEgbWVzc2FnZSBmb3JtIHdpdGggYSBzZW5kIG1lc3NhZ2UgYnV0dG9uLlxuICpcbiAqIGBgYHRzXG4gKiA8bmItY2hhdC1mb3JtIHNob3dCdXR0b249XCJ0cnVlXCIgYnV0dG9uSWNvbj1cIm5iLXNlbmRcIj5cbiAqIDwvbmItY2hhdC1mb3JtPlxuICogYGBgXG4gKlxuICogV2hlbiBgW2Ryb3BGaWxlc109XCJ0cnVlXCJgIGhhbmRsZXMgZmlsZXMgZHJhZyZkcm9wIHdpdGggYSBmaWxlIHByZXZpZXcuXG4gKlxuICogRHJhZyAmIGRyb3AgYXZhaWxhYmxlIGZvciBmaWxlcyBhbmQgaW1hZ2VzOlxuICogQHN0YWNrZWQtZXhhbXBsZShEcmFnICYgRHJvcCBDaGF0LCBjaGF0L2NoYXQtZHJvcC5jb21wb25lbnQpXG4gKlxuICogTmV3IG1lc3NhZ2UgY291bGQgYmUgdHJhY2tlZCBvdXRzaWRlIGJ5IHVzaW5nIGAoc2VuZClgIG91dHB1dC5cbiAqXG4gKiBgYGB0c1xuICogPG5iLWNoYXQtZm9ybSAoc2VuZCk9XCJvbk5ld01lc3NhZ2UoJGV2ZW50KVwiPlxuICogPC9uYi1jaGF0LWZvcm0+XG4gKlxuICogLy8gLi4uXG4gKlxuICogb25OZXdNZXNzYWdlKHsgbWVzc2FnZTogc3RyaW5nLCBmaWxlczogYW55W10gfSkge1xuICogICB0aGlzLnNlcnZpY2Uuc2VuZFRvU2VydmVyKG1lc3NhZ2UsIGZpbGVzKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBOYkNoYXRGb3JtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZCwgZG9tU2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5kb21TYW5pdGl6ZXIgPSBkb21TYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy5pbnB1dEZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5wdXRIb3ZlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyb3BwZWRGaWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmltZ0Ryb3BUeXBlcyA9IFsnaW1hZ2UvcG5nJywgJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvZ2lmJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVkZWZpbmVkIG1lc3NhZ2UgdGV4dFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXNzYWdlIHBsYWNlaG9sZGVyIHRleHRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWVzc2FnZVBsYWNlaG9sZGVyID0gJ1R5cGUgYSBtZXNzYWdlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgYnV0dG9uIHRpdGxlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1dHRvblRpdGxlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGJ1dHRvbiBpY29uLCBzaG93biBpZiBgYnV0dG9uVGl0bGVgIGlzIGVtcHR5XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1dHRvbkljb24gPSAncGFwZXItcGxhbmUtb3V0bGluZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHNlbmQgYnV0dG9uXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93QnV0dG9uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgc2VuZCBidXR0b25cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyb3BGaWxlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlsZSBkcm9wIHBsYWNlaG9sZGVyIHRleHRcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJvcEZpbGVQbGFjZWhvbGRlciA9ICdEcm9wIGZpbGUgdG8gc2VuZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPHsgbWVzc2FnZTogc3RyaW5nLCBmaWxlczogRmlsZVtdIH0+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmZpbGVPdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIG9uRHJvcChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcm9wRmlsZXMpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZU92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIgJiYgZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmaWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbWdEcm9wVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuc3JjID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy51cmxTdHlsZSA9IHRoaXMuZG9tU2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShgdXJsKCR7cmVzLnNyY30pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRGaWxlcy5wdXNoKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUZpbGUoZmlsZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZHJvcHBlZEZpbGVzLmluZGV4T2YoZmlsZSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3BwZWRGaWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRHJhZ092ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BGaWxlcykge1xuICAgICAgICAgICAgdGhpcy5maWxlT3ZlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25EcmFnTGVhdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BGaWxlcykge1xuICAgICAgICAgICAgdGhpcy5maWxlT3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5kcm9wcGVkRmlsZXMubGVuZ3RoIHx8IFN0cmluZyh0aGlzLm1lc3NhZ2UpLnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZC5lbWl0KHsgbWVzc2FnZTogdGhpcy5tZXNzYWdlLCBmaWxlczogdGhpcy5kcm9wcGVkRmlsZXMgfSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZHJvcHBlZEZpbGVzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IHN0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbnB1dFN0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZU92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhpZ2hsaWdodFN0YXR1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlucHV0Rm9jdXMgfHwgdGhpcy5pbnB1dEhvdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdiYXNpYyc7XG4gICAgfVxuICAgIGdldEJ1dHRvblN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGlnaGxpZ2h0U3RhdHVzKCk7XG4gICAgfVxuICAgIGdldEhpZ2hsaWdodFN0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAnYmFzaWMnIHx8IHRoaXMuc3RhdHVzID09PSAnY29udHJvbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAncHJpbWFyeSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzO1xuICAgIH1cbn1cbk5iQ2hhdEZvcm1Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNoYXQtZm9ybScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiZHJvcHBlZC1maWxlc1wiICpuZ0lmPVwiZHJvcHBlZEZpbGVzPy5sZW5ndGhcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGZpbGUgb2YgZHJvcHBlZEZpbGVzXCI+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJmaWxlLnVybFN0eWxlXCIgW3N0eWxlLmJhY2tncm91bmQtaW1hZ2VdPVwiZmlsZS51cmxTdHlsZVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmVtb3ZlXCIgKGNsaWNrKT1cInJlbW92ZUZpbGUoZmlsZSlcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxuYi1pY29uICpuZ0lmPVwiIWZpbGUudXJsU3R5bGVcIiBpY29uPVwiZmlsZS10ZXh0LW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmVtb3ZlXCIgKGNsaWNrKT1cInJlbW92ZUZpbGUoZmlsZSlcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLXJvd1wiPlxuICAgICAgPGlucHV0IG5iSW5wdXRcbiAgICAgICAgICAgICBmdWxsV2lkdGhcbiAgICAgICAgICAgICBbc3RhdHVzXT1cImdldElucHV0U3RhdHVzKClcIlxuICAgICAgICAgICAgIChmb2N1cyk9XCJpbnB1dEZvY3VzID0gdHJ1ZVwiXG4gICAgICAgICAgICAgKGJsdXIpPVwiaW5wdXRGb2N1cyA9IGZhbHNlXCJcbiAgICAgICAgICAgICAobW91c2VlbnRlcik9XCJpbnB1dEhvdmVyID0gdHJ1ZVwiXG4gICAgICAgICAgICAgKG1vdXNlbGVhdmUpPVwiaW5wdXRIb3ZlciA9IGZhbHNlXCJcbiAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1lc3NhZ2VcIlxuICAgICAgICAgICAgIFtjbGFzcy53aXRoLWJ1dHRvbl09XCJzaG93QnV0dG9uXCJcbiAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7eyBmaWxlT3ZlciA/IGRyb3BGaWxlUGxhY2Vob2xkZXIgOiBtZXNzYWdlUGxhY2Vob2xkZXIgfX1cIlxuICAgICAgICAgICAgIChrZXl1cC5lbnRlcik9XCJzZW5kTWVzc2FnZSgpXCI+XG4gICAgICA8YnV0dG9uIG5iQnV0dG9uXG4gICAgICAgICAgICAgIFtzdGF0dXNdPVwiZ2V0QnV0dG9uU3RhdHVzKClcIlxuICAgICAgICAgICAgICAqbmdJZj1cInNob3dCdXR0b25cIlxuICAgICAgICAgICAgICBbY2xhc3Mud2l0aC1pY29uXT1cIiFidXR0b25UaXRsZVwiXG4gICAgICAgICAgICAgIChjbGljayk9XCJzZW5kTWVzc2FnZSgpXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJzZW5kLWJ1dHRvblwiPlxuICAgICAgICA8bmItaWNvbiAqbmdJZj1cIiFidXR0b25UaXRsZTsgZWxzZSB0aXRsZVwiIFtpY29uXT1cImJ1dHRvbkljb25cIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICA8bmctdGVtcGxhdGUgI3RpdGxlPnt7IGJ1dHRvblRpdGxlIH19PC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2hhdEZvcm1Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH1cbl07XG5OYkNoYXRGb3JtQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG1lc3NhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG1lc3NhZ2VQbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgYnV0dG9uVGl0bGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJ1dHRvbkljb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dCdXR0b246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRyb3BGaWxlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZHJvcEZpbGVQbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VuZDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGZpbGVPdmVyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5maWxlLW92ZXInLF0gfV0sXG4gICAgb25Ecm9wOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnZHJvcCcsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBvbkRyYWdPdmVyOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnZHJhZ292ZXInLF0gfV0sXG4gICAgb25EcmFnTGVhdmU6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydkcmFnbGVhdmUnLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ2hhdCBtZXNzYWdlIGNvbXBvbmVudC5cbiAqXG4gKiBNdWx0aXBsZSBtZXNzYWdlIHR5cGVzIGFyZSBhdmFpbGFibGUgdGhyb3VnaCBhIGB0eXBlYCBwcm9wZXJ0eSwgc3VjaCBhc1xuICogLSB0ZXh0IC0gc2ltcGxlIHRleHQgbWVzc2FnZVxuICogLSBmaWxlIC0gY291bGQgYmUgYSBmaWxlIHByZXZpZXcgb3IgYSBmaWxlIGljb25cbiAqIGlmIG11bHRpcGxlIGZpbGVzIGFyZSBwcm92aWRlZCBncm91cGVkIGZpbGVzIGFyZSBzaG93blxuICogLSBxdW90ZSAtIHF1b3RlcyBhIG1lc3NhZ2Ugd2l0aCBzcGVjaWZpYyBxdW90ZSBzdHlsZXNcbiAqIC0gbWFwIC0gc2hvd3MgYSBnb29nbGUgbWFwIHBpY3R1cmUgYnkgcHJvdmlkZWQgW2xhdGl0dWRlXSBhbmQgW2xvbmdpdHVkZV0gcHJvcGVydGllc1xuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQXZhaWxhYmxlIFR5cGVzLCBjaGF0L2NoYXQtbWVzc2FnZS10eXBlcy1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogTWVzc2FnZSB3aXRoIGF0dGFjaGVkIGZpbGVzOlxuICogYGBgaHRtbFxuICogPG5iLWNoYXQtbWVzc2FnZVxuICogICB0eXBlPVwiZmlsZVwiXG4gKiAgIFtmaWxlc109XCJbIHsgdXJsOiAnLi4uJyB9IF1cIlxuICogICBtZXNzYWdlPVwiSGVsbG8gd29ybGQhXCI+XG4gKiA8L25iLWNoYXQtbWVzc2FnZT5cbiAqIGBgYFxuICpcbiAqIE1hcCBtZXNzYWdlOlxuICogYGBgaHRtbFxuICogPG5iLWNoYXQtbWVzc2FnZVxuICogICB0eXBlPVwibWFwXCJcbiAqICAgW2xhdGl0dWRlXT1cIjUzLjkxNFwiXG4gKiAgIFtsb25naXR1ZGVdPVwiMjcuNTlcIlxuICogICBtZXNzYWdlPVwiSGVyZSBJIGFtXCI+XG4gKiA8L25iLWNoYXQtbWVzc2FnZT5cbiAqIGBgYFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBjaGF0LW1lc3NhZ2UtYmFja2dyb3VuZDpcbiAqIGNoYXQtbWVzc2FnZS10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXJlcGx5LWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcmVwbHktdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1hdmF0YXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1zZW5kZXItdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1xdW90ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXF1b3RlLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtZmlsZS10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLWZpbGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJDaGF0TWVzc2FnZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZG9tU2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuZG9tU2FuaXRpemVyID0gZG9tU2FuaXRpemVyO1xuICAgICAgICB0aGlzLl9yZXBseSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZmx5SW5PdXQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgbm90UmVwbHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yZXBseTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIG1lc3NhZ2UgaXMgYSByZXBseVxuICAgICAqL1xuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGx5O1xuICAgIH1cbiAgICBzZXQgcmVwbHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVwbHkgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIHNlbmQgYXZhdGFyXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBzZXQgYXZhdGFyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXZhdGFyU3R5bGUgPSB2YWx1ZSA/IHRoaXMuZG9tU2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShgdXJsKCR7dmFsdWV9KWApIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbmRlcikge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLnNlbmRlci5zcGxpdCgnICcpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLm1hcChuID0+IG4uY2hhckF0KDApKS5zcGxpY2UoMCwgMikuam9pbignJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJhdmF0YXJcIiBbc3R5bGUuYmFja2dyb3VuZC1pbWFnZV09XCJhdmF0YXJTdHlsZVwiICpuZ0lmPVwiIXJlcGx5XCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWF2YXRhclN0eWxlXCI+XG4gICAgICAgIHt7IGdldEluaXRpYWxzKCkgfX1cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlXCI+XG4gICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJ0eXBlXCI+XG5cbiAgICAgICAgPG5iLWNoYXQtbWVzc2FnZS1maWxlICpuZ1N3aXRjaENhc2U9XCInZmlsZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCIgW2RhdGVGb3JtYXRdPVwiZGF0ZUZvcm1hdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWVzc2FnZV09XCJtZXNzYWdlXCIgW2ZpbGVzXT1cImZpbGVzXCI+XG4gICAgICAgIDwvbmItY2hhdC1tZXNzYWdlLWZpbGU+XG5cbiAgICAgICAgPG5iLWNoYXQtbWVzc2FnZS1xdW90ZSAqbmdTd2l0Y2hDYXNlPVwiJ3F1b3RlJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VuZGVyXT1cInNlbmRlclwiIFtkYXRlXT1cImRhdGVcIiBbZGF0ZUZvcm1hdF09XCJkYXRlRm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttZXNzYWdlXT1cIm1lc3NhZ2VcIiBbcXVvdGVdPVwicXVvdGVcIj5cbiAgICAgICAgPC9uYi1jaGF0LW1lc3NhZ2UtcXVvdGU+XG5cbiAgICAgICAgPG5iLWNoYXQtbWVzc2FnZS1tYXAgKm5nU3dpdGNoQ2FzZT1cIidtYXAnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW5kZXJdPVwic2VuZGVyXCIgW2RhdGVdPVwiZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWVzc2FnZV09XCJtZXNzYWdlXCIgW2xhdGl0dWRlXT1cImxhdGl0dWRlXCIgW2xvbmdpdHVkZV09XCJsb25naXR1ZGVcIj5cbiAgICAgICAgPC9uYi1jaGF0LW1lc3NhZ2UtbWFwPlxuXG4gICAgICAgIDxuYi1jaGF0LW1lc3NhZ2UtdGV4dCAqbmdTd2l0Y2hEZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VuZGVyXT1cInNlbmRlclwiIFtkYXRlXT1cImRhdGVcIiBbZGF0ZUZvcm1hdF09XCJkYXRlRm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttZXNzYWdlXT1cIm1lc3NhZ2VcIj5cbiAgICAgICAgPC9uYi1jaGF0LW1lc3NhZ2UtdGV4dD5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignZmx5SW5PdXQnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnaW4nLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTEwMCUpJyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDgwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoODAsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMDAlKScgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IERvbVNhbml0aXplciB9XG5dO1xuTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmbHlJbk91dDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnQGZseUluT3V0JyxdIH1dLFxuICAgIG5vdFJlcGx5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5ub3QtcmVwbHknLF0gfV0sXG4gICAgcmVwbHk6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MucmVwbHknLF0gfV0sXG4gICAgbWVzc2FnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VuZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlRm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmaWxlczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcXVvdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxhdGl0dWRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsb25naXR1ZGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGF2YXRhcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdHlwZTogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ29udmVyc2F0aW9uYWwgVUkgY29sbGVjdGlvbiAtIGEgc2V0IG9mIGNvbXBvbmVudHMgZm9yIGNoYXQtbGlrZSBVSSBjb25zdHJ1Y3Rpb24uXG4gKlxuICogTWFpbiBmZWF0dXJlczpcbiAqIC0gZGlmZmVyZW50IG1lc3NhZ2UgdHlwZXMgc3VwcG9ydCAodGV4dCwgaW1hZ2UsIGZpbGUsIGZpbGUgZ3JvdXAsIG1hcCwgZXRjKVxuICogLSBkcmFnICYgZHJvcCBmb3IgaW1hZ2VzIGFuZCBmaWxlcyB3aXRoIHByZXZpZXdcbiAqIC0gZGlmZmVyZW50IFVJIHN0eWxlc1xuICogLSBjdXN0b20gYWN0aW9uIGJ1dHRvbnMgKGNvbWluZyBzb29uKVxuICpcbiAqIEhlcmUncyBhIGNvbXBsZXRlIGV4YW1wbGUgYnVpbGQgaW4gYSBib3QtbGlrZSBhcHAuIFR5cGUgYGhlbHBgIHRvIGJlIGFibGUgdG8gcmVjZWl2ZSBkaWZmZXJlbnQgbWVzc2FnZSB0eXBlcy5cbiAqIEVuam95IHRoZSBjb252ZXJzYXRpb24gYW5kIHRoZSBiZWF1dGlmdWwgVUkuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjaGF0L2NoYXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEJhc2ljIGNoYXQgY29uZmlndXJhdGlvbiBhbmQgdXNhZ2U6XG4gKiBgYGB0c1xuICogPG5iLWNoYXQgdGl0bGU9XCJOZWJ1bGFyIENvbnZlcnNhdGlvbmFsIFVJXCI+XG4gKiAgICAgICA8bmItY2hhdC1tZXNzYWdlICpuZ0Zvcj1cImxldCBtc2cgb2YgbWVzc2FnZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJtc2cudHlwZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFttZXNzYWdlXT1cIm1zZy50ZXh0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3JlcGx5XT1cIm1zZy5yZXBseVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW5kZXJdPVwibXNnLnVzZXIubmFtZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRlXT1cIm1zZy5kYXRlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW2ZpbGVzXT1cIm1zZy5maWxlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtxdW90ZV09XCJtc2cucXVvdGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbGF0aXR1ZGVdPVwibXNnLmxhdGl0dWRlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW2xvbmdpdHVkZV09XCJtc2cubG9uZ2l0dWRlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW2F2YXRhcl09XCJtc2cudXNlci5hdmF0YXJcIj5cbiAqICAgPC9uYi1jaGF0LW1lc3NhZ2U+XG4gKlxuICogICA8bmItY2hhdC1mb3JtIChzZW5kKT1cInNlbmRNZXNzYWdlKCRldmVudClcIiBbZHJvcEZpbGVzXT1cInRydWVcIj5cbiAqICAgPC9uYi1jaGF0LWZvcm0+XG4gKiA8L25iLWNoYXQ+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ2hhdE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJDaGF0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogSWYgeW91IG5lZWQgdG8gcHJvdmlkZSBhbiBBUEkga2V5IGZvciBhIGBtYXBgIG1lc3NhZ2UgdHlwZSAod2hpY2ggaXMgcmVxdWlyZWQgYnkgR29vZ2xlIE1hcHMpXG4gKiB5b3UgbWF5IHVzZSBgTmJDaGF0TW9kdWxlLmZvclJvb3QoeyAuLi4gfSlgIGNhbGwgaWYgdGhpcyBpcyBhIGdsb2JhbCBhcHAgY29uZmlndXJhdGlvblxuICogb3IgYE5iQ2hhdE1vZHVsZS5mb3JDaGlsZCh7IC4uLiB9KWAgZm9yIGEgZmVhdHVyZSBtb2R1bGUgY29uZmlndXJhdGlvbjpcbiAqXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2hhdE1vZHVsZS5mb3JSb290KHsgbWVzc2FnZUdvb2dsZU1hcEtleTogJ01BUF9LRVknIH0pLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgbWFpbiBjb21wb25lbnRzOlxuICogYGBgdHNcbiAqIDxuYi1jaGF0PlxuICogPC9uYi1jaGF0PiAvLyBjaGF0IGNvbnRhaW5lclxuICpcbiAqIDxuYi1jaGF0LWZvcm0+XG4gKiA8L25iLWNoYXQtZm9ybT4gLy8gY2hhdCBmb3JtIHdpdGggZHJhZyZkcm9wIGZpbGVzIGZlYXR1cmVcbiAqXG4gKiA8bmItY2hhdC1tZXNzYWdlPlxuICogPC9uYi1jaGF0LW1lc3NhZ2U+IC8vIGNoYXQgbWVzc2FnZSwgYXZhaWxhYmxlIG11bHRpcGxlIHR5cGVzXG4gKiBgYGBcbiAqXG4gKiBUd28gdXNlcnMgY29udmVyc2F0aW9uIHNob3djYXNlOlxuICogQHN0YWNrZWQtZXhhbXBsZShDb252ZXJzYXRpb24sIGNoYXQvY2hhdC1jb252ZXJzYXRpb24tc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIENoYXQgVUkgaXMgYWxzbyBhdmFpbGFibGUgaW4gZGlmZmVyZW50IGNvbG9ycyBieSBzcGVjaWZ5aW5nIGEgYFtzdGF0dXNdYCBpbnB1dDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgQ2hhdCwgY2hhdC9jaGF0LWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogQWxzbyBpdCBpcyBwb3NzaWJsZSB0byBjb25maWd1cmUgc2l6ZXMgdGhyb3VnaCBgW3NpemVdYCBpbnB1dDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENoYXQgU2l6ZXMsIGNoYXQvY2hhdC1zaXplcy5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNoYXQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtYm9yZGVyOlxuICogY2hhdC1ib3JkZXItcmFkaXVzOlxuICogY2hhdC1zaGFkb3c6XG4gKiBjaGF0LXBhZGRpbmc6XG4gKiBjaGF0LXNjcm9sbGJhci1jb2xvcjpcbiAqIGNoYXQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LXNjcm9sbGJhci13aWR0aDpcbiAqIGNoYXQtdGV4dC1jb2xvcjpcbiAqIGNoYXQtdGV4dC1mb250LWZhbWlseTpcbiAqIGNoYXQtdGV4dC1mb250LXNpemU6XG4gKiBjaGF0LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjaGF0LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjaGF0LWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2hhdC1oZWFkZXItdGV4dC1mb250LXNpemU6XG4gKiBjaGF0LWhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2hhdC1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGNoYXQtdGlueS1oZWlnaHQ6XG4gKiBjaGF0LXNtYWxsLWhlaWdodDpcbiAqIGNoYXQtbWVkaXVtLWhlaWdodDpcbiAqIGNoYXQtbGFyZ2UtaGVpZ2h0OlxuICogY2hhdC1naWFudC1oZWlnaHQ6XG4gKiBjaGF0LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LWJhc2ljLXRleHQtY29sb3I6XG4gKiBjaGF0LXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogY2hhdC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGNoYXQtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1pbmZvLXRleHQtY29sb3I6XG4gKiBjaGF0LXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtd2FybmluZy10ZXh0LWNvbG9yOlxuICogY2hhdC1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBjaGF0LWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtY29udHJvbC10ZXh0LWNvbG9yOlxuICogY2hhdC1kaXZpZGVyLWNvbG9yOlxuICogY2hhdC1kaXZpZGVyLXN0eWxlOlxuICogY2hhdC1kaXZpZGVyLXdpZHRoOlxuICogY2hhdC1tZXNzYWdlLWJhY2tncm91bmQ6XG4gKiBjaGF0LW1lc3NhZ2UtdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1yZXBseS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXJlcGx5LXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtYXZhdGFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2Utc2VuZGVyLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcXVvdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1xdW90ZS10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLWZpbGUtdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1maWxlLWJhY2tncm91bmQtY29sb3I6XG4gKi9cbmNsYXNzIE5iQ2hhdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhdCBzdGF0dXMgY29sb3IgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYGJhc2ljYCAoZGVmYXVsdCksIGBwcmltYXJ5YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy5ub01lc3NhZ2VzUGxhY2Vob2xkZXIgPSAnTm8gbWVzc2FnZXMgeWV0Lic7XG4gICAgICAgIHRoaXMuX3Njcm9sbEJvdHRvbSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBjaGF0IHRvIHRoZSBib3R0b20gb2YgdGhlIGxpc3Qgd2hlbiBhIG5ldyBtZXNzYWdlIGFycml2ZXNcbiAgICAgKi9cbiAgICBnZXQgc2Nyb2xsQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQm90dG9tO1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsQm90dG9tKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbEJvdHRvbSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybVN0YXR1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JtU3RhdHVzKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5jaGFuZ2VzXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChtZXNzYWdlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICB9XG4gICAgdXBkYXRlVmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExpc3RCb3R0b20oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGxMaXN0Qm90dG9tKCkge1xuICAgICAgICB0aGlzLnNjcm9sbGFibGUubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbGFibGUubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvcm1TdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXRGb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmNoYXRGb3JtLnNldFN0YXR1cyh0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuTmJDaGF0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jaGF0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJcIj57eyB0aXRsZSB9fTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzY3JvbGxhYmxlXCIgI3Njcm9sbGFibGU+XG4gICAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZXNcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2hhdC1tZXNzYWdlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8cCBjbGFzcz1cIm5vLW1lc3NhZ2VzXCIgKm5nSWY9XCIhbWVzc2FnZXM/Lmxlbmd0aFwiPnt7IG5vTWVzc2FnZXNQbGFjZWhvbGRlciB9fTwvcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmb3JtXCI+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jaGF0LWZvcm1cIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNoYXRDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlN0YXR1c1NlcnZpY2UgfVxuXTtcbk5iQ2hhdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhdHVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBub01lc3NhZ2VzUGxhY2Vob2xkZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNjcm9sbEJvdHRvbTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2Nyb2xsYWJsZTogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ3Njcm9sbGFibGUnLF0gfV0sXG4gICAgbWVzc2FnZXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05iQ2hhdE1lc3NhZ2VDb21wb25lbnQsXSB9XSxcbiAgICBjaGF0Rm9ybTogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTmJDaGF0Rm9ybUNvbXBvbmVudCxdIH1dLFxuICAgIHRpbnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtdGlueScsXSB9XSxcbiAgICBzbWFsbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1zbWFsbCcsXSB9XSxcbiAgICBtZWRpdW06IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbWVkaXVtJyxdIH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dLFxuICAgIGdpYW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWdpYW50JyxdIH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJDaGF0T3B0aW9ucyB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ2hhdCBtZXNzYWdlIGNvbXBvbmVudC5cbiAqL1xuY2xhc3MgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBzZW5kIGRhdGUgZm9ybWF0LCBkZWZhdWx0ICdzaG9ydFRpbWUnXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGVGb3JtYXQgPSAnc2hvcnRUaW1lJztcbiAgICAgICAgdGhpcy5tYXBLZXkgPSBvcHRpb25zLm1lc3NhZ2VHb29nbGVNYXBLZXk7XG4gICAgfVxuICAgIGdldCBmaWxlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL3N0YXRpY21hcD9jZW50ZXI9JHt0aGlzLmxhdGl0dWRlfSwke3RoaXMubG9uZ2l0dWRlfSZ6b29tPTEyJnNpemU9NDAweDQwMCZrZXk9JHt0aGlzLm1hcEtleX1gLFxuICAgICAgICAgICAgdHlwZTogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICBpY29uOiAnbG9jYXRpb24nLFxuICAgICAgICB9O1xuICAgIH1cbn1cbk5iQ2hhdE1lc3NhZ2VNYXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWNoYXQtbWVzc2FnZS1tYXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNoYXQtbWVzc2FnZS1maWxlIFtmaWxlc109XCJbZmlsZV1cIiBbbWVzc2FnZV09XCJtZXNzYWdlXCIgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCJcbiAgICAgW2RhdGVGb3JtYXRdPVwiZGF0ZUZvcm1hdFwiPjwvbmItY2hhdC1tZXNzYWdlLWZpbGU+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iQ2hhdE9wdGlvbnMgfVxuXTtcbk5iQ2hhdE1lc3NhZ2VNYXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbWVzc2FnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VuZGVyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkYXRlRm9ybWF0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsYXRpdHVkZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbG9uZ2l0dWRlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBDaGF0IG1lc3NhZ2UgY29tcG9uZW50LlxuICovXG5jbGFzcyBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY2QsIGRvbVNhbml0aXplcikge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuZG9tU2FuaXRpemVyID0gZG9tU2FuaXRpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBzZW5kIGRhdGUgZm9ybWF0LCBkZWZhdWx0ICdzaG9ydFRpbWUnXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGVGb3JtYXQgPSAnc2hvcnRUaW1lJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWxlIHBhdGhcbiAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgKi9cbiAgICBzZXQgZmlsZXMoZmlsZXMpIHtcbiAgICAgICAgdGhpcy5yZWFkeUZpbGVzID0gKGZpbGVzIHx8IFtdKS5tYXAoKGZpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzSW1hZ2UgPSB0aGlzLmlzSW1hZ2UoZmlsZSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxlKSwgeyB1cmxTdHlsZTogaXNJbWFnZSAmJiB0aGlzLmRvbVNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoYHVybCgke2ZpbGUudXJsfSlgKSwgaXNJbWFnZTogaXNJbWFnZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbiAgICBpc0ltYWdlKGZpbGUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL2dpZiddLmluY2x1ZGVzKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5OYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlLWZpbGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNoYXQtbWVzc2FnZS10ZXh0IFtzZW5kZXJdPVwic2VuZGVyXCIgW2RhdGVdPVwiZGF0ZVwiIFtkYXRlRm9ybWF0XT1cImRhdGVGb3JtYXRcIiBbbWVzc2FnZV09XCJtZXNzYWdlXCI+XG4gICAgICB7eyBtZXNzYWdlIH19XG4gICAgPC9uYi1jaGF0LW1lc3NhZ2UtdGV4dD5cblxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyZWFkeUZpbGVzPy5sZW5ndGggPiAxXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1jb250ZW50LWdyb3VwXCI+XG4gICAgICAgIDxhICpuZ0Zvcj1cImxldCBmaWxlIG9mIHJlYWR5RmlsZXNcIiBbaHJlZl09XCJmaWxlLnVybFwiIHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgICAgIDxuYi1pY29uIFtpY29uXT1cImZpbGUuaWNvblwiICpuZ0lmPVwiIWZpbGUudXJsU3R5bGUgJiYgZmlsZS5pY29uXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJmaWxlLnVybFN0eWxlXCIgW3N0eWxlLmJhY2tncm91bmQtaW1hZ2VdPVwiZmlsZS51cmxTdHlsZVwiPjwvZGl2PlxuICAgICAgICA8L2E+XG4gICAgICA8L2Rpdj5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyZWFkeUZpbGVzPy5sZW5ndGggPT09IDFcIj5cbiAgICAgIDxhIFtocmVmXT1cInJlYWR5RmlsZXNbMF0udXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgIDxuYi1pY29uIFtpY29uXT1cInJlYWR5RmlsZXNbMF0uaWNvblwiICpuZ0lmPVwiIXJlYWR5RmlsZXNbMF0udXJsU3R5bGUgJiYgcmVhZHlGaWxlc1swXS5pY29uXCI+PC9uYi1pY29uPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwicmVhZHlGaWxlc1swXS51cmxTdHlsZVwiIFtzdHlsZS5iYWNrZ3JvdW5kLWltYWdlXT1cInJlYWR5RmlsZXNbMF0udXJsU3R5bGVcIj48L2Rpdj5cbiAgICAgIDwvYT5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBEb21TYW5pdGl6ZXIgfVxuXTtcbk5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG1lc3NhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbmRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZUZvcm1hdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsZXM6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIENoYXQgbWVzc2FnZSBjb21wb25lbnQuXG4gKi9cbmNsYXNzIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICogTWVzc2FnZSBzZW5kIGRhdGUgZm9ybWF0LCBkZWZhdWx0ICdzaG9ydFRpbWUnXG4gICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0ZUZvcm1hdCA9ICdzaG9ydFRpbWUnO1xuICAgIH1cbn1cbk5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlLXF1b3RlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxwIGNsYXNzPVwic2VuZGVyXCIgKm5nSWY9XCJzZW5kZXIgfHwgZGF0ZVwiPnt7IHNlbmRlciB9fSA8dGltZT57eyBkYXRlIHwgZGF0ZTogZGF0ZUZvcm1hdCB9fTwvdGltZT48L3A+XG4gICAgPHAgY2xhc3M9XCJxdW90ZVwiPlxuICAgICAge3sgcXVvdGUgfX1cbiAgICA8L3A+XG4gICAgPG5iLWNoYXQtbWVzc2FnZS10ZXh0IFttZXNzYWdlXT1cIm1lc3NhZ2VcIj5cbiAgICAgIHt7IG1lc3NhZ2UgfX1cbiAgICA8L25iLWNoYXQtbWVzc2FnZS10ZXh0PlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBtZXNzYWdlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZW5kZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRhdGVGb3JtYXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHF1b3RlOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBDaGF0IG1lc3NhZ2UgY29tcG9uZW50LlxuICovXG5jbGFzcyBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXNzYWdlIHNlbmQgZGF0ZSBmb3JtYXQsIGRlZmF1bHQgJ3Nob3J0VGltZSdcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0ZUZvcm1hdCA9ICdzaG9ydFRpbWUnO1xuICAgIH1cbn1cbk5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jaGF0LW1lc3NhZ2UtdGV4dCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8cCBjbGFzcz1cInNlbmRlclwiICpuZ0lmPVwic2VuZGVyIHx8IGRhdGVcIj57eyBzZW5kZXIgfX0gPHRpbWU+e3sgZGF0ZSAgfCBkYXRlOiBkYXRlRm9ybWF0IH19PC90aW1lPjwvcD5cbiAgICA8cCBjbGFzcz1cInRleHRcIiAqbmdJZj1cIm1lc3NhZ2VcIj57eyBtZXNzYWdlIH19PC9wPlxuICBgLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNlbmRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbWVzc2FnZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGF0ZUZvcm1hdDogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qXG4gKiBDbGFzcyB1c2VkIGFzIGluamVjdGlvbiB0b2tlbiB0byBwcm92aWRlIGZvcm0gZWxlbWVudC5cbiAqKi9cbmNsYXNzIE5iRm9ybUZpZWxkQ29udHJvbCB7XG59XG5OYkZvcm1GaWVsZENvbnRyb2wuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbi8qXG4gKiBPcHRpb25hbCBjb25maWcgdG8gYmUgcHJvdmlkZWQgb24gTmJGb3JtRmllbGRDb250cm9sIHRvIGFsdGVyIGRlZmF1bHQgc2V0dGluZ3MuXG4gKiovXG5jbGFzcyBOYkZvcm1GaWVsZENvbnRyb2xDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN1cHBvcnRzUHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c1N1ZmZpeCA9IHRydWU7XG4gICAgfVxufVxuTmJGb3JtRmllbGRDb250cm9sQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQmFzaWMgaW5wdXQgZGlyZWN0aXZlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBuYklucHV0PjwvaW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYklucHV0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYklucHV0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBEZWZhdWx0IGlucHV0IHNpemUgaXMgYG1lZGl1bWA6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBpbnB1dC9pbnB1dC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogSW5wdXRzIGFyZSBhdmFpbGFibGUgaW4gbXVsdGlwbGUgY29sb3JzIHVzaW5nIGBzdGF0dXNgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShJbnB1dCBDb2xvcnMsIGlucHV0L2lucHV0LWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIGlucHV0IHNpemVzOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgU2l6ZXMsIGlucHV0L2lucHV0LXNpemVzLmNvbXBvbmVudClcbiAqXG4gKiBJbnB1dHMgYXZhaWxhYmxlIGluIGRpZmZlcmVudCBzaGFwZXMsIHdoaWNoIGNvdWxkIGJlIGNvbWJpbmVkIHdpdGggdGhlIG90aGVyIHByb3BlcnRpZXM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKElucHV0IFNoYXBlcywgaW5wdXQvaW5wdXQtc2hhcGVzLmNvbXBvbmVudClcbiAqXG4gKiBgbmJJbnB1dGAgY291bGQgYmUgYXBwbGllZCB0byB0aGUgZm9sbG93aW5nIHNlbGVjdG9ycyAtIGBpbnB1dGAsIGB0ZXh0YXJlYWA6XG4gKiBAc3RhY2tlZC1leGFtcGxlKElucHV0IEVsZW1lbnRzLCBpbnB1dC9pbnB1dC10eXBlcy5jb21wb25lbnQpXG4gKlxuICogWW91IGNhbiBhZGQgYGZ1bGxXaWR0aGAgYXR0cmlidXRlIHRvIG1ha2UgZWxlbWVudCBmaWxsIGNvbnRhaW5lcjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRnVsbCB3aWR0aCBpbnB1dHMsIGlucHV0L2lucHV0LWZ1bGwtd2lkdGguY29tcG9uZW50KVxuICpcbiAqIE9yIHlvdSBjYW4gYmluZCBjb250cm9sIHdpdGggZm9ybSBjb250cm9scyBvciBuZ01vZGVsOlxuICogQHN0YWNrZWQtZXhhbXBsZShJbnB1dCBmb3JtIGJpbmRpbmcsIGlucHV0L2lucHV0LWZvcm0uY29tcG9uZW50KVxuICpcbiAqIFVzZSBgPG5iLWZvcm0tZmllbGQ+YCB0byBhZGQgY3VzdG9tIGNvbnRlbnQgdG8gdGhlIGlucHV0IGZpZWxkLlxuICogRmlyc3QgaW1wb3J0IGBOYkZvcm1GaWVsZE1vZHVsZWAuIFRoZW4gcHV0IHRoZSBpbnB1dCBmaWVsZCBhbmQgY3VzdG9tIGNvbnRlbnQgaW50b1xuICogYDxuYi1mb3JtLWZpZWxkPmAgYW5kIGFkZCBgbmJQcmVmaXhgIG9yIGBuYlN1ZmZpeGAgZGlyZWN0aXZlIHRvIHRoZSBjdXN0b20gY29udGVudC5cbiAqIGBuYlByZWZpeGAgcHV0cyBjb250ZW50IGJlZm9yZSBpbnB1dCBhbmQgYG5iU3VmZml4YCBhZnRlci5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKElucHV0IHdpdGggaWNvbiwgZm9ybS1maWVsZC9mb3JtLWZpZWxkLWlucHV0LmNvbXBvbmVudClcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgd2l0aCBidXR0b24sIGZvcm0tZmllbGQvZm9ybS1maWVsZC1wYXNzd29yZC5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGlucHV0LWJvcmRlci1zdHlsZTpcbiAqIGlucHV0LWJvcmRlci13aWR0aDpcbiAqIGlucHV0LW91dGxpbmUtY29sb3I6XG4gKiBpbnB1dC1vdXRsaW5lLXdpZHRoOlxuICogaW5wdXQtcGxhY2Vob2xkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIGlucHV0LXRleHQtZm9udC1mYW1pbHk6XG4gKiBpbnB1dC1iYXNpYy10ZXh0LWNvbG9yOlxuICogaW5wdXQtYmFzaWMtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtYmFzaWMtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtYmFzaWMtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtYmFzaWMtZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLXRleHQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWluZm8tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtaW5mby1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGlucHV0LWluZm8tZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLXRleHQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogaW5wdXQtc2VtaS1yb3VuZC1ib3JkZXItcmFkaXVzOlxuICogaW5wdXQtcm91bmQtYm9yZGVyLXJhZGl1czpcbiAqIGlucHV0LXRpbnktdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC10aW55LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC10aW55LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC10aW55LXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtdGlueS1wbGFjZWhvbGRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaW5wdXQtdGlueS1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtdGlueS1wYWRkaW5nOlxuICogaW5wdXQtdGlueS1tYXgtd2lkdGg6XG4gKiBpbnB1dC1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LXNtYWxsLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC1zbWFsbC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtc21hbGwtcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC1zbWFsbC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaW5wdXQtc21hbGwtcGxhY2Vob2xkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGlucHV0LXNtYWxsLXBhZGRpbmc6XG4gKiBpbnB1dC1zbWFsbC1tYXgtd2lkdGg6XG4gKiBpbnB1dC1tZWRpdW0tdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC1tZWRpdW0tdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LW1lZGl1bS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGlucHV0LW1lZGl1bS1wYWRkaW5nOlxuICogaW5wdXQtbWVkaXVtLW1heC13aWR0aDpcbiAqIGlucHV0LWxhcmdlLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtbGFyZ2UtdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1sYXJnZS1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LWxhcmdlLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC1sYXJnZS1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtbGFyZ2UtcGFkZGluZzpcbiAqIGlucHV0LWxhcmdlLW1heC13aWR0aDpcbiAqIGlucHV0LWdpYW50LXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtZ2lhbnQtdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LWdpYW50LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1naWFudC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC1naWFudC1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtZ2lhbnQtcGFkZGluZzpcbiAqIGlucHV0LWdpYW50LW1heC13aWR0aDpcbiAqL1xuY2xhc3MgTmJJbnB1dERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgZm9jdXNNb25pdG9yLCByZW5kZXJlciwgem9uZSwgc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmZvY3VzTW9uaXRvciA9IGZvY3VzTW9uaXRvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpZWxkIHNpemUgbW9kaWZpY2F0aW9ucy4gUG9zc2libGUgdmFsdWVzOiBgc21hbGxgLCBgbWVkaXVtYCAoZGVmYXVsdCksIGBsYXJnZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpZWxkU2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmllbGQgc3RhdHVzIChhZGRzIHNwZWNpZmljIHN0eWxlcyk6XG4gICAgICAgICAqIGBiYXNpY2AsIGBwcmltYXJ5YCwgYGluZm9gLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmllbGQgc2hhcGVzIG1vZGlmaWNhdGlvbnMuIFBvc3NpYmxlIHZhbHVlczogYHJlY3RhbmdsZWAgKGRlZmF1bHQpLCBgcm91bmRgLCBgc2VtaS1yb3VuZGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gJ3JlY3RhbmdsZSc7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGZhbHNlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5zdGF0dXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLnN0YXR1cyk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLnNpemUkID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLmZpZWxkU2l6ZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmRpc2FibGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5mdWxsV2lkdGgkID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLmZ1bGxXaWR0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHNldCBlbGVtZW50IHdpbGwgZmlsbCBjb250YWluZXIuIGBmYWxzZWAgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBnZXQgZnVsbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsbFdpZHRoO1xuICAgIH1cbiAgICBzZXQgZnVsbFdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBhZGRpdGlvbmFsQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzU2VydmljZS5pc0N1c3RvbVN0YXR1cyh0aGlzLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMuc3RhdHVzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5kaXNhYmxlZDtcbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgIT09IHRoaXMuZGlzYWJsZWQkLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkJC5uZXh0KGlzRGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKHsgc3RhdHVzLCBmaWVsZFNpemUsIGZ1bGxXaWR0aCB9KSB7XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzJC5uZXh0KHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUkLm5leHQodGhpcy5maWVsZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbFdpZHRoJC5uZXh0KHRoaXMuZnVsbFdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLmVsZW1lbnRSZWYpXG4gICAgICAgICAgICAucGlwZShtYXAob3JpZ2luID0+ICEhb3JpZ2luKSwgZmluYWxpemUoKCkgPT4gdGhpcy5mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5lbGVtZW50UmVmKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mb2N1c2VkJCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgLy8gVE9ETzogIzIyNTRcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ25iLXRyYW5zaXRpb24nKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZFNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZFNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkU2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRTaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkU2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICAgIGdldCBzZW1pUm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAnc2VtaS1yb3VuZCc7XG4gICAgfVxuICAgIGdldCByb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyb3VuZCc7XG4gICAgfVxufVxuTmJJbnB1dERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbbmJJbnB1dF0sdGV4dGFyZWFbbmJJbnB1dF0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5iRm9ybUZpZWxkQ29udHJvbCwgdXNlRXhpc3Rpbmc6IE5iSW5wdXREaXJlY3RpdmUgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYklucHV0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmJGb2N1c01vbml0b3IgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBOYlN0YXR1c1NlcnZpY2UgfVxuXTtcbk5iSW5wdXREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmllbGRTaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNoYXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmdWxsV2lkdGg6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaW5wdXQtZnVsbC13aWR0aCcsXSB9XSxcbiAgICBhZGRpdGlvbmFsQ2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MnLF0gfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgcmVjdGFuZ2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yZWN0YW5nbGUnLF0gfV0sXG4gICAgc2VtaVJvdW5kOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1zZW1pLXJvdW5kJyxdIH1dLFxuICAgIHJvdW5kOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yb3VuZCcsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfSU5QVVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYklucHV0RGlyZWN0aXZlLFxuXTtcbmNsYXNzIE5iSW5wdXRNb2R1bGUge1xufVxuTmJJbnB1dE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW05iU2hhcmVkTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IE5CX0lOUFVUX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogTkJfSU5QVVRfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9DSEFUX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJDaGF0Q29tcG9uZW50LFxuICAgIE5iQ2hhdE1lc3NhZ2VDb21wb25lbnQsXG4gICAgTmJDaGF0Rm9ybUNvbXBvbmVudCxcbiAgICBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudCxcbiAgICBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudCxcbiAgICBOYkNoYXRNZXNzYWdlUXVvdGVDb21wb25lbnQsXG4gICAgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudCxcbl07XG5jbGFzcyBOYkNoYXRNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYkNoYXRNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5iQ2hhdE9wdGlvbnMsIHVzZVZhbHVlOiBvcHRpb25zIHx8IHt9IH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZm9yQ2hpbGQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iQ2hhdE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTmJDaGF0T3B0aW9ucywgdXNlVmFsdWU6IG9wdGlvbnMgfHwge30gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuTmJDaGF0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkljb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSW5wdXRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQnV0dG9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX0NIQVRfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfQ0hBVF9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBTdHlsZWQgc3Bpbm5lciBjb21wb25lbnRcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogc3Bpbm5lci10ZXh0LWNvbG9yOlxuICogc3Bpbm5lci10ZXh0LWZvbnQtZmFtaWx5OlxuICogc3Bpbm5lci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNwaW5uZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHNwaW5uZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHNwaW5uZXItYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNwaW5uZXItYmFzaWMtY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItYmFzaWMtY2lyY2xlLWVtcHR5LWNvbG9yOlxuICogc3Bpbm5lci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBzcGlubmVyLXByaW1hcnktY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItcHJpbWFyeS1jaXJjbGUtZW1wdHktY29sb3I6XG4gKiBzcGlubmVyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNwaW5uZXItaW5mby1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICogc3Bpbm5lci1pbmZvLWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAqIHNwaW5uZXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3Bpbm5lci1zdWNjZXNzLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gKiBzcGlubmVyLXN1Y2Nlc3MtY2lyY2xlLWVtcHR5LWNvbG9yOlxuICogc3Bpbm5lci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBzcGlubmVyLXdhcm5pbmctY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItd2FybmluZy1jaXJjbGUtZW1wdHktY29sb3I6XG4gKiBzcGlubmVyLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3Bpbm5lci1kYW5nZXItY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItZGFuZ2VyLWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAqIHNwaW5uZXItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3Bpbm5lci1jb250cm9sLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gKiBzcGlubmVyLWNvbnRyb2wtY2lyY2xlLWVtcHR5LWNvbG9yOlxuICogc3Bpbm5lci1oZWlnaHQtdGlueTpcbiAqIHNwaW5uZXItaGVpZ2h0LXNtYWxsOlxuICogc3Bpbm5lci1oZWlnaHQtbWVkaXVtOlxuICogc3Bpbm5lci1oZWlnaHQtbGFyZ2U6XG4gKiBzcGlubmVyLWhlaWdodC1naWFudDpcbiAqL1xuY2xhc3MgTmJTcGlubmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkaW5nIHRleHQgdGhhdCBpcyBzaG93biBuZWFyIHRoZSBpY29uXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ0xvYWRpbmcuLi4nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Bpbm5lciBzaXplLCBhdmFpbGFibGUgc2l6ZXM6XG4gICAgICAgICAqIHRpbnksIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCBnaWFudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Bpbm5lciBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgYWRkaXRpb25hbENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1NlcnZpY2UuaXNDdXN0b21TdGF0dXModGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RhdHVzU2VydmljZS5nZXRTdGF0dXNDbGFzcyh0aGlzLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5OYlNwaW5uZXJDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXNwaW5uZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gY2xhc3M9XCJzcGluLWNpcmNsZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIiAqbmdJZj1cIm1lc3NhZ2VcIj57eyBtZXNzYWdlIH19PC9zcGFuPlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7b3BhY2l0eToxO3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlci1yYWRpdXM6aW5oZXJpdDt0b3A6MDtyaWdodDowO2xlZnQ6MDtib3R0b206MDtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDo5OTk5O2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt2aXNpYmlsaXR5OnZpc2libGV9Omhvc3QgLnNwaW4tY2lyY2xle2FuaW1hdGlvbjpzcGluIDAuOHMgaW5maW5pdGUgbGluZWFyO2JvcmRlci1yYWRpdXM6NTAlO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6MC4xMjVlbTt3aWR0aDoxZW07aGVpZ2h0OjFlbX06aG9zdCAubWVzc2FnZXttYXJnaW4tbGVmdDowLjVyZW19XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iU3Bpbm5lckNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iU3RhdHVzU2VydmljZSB9XG5dO1xuTmJTcGlubmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG1lc3NhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFN0eWxlZCBzcGlubmVyIGRpcmVjdGl2ZVxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3Bpbm5lciBTaG93Y2FzZSwgc3Bpbm5lci9zcGlubmVyLWNhcmQuY29tcG9uZW50KVxuICpcbiAqXG4gKiBgYGB0c1xuICogPG5iLWNhcmQgW25iU3Bpbm5lcl09XCJsb2FkaW5nXCIgbmJTcGlubmVyU3RhdHVzPVwiZGFuZ2VyXCI+XG4gKiAgIDxuYi1jYXJkLWJvZHk+Q2FyZCBDb250ZW50PC9uYi1jYXJkLWJvZHk+XG4gKiA8L25iLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlNwaW5uZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iU3Bpbm5lck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ291bGQgYmUgY29sb3JlZCB1c2luZyBgc3RhdHVzYCBwcm9wZXJ0eVxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3Bpbm5lciBDb2xvcnMsIHNwaW5uZXIvc3Bpbm5lci1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEF2YWlsYWJsZSBpbiBkaWZmZXJlbnQgc2l6ZXMgd2l0aCBgc2l6ZWAgcHJvcGVydHk6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTcGlubmVyIFNpemVzLCBzcGlubmVyL3NwaW5uZXItc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcGxhY2UgaXQgaW50byB0aGUgYnV0dG9uOlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b25zIHdpdGggc3Bpbm5lciwgc3Bpbm5lci9zcGlubmVyLWJ1dHRvbi5jb21wb25lbnQpXG4gKlxuICogT3IgdGFiczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3Bpbm5lciBpbiB0YWJzLCBzcGlubmVyL3NwaW5uZXItdGFicy5jb21wb25lbnQpXG4gKi9cbmNsYXNzIE5iU3Bpbm5lckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZGlyZWN0aXZlVmlldywgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCByZW5kZXJlciwgZGlyZWN0aXZlRWxlbWVudCkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZVZpZXcgPSBkaXJlY3RpdmVWaWV3O1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZUVsZW1lbnQgPSBkaXJlY3RpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwaW5uZXIgc3RhdHVzIGNvbG9yXG4gICAgICAgICAqIGBiYXNpY2AsIGBwcmltYXJ5YCwgYGluZm9gLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lclN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGlubmVyIHNpemUuIFBvc3NpYmxlIHZhbHVlczogYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCAoZGVmYXVsdCksIGBsYXJnZWAsIGBnaWFudGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lclNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5pc1NwaW5uZXJFeGlzdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgdmFsdWUgLSBzaG93IG9yIGhpZGUgc3Bpbm5lclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IG5iU3Bpbm5lcih2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KE5iU3Bpbm5lckNvbXBvbmVudCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3Bpbm5lckV4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZVZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmlzU3Bpbm5lckV4aXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3Bpbm5lckV4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIgPSB0aGlzLmRpcmVjdGl2ZVZpZXcuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgICAgICB0aGlzLnNldEluc3RhbmNlSW5wdXRzKHRoaXMuc3Bpbm5lci5pbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmRpcmVjdGl2ZUVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5zcGlubmVyLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5pc1NwaW5uZXJFeGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SW5zdGFuY2VJbnB1dHMoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UubWVzc2FnZSA9IHRoaXMuc3Bpbm5lck1lc3NhZ2U7XG4gICAgICAgIHR5cGVvZiB0aGlzLnNwaW5uZXJTdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIChpbnN0YW5jZS5zdGF0dXMgPSB0aGlzLnNwaW5uZXJTdGF0dXMpO1xuICAgICAgICB0eXBlb2YgdGhpcy5zcGlubmVyU2l6ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGluc3RhbmNlLnNpemUgPSB0aGlzLnNwaW5uZXJTaXplKTtcbiAgICB9XG59XG5OYlNwaW5uZXJEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmJTcGlubmVyXScgfSxdIH1cbl07XG5OYlNwaW5uZXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBWaWV3Q29udGFpbmVyUmVmIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9XG5dO1xuTmJTcGlubmVyRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNwaW5uZXJNZXNzYWdlOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlNwaW5uZXJNZXNzYWdlJyxdIH1dLFxuICAgIHNwaW5uZXJTdGF0dXM6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iU3Bpbm5lclN0YXR1cycsXSB9XSxcbiAgICBzcGlubmVyU2l6ZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJTcGlubmVyU2l6ZScsXSB9XSxcbiAgICBuYlNwaW5uZXI6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iU3Bpbm5lcicsXSB9XSxcbiAgICBpc1NwaW5uZXJFeGlzdDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItc3Bpbm5lci1jb250YWluZXInLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iU3Bpbm5lck1vZHVsZSB7XG59XG5OYlNwaW5uZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbTmJTcGlubmVyQ29tcG9uZW50LCBOYlNwaW5uZXJEaXJlY3RpdmVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iU3Bpbm5lckNvbXBvbmVudCwgTmJTcGlubmVyRGlyZWN0aXZlXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYlNwaW5uZXJDb21wb25lbnRdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbmNvbnN0IE5CX1NURVBQRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgU3RlcHBlciBDb21wb25lbnQnKTtcblxuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gIHRoZSBgPG5iLXN0ZXBwZXI+YCBjb21wb25lbnQuXG4gKiBDb250YWluZXIgZm9yIGEgc3RlcFxuICovXG5jbGFzcyBOYlN0ZXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICAgICAgdGhpcy5faGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludGVyYWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGVwcGVyID0gc3RlcHBlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBzdGVwIHdpbGwgYmUgZGlzcGxheWVkIGluIHdpemFyZFxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgc2V0IGhpZGRlbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGxhYmVsIGlzIGEgVGVtcGxhdGVSZWYuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICAgKiAqL1xuICAgIGdldCBpc0xhYmVsVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgc3RlcCBpcyBtYXJrZWQgYXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlZCB8fCB0aGlzLmlzQ29tcGxldGVkO1xuICAgIH1cbiAgICBzZXQgY29tcGxldGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBpc0NvbXBsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbnRyb2wgPyB0aGlzLnN0ZXBDb250cm9sLnZhbGlkICYmIHRoaXMuaW50ZXJhY3RlZCA6IHRoaXMuaW50ZXJhY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFyayBzdGVwIGFzIHNlbGVjdGVkXG4gICAgICogKi9cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlci5zZWxlY3RlZCA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHN0ZXAgYW5kIHN0ZXBDb250cm9sIHN0YXRlXG4gICAgICogKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0ZXBDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBDb250cm9sLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5OYlN0ZXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXN0ZXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJTdGVwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9TVEVQUEVSLF0gfV0gfVxuXTtcbk5iU3RlcENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb250ZW50OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtUZW1wbGF0ZVJlZiwgeyBzdGF0aWM6IHRydWUgfSxdIH1dLFxuICAgIHN0ZXBDb250cm9sOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsYWJlbDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaGlkZGVuOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBjb21wbGV0ZWQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFN0ZXBwZXIgY29tcG9uZW50XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgc3RlcHBlci9zdGVwcGVyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlN0ZXBwZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iU3RlcHBlck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogSWYgc3RlcCBsYWJlbCBpcyBzdHJpbmcgeW91IGNhbiBwYXNzIGl0IGFzIGBsYWJlbGAgYXR0cmlidXRlLiBPdGhlcndpc2UgbmctdGVtcGxhdGUgc2hvdWxkIGJlIHVzZWQ6XG4gKiBgYGBodG1sXG4gKiAvLyAuLi5cbiAqIDxuYi1zdGVwcGVyIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICogICA8bmItc3RlcCBsYWJlbD1cInN0ZXAgbnVtYmVyIG9uZVwiPlxuICogICAgICAgLy8gLi4uIHN0ZXAgY29udGVudCBoZXJlXG4gKiAgIDwvbmItc3RlcD5cbiAqICAgPG5iLXN0ZXAgbGFiZWw9XCJzdGVwTGFiZWxcIj5cbiAqICAgICAgIDxuZy10ZW1wbGF0ZSAjc3RlcExhYmVsPlxuICogICAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAgICAgIHN0ZXAgbnVtYmVyIHR3b1xuICogICAgICAgICAgIDwvZGl2PlxuICogICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgIC8vIC4uLiBzdGVwIGNvbnRlbnQgaGVyZVxuICogICA8L25iLXN0ZXA+XG4gKiA8L25iLXN0ZXBwZXI+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIGxpbmVhciBtb2RlIGVuYWJsZWQgdXNlciBjYW4ndCBtb3ZlIGZvcndhcmQgdW5sZXNzIGN1cnJlbnQgc3RlcCBpcyBjb21wbGV0ZS5cbiAqIEBzdGFja2VkLWV4YW1wbGUoTGluZWFyLCBzdGVwcGVyL3N0ZXBwZXItbGluZWFyLmNvbXBvbmVudClcbiAqXG4gKiBTcGVjaWZ5IGBbc3RlcENvbnRyb2xdPVwiZm9ybVwiYCBhbmQgc3RlcHBlciBhbGxvdyBnbyB0byB0aGUgbmV4dCBzdGVwIG9ubHkgaWYgZm9ybSBpcyB2YWxpZC5cbiAqIFlvdSBjYW4gZGlzYWJsZSBpdCB2aWEgYGxpbmVhcmAgbW9kZSBzZXR0aW5nLlxuICogYGBgaHRtbFxuICogLy8gLi4uXG4gKiA8bmItc3RlcHBlciAgb3JpZW50YXRpb249XCJob3Jpem9udGFsXCI+XG4gKiAgIDxuYi1zdGVwIGxhYmVsPVwic3RlcCBudW1iZXIgb25lXCIgW3N0ZXBDb250cm9sXT1cImZvcm1cIj5cbiAqICAgICA8Zm9ybSBbZm9ybUdyb3VwXT1cImZvcm1cIj5cbiAqICAgICAgIC8vIC4uLlxuICogICAgIDwvZm9ybT5cbiAqICAgPC9uYi1zdGVwPlxuICogICAgLy8gLi4uXG4gKiA8L25iLXN0ZXBwZXI+XG4gKiBgYGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFZhbGlkYXRpb24sIHN0ZXBwZXIvc3RlcHBlci12YWxpZGF0aW9uLmNvbXBvbmVudClcbiAqXG4gKiBTdGVwcGVyIGNvbXBvbmVudCBoYXMgdHdvIGxheW91dCBvcHRpb25zIC0gYHZlcnRpY2FsYCAmIGBob3Jpem9udGFsYFxuICogQHN0YWNrZWQtZXhhbXBsZShWZXJ0aWNhbCwgc3RlcHBlci9zdGVwcGVyLXZlcnRpY2FsLmNvbXBvbmVudClcbiAqXG4gKiBgZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uYCBkaXNhYmxlcyBuYXZpZ2F0aW9uIGJ5IGNsaWNraW5nIG9uIHN0ZXBzLCBzbyB1c2VyIGNhbiBuYXZpZ2F0ZSBvbmx5IHVzaW5nXG4gKiAnbmJTdGVwcGVyUHJldmlvdXMnIGFuZCAnbmJTdGVwcGVyTmV4dCcgYnV0dG9ucy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQgc3RlcHMgbmF2aWdhdGlvbiwgc3RlcHBlci9zdGVwcGVyLWRpc2FibGVkLXN0ZXAtbmF2LmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogc3RlcHBlci1zdGVwLXRleHQtY29sb3I6XG4gKiBzdGVwcGVyLXN0ZXAtdGV4dC1mb250LWZhbWlseTpcbiAqIHN0ZXBwZXItc3RlcC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHN0ZXBwZXItc3RlcC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc3RlcHBlci1zdGVwLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzdGVwcGVyLXN0ZXAtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBzdGVwcGVyLXN0ZXAtY29tcGxldGVkLXRleHQtY29sb3I6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYm9yZGVyLWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWJvcmRlci1zdHlsZTpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC1ib3JkZXItd2lkdGg6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYm9yZGVyLXJhZGl1czpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC13aWR0aDpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWNvbXBsZXRlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWNvbXBsZXRlZC1ib3JkZXItY29sb3I6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtY29tcGxldGVkLXRleHQtY29sb3I6XG4gKiBzdGVwcGVyLWNvbm5lY3Rvci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3RlcHBlci1jb25uZWN0b3ItY29tcGxldGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzdGVwcGVyLWhvcml6b250YWwtY29ubmVjdG9yLW1hcmdpbjpcbiAqIHN0ZXBwZXItdmVydGljYWwtY29ubmVjdG9yLW1hcmdpbjpcbiAqIHN0ZXBwZXItc3RlcC1jb250ZW50LXBhZGRpbmc6XG4gKi9cbmNsYXNzIE5iU3RlcHBlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9kaXNhYmxlU3RlcE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0ZXBwZXIgb3JpZW50YXRpb24gLSBgaG9yaXpvbnRhbGB8YHZlcnRpY2FsYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5fbGluZWFyID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0ZWQgc3RlcCBpbmRleFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0ZXBzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrQ3VycmVudFN0ZXBJbnRlcmFjdGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbkJlU2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgbmF2aWdhdGlvbiBieSBjbGlja2luZyBvbiBzdGVwcy4gRmFsc2UgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVTdGVwTmF2aWdhdGlvbiA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlU3RlcE5hdmlnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlU3RlcE5hdmlnYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdGVkIHN0ZXAgY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcyA/IHRoaXMuc3RlcHMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZChzdGVwKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGVwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuc3RlcHMudG9BcnJheSgpLmluZGV4T2Yoc3RlcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IG1vdmluZyBmb3J3YXJkIG9ubHkgaWYgdGhlIGN1cnJlbnQgc3RlcCBpcyBjb21wbGV0ZVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBzZXQgbGluZWFyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xpbmVhciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBsaW5lYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lYXI7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byBuZXh0IHN0ZXBcbiAgICAgKiAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEsIHRoaXMuc3RlcHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHByZXZpb3VzIHN0ZXBcbiAgICAgKiAqL1xuICAgIHByZXZpb3VzKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBNYXRoLm1heCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgc3RlcHBlciBhbmQgc3RlcENvbnRyb2xzIHRvIGluaXRpYWwgc3RhdGVcbiAgICAgKiAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gc3RlcC5yZXNldCgpKTtcbiAgICB9XG4gICAgaXNTdGVwU2VsZWN0ZWQoc3RlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCA9PT0gc3RlcDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICoqL1xuICAgIGdldFN0ZXBUZW1wbGF0ZShzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwLmlzTGFiZWxUZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAubGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlzU3RlcFZhbGlkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLnRvQXJyYXkoKVtpbmRleF0uY29tcGxldGVkO1xuICAgIH1cbiAgICBjYW5CZVNlbGVjdGVkKGluZGV4VG9DaGVjaykge1xuICAgICAgICBjb25zdCBub1N0ZXBzID0gIXRoaXMuc3RlcHMgfHwgdGhpcy5zdGVwcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChub1N0ZXBzIHx8IGluZGV4VG9DaGVjayA8IDAgfHwgaW5kZXhUb0NoZWNrID49IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4VG9DaGVjayA8PSB0aGlzLnNlbGVjdGVkSW5kZXggfHwgIXRoaXMubGluZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNBbGxTdGVwc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc2VsZWN0ZWRJbmRleDsgaSA8IGluZGV4VG9DaGVjazsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTdGVwVmFsaWQoaSkpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFN0ZXBzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBbGxTdGVwc1ZhbGlkO1xuICAgIH1cbiAgICBtYXJrQ3VycmVudFN0ZXBJbnRlcmFjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5pbnRlcmFjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iU3RlcHBlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItc3RlcHBlcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLXRlbXBsYXRlPjxuZy1jb250ZW50IHNlbGVjdD1cXFwibmItc3RlcFxcXCI+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+XFxuPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gIDxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGluZGV4ID0gaW5kZXg7IGxldCBmaXJzdCA9IGZpcnN0XFxcIj5cXG5cXG4gICAgPGRpdiAqbmdJZj1cXFwiIWZpcnN0ICYmICFzdGVwLmhpZGRlblxcXCJcXG4gICAgICAgICBbY2xhc3MuY29ubmVjdG9yLXBhc3RdPVxcXCJpbmRleCA8PSBzZWxlY3RlZEluZGV4XFxcIlxcbiAgICAgICAgIGNsYXNzPVxcXCJjb25uZWN0b3JcXFwiPjwvZGl2PlxcblxcbiAgICA8ZGl2ICpuZ0lmPVxcXCIhc3RlcC5oaWRkZW5cXFwiIGNsYXNzPVxcXCJzdGVwXFxcIlxcbiAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XFxcImlzU3RlcFNlbGVjdGVkKHN0ZXApXFxcIlxcbiAgICAgICAgIFtjbGFzcy5jb21wbGV0ZWRdPVxcXCIhaXNTdGVwU2VsZWN0ZWQoc3RlcCkgJiYgc3RlcC5jb21wbGV0ZWRcXFwiXFxuICAgICAgICAgW2NsYXNzLm5vbmludGVyYWN0aXZlXT1cXFwiZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uXFxcIlxcbiAgICAgICAgIChjbGljayk9XFxcIiFkaXNhYmxlU3RlcE5hdmlnYXRpb24gJiYgc3RlcC5zZWxlY3QoKVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGFiZWwtaW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFzdGVwLmNvbXBsZXRlZCB8fCBpc1N0ZXBTZWxlY3RlZChzdGVwKVxcXCI+e3sgaW5kZXggKyAxIH19PC9zcGFuPlxcbiAgICAgICAgPG5iLWljb24gKm5nSWY9XFxcIiFpc1N0ZXBTZWxlY3RlZChzdGVwKSAmJiBzdGVwLmNvbXBsZXRlZFxcXCIgaWNvbj1cXFwiY2hlY2ttYXJrLW91dGxpbmVcXFwiIHBhY2s9XFxcIm5lYnVsYXItZXNzZW50aWFsc1xcXCI+XFxuICAgICAgICA8L25iLWljb24+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGFiZWxcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwic3RlcC5pc0xhYmVsVGVtcGxhdGVcXFwiPlxcbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVxcXCJnZXRTdGVwVGVtcGxhdGUoc3RlcClcXFwiPjwvbmctY29udGFpbmVyPlxcbiAgICAgICAgPC9uZy1jb250YWluZXI+XFxuICAgICAgICA8c3BhbiAqbmdJZj1cXFwiIXN0ZXAuaXNMYWJlbFRlbXBsYXRlXFxcIj57eyBzdGVwLmxhYmVsIH19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvbmctY29udGFpbmVyPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInN0ZXAtY29udGVudFxcXCI+XFxuICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwic2VsZWN0ZWQ/LmNvbnRlbnRcXFwiPjwvbmctY29udGFpbmVyPlxcbjwvZGl2PlxcblwiLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkJfU1RFUFBFUiwgdXNlRXhpc3Rpbmc6IE5iU3RlcHBlckNvbXBvbmVudCB9XSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0KC5ob3Jpem9udGFsKSAuaGVhZGVyIC5zdGVwe2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn06aG9zdCguaG9yaXpvbnRhbCkgLmhlYWRlciAuY29ubmVjdG9ye2hlaWdodDoycHh9Omhvc3QoLmhvcml6b250YWwpIC5sYWJlbC1pbmRleHttYXJnaW4tYm90dG9tOjEwcHh9Omhvc3QoLnZlcnRpY2FsKXtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCV9Omhvc3QoLnZlcnRpY2FsKSAuaGVhZGVye2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn06aG9zdCgudmVydGljYWwpIC5oZWFkZXIgLmxhYmVse21hcmdpbjowIDEwcHh9Omhvc3QoLnZlcnRpY2FsKSAuaGVhZGVyIC5jb25uZWN0b3J7d2lkdGg6MnB4fS5oZWFkZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7bWFyZ2luLWJvdHRvbToxMHB4fS5oZWFkZXIgLmNvbm5lY3RvcntmbGV4OmF1dG99LmhlYWRlciAuc3RlcHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2N1cnNvcjpwb2ludGVyfS5oZWFkZXIgLnN0ZXAubm9uaW50ZXJhY3RpdmV7Y3Vyc29yOmRlZmF1bHR9LmhlYWRlciAubGFiZWwtaW5kZXh7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5oZWFkZXIgLmxhYmVse3dpZHRoOm1heC1jb250ZW50fVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlN0ZXBwZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2VsZWN0ZWRJbmRleDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3JpZW50YXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGxpbmVhcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdmVydGljYWw6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnZlcnRpY2FsJyxdIH1dLFxuICAgIGhvcml6b250YWw6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmhvcml6b250YWwnLF0gfV0sXG4gICAgc3RlcHM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05iU3RlcENvbXBvbmVudCxdIH1dXG59O1xuXG5jbGFzcyBOYlN0ZXBwZXJOZXh0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGVwcGVyKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlciA9IHN0ZXBwZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdWJtaXQnO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnN0ZXBwZXIubmV4dCgpO1xuICAgIH1cbn1cbk5iU3RlcHBlck5leHREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvbltuYlN0ZXBwZXJOZXh0XScsXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iU3RlcHBlck5leHREaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlN0ZXBwZXJDb21wb25lbnQgfVxuXTtcbk5iU3RlcHBlck5leHREaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdHlwZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLnR5cGUnLF0gfV0sXG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJyxdIH1dXG59O1xuY2xhc3MgTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyID0gc3RlcHBlcjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2J1dHRvbic7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlci5wcmV2aW91cygpO1xuICAgIH1cbn1cbk5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbmJTdGVwcGVyUHJldmlvdXNdJyxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlN0ZXBwZXJDb21wb25lbnQgfVxuXTtcbk5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHR5cGU6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci50eXBlJyxdIH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJTdGVwcGVyTW9kdWxlIHtcbn1cbk5iU3RlcHBlck1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iU3RlcHBlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJTdGVwQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlN0ZXBwZXJOZXh0RGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBOYlN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTdGVwcGVyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlN0ZXBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iU3RlcHBlck5leHREaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgIE5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBBbiBhY2NvcmRpb24gYWxsb3dzIHRvIHRvZ2dsZSB0aGUgZGlzcGxheSBvZiBzZWN0aW9ucyBvZiBjb250ZW50XG4gKlxuICogQmFzaWMgZXhhbXBsZVxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgYWNjb3JkaW9uL2FjY29yZGlvbi1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogYGBgdHNcbiAqIDxuYi1hY2NvcmRpb24+XG4gKiAgPG5iLWFjY29yZGlvbi1pdGVtPlxuICogICA8bmItYWNjb3JkaW9uLWl0ZW0taGVhZGVyPlByb2R1Y3QgRGV0YWlsczwvbmItYWNjb3JkaW9uLWl0ZW0taGVhZGVyPlxuICogICA8bmItYWNjb3JkaW9uLWl0ZW0tYm9keT5cbiAqICAgICBJdGVtIENvbnRlbnRcbiAqICAgPC9uYi1hY2NvcmRpb24taXRlbS1ib2R5PlxuICogIDwvbmItYWNjb3JkaW9uLWl0ZW0+XG4gKiA8L25iLWFjY29yZGlvbj5cbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJBY2NvcmRpb25Nb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQWNjb3JkaW9uTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBXaXRoIGBtdWx0aWAgbW9kZSBhY2NvcmRpb24gY2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgZXhwYW5kZWQ6XG4gKiBAc3RhY2tlZC1leGFtcGxlKE11bHRpcGxlIGV4cGFuZGVkIGl0ZW1zLCBhY2NvcmRpb24vYWNjb3JkaW9uLW11bHRpLmNvbXBvbmVudClcbiAqXG4gKiBgTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50YCBoYXMgc2V2ZXJhbCBtZXRob2RzLCBmb3IgZXhhbXBsZSBpdCBpcyBwb3NzaWJsZSB0byB0cmlnZ2VyIGl0ZW0gY2xpY2svdG9nZ2xlOlxuICogQHN0YWNrZWQtZXhhbXBsZShFeHBhbmQgQVBJLCBhY2NvcmRpb24vYWNjb3JkaW9uLXRvZ2dsZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGFjY29yZGlvbi1ib3JkZXItcmFkaXVzOlxuICogYWNjb3JkaW9uLXBhZGRpbmc6XG4gKiBhY2NvcmRpb24tc2hhZG93OlxuICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWNvbG9yOlxuICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGFjY29yZGlvbi1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGFjY29yZGlvbi1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIGFjY29yZGlvbi1oZWFkZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGFjY29yZGlvbi1oZWFkZXItYm9yZGVyLWNvbG9yOlxuICogYWNjb3JkaW9uLWhlYWRlci1ib3JkZXItc3R5bGU6XG4gKiBhY2NvcmRpb24taGVhZGVyLWJvcmRlci13aWR0aDpcbiAqIGFjY29yZGlvbi1pdGVtLWJhY2tncm91bmQtY29sb3I6XG4gKiBhY2NvcmRpb24taXRlbS10ZXh0LWNvbG9yOlxuICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1mb250LWZhbWlseTpcbiAqIGFjY29yZGlvbi1pdGVtLXRleHQtZm9udC1zaXplOlxuICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1mb250LXdlaWdodDpcbiAqIGFjY29yZGlvbi1pdGVtLXRleHQtbGluZS1oZWlnaHQ6XG4gKi9cbmNsYXNzIE5iQWNjb3JkaW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGVuQ2xvc2VJdGVtcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgbXVsdGlwbGUgaXRlbXMgdG8gYmUgZXhwYW5kZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgbXVsdGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpVmFsdWU7XG4gICAgfVxuICAgIHNldCBtdWx0aSh2YWwpIHtcbiAgICAgICAgdGhpcy5tdWx0aVZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFsbCBlbmFibGVkIGFjY29yZGlvbiBpdGVtcy5cbiAgICAgKi9cbiAgICBvcGVuQWxsKCkge1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuQ2xvc2VJdGVtcy5uZXh0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGVuYWJsZWQgYWNjb3JkaW9uIGl0ZW1zLlxuICAgICAqL1xuICAgIGNsb3NlQWxsKCkge1xuICAgICAgICB0aGlzLm9wZW5DbG9zZUl0ZW1zLm5leHQodHJ1ZSk7XG4gICAgfVxufVxuTmJBY2NvcmRpb25Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWFjY29yZGlvbicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbVwiPjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkFjY29yZGlvbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBtdWx0aTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbXVsdGknLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIGA8bmItYWNjb3JkaW9uPmAgY29tcG9uZW50XG4gKi9cbmNsYXNzIE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYWNjb3JkaW9uLCBjZCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbiA9IGFjY29yZGlvbjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbmV2ZXIgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSBhY2NvcmRpb24gY2hhbmdlcy5cbiAgICAgICAgICogUHJpbWFyaWx5IHVzZWQgdG8gZmFjaWxpdGF0ZSB0d28td2F5IGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZW0gaXMgY29sbGFwc2UgKGB0cnVlYCBieSBkZWZhdWx0KVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZFZhbHVlO1xuICAgIH1cbiAgICBzZXQgY29sbGFwc2VkKHZhbCkge1xuICAgICAgICB0aGlzLmNvbGxhcHNlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5jb2xsYXBzZWRWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVtIGlzIGV4cGFuZGVkIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cbiAgICBzZXQgZXhwYW5kZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkVmFsdWUgPSAhY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZW0gaXMgZGlzYWJsZWQgYW5kIGNhbm5vdCBiZSBvcGVuZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZFZhbHVlO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3Blbi9jbG9zZSB0aGUgaXRlbVxuICAgICAqL1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdGVtcG9yYXJ5IHZhcmlhYmxlIGFzIGBvcGVuQ2xvc2VJdGVtcy5uZXh0YCB3aWxsIGNoYW5nZSBjdXJyZW50IHZhbHVlIHdlIG5lZWQgdG8gc2F2ZVxuICAgICAgICAgICAgY29uc3Qgd2lsbFNldCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY2NvcmRpb24ubXVsdGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5vcGVuQ2xvc2VJdGVtcy5uZXh0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSB3aWxsU2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGl0ZW0uXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgaXRlbS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gdHJ1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbi5vcGVuQ2xvc2VJdGVtc1xuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShjb2xsYXBzZWQgPT4ge1xuICAgICAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gY29sbGFwc2VkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZS5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbkl0ZW1JbnZhbGlkYXRlLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1hY2NvcmRpb24taXRlbScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbS1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItYWNjb3JkaW9uLWl0ZW0tYm9keVwiPjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iQWNjb3JkaW9uQ29tcG9uZW50LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBIb3N0IH1dIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbGxhcHNlZDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnY29sbGFwc2VkJyxdIH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuY29sbGFwc2VkJyxdIH1dLFxuICAgIGV4cGFuZGVkOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydleHBhbmRlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmV4cGFuZGVkJyxdIH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRpc2FibGVkJyxdIH1dLFxuICAgIGNvbGxhcHNlZENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBhY2NvcmRpb25JdGVtQm9keVRyaWdnZXIgPSB0cmlnZ2VyKCdhY2NvcmRpb25JdGVtQm9keScsIFtcbiAgICBzdGF0ZSgnY29sbGFwc2VkJywgc3R5bGUoe1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgfSkpLFxuICAgIHN0YXRlKCdleHBhbmRlZCcsIHN0eWxlKHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgfSkpLFxuICAgIHRyYW5zaXRpb24oJ2NvbGxhcHNlZCA9PiBleHBhbmRlZCcsIGFuaW1hdGUoJzEwMG1zIGVhc2UtaW4nKSksXG4gICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPT4gY29sbGFwc2VkJywgYW5pbWF0ZSgnMTAwbXMgZWFzZS1vdXQnKSksXG5dKTtcbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIGA8bmItYWNjb3JkaW9uLWl0ZW0+YCBjb21wb25lbnRcbiAqL1xuY2xhc3MgTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYWNjb3JkaW9uSXRlbSwgY2QpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtID0gYWNjb3JkaW9uSXRlbTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NvcmRpb25JdGVtLmNvbGxhcHNlZCA/ICdjb2xsYXBzZWQnIDogJ2V4cGFuZGVkJztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uSXRlbS5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYWNjb3JkaW9uLWl0ZW0tYm9keScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IFtAYWNjb3JkaW9uSXRlbUJvZHldPVwieyB2YWx1ZTogc3RhdGUgfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cIml0ZW0tYm9keVwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbYWNjb3JkaW9uSXRlbUJvZHlUcmlnZ2VyXSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkFjY29yZGlvbkl0ZW1Cb2R5Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBIb3N0IH1dIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiBgPG5iLWFjY29yZGlvbi1pdGVtPmAgY29tcG9uZW50XG4gKi9cbmNsYXNzIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYWNjb3JkaW9uSXRlbSwgY2QpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtID0gYWNjb3JkaW9uSXRlbTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgZ2V0IGlzQ29sbGFwc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NvcmRpb25JdGVtLmNvbGxhcHNlZDtcbiAgICB9XG4gICAgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuYWNjb3JkaW9uSXRlbS5jb2xsYXBzZWQ7XG4gICAgfVxuICAgIC8vIGlzc3VlICM3OTRcbiAgICBnZXQgdGFiYmFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY29yZGlvbkl0ZW0uZGlzYWJsZWQgPyAnLTEnIDogJzAnO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY29yZGlvbkl0ZW0uZGlzYWJsZWQ7XG4gICAgfVxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtLnRvZ2dsZSgpO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbGxhcHNlZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnZXhwYW5kZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbkl0ZW0uYWNjb3JkaW9uSXRlbUludmFsaWRhdGVcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbk5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYWNjb3JkaW9uLWl0ZW0taGVhZGVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWFjY29yZGlvbi1pdGVtLXRpdGxlXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWFjY29yZGlvbi1pdGVtLWRlc2NyaXB0aW9uXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8bmItaWNvbiBpY29uPVwiY2hldnJvbi1kb3duLW91dGxpbmVcIlxuICAgICAgICAgICAgIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIlxuICAgICAgICAgICAgIFtAZXhwYW5zaW9uSW5kaWNhdG9yXT1cInN0YXRlXCJcbiAgICAgICAgICAgICAqbmdJZj1cIiFkaXNhYmxlZFwiXG4gICAgICAgICAgICAgY2xhc3M9XCJleHBhbnNpb24taW5kaWNhdG9yXCI+XG4gICAgPC9uYi1pY29uPlxuICBgLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignZXhwYW5zaW9uSW5kaWNhdG9yJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2NvbGxhcHNlZCA9PiBleHBhbmRlZCcsIGFuaW1hdGUoJzEwMG1zIGVhc2UtaW4nKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdleHBhbmRlZCA9PiBjb2xsYXBzZWQnLCBhbmltYXRlKCcxMDBtcyBlYXNlLW91dCcpKSxcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9Omhvc3Q6Zm9jdXN7b3V0bGluZTowfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkFjY29yZGlvbkl0ZW1IZWFkZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEhvc3QgfV0gfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5OYkFjY29yZGlvbkl0ZW1IZWFkZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaXNDb2xsYXBzZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY29yZGlvbi1pdGVtLWhlYWRlci1jb2xsYXBzZWQnLF0gfV0sXG4gICAgZXhwYW5kZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjY29yZGlvbi1pdGVtLWhlYWRlci1leHBhbmRlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1leHBhbmRlZCcsXSB9XSxcbiAgICB0YWJiYWJsZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci50YWJpbmRleCcsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWRpc2FibGVkJyxdIH1dLFxuICAgIHRvZ2dsZTogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJyxdIH0sIHsgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2tleWRvd24uc3BhY2UnLF0gfSwgeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bi5lbnRlcicsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfQUNDT1JESU9OX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJBY2NvcmRpb25Db21wb25lbnQsXG4gICAgTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50LFxuICAgIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudCxcbiAgICBOYkFjY29yZGlvbkl0ZW1Cb2R5Q29tcG9uZW50LFxuXTtcbmNsYXNzIE5iQWNjb3JkaW9uTW9kdWxlIHtcbn1cbk5iQWNjb3JkaW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBOYkljb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFsuLi5OQl9BQ0NPUkRJT05fQ09NUE9ORU5UU10sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbLi4uTkJfQUNDT1JESU9OX0NPTVBPTkVOVFNdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBgW25iQnV0dG9uVG9nZ2xlXWAgaXMgYSBkaXJlY3RpdmUgdG8gYWRkIGEgYHByZXNzZWRgIHN0YXRlIHRvIGEgYnV0dG9uLlxuICovXG5jbGFzcyBOYkJ1dHRvblRvZ2dsZURpcmVjdGl2ZSBleHRlbmRzIE5iQnV0dG9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgaG9zdEVsZW1lbnQsIGNkLCB6b25lLCBzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyLCBob3N0RWxlbWVudCwgY2QsIHpvbmUsIHN0YXR1c1NlcnZpY2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9wcmVzc2VkQ2hhbmdlJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdmaWxsZWQnO1xuICAgICAgICB0aGlzLl9wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuZXZlciBidXR0b24gcHJlc3NlZCBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLnByZXNzZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBwcmVzc2VkQ2hhbmdlJCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXNzZWRDaGFuZ2UkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBidXR0b24gcHJlc3NlZCBzdGF0ZVxuICAgICAqKi9cbiAgICBnZXQgcHJlc3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXNzZWQ7XG4gICAgfVxuICAgIHNldCBwcmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXNzZWQgIT09IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXNzZWQgPSAhdGhpcy5wcmVzc2VkO1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkQ2hhbmdlLmVtaXQodGhpcy5wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXNzZWRDaGFuZ2UkLm5leHQoeyBzb3VyY2U6IHRoaXMsIHByZXNzZWQ6IHRoaXMucHJlc3NlZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIC8vIEJ5IGRlc2lnbiwgYWxsIHRvZ2dsZSBidXR0b25zIHNob3VsZCBoYXZlIGEgYGJhc2ljYCBzdGF0dXMgd2hlbiBub3QgcHJlc3NlZC5cbiAgICAgICAgcmV0dXJuICF0aGlzLnByZXNzZWQ7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzc2VkICYmICh0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJyB8fCB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknKTtcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWQgJiYgdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWQgJiYgdGhpcy5zdGF0dXMgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXNzZWQgJiYgdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc3NlZCAmJiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzc2VkICYmIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIGdldCBhZGRpdGlvbmFsQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzU2VydmljZS5pc0N1c3RvbVN0YXR1cyh0aGlzLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMuc3RhdHVzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnByZXNzZWQgPSAhdGhpcy5wcmVzc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVByZXNzZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuTmJCdXR0b25Ub2dnbGVEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2J1dHRvbltuYkJ1dHRvblRvZ2dsZV0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5iQnV0dG9uLCB1c2VFeGlzdGluZzogTmJCdXR0b25Ub2dnbGVEaXJlY3RpdmUgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmJCdXR0b25Ub2dnbGUnLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkJ1dHRvblRvZ2dsZURpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYkJ1dHRvblRvZ2dsZURpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBhcHBlYXJhbmNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwcmVzc2VkOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1wcmVzc2VkJyxdIH1dLFxuICAgIHByZXNzZWRDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIGluZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBjb250cm9sOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtY29udHJvbCcsXSB9XSxcbiAgICBhZGRpdGlvbmFsQ2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MnLF0gfV0sXG4gICAgb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIGA8bmItYnV0dG9uLWdyb3VwPmAgdmlzdWFsbHkgZ3JvdXBzIGJ1dHRvbnMgdG9nZXRoZXIgYW5kIGFsbG93IHRvIGNvbnRyb2wgYnV0dG9ucyBwcm9wZXJ0aWVzIGFuZCB0aGUgc3RhdGUgYXMgYVxuICogZ3JvdXAuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbiBHcm91cCBTaG93Y2FzZSwgYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJCdXR0b25Hcm91cE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJCdXR0b25Hcm91cE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFlvdSBjYW4gdXNlIGA8bmItYnV0dG9uLWdyb3VwPmAgdG8gZ3JvdXAgYSBzZXJpZXMgb2YgYFtuYkJ1dHRvbl1gIG9yIGBbbmJCdXR0b25Ub2dnbGVdYCBjb21wb25lbnRzLlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gYW5kIEJ1dHRvbiBUb2dnbGUgR3JvdXBzLCBidXR0b24tZ3JvdXAvYnV0dG9uLWFuZC1idXR0b24tdG9nZ2xlLWdyb3Vwcy5jb21wb25lbnQpXG4gKlxuICogRm9yIGEgZ3JvdXAgb2YgbXVsdGlwbGUgYFtuYkJ1dHRvblRvZ2dsZV1gIHlvdSBhbHNvIGNhbiBjb250cm9sIG11bHRpLXNlbGVjdGlvbiBiZWhhdmlvci4gQnkgZGVmYXVsdCwgdGhlIGdyb3VwXG4gKiBjb21wb25lbnQgYWxsb3dzIG9ubHkgb25lIHByZXNzZWQgYnV0dG9uIHRvZ2dsZSBhdCBhIHRpbWUgKHNpbWlsYXIgdG8gdGhlIHJhZGlvIGdyb3VwKS4gVG8gYmUgYWJsZSB0byBrZWVwIG11bHRpcGxlXG4gKiB0b2dnbGVzIHByZXNzZWQsIHlvdSBuZWVkIHRvIGFkZCBgbXVsdGlwbGVgIGF0dHJpYnV0ZXMgdG8gdGhlIGA8bmItYnV0dG9uLXRvZ2dsZT5gLlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gR3JvdXAgTXVsdGlwbGUsIGJ1dHRvbi1ncm91cC9idXR0b24tZ3JvdXAtbXVsdGlwbGUuY29tcG9uZW50KVxuICpcbiAqIFRvIGRpc2FibGUgYSBncm91cCBvZiBidXR0b25zLCBhZGQgYSBgZGlzYWJsZWRgIGF0dHJpYnV0ZSB0byB0aGUgYDxuYi1idXR0b24tZ3JvdXA+YC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIEdyb3VwIERpc2FibGVkLCBidXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLWRpc2FibGVkLmNvbXBvbmVudClcbiAqXG4gKiBUaGUgZ3JvdXAgY29tcG9uZW50IGNvbnRyb2xzIGFsbCB2aXN1YWwgYXR0cmlidXRlcyBvZiBidXR0b25zIHN1Y2ggYXMgYGFwcGVhcmFuY2VgLCBgc3RhdHVzYCwgYHNpemVgLCBgc2hhcGVgLlxuICogWW91IGNhbiBjaGFuZ2UgaXQgdmlhIHRoZSBhcHByb3ByaWF0ZSBhdHRyaWJ1dGVzLlxuICpcbiAqIEJ1dHRvbiBncm91cCBhcHBlYXJhbmNlczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIEdyb3VwIEFwcGVhcmFuY2VzLCBidXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLWFwcGVhcmFuY2VzLmNvbXBvbmVudClcbiAqXG4gKiBCdXR0b24gZ3JvdXAgc3RhdHVzZXM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbiBHcm91cCBTdGF0dXNlcywgYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC1zdGF0dXNlcy5jb21wb25lbnQpXG4gKlxuICogQnV0dG9uIGdyb3VwIHNpemVzOlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gR3JvdXAgU2l6ZXMsIGJ1dHRvbi1ncm91cC9idXR0b24tZ3JvdXAtc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEJ1dHRvbnMgZ3JvdXAgc2hhcGVzOlxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShCdXR0b24gR3JvdXAgU2hhcGVzLCBidXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLXNoYXBlcy5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtYnV0dG9uLWJhc2ljLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWJ1dHRvbi1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWJ1dHRvbi1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWJ1dHRvbi1pbmZvLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWJ1dHRvbi13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWJ1dHRvbi1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtYnV0dG9uLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtYmFzaWMtZGl2aWRlci1jb2xvcjpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtcHJpbWFyeS1kaXZpZGVyLWNvbG9yOlxuICogYnV0dG9uLWdyb3VwLWZpbGxlZC1zdWNjZXNzLWRpdmlkZXItY29sb3I6XG4gKiBidXR0b24tZ3JvdXAtZmlsbGVkLWluZm8tZGl2aWRlci1jb2xvcjpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtd2FybmluZy1kaXZpZGVyLWNvbG9yOlxuICogYnV0dG9uLWdyb3VwLWZpbGxlZC1kYW5nZXItZGl2aWRlci1jb2xvcjpcbiAqIGJ1dHRvbi1ncm91cC1maWxsZWQtY29udHJvbC1kaXZpZGVyLWNvbG9yOlxuICogYnV0dG9uLWdyb3VwLWdob3N0LWRpdmlkZXItY29sb3I6XG4gKiovXG5jbGFzcyBOYkJ1dHRvbkdyb3VwQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZCwgc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VydmljZSA9IHN0YXR1c1NlcnZpY2U7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmJ1dHRvbnNDaGFuZ2UkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1dHRvbiBncm91cCBzaXplLCBhdmFpbGFibGUgc2l6ZXM6XG4gICAgICAgICAqIGB0aW55YCwgYHNtYWxsYCwgYG1lZGl1bWAsIGBsYXJnZWAsIGBnaWFudGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnV0dG9uIGdyb3VwIHN0YXR1cyAoYWRkcyBzcGVjaWZpYyBzdHlsZXMpOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1dHRvbiBncm91cCBzaGFwZXM6IGByZWN0YW5nbGVgLCBgcm91bmRgLCBgc2VtaS1yb3VuZGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hhcGUgPSAncmVjdGFuZ2xlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1dHRvbiBncm91cCBhcHBlYXJhbmNlOiBgZmlsbGVkYCwgYG91dGxpbmVgLCBgZ2hvc3RgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZmlsbGVkJztcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb2xlID0gJ2dyb3VwJztcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCAhPT0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAhdGhpcy5kaXNhYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8ga2VlcCBtdWx0aXBsZSBidXR0b24gdG9nZ2xlcyBwcmVzc2VkLiBPZmYgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBnZXQgbXVsdGlwbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aXBsZTtcbiAgICB9XG4gICAgc2V0IG11bHRpcGxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBgZmlsbGVkYCBhcHBlYXJhbmNlXG4gICAgICovXG4gICAgZ2V0IGZpbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2ZpbGxlZCc7XG4gICAgfVxuICAgIHNldCBmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdmaWxsZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYG91dGxpbmVgIGFwcGVhcmFuY2VcbiAgICAgKi9cbiAgICBnZXQgb3V0bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ291dGxpbmUnO1xuICAgIH1cbiAgICBzZXQgb3V0bGluZSh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ291dGxpbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYGdob3N0YCBhcHBlYXJhbmNlXG4gICAgICovXG4gICAgZ2V0IGdob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlYXJhbmNlID09PSAnZ2hvc3QnO1xuICAgIH1cbiAgICBzZXQgZ2hvc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdnaG9zdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKHsgc2l6ZSwgc3RhdHVzLCBzaGFwZSwgbXVsdGlwbGUsIGZpbGxlZCwgb3V0bGluZSwgZ2hvc3QsIGRpc2FibGVkIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc2l6ZSB8fCBzdGF0dXMgfHwgc2hhcGUgfHwgbXVsdGlwbGUgfHwgZmlsbGVkIHx8IG91dGxpbmUgfHwgZ2hvc3QgfHwgZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0J1dHRvbnNQcm9wZXJ0aWVzKCgoX2EgPSB0aGlzLmJ1dHRvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0FycmF5KCkpIHx8IFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uc0NoYW5nZSRcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGJ1dHRvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuQnV0dG9uUHJlc3NlZFN0YXRlKGJ1dHRvbnMpO1xuICAgICAgICAgICAgdGhpcy5zeW5jQnV0dG9uc1Byb3BlcnRpZXMoYnV0dG9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1dHRvbnMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgIC8vIGBidXR0b25zLmNoYW5nZXNgIGVtaXQgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24gcnVuIGFmdGVyIHByb2plY3RlZCBjb250ZW50IGFscmVhZHkgd2FzIGluaXRpYWxpemVkLlxuICAgICAgICAvLyBTbyBhdCB0aGlzIHRpbWUsIGl0J3MgdG9vIGxhdGUgdG8gdXBkYXRlIHByb2plY3RlZCBidXR0b25zIHByb3BlcnRpZXMgYXMgdXBkYXRpbmcgYmluZGluZ3MgYWZ0ZXJcbiAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24gZG9lc24ndCBtYWtlIHNlbnNlLiBDaGFuZ2VzIHdvbid0IGJlIHBpY2tlZCB1cCBhbmQgc2hvdWxkIGNhdXNlIGFuIFwiZXhwcmVzc2lvbiBjaGFuZ2VkXCIgZXJyb3IuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHdyYXAgdGhlIG5ldyBidXR0b25zIGxpc3QgaW50byBhIHByb21pc2UgdG8gZGVmZXIgdXBkYXRlIHRvIHRoZSBmb2xsb3dpbmcgbWljcm90YXNrIGFuZCBhbHNvIHRvXG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBvbmUgbW9yZSB0aW1lLlxuICAgICAgICBzd2l0Y2hNYXAoKGJ1dHRvbnMpID0+IGZyb20oUHJvbWlzZS5yZXNvbHZlKGJ1dHRvbnMudG9BcnJheSgpKSkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuYnV0dG9uc0NoYW5nZSQpO1xuICAgICAgICB0aGlzLmJ1dHRvbnNDaGFuZ2UkLm5leHQodGhpcy5idXR0b25zLnRvQXJyYXkoKSk7XG4gICAgfVxuICAgIGxpc3RlbkJ1dHRvblByZXNzZWRTdGF0ZShidXR0b25zKSB7XG4gICAgICAgIGNvbnN0IHRvZ2dsZUJ1dHRvbnMgPSBidXR0b25zLmZpbHRlcigoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uIGluc3RhbmNlb2YgTmJCdXR0b25Ub2dnbGVEaXJlY3RpdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRvZ2dsZUJ1dHRvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnV0dG9uc1ByZXNzZWRDaGFuZ2UkID0gdG9nZ2xlQnV0dG9uc1xuICAgICAgICAgICAgLm1hcCgoYnV0dG9uKSA9PiBidXR0b24ucHJlc3NlZENoYW5nZSQpO1xuICAgICAgICBtZXJnZSguLi5idXR0b25zUHJlc3NlZENoYW5nZSQpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsgcHJlc3NlZCB9KSA9PiAhdGhpcy5tdWx0aXBsZSAmJiBwcmVzc2VkKSwgdGFrZVVudGlsKG1lcmdlKHRoaXMuYnV0dG9uc0NoYW5nZSQsIHRoaXMuZGVzdHJveSQpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHsgc291cmNlIH0pID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChidXR0b24pID0+IGJ1dHRvbiAhPT0gc291cmNlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChidXR0b24pID0+IGJ1dHRvbi5fdXBkYXRlUHJlc3NlZChmYWxzZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3luY0J1dHRvbnNQcm9wZXJ0aWVzKGJ1dHRvbnMpIHtcbiAgICAgICAgYnV0dG9ucy5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgICAgICAgIGJ1dHRvbi51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhcHBlYXJhbmNlOiB0aGlzLmFwcGVhcmFuY2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc2hhcGU6IHRoaXMuc2hhcGUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuTmJCdXR0b25Hcm91cENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYnV0dG9uLWdyb3VwJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkJ1dHRvbkdyb3VwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5iU3RhdHVzU2VydmljZSB9XG5dO1xuTmJCdXR0b25Hcm91cENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBidXR0b25zOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYkJ1dHRvbixdIH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2hhcGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFwcGVhcmFuY2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtdWx0aXBsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsbGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvdXRsaW5lOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBnaG9zdDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJCdXR0b25Hcm91cE1vZHVsZSB7XG59XG5OYkJ1dHRvbkdyb3VwTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYkJ1dHRvbkdyb3VwQ29tcG9uZW50LCBOYkJ1dHRvblRvZ2dsZURpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW05iQnV0dG9uR3JvdXBDb21wb25lbnQsIE5iQnV0dG9uVG9nZ2xlRGlyZWN0aXZlXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIExpc3QgaXMgYSBjb250YWluZXIgY29tcG9uZW50IHRoYXQgd3JhcHMgYG5iLWxpc3QtaXRlbWAgY29tcG9uZW50LlxuICpcbiAqIEJhc2ljIGV4YW1wbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbXBsZSBsaXN0LCBsaXN0L3NpbXBsZS1saXN0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgbmItbGlzdC1pdGVtYCBhY2NlcHRzIGFyYml0cmFyeSBjb250ZW50LCBzbyB5b3UgY2FuIGNyZWF0ZSBhIGxpc3Qgb2YgYW55IGNvbXBvbmVudHMuXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJMaXN0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkxpc3RNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIExpc3Qgb2YgdXNlcnM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFVzZXJzIGxpc3QsIGxpc3QvdXNlcnMtbGlzdC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGxpc3QtaXRlbS1kaXZpZGVyLWNvbG9yOlxuICogbGlzdC1pdGVtLWRpdmlkZXItc3R5bGU6XG4gKiBsaXN0LWl0ZW0tZGl2aWRlci13aWR0aDpcbiAqIGxpc3QtaXRlbS1wYWRkaW5nOlxuICogbGlzdC1pdGVtLXRleHQtY29sb3I6XG4gKiBsaXN0LWl0ZW0tZm9udC1mYW1pbHk6XG4gKiBsaXN0LWl0ZW0tZm9udC1zaXplOlxuICogbGlzdC1pdGVtLWZvbnQtd2VpZ2h0OlxuICogbGlzdC1pdGVtLWxpbmUtaGVpZ2h0OlxuICovXG5jbGFzcyBOYkxpc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUm9sZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9sZSA9ICdsaXN0JztcbiAgICB9XG59XG5OYkxpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWxpc3QnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItbGlzdC1pdGVtXCI+PC9uZy1jb250ZW50PmAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXg6MSAxIGF1dG87b3ZlcmZsb3c6YXV0b31cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHJvbGU6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5yb2xlJyxdIH1dXG59O1xuLyoqXG4gKiBMaXN0IGl0ZW0gY29tcG9uZW50IGlzIGEgZ3JvdXBpbmcgY29tcG9uZW50IHRoYXQgYWNjZXB0cyBhcmJpdHJhcnkgY29udGVudC5cbiAqIEl0IHNob3VsZCBiZSBkaXJlY3QgY2hpbGQgb2YgYG5iLWxpc3RgIGNvbXBvbmV0LlxuICovXG5jbGFzcyBOYkxpc3RJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJvbGUgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvbGUgPSAnbGlzdGl0ZW0nO1xuICAgIH1cbn1cbk5iTGlzdEl0ZW1Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWxpc3QtaXRlbScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC1zaHJpbms6MH1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMaXN0SXRlbUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICByb2xlOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XVxufTtcblxuLyoqXG4gKiBMaXN0IHBhZ2VyIGRpcmVjdGl2ZVxuICpcbiAqIERpcmVjdGl2ZSBhbGxvd3MgeW91IHRvIGRldGVybWluZSBwYWdlIG9mIGN1cnJlbnRseSB2aWV3aW5nIGl0ZW1zLlxuICpcbiAqL1xuY2xhc3MgTmJMaXN0UGFnZVRyYWNrZXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhZ2UgdG8gc3RhcnQgY291bnRpbmcgd2l0aC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRQYWdlID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gYW5vdGhlciBwYWdlIGJlY29tZSB2aXNpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4gdGhpcy5jaGVja0ZvclBhZ2VDaGFuZ2UoZW50cmllcyksIHsgdGhyZXNob2xkOiAwLjUgfSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdEl0ZW1zICYmIHRoaXMubGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSXRlbXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RJdGVtcy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub2JzZXJ2ZUl0ZW1zKCkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0ICYmIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBvYnNlcnZlSXRlbXMoKSB7XG4gICAgICAgIHRoaXMubGlzdEl0ZW1zLmZvckVhY2goaSA9PiB0aGlzLm9ic2VydmVyLm9ic2VydmUoaS5uYXRpdmVFbGVtZW50KSk7XG4gICAgfVxuICAgIGNoZWNrRm9yUGFnZUNoYW5nZShlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IG1vc3RWaXNpYmxlUGFnZSA9IHRoaXMuZmluZE1vc3RWaXNpYmxlUGFnZShlbnRyaWVzKTtcbiAgICAgICAgaWYgKG1vc3RWaXNpYmxlUGFnZSAmJiB0aGlzLmN1cnJlbnRQYWdlICE9PSBtb3N0VmlzaWJsZVBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBtb3N0VmlzaWJsZVBhZ2U7XG4gICAgICAgICAgICB0aGlzLnBhZ2VDaGFuZ2UuZW1pdCh0aGlzLmN1cnJlbnRQYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW9zdFZpc2libGVQYWdlKGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uUmF0aW9CeVBhZ2UgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmludGVyc2VjdGlvblJhdGlvIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50SW5kZXggPSB0aGlzLmVsZW1lbnRJbmRleChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnN0YXJ0UGFnZSArIE1hdGguZmxvb3IoZWxlbWVudEluZGV4IC8gdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbztcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpb0J5UGFnZS5oYXMocGFnZSkpIHtcbiAgICAgICAgICAgICAgICByYXRpbyArPSBpbnRlcnNlY3Rpb25SYXRpb0J5UGFnZS5nZXQocGFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25SYXRpb0J5UGFnZS5zZXQocGFnZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhSYXRpbyA9IDA7XG4gICAgICAgIGxldCBtb3N0VmlzaWJsZVBhZ2U7XG4gICAgICAgIGludGVyc2VjdGlvblJhdGlvQnlQYWdlLmZvckVhY2goKHJhdGlvLCBwYWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmF0aW8gPiBtYXhSYXRpbykge1xuICAgICAgICAgICAgICAgIG1heFJhdGlvID0gcmF0aW87XG4gICAgICAgICAgICAgICAgbW9zdFZpc2libGVQYWdlID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb3N0VmlzaWJsZVBhZ2U7XG4gICAgfVxuICAgIGVsZW1lbnRJbmRleChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudEVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuXG4gICAgICAgICAgICA/IEFycmF5LmZyb20oZWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuKS5pbmRleE9mKGVsZW1lbnQpXG4gICAgICAgICAgICA6IC0xO1xuICAgIH1cbn1cbk5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJMaXN0UGFnZVRyYWNrZXJdJyxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJMaXN0UGFnZVRyYWNrZXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXTtcbk5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHBhZ2VTaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGFydFBhZ2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBhZ2VDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBsaXN0SXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05iTGlzdEl0ZW1Db21wb25lbnQsIHsgcmVhZDogRWxlbWVudFJlZiB9LF0gfV1cbn07XG5cbmNsYXNzIE5iU2Nyb2xsYWJsZUNvbnRhaW5lckRpbWVudGlvbnMge1xufVxuLyoqXG4gKiBJbmZpbml0ZSBMaXN0IERpcmVjdGl2ZVxuICpcbiAqIGBgYGh0bWxcbiAqICA8bmItbGlzdCBuYkluZmluaXRlTGlzdCBbdGhyZXNob2xkXT1cIjUwMFwiIChib3R0b21UaHJlc2hvbGQpPVwibG9hZE5leHQoKVwiPlxuICogICAgPG5iLWxpc3QtaXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPjwvbmItbGlzdC1pdGVtPlxuICogIDwvbmItbGlzdD5cbiAqIGBgYFxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2ltcGxlIGluZmluaXRlIGxpc3QsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogRGlyZWN0aXZlIHdpbGwgbm90aWZ5IHdoZW4gbGlzdCBzY3JvbGxlZCB1cCBvciBkb3duIHRvIGEgZ2l2ZW4gdGhyZXNob2xkLlxuICogQnkgZGVmYXVsdCBpdCBsaXN0ZW4gdG8gc2Nyb2xsIG9mIGxpc3Qgb24gd2hpY2ggYXBwbGllZCwgYnV0IGFsc28gY2FuIGJlIHNldCB0byBsaXN0ZW4gdG8gd2luZG93IHNjcm9sbC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNjcm9sbCBtb2RlcywgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1saXN0LXNjcm9sbC1tb2Rlcy5jb21wb25lbnQpXG4gKlxuICogVG8gaW1wcm92ZSBVWCBvZiBpbmZpbml0ZSBsaXN0cywgaXQncyBiZXR0ZXIgdG8ga2VlcCBjdXJyZW50IHBhZ2UgaW4gdXJsLFxuICogc28gdXNlciBhYmxlIHRvIHJldHVybiB0byB0aGUgbGFzdCB2aWV3ZWQgcGFnZSBvciB0byBzaGFyZSBhIGxpbmsgdG8gdGhpcyBwYWdlLlxuICogYG5iTGlzdFBhZ2VUcmFja2VyYCBkaXJlY3RpdmUgd2lsbCBoZWxwIHlvdSB0byBrbm93LCB3aGF0IHBhZ2UgdXNlciBjdXJyZW50bHkgdmlld2luZy5cbiAqIEp1c3QgcHV0IGl0IG9uIGEgbGlzdCwgc2V0IHBhZ2Ugc2l6ZSBhbmQgaXQgd2lsbCBjYWxjdWxhdGUgcGFnZSB0aGF0IGN1cnJlbnRseSBpbiB2aWV3cG9ydC5cbiAqIFlvdSBjYW4gW29wZW4gdGhlIGV4YW1wbGVdKGV4YW1wbGUvaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1uZXdzLWxpc3QuY29tcG9uZW50KVxuICogaW4gYSBuZXcgdGFiIHRvIGNoZWNrIG91dCB0aGlzIGZlYXR1cmUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShJbmZpbml0ZSBsaXN0IHdpdGggcGFnZXIsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbmV3cy1saXN0LmNvbXBvbmVudClcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEluZmluaXRlIGxpc3Qgd2l0aCBwbGFjZWhvbGRlcnMgYXQgdGhlIHRvcCwgaW5maW5pdGUtbGlzdC9pbmZpbml0ZS1saXN0LXBsYWNlaG9sZGVycy5jb21wb25lbnQpXG4gKlxuICovXG5jbGFzcyBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgc2Nyb2xsU2VydmljZSwgZGltZW5zaW9uc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zU2VydmljZSA9IGRpbWVuc2lvbnNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy53aW5kb3dTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gZGlzdGFuY2UgYmV0d2VlbiBsaXN0IGJvdHRvbSBhbmQgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaXMgbGVzcyB0aGFuIHRocmVzaG9sZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm90dG9tVGhyZXNob2xkID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gZGlzdGFuY2UgYmV0d2VlbiBsaXN0IHRvcCBhbmQgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gaXMgbGVzcyB0aGFuIHRocmVzaG9sZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9wVGhyZXNob2xkID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy53aW5kb3dTY3JvbGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQgY29tcG9uZW50IG9ic2VydmVzIGxpc3Qgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIGNvbXBvbmVudCB3aWxsIG9ic2VydmUgcG9zaXRpb24gb2YgcGFnZSBzY3JvbGwgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBzZXQgbGlzdGVuV2luZG93U2Nyb2xsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93U2Nyb2xsID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgb25FbGVtZW50U2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50U2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUG9zaXRpb24odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlLm9uU2Nyb2xsKClcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLndpbmRvd1Njcm9sbCksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLmdldENvbnRhaW5lckRpbWVuc2lvbnMoKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGltZW50aW9ucyA9PiB0aGlzLmNoZWNrUG9zaXRpb24oZGltZW50aW9ucykpO1xuICAgICAgICB0aGlzLmxpc3RJdGVtcy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBjaGFuZ2VzIGFyZSBlbWl0dGVkIGJlZm9yZSBsaXN0IGl0ZW0gcmVtb3ZlZCBmcm9tIGRvbSxcbiAgICAgICAgLy8gc28gZGltZW5zaW9ucyB3aWxsIGJlIGluY29ycmVjdC5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgNTBtcyBmb3IgYSBzZWNvbmQgaWYgZG9tIGFuZCBxdWVyeSBhcmUgaW4gc3luYy5cbiAgICAgICAgLy8gT25jZSB0aGV5IHN5bmNocm9uaXplZCwgd2UgY2FuIGdldCBwcm9wZXIgZGltZW5zaW9ucy5cbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IGludGVydmFsKDUwKS5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmluU3luY1dpdGhEb20oKSksIHRha2UoMSksIHRha2VVbnRpbCh0aW1lcigxMDAwKSkpKSwgc3dpdGNoTWFwKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkaW1lbnRpb25zID0+IHRoaXMuY2hlY2tQb3NpdGlvbihkaW1lbnRpb25zKSk7XG4gICAgICAgIHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpLnN1YnNjcmliZShkaW1lbnRpb25zID0+IHRoaXMuY2hlY2tQb3NpdGlvbihkaW1lbnRpb25zKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBjaGVja1Bvc2l0aW9uKHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AsIGNsaWVudEhlaWdodCB9KSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxDaGVjayA9IHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uID09IG51bGw7XG4gICAgICAgIGNvbnN0IG1hbnVhbENoZWNrID0gdGhpcy5sYXN0U2Nyb2xsUG9zaXRpb24gPT09IHNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVXAgPSBzY3JvbGxUb3AgPCB0aGlzLmxhc3RTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRG93biA9IHNjcm9sbFRvcCA+IHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoKGluaXRpYWxDaGVjayB8fCBtYW51YWxDaGVjayB8fCBzY3JvbGxEb3duKSAmJiBkaXN0YW5jZVRvQm90dG9tIDw9IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVRocmVzaG9sZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbml0aWFsQ2hlY2sgfHwgc2Nyb2xsVXApICYmIHNjcm9sbFRvcCA8PSB0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy50b3BUaHJlc2hvbGQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRDb250YWluZXJEaW1lbnNpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50U2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIG9mKHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ya0pvaW4odGhpcy5zY3JvbGxTZXJ2aWNlLmdldFBvc2l0aW9uKCksIHRoaXMuZGltZW5zaW9uc1NlcnZpY2UuZ2V0RGltZW5zaW9ucygpKVxuICAgICAgICAgICAgLnBpcGUobWFwKChbc2Nyb2xsUG9zaXRpb24sIGRpbWVuc2lvbnNdKSA9PiAoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxQb3NpdGlvbi55LFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiBkaW1lbnNpb25zLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGltZW5zaW9ucy5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGluU3luY1dpdGhEb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IHRoaXMubGlzdEl0ZW1zLmxlbmd0aDtcbiAgICB9XG59XG5OYkluZmluaXRlTGlzdERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iSW5maW5pdGVMaXN0XScsXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iSW5maW5pdGVMaXN0RGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmJMYXlvdXRTY3JvbGxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkxheW91dFJ1bGVyU2VydmljZSB9XG5dO1xuTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGhyZXNob2xkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBsaXN0ZW5XaW5kb3dTY3JvbGw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJvdHRvbVRocmVzaG9sZDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHRvcFRocmVzaG9sZDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG9uRWxlbWVudFNjcm9sbDogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ3Njcm9sbCcsXSB9XSxcbiAgICBsaXN0SXRlbXM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05iTGlzdEl0ZW1Db21wb25lbnQsXSB9XVxufTtcblxuY29uc3QgY29tcG9uZW50cyA9IFtcbiAgICBOYkxpc3RDb21wb25lbnQsXG4gICAgTmJMaXN0SXRlbUNvbXBvbmVudCxcbiAgICBOYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZSxcbiAgICBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSxcbl07XG5jbGFzcyBOYkxpc3RNb2R1bGUge1xufVxuTmJMaXN0TW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogY29tcG9uZW50cyxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG5jbGFzcyBOYkRpcmVjdGlvbmFsaXR5IGV4dGVuZHMgRGlyZWN0aW9uYWxpdHkge1xufVxuTmJEaXJlY3Rpb25hbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuXG5jbGFzcyBOYkJpZGlNb2R1bGUgZXh0ZW5kcyBCaWRpTW9kdWxlIHtcbn1cbk5iQmlkaU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTmJEaXJlY3Rpb25hbGl0eSwgdXNlRXhpc3Rpbmc6IERpcmVjdGlvbmFsaXR5IH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JuYmlvbi5cbiAqL1xuLyoqXG4gKiBDZWxsIGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIE5iQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIENka0NlbGxEZWYge1xufVxuTmJDZWxsRGVmRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJDZWxsRGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJDZWxsRGVmRGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKipcbiAqIEhlYWRlciBjZWxsIGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGhlYWRlciBjZWxsIGFuZCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlIGV4dGVuZHMgQ2RrSGVhZGVyQ2VsbERlZiB7XG59XG5OYkhlYWRlckNlbGxEZWZEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYkhlYWRlckNlbGxEZWZdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0hlYWRlckNlbGxEZWYsIHVzZUV4aXN0aW5nOiBOYkhlYWRlckNlbGxEZWZEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKlxuICogRm9vdGVyIGNlbGwgZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZm9vdGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBOYkZvb3RlckNlbGxEZWZEaXJlY3RpdmUgZXh0ZW5kcyBDZGtGb290ZXJDZWxsRGVmIHtcbn1cbk5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iRm9vdGVyQ2VsbERlZl0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrRm9vdGVyQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuY29uc3QgTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRiA9IG5ldyBJbmplY3Rpb25Ub2tlbignTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRicpO1xuLyoqXG4gKiBDb2x1bW4gZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogRGVmaW5lcyBhIHNldCBvZiBjZWxscyBhdmFpbGFibGUgZm9yIGEgdGFibGUgY29sdW1uLlxuICovXG5jbGFzcyBOYkNvbHVtbkRlZkRpcmVjdGl2ZSBleHRlbmRzIENka0NvbHVtbkRlZiB7XG4gICAgLyoqIFVuaXF1ZSBuYW1lIGZvciB0aGlzIGNvbHVtbi4gKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldE5hbWVJbnB1dCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoaXMgY29sdW1uIHNob3VsZCBiZSBzdGlja3kgcG9zaXRpb25lZCBvbiB0aGUgZW5kIG9mIHRoZSByb3cgKi9cbiAgICBnZXQgc3RpY2t5RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RpY2t5RW5kO1xuICAgIH1cbiAgICBzZXQgc3RpY2t5RW5kKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHRoaXMuX3N0aWNreUVuZDtcbiAgICAgICAgdGhpcy5fc3RpY2t5RW5kID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5faGFzU3RpY2t5Q2hhbmdlZCA9IHByZXZWYWx1ZSAhPT0gdGhpcy5fc3RpY2t5RW5kO1xuICAgIH1cbn1cbk5iQ29sdW1uRGVmRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJDb2x1bW5EZWZdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBDZGtDb2x1bW5EZWYsIHVzZUV4aXN0aW5nOiBOYkNvbHVtbkRlZkRpcmVjdGl2ZSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYsIHVzZUV4aXN0aW5nOiBOYkNvbHVtbkRlZkRpcmVjdGl2ZSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ29sdW1uRGVmRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG5hbWU6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iQ29sdW1uRGVmJyxdIH1dLFxuICAgIHN0aWNreTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RpY2t5RW5kOiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcbi8qKiBIZWFkZXIgY2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuY2xhc3MgTmJIZWFkZXJDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrSGVhZGVyQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBuYi1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgfVxufVxuTmJIZWFkZXJDZWxsRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1oZWFkZXItY2VsbCwgdGhbbmJIZWFkZXJDZWxsXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbmItaGVhZGVyLWNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iSGVhZGVyQ2VsbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iQ29sdW1uRGVmRGlyZWN0aXZlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG4vKiogRm9vdGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbmNsYXNzIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSBleHRlbmRzIENka0Zvb3RlckNlbGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZiwgZWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihjb2x1bW5EZWYsIGVsZW1lbnRSZWYpO1xuICAgICAgICBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbmItY29sdW1uLSR7Y29sdW1uRGVmLmNzc0NsYXNzRnJpZW5kbHlOYW1lfWApO1xuICAgIH1cbn1cbk5iRm9vdGVyQ2VsbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItZm9vdGVyLWNlbGwsIHRkW25iRm9vdGVyQ2VsbF0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ25iLWZvb3Rlci1jZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iRm9vdGVyQ2VsbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iQ29sdW1uRGVmRGlyZWN0aXZlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG4vKiogQ2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuY2xhc3MgTmJDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBuYi1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgfVxufVxuTmJDZWxsRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1jZWxsLCB0ZFtuYkNlbGxdJyxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICduYi1jZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iQ2VsbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iQ29sdW1uRGVmRGlyZWN0aXZlIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5cbmNsYXNzIE5iRGF0YVNvdXJjZSBleHRlbmRzIERhdGFTb3VyY2Uge1xufVxuXG5jbGFzcyBOYkRhdGFSb3dPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBEYXRhUm93T3V0bGV0IHtcbn1cbk5iRGF0YVJvd091dGxldERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iUm93T3V0bGV0XScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEYXRhUm93T3V0bGV0LCB1c2VFeGlzdGluZzogTmJEYXRhUm93T3V0bGV0RGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5jbGFzcyBOYkhlYWRlclJvd091dGxldERpcmVjdGl2ZSBleHRlbmRzIEhlYWRlclJvd091dGxldCB7XG59XG5OYkhlYWRlclJvd091dGxldERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iSGVhZGVyUm93T3V0bGV0XScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBIZWFkZXJSb3dPdXRsZXQsIHVzZUV4aXN0aW5nOiBOYkhlYWRlclJvd091dGxldERpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuY2xhc3MgTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBGb290ZXJSb3dPdXRsZXQge1xufVxuTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYkZvb3RlclJvd091dGxldF0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRm9vdGVyUm93T3V0bGV0LCB1c2VFeGlzdGluZzogTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbmNsYXNzIE5iTm9EYXRhUm93T3V0bGV0RGlyZWN0aXZlIGV4dGVuZHMgTm9EYXRhUm93T3V0bGV0IHtcbn1cbk5iTm9EYXRhUm93T3V0bGV0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJOb0RhdGFSb3dPdXRsZXRdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5vRGF0YVJvd091dGxldCwgdXNlRXhpc3Rpbmc6IE5iTm9EYXRhUm93T3V0bGV0RGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5jbGFzcyBOYkNlbGxPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBDZGtDZWxsT3V0bGV0IHtcbn1cbk5iQ2VsbE91dGxldERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iQ2VsbE91dGxldF0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrQ2VsbE91dGxldCwgdXNlRXhpc3Rpbmc6IE5iQ2VsbE91dGxldERpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqXG4gKiBIZWFkZXIgcm93IGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBoZWFkZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIGhlYWRlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xuY2xhc3MgTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUgZXh0ZW5kcyBDZGtIZWFkZXJSb3dEZWYge1xufVxuTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYkhlYWRlclJvd0RlZl0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrSGVhZGVyUm93RGVmLCB1c2VFeGlzdGluZzogTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iSGVhZGVyUm93RGVmRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iSGVhZGVyUm93RGVmJyxdIH1dLFxuICAgIHN0aWNreTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJIZWFkZXJSb3dEZWZTdGlja3knLF0gfV1cbn07XG4vKipcbiAqIEZvb3RlciByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIGZvb3RlciByb3cncyB0ZW1wbGF0ZSBhbmQgb3RoZXIgZm9vdGVyIHByb3BlcnRpZXMgc3VjaCBhcyB0aGUgY29sdW1ucyB0byBkaXNwbGF5LlxuICovXG5jbGFzcyBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIENka0Zvb3RlclJvd0RlZiB7XG59XG5OYkZvb3RlclJvd0RlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iRm9vdGVyUm93RGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtGb290ZXJSb3dEZWYsIHVzZUV4aXN0aW5nOiBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJGb290ZXJSb3dEZWZEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJGb290ZXJSb3dEZWYnLF0gfV0sXG4gICAgc3RpY2t5OiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkZvb3RlclJvd0RlZlN0aWNreScsXSB9XVxufTtcbi8qKlxuICogRGF0YSByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIGRhdGEgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIHByb3BlcnRpZXMgc3VjaCBhcyB0aGUgY29sdW1ucyB0byBkaXNwbGF5IGFuZFxuICogYSB3aGVuIHByZWRpY2F0ZSB0aGF0IGRlc2NyaWJlcyB3aGVuIHRoaXMgcm93IHNob3VsZCBiZSB1c2VkLlxuICovXG5jbGFzcyBOYlJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIENka1Jvd0RlZiB7XG59XG5OYlJvd0RlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iUm93RGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtSb3dEZWYsIHVzZUV4aXN0aW5nOiBOYlJvd0RlZkRpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJSb3dEZWZEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJSb3dEZWZDb2x1bW5zJyxdIH1dLFxuICAgIHdoZW46IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iUm93RGVmV2hlbicsXSB9XVxufTtcbi8qKiBGb290ZXIgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGNlbGwgb3V0bGV0LiBBZGRzIHRoZSByaWdodCBjbGFzcyBhbmQgcm9sZS4gKi9cbmNsYXNzIE5iSGVhZGVyUm93Q29tcG9uZW50IGV4dGVuZHMgQ2RrSGVhZGVyUm93IHtcbn1cbk5iSGVhZGVyUm93Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1oZWFkZXItcm93LCB0cltuYkhlYWRlclJvd10nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBuYkNlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+YCxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICduYi1oZWFkZXItcm93JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncm93JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrSGVhZGVyUm93LCB1c2VFeGlzdGluZzogTmJIZWFkZXJSb3dDb21wb25lbnQgfV1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqIEZvb3RlciB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLiAqL1xuY2xhc3MgTmJGb290ZXJSb3dDb21wb25lbnQgZXh0ZW5kcyBDZGtGb290ZXJSb3cge1xufVxuTmJGb290ZXJSb3dDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLWZvb3Rlci1yb3csIHRyW25iRm9vdGVyUm93XScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIG5iQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5gLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ25iLWZvb3Rlci1yb3cnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtGb290ZXJSb3csIHVzZUV4aXN0aW5nOiBOYkZvb3RlclJvd0NvbXBvbmVudCB9XVxuICAgICAgICAgICAgfSxdIH1cbl07XG4vKiogRGF0YSByb3cgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhlIGNlbGwgb3V0bGV0LiBBZGRzIHRoZSByaWdodCBjbGFzcyBhbmQgcm9sZS4gKi9cbmNsYXNzIE5iUm93Q29tcG9uZW50IGV4dGVuZHMgQ2RrUm93IHtcbn1cbk5iUm93Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1yb3csIHRyW25iUm93XScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIG5iQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5gLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ25iLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka1JvdywgdXNlRXhpc3Rpbmc6IE5iUm93Q29tcG9uZW50IH1dXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuY29uc3QgTkJfVEFCTEVfVEVNUExBVEUgPSBgXG4gIDxuZy1jb250YWluZXIgbmJIZWFkZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgbmJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgbmJOb0RhdGFSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgbmJGb290ZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG5gO1xuY29uc3QgTkJfVklFV19SRVBFQVRFUl9TVFJBVEVHWSA9IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZO1xuY29uc3QgTkJfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUiA9IF9DT0FMRVNDRURfU1RZTEVfU0NIRURVTEVSO1xuY29uc3QgTkJfVEFCTEVfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogTkJfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgdXNlQ2xhc3M6IF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3kgfSxcbiAgICB7IHByb3ZpZGU6IE5CX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsIHVzZUNsYXNzOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgfSxcbl07XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxuY2xhc3MgTmJUYWJsZSBleHRlbmRzIENka1RhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWZmZXJzLCBjaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZiwgcm9sZSwgZGlyLCBkb2N1bWVudCwgcGxhdGZvcm0sIF92aWV3UmVwZWF0ZXIsIF9jb2FsZXNjZWRTdHlsZVNjaGVkdWxlcikge1xuICAgICAgICBzdXBlcihkaWZmZXJzLCBjaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZiwgcm9sZSwgZGlyLCBkb2N1bWVudCwgcGxhdGZvcm0sIF92aWV3UmVwZWF0ZXIsIF9jb2FsZXNjZWRTdHlsZVNjaGVkdWxlcik7XG4gICAgICAgIHRoaXMuX3ZpZXdSZXBlYXRlciA9IF92aWV3UmVwZWF0ZXI7XG4gICAgICAgIHRoaXMuX2NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyID0gX2NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyO1xuICAgIH1cbn1cbk5iVGFibGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRhYmxlLW5vdC1pbXBsZW1lbnRlZCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBgLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogTkJfVEFCTEVfUFJPVklERVJTXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVGFibGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJdGVyYWJsZURpZmZlcnMgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBTdHJpbmcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEF0dHJpYnV0ZSwgYXJnczogWydyb2xlJyxdIH1dIH0sXG4gICAgeyB0eXBlOiBOYkRpcmVjdGlvbmFsaXR5IH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUGxhdGZvcm0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSwgeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtfVklFV19SRVBFQVRFUl9TVFJBVEVHWSxdIH1dIH0sXG4gICAgeyB0eXBlOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsXSB9XSB9XG5dO1xuY29uc3QgQ09NUE9ORU5UUyQxID0gW1xuICAgIE5iVGFibGUsXG4gICAgLy8gVGVtcGxhdGUgZGVmc1xuICAgIE5iSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSxcbiAgICBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZSxcbiAgICBOYkNvbHVtbkRlZkRpcmVjdGl2ZSxcbiAgICBOYkNlbGxEZWZEaXJlY3RpdmUsXG4gICAgTmJSb3dEZWZEaXJlY3RpdmUsXG4gICAgTmJGb290ZXJDZWxsRGVmRGlyZWN0aXZlLFxuICAgIE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlLFxuICAgIC8vIE91dGxldHNcbiAgICBOYkRhdGFSb3dPdXRsZXREaXJlY3RpdmUsXG4gICAgTmJIZWFkZXJSb3dPdXRsZXREaXJlY3RpdmUsXG4gICAgTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUsXG4gICAgTmJOb0RhdGFSb3dPdXRsZXREaXJlY3RpdmUsXG4gICAgTmJDZWxsT3V0bGV0RGlyZWN0aXZlLFxuICAgIC8vIENlbGwgZGlyZWN0aXZlc1xuICAgIE5iSGVhZGVyQ2VsbERpcmVjdGl2ZSxcbiAgICBOYkNlbGxEaXJlY3RpdmUsXG4gICAgTmJGb290ZXJDZWxsRGlyZWN0aXZlLFxuICAgIC8vIFJvdyBkaXJlY3RpdmVzXG4gICAgTmJIZWFkZXJSb3dDb21wb25lbnQsXG4gICAgTmJSb3dDb21wb25lbnQsXG4gICAgTmJGb290ZXJSb3dDb21wb25lbnQsXG5dO1xuY2xhc3MgTmJUYWJsZU1vZHVsZSBleHRlbmRzIENka1RhYmxlTW9kdWxlIHtcbn1cbk5iVGFibGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYkJpZGlNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVFMkMV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogWy4uLkNPTVBPTkVOVFMkMV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfRElBTE9HX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignRGVmYXVsdCBkaWFsb2cgb3B0aW9ucycpO1xuLyoqXG4gKiBEZXNjcmliZXMgYWxsIGF2YWlsYWJsZSBvcHRpb25zIHRoYXQgbWF5IGJlIHBhc3NlZCB0byB0aGUgTmJEaWFsb2dTZXJ2aWNlLlxuICogKi9cbmNsYXNzIE5iRGlhbG9nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgdGhhbiBvdmVybGF5IHdpbGwgcmVuZGVyIGJhY2tkcm9wIHVuZGVyIGEgZGlhbG9nLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRoYXQnbGwgYmUgYXNzaWduZWQgdG8gdGhlIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYmFja2Ryb3BDbGFzcyA9ICdvdmVybGF5LWJhY2tkcm9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRoYXQnbGwgYmUgYXNzaWduZWQgdG8gdGhlIGRpYWxvZyBvdmVybGF5LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmRpYWxvZ0NsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIHRoZW4gbW91c2UgY2xpY2tzIGJ5IGJhY2tkcm9wIHdpbGwgY2xvc2UgYSBkaWFsb2cuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuY2xvc2VPbkJhY2tkcm9wQ2xpY2sgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSB0aGVuIGVzY2FwZSBwcmVzcyB3aWxsIGNsb3NlIGEgZGlhbG9nLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmNsb3NlT25Fc2MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgc2Nyb2xsIG9uIGNvbnRlbnQgdW5kZXIgZGlhbG9nIGlmIHRydWUgYW5kIGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuaGFzU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1c2VzIGRpYWxvZyBhdXRvbWF0aWNhbGx5IGFmdGVyIG9wZW4gaWYgdHJ1ZS5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5hdXRvRm9jdXMgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJEaWFsb2dSZWZgIGhlbHBzIHRvIG1hbmlwdWxhdGUgZGlhbG9nIGFmdGVyIGl0IHdhcyBjcmVhdGVkLlxuICogVGhlIGRpYWxvZyBjYW4gYmUgZGlzbWlzc2VkIGJ5IHVzaW5nIGBjbG9zZWAgbWV0aG9kIG9mIHRoZSBkaWFsb2dSZWYuXG4gKiBZb3UgY2FuIGFjY2VzcyByZW5kZXJlZCBjb21wb25lbnQgYXMgYGNvbnRlbnRgIHByb3BlcnR5IG9mIHRoZSBkaWFsb2dSZWYuXG4gKiBgb25CYWNrZHJvcENsaWNrYCBzdHJlYW1zIGNsaWNrIGV2ZW50cyBvbiB0aGUgYmFja2Ryb3Agb2YgdGhlIGRpYWxvZy5cbiAqICovXG5jbGFzcyBOYkRpYWxvZ1JlZiB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheVJlZikge1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSBvdmVybGF5UmVmO1xuICAgICAgICB0aGlzLm9uQ2xvc2UkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlJC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5vbkJhY2tkcm9wQ2xpY2sgPSB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyBkaWFsb2cuXG4gICAgICogKi9cbiAgICBjbG9zZShyZXMpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UkLm5leHQocmVzKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlJC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBDb250YWluZXIgY29tcG9uZW50IGZvciBlYWNoIGRpYWxvZy5cbiAqIEFsbCB0aGUgZGlhbG9ncyB3aWxsIGJlIGF0dGFjaGVkIHRvIGl0LlxuICogLy8gVE9ETyBhZGQgYW5pbWF0aW9uc1xuICogKi9cbmNsYXNzIE5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGVsZW1lbnRSZWYsIGZvY3VzVHJhcEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwRmFjdG9yeSA9IGZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMuZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAuYmx1clByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0b0ZvY3VzICYmIHRoaXMuZm9jdXNUcmFwKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5yZXN0b3JlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnRhbE91dGxldC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICB9XG4gICAgYXR0YWNoVGVtcGxhdGVQb3J0YWwocG9ydGFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnRhbE91dGxldC5hdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpO1xuICAgIH1cbn1cbk5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1kaWFsb2ctY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZSBuYlBvcnRhbE91dGxldD48L25nLXRlbXBsYXRlPidcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRpYWxvZ0NvbmZpZyB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmJGb2N1c1RyYXBGYWN0b3J5U2VydmljZSB9XG5dO1xuTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgcG9ydGFsT3V0bGV0OiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtOYlBvcnRhbE91dGxldERpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJEaWFsb2dTZXJ2aWNlYCBoZWxwcyB0byBvcGVuIGRpYWxvZ3MuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgZGlhbG9nL2RpYWxvZy1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQSBuZXcgZGlhbG9nIGlzIG9wZW5lZCBieSBjYWxsaW5nIHRoZSBgb3BlbmAgbWV0aG9kIHdpdGggYSBjb21wb25lbnQgdG8gYmUgbG9hZGVkIGFuZCBhbiBvcHRpb25hbCBjb25maWd1cmF0aW9uLlxuICogYG9wZW5gIG1ldGhvZCB3aWxsIHJldHVybiBgTmJEaWFsb2dSZWZgIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBmdXJ0aGVyIG1hbmlwdWxhdGlvbnMuXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJEaWFsb2dNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIGFwcCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iRGlhbG9nTW9kdWxlLmZvclJvb3QoY29uZmlnKSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogSWYgeW91IGFyZSB1c2luZyBpdCBpbiBhIGxhenkgbG9hZGVkIG1vZHVsZSB0aGFuIHlvdSBoYXZlIHRvIGluc3RhbGwgaXQgd2l0aCBgTmJEaWFsb2dNb2R1bGUuZm9yQ2hpbGQoKWA6XG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iRGlhbG9nTW9kdWxlLmZvckNoaWxkKGNvbmZpZyksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIExhenlMb2FkZWRNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2dTZXJ2aWNlLm9wZW4oTXlEaWFsb2dDb21wb25lbnQsIHsgLi4uIH0pO1xuICogYGBgXG4gKlxuICogYE5iRGlhbG9nUmVmYCBnaXZlcyBjYXBhYmlsaXR5IGFjY2VzcyByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVkIGRpYWxvZyBjb21wb25lbnQsXG4gKiBkZXN0cm95IGRpYWxvZyBhbmQgc29tZSBvdGhlciBvcHRpb25zIGRlc2NyaWJlZCBiZWxvdy5cbiAqXG4gKiBBbHNvLCB5b3UgY2FuIGluamVjdCBgTmJEaWFsb2dSZWZgIGluIGRpYWxvZyBjb21wb25lbnQuXG4gKlxuICogYGBgdHNcbiAqIHRoaXMuZGlhbG9nU2VydmljZS5vcGVuKE15RGlhbG9nQ29tcG9uZW50LCB7IC4uLiB9KTtcbiAqXG4gKiAvLyBteS1kaWFsb2cuY29tcG9uZW50LnRzXG4gKiBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGlhbG9nUmVmOiBOYkRpYWxvZ1JlZikge1xuICogfVxuICpcbiAqIGNsb3NlKCkge1xuICogICB0aGlzLmRpYWxvZ1JlZi5jbG9zZSgpO1xuICogfVxuICogYGBgXG4gKlxuICogSW5zdGVhZCBvZiBjb21wb25lbnQgeW91IGNhbiBjcmVhdGUgZGlhbG9nIGZyb20gVGVtcGxhdGVSZWY6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShUZW1wbGF0ZSByZWYsIGRpYWxvZy9kaWFsb2ctdGVtcGxhdGUuY29tcG9uZW50KVxuICpcbiAqIFRoZSBkaWFsb2cgbWF5IHJldHVybiByZXN1bHQgdGhyb3VnaCBgTmJEaWFsb2dSZWZgLiBDYWxsaW5nIGNvbXBvbmVudCBjYW4gcmVjZWl2ZSB0aGlzIHJlc3VsdCB3aXRoIGBvbkNsb3NlYFxuICogc3RyZWFtIG9mIGBOYkRpYWxvZ1JlZmAuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShSZXN1bHQsIGRpYWxvZy9kaWFsb2ctcmVzdWx0LmNvbXBvbmVudClcbiAqXG4gKiAjIyMgQ29uZmlndXJhdGlvblxuICpcbiAqIEFzIHdlIG1lbnRpb25lZCBhYm92ZSwgYG9wZW5gIG1ldGhvZCBvZiB0aGUgYE5iRGlhbG9nU2VydmljZWAgbWF5IHJlY2VpdmUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICogQWxzbywgeW91IGNhbiBwcm92aWRlIGdsb2JhbCBkaWFsb2dzIGNvbmZpZ3VyYXRpb24gdGhyb3VnaCBgTmJEaWFsb2dNb2R1bGUuZm9yUm9vdCh7IC4uLiB9KWAuXG4gKlxuICogVGhpcyBjb25maWcgbWF5IGNvbnRhaW4gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiBgY29udGV4dGAgLSBib3RoLCB0ZW1wbGF0ZSBhbmQgY29tcG9uZW50IG1heSByZWNlaXZlIGRhdGEgdGhyb3VnaCBgY29uZmlnLmNvbnRleHRgIHByb3BlcnR5LlxuICogRm9yIGNvbXBvbmVudHMsIHRoaXMgZGF0YSB3aWxsIGJlIGFzc2lnbmVkIHRocm91Z2ggaW5wdXRzLlxuICogRm9yIHRlbXBsYXRlcywgeW91IGNhbiBhY2Nlc3MgaXQgaW5zaWRlIHRlbXBsYXRlIGFzICRpbXBsaWNpdC5cbiAqXG4gKiBgYGB0c1xuICogdGhpcy5kaWFsb2dTZXJ2aWNlLm9wZW4odGVtcGxhdGUsIHsgY29udGV4dDogJ3Bhc3MgZGF0YSBpbiB0ZW1wbGF0ZScgfSk7XG4gKiBgYGBcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmctdGVtcGxhdGUgbGV0LXNvbWUtYWRkaXRpb25hbC1kYXRhPlxuICogICB7eyBzb21lLWFkZGl0aW9uYWwtZGF0YSB9fVxuICogPG5nLXRlbXBsYXRlLz5cbiAqIGBgYFxuICpcbiAqIGBoYXNCYWNrZHJvcGAgLSBkZXRlcm1pbmVzIGlzIHNlcnZpY2UgaGF2ZSB0byByZW5kZXIgYmFja2Ryb3AgdW5kZXIgdGhlIGRpYWxvZy5cbiAqIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQmFja2Ryb3AsIGRpYWxvZy9kaWFsb2ctaGFzLWJhY2tkcm9wLmNvbXBvbmVudClcbiAqXG4gKiBgY2xvc2VPbkJhY2tkcm9wQ2xpY2tgIC0gY2xvc2UgZGlhbG9nIG9uIGJhY2tkcm9wIGNsaWNrIGlmIHRydWUuXG4gKiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJhY2tkcm9wIGNsaWNrLCBkaWFsb2cvZGlhbG9nLWJhY2tkcm9wLWNsaWNrLmNvbXBvbmVudClcbiAqXG4gKiBgY2xvc2VPbkVzY2AgLSBjbG9zZSBkaWFsb2cgb24gZXNjYXBlIGJ1dHRvbiBvbiB0aGUga2V5Ym9hcmQuXG4gKiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEVzY2FwZSBoaXQsIGRpYWxvZy9kaWFsb2ctZXNjLmNvbXBvbmVudClcbiAqXG4gKiBgaGFzU2Nyb2xsYCAtIERpc2FibGVzIHNjcm9sbCBvbiBjb250ZW50IHVuZGVyIGRpYWxvZyBpZiB0cnVlIGFuZCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICogRGVmYXVsdCBpcyBmYWxzZS5cbiAqIFBsZWFzZSwgb3BlbiBkaWFsb2dzIGluIHRoZSBzZXBhcmF0ZSB3aW5kb3cgYW5kIHRyeSB0byBzY3JvbGwuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNjcm9sbCwgZGlhbG9nL2RpYWxvZy1zY3JvbGwuY29tcG9uZW50KVxuICpcbiAqIGBhdXRvRm9jdXNgIC0gRm9jdXNlcyBkaWFsb2cgYXV0b21hdGljYWxseSBhZnRlciBvcGVuIGlmIHRydWUuIEl0J3MgdXNlZnVsIHRvIHByZXZlbnQgbWlzY2xpY2tzIG9uXG4gKiB0cmlnZ2VyIGVsZW1lbnRzIGFuZCBvcGVuaW5nIG11bHRpcGxlIGRpYWxvZ3MuXG4gKiBEZWZhdWx0IGlzIHRydWUuXG4gKlxuICogQXMgeW91IGNhbiBzZWUsIGlmIHlvdSBvcGVuIGRpYWxvZyB3aXRoIGF1dG8gZm9jdXMgZGlhbG9nIHdpbGwgZm9jdXMgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAqIG9yIGp1c3QgYmx1ciBwcmV2aW91c2x5IGZvY3VzZWQgYXV0b21hdGljYWxseS5cbiAqIE90aGVyd2lzZSwgd2l0aG91dCBhdXRvIGZvY3VzLCB0aGUgZm9jdXMgd2lsbCBzdGF5IG9uIHRoZSBwcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudC5cbiAqIFBsZWFzZSwgb3BlbiBkaWFsb2dzIGluIHRoZSBzZXBhcmF0ZSB3aW5kb3cgYW5kIHRyeSB0byBjbGljayBvbiB0aGUgYnV0dG9uIHdpdGhvdXQgZm9jdXNcbiAqIGFuZCB0aGVuIGhpdCBzcGFjZSBhbnkgdGltZXMuIE11bHRpcGxlIHNhbWUgZGlhbG9ncyB3aWxsIGJlIG9wZW5lZC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQXV0byBmb2N1cywgZGlhbG9nL2RpYWxvZy1hdXRvLWZvY3VzLmNvbXBvbmVudClcbiAqICovXG5jbGFzcyBOYkRpYWxvZ1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBnbG9iYWxDb25maWcsIHBvc2l0aW9uQnVpbGRlciwgb3ZlcmxheSwgaW5qZWN0b3IsIGNmcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuZ2xvYmFsQ29uZmlnID0gZ2xvYmFsQ29uZmlnO1xuICAgICAgICB0aGlzLnBvc2l0aW9uQnVpbGRlciA9IHBvc2l0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNmciA9IGNmcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgbmV3IGluc3RhbmNlIG9mIHRoZSBkaWFsb2csIG1heSByZWNlaXZlIG9wdGlvbmFsIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIG9wZW4oY29udGVudCwgdXNlckNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBOYkRpYWxvZ0NvbmZpZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2xvYmFsQ29uZmlnKSwgdXNlckNvbmZpZykpO1xuICAgICAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5jcmVhdGVPdmVybGF5KGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGRpYWxvZ1JlZiA9IG5ldyBOYkRpYWxvZ1JlZihvdmVybGF5UmVmKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250YWluZXIoY29uZmlnLCBvdmVybGF5UmVmKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50KGNvbmZpZywgY29udGVudCwgY29udGFpbmVyLCBkaWFsb2dSZWYpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ2xvc2VMaXN0ZW5lcnMoY29uZmlnLCBvdmVybGF5UmVmLCBkaWFsb2dSZWYpO1xuICAgICAgICByZXR1cm4gZGlhbG9nUmVmO1xuICAgIH1cbiAgICBjcmVhdGVPdmVybGF5KGNvbmZpZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVTY3JvbGxTdHJhdGVneShjb25maWcuaGFzU2Nyb2xsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5jcmVhdGUoe1xuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5LFxuICAgICAgICAgICAgaGFzQmFja2Ryb3A6IGNvbmZpZy5oYXNCYWNrZHJvcCxcbiAgICAgICAgICAgIGJhY2tkcm9wQ2xhc3M6IGNvbmZpZy5iYWNrZHJvcENsYXNzLFxuICAgICAgICAgICAgcGFuZWxDbGFzczogY29uZmlnLmRpYWxvZ0NsYXNzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25CdWlsZGVyXG4gICAgICAgICAgICAuZ2xvYmFsKClcbiAgICAgICAgICAgIC5jZW50ZXJWZXJ0aWNhbGx5KClcbiAgICAgICAgICAgIC5jZW50ZXJIb3Jpem9udGFsbHkoKTtcbiAgICB9XG4gICAgY3JlYXRlU2Nyb2xsU3RyYXRlZ3koaGFzU2Nyb2xsKSB7XG4gICAgICAgIGlmIChoYXNTY3JvbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ub29wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIoY29uZmlnLCBvdmVybGF5UmVmKSB7XG4gICAgICAgIGNvbnN0IGluamVjdG9yID0gbmV3IE5iUG9ydGFsSW5qZWN0b3IodGhpcy5jcmVhdGVJbmplY3Rvcihjb25maWcpLCBuZXcgV2Vha01hcChbW05iRGlhbG9nQ29uZmlnLCBjb25maWddXSkpO1xuICAgICAgICBjb25zdCBjb250YWluZXJQb3J0YWwgPSBuZXcgTmJDb21wb25lbnRQb3J0YWwoTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQsIG51bGwsIGluamVjdG9yLCB0aGlzLmNmcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IG92ZXJsYXlSZWYuYXR0YWNoKGNvbnRhaW5lclBvcnRhbCk7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRlbnQoY29uZmlnLCBjb250ZW50LCBjb250YWluZXIsIGRpYWxvZ1JlZikge1xuICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0YWwgPSB0aGlzLmNyZWF0ZVRlbXBsYXRlUG9ydGFsKGNvbmZpZywgY29udGVudCwgZGlhbG9nUmVmKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9ydGFsID0gdGhpcy5jcmVhdGVDb21wb25lbnRQb3J0YWwoY29uZmlnLCBjb250ZW50LCBkaWFsb2dSZWYpO1xuICAgICAgICAgICAgZGlhbG9nUmVmLmNvbXBvbmVudFJlZiA9IGNvbnRhaW5lci5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGlhbG9nUmVmLmNvbXBvbmVudFJlZi5pbnN0YW5jZSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVUZW1wbGF0ZVBvcnRhbChjb25maWcsIGNvbnRlbnQsIGRpYWxvZ1JlZikge1xuICAgICAgICByZXR1cm4gbmV3IE5iVGVtcGxhdGVQb3J0YWwoY29udGVudCwgbnVsbCwgeyAkaW1wbGljaXQ6IGNvbmZpZy5jb250ZXh0LCBkaWFsb2dSZWYgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlJ3JlIGNyZWF0aW5nIHBvcnRhbCB3aXRoIGN1c3RvbSBpbmplY3RvciBwcm92aWRlZCB0aHJvdWdoIGNvbmZpZyBvciB1c2luZyBnbG9iYWwgaW5qZWN0b3IuXG4gICAgICogVGhpcyBhcHByb2FjaCBwcm92aWRlcyB1cyBjYXBhYmlsaXR5IGluamVjdCBgTmJEaWFsb2dSZWZgIGluIGRpYWxvZyBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBjcmVhdGVDb21wb25lbnRQb3J0YWwoY29uZmlnLCBjb250ZW50LCBkaWFsb2dSZWYpIHtcbiAgICAgICAgY29uc3QgaW5qZWN0b3IgPSB0aGlzLmNyZWF0ZUluamVjdG9yKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHBvcnRhbEluamVjdG9yID0gbmV3IE5iUG9ydGFsSW5qZWN0b3IoaW5qZWN0b3IsIG5ldyBXZWFrTWFwKFtbTmJEaWFsb2dSZWYsIGRpYWxvZ1JlZl1dKSk7XG4gICAgICAgIHJldHVybiBuZXcgTmJDb21wb25lbnRQb3J0YWwoY29udGVudCwgY29uZmlnLnZpZXdDb250YWluZXJSZWYsIHBvcnRhbEluamVjdG9yKTtcbiAgICB9XG4gICAgY3JlYXRlSW5qZWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBjb25maWcudmlld0NvbnRhaW5lclJlZiAmJiBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvciB8fCB0aGlzLmluamVjdG9yO1xuICAgIH1cbiAgICByZWdpc3RlckNsb3NlTGlzdGVuZXJzKGNvbmZpZywgb3ZlcmxheVJlZiwgZGlhbG9nUmVmKSB7XG4gICAgICAgIGlmIChjb25maWcuY2xvc2VPbkJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICAgIG92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiBkaWFsb2dSZWYuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jbG9zZU9uRXNjKSB7XG4gICAgICAgICAgICBmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ2tleXVwJylcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC5rZXlDb2RlID09PSAyNyksIHRha2VVbnRpbChkaWFsb2dSZWYub25DbG9zZSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiBkaWFsb2dSZWYuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5OYkRpYWxvZ1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iRGlhbG9nU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfRE9DVU1FTlQsXSB9XSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ESUFMT0dfQ09ORklHLF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogSW5qZWN0b3IgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkRpYWxvZ01vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoZGlhbG9nQ29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYkRpYWxvZ01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iRGlhbG9nU2VydmljZSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX0RJQUxPR19DT05GSUcsIHVzZVZhbHVlOiBkaWFsb2dDb25maWcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDaGlsZChkaWFsb2dDb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iRGlhbG9nTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTmJEaWFsb2dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfRElBTE9HX0NPTkZJRywgdXNlVmFsdWU6IGRpYWxvZ0NvbmZpZyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5OYkRpYWxvZ01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW05iU2hhcmVkTW9kdWxlLCBOYk92ZXJsYXlNb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYkRpYWxvZ0NvbnRhaW5lckNvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJUb2FzdCB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogVGhlIGBOYlRvYXN0Q29tcG9uZW50YCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIGVhY2ggdG9hc3Qgd2l0aCBhcHByb3ByaWF0ZSBzdHlsZXMuXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHRvYXN0ci1ib3JkZXItc3R5bGU6XG4gKiB0b2FzdHItYm9yZGVyLXdpZHRoOlxuICogdG9hc3RyLWJvcmRlci1yYWRpdXM6XG4gKiB0b2FzdHItcGFkZGluZzpcbiAqIHRvYXN0ci1zaGFkb3c6XG4gKiB0b2FzdHItdGV4dC1mb250LWZhbWlseTpcbiAqIHRvYXN0ci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvYXN0ci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9hc3RyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0b2FzdHItdGl0bGUtdGV4dC1mb250LWZhbWlseTpcbiAqIHRvYXN0ci10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvYXN0ci10aXRsZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9hc3RyLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0b2FzdHItYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1iYXNpYy1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogdG9hc3RyLWljb24tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24tcHJpbWFyeS1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLXN1Y2Nlc3MtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1pbmZvLXRleHQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1pbmZvLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItd2FybmluZy10ZXh0LWNvbG9yOlxuICogdG9hc3RyLWljb24td2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24td2FybmluZy1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24tZGFuZ2VyLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWRhbmdlci1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWNvbnRyb2wtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWNvbnRyb2wtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogKi9cbmNsYXNzIE5iVG9hc3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBlbGVtZW50UmVmLCBzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgZGVzdHJveUJ5Q2xpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0LmNvbmZpZy5kZXN0cm95QnlDbGljaztcbiAgICB9XG4gICAgZ2V0IGhhc0ljb24oKSB7XG4gICAgICAgIGNvbnN0IHsgaWNvbiB9ID0gdGhpcy50b2FzdC5jb25maWc7XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIShpY29uICYmIGljb24uaWNvbik7XG4gICAgfVxuICAgIGdldCBjdXN0b21JY29uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmljb247XG4gICAgfVxuICAgIGdldCBpY29uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuaWNvbjtcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMudG9hc3QuY29uZmlnLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95LmVtaXQoKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvYXN0LmNvbmZpZy50b2FzdENsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLnRvYXN0LmNvbmZpZy50b2FzdENsYXNzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5iVG9hc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRvYXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJpY29uLWNvbnRhaW5lclxcXCIgKm5nSWY9XFxcImhhc0ljb24gJiYgaWNvblxcXCI+XFxuICA8bmItaWNvbiBbY29uZmlnXT1cXFwiaWNvblxcXCI+PC9uYi1pY29uPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnQtY29udGFpbmVyXFxcIj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJ0aXRsZSBzdWJ0aXRsZVxcXCI+e3sgdG9hc3QudGl0bGUgfX08L3NwYW4+XFxuICA8ZGl2IGNsYXNzPVxcXCJtZXNzYWdlXFxcIj57eyB0b2FzdC5tZXNzYWdlIH19PC9kaXY+XFxuPC9kaXY+XFxuXCIsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3dpZHRoOjI1cmVtO21hcmdpbjowLjVyZW19Omhvc3QgLnRpdGxle21hcmdpbi1yaWdodDowLjI1cmVtfTpob3N0LmRlZmF1bHQgLmNvbnRlbnQtY29udGFpbmVyLDpob3N0Om5vdCguaGFzLWljb24pIC5jb250ZW50LWNvbnRhaW5lcntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93fTpob3N0LmRlc3Ryb3ktYnktY2xpY2t7Y3Vyc29yOnBvaW50ZXJ9Omhvc3QgbmItaWNvbntmb250LXNpemU6Mi41cmVtfTpob3N0IHN2Z3t3aWR0aDoyLjVyZW07aGVpZ2h0OjIuNXJlbX1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUb2FzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlRvYXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHRvYXN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkZXN0cm95OiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgZGVzdHJveUJ5Q2xpY2s6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmRlc3Ryb3ktYnktY2xpY2snLF0gfV0sXG4gICAgaGFzSWNvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaGFzLWljb24nLF0gfV0sXG4gICAgY3VzdG9tSWNvbjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuY3VzdG9tLWljb24nLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3Qgdm9pZFN0YXRlID0gc3R5bGUoe1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoe3sgZGlyZWN0aW9uIH19MTEwJSknLFxuICAgIGhlaWdodDogMCxcbiAgICBtYXJnaW5MZWZ0OiAnMCcsXG4gICAgbWFyZ2luUmlnaHQ6ICcwJyxcbiAgICBtYXJnaW5Ub3A6ICcwJyxcbiAgICBtYXJnaW5Cb3R0b206ICcwJyxcbn0pO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IHBhcmFtczogeyBkaXJlY3Rpb246ICcnIH0gfTtcbmNsYXNzIE5iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXREaXJlY3Rpb24sIHBvc2l0aW9uSGVscGVyKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uID0gbGF5b3V0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGVscGVyID0gcG9zaXRpb25IZWxwZXI7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkRpcmVjdGlvbkNoYW5nZSgpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIG9uRGlyZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLnBvc2l0aW9uSGVscGVyLmlzUmlnaHRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKSA/ICcnIDogJy0nO1xuICAgICAgICB0aGlzLmZhZGVJbiA9IHsgdmFsdWU6ICcnLCBwYXJhbXM6IHsgZGlyZWN0aW9uIH0gfTtcbiAgICB9XG59XG5OYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItdG9hc3RyLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItdG9hc3QgW0BmYWRlSW5dPVwiZmFkZUluXCIgKm5nRm9yPVwibGV0IHRvYXN0IG9mIGNvbnRlbnRcIiBbdG9hc3RdPVwidG9hc3RcIj48L25iLXRvYXN0PmAsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKCdmYWRlSW4nLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbdm9pZFN0YXRlLCBhbmltYXRlKDEwMCldLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbYW5pbWF0ZSgxMDAsIHZvaWRTdGF0ZSldLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkxheW91dERpcmVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25IZWxwZXIgfVxuXTtcbk5iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbnRlbnQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNvbnRleHQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b2FzdHM6IFt7IHR5cGU6IFZpZXdDaGlsZHJlbiwgYXJnczogW05iVG9hc3RDb21wb25lbnQsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfVE9BU1RSX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignRGVmYXVsdCB0b2FzdHIgb3B0aW9ucycpO1xuLyoqXG4gKiBUaGUgYE5iVG9hc3RyQ29uZmlnYCBjbGFzcyBkZXNjcmliZXMgY29uZmlndXJhdGlvbiBvZiB0aGUgYE5iVG9hc3RyU2VydmljZS5zaG93YCBhbmQgZ2xvYmFsIHRvYXN0ciBjb25maWd1cmF0aW9uLlxuICogKi9cbmNsYXNzIE5iVG9hc3RyQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgd2hlcmUgb24gdGhlIHNjcmVlbiB0b2FzdCBoYXZlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBjaG9vc2VzIGNvbG9yIHNjaGVtZSBmb3IgdGhlIHRvYXN0LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEdXJhdGlvbiBpcyB0aW1lb3V0IGJldHdlZW4gdG9hc3QgYXBwZWFycyBhbmQgZGlzYXBwZWFycy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDMwMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGJ5IGNsaWNrIG1lYW5zIHlvdSBjYW4gaGlkZSB0aGUgdG9hc3QgYnkgY2xpY2tpbmcgaXQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuZGVzdHJveUJ5Q2xpY2sgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcHJldmVudER1cGxpY2F0ZXMgaXMgdHJ1ZSB0aGVuIHRoZSB0b2FzdCB3aXRoIHRoZSBzYW1lIHRpdGxlLCBtZXNzYWdlIGFuZCBzdGF0dXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqIEZpbmQgZHVwbGljYXRlcyBiZWhhdmlvdXIgZGV0ZXJtaW5lZCBieSBgcHJldmVudER1cGxpY2F0ZXNgLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBgcHJldmlvdXNgIGR1cGxpY2F0ZSBiZWhhdmlvdXIgaXMgdXNlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wcmV2ZW50RHVwbGljYXRlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgaG93IHRvIHRyZWF0IGR1cGxpY2F0ZXMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuZHVwbGljYXRlc0JlaGF2aW91ciA9ICdwcmV2aW91cyc7XG4gICAgICAgIC8qXG4gICAgICAgICogVGhlIG51bWJlciBvZiB2aXNpYmxlIHRvYXN0cy4gSWYgdGhlIGxpbWl0IGV4Y2VlZGVkIHRoZSBvbGRlc3QgdG9hc3Qgd2lsbCBiZSByZW1vdmVkLlxuICAgICAgICAqICovXG4gICAgICAgIHRoaXMubGltaXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgdG9hc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvYXN0Q2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgcmVuZGVyIGljb24gb3Igbm90LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmhhc0ljb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWNvbiBuYW1lIG9yIGljb24gY29uZmlnIG9iamVjdCB0aGF0IGNhbiBiZSBwcm92aWRlZCB0byByZW5kZXIgY3VzdG9tIGljb24uXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuaWNvbiA9ICdlbWFpbCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2FzdCBzdGF0dXMgaWNvbi1jbGFzcyBtYXBwaW5nLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmljb25zID0ge1xuICAgICAgICAgICAgZGFuZ2VyOiAnZmxhc2gtb3V0bGluZScsXG4gICAgICAgICAgICBzdWNjZXNzOiAnY2hlY2ttYXJrLW91dGxpbmUnLFxuICAgICAgICAgICAgaW5mbzogJ3F1ZXN0aW9uLW1hcmstb3V0bGluZScsXG4gICAgICAgICAgICB3YXJuaW5nOiAnYWxlcnQtdHJpYW5nbGUtb3V0bGluZScsXG4gICAgICAgICAgICBwcmltYXJ5OiAnZW1haWwtb3V0bGluZScsXG4gICAgICAgICAgICBjb250cm9sOiAnZW1haWwtb3V0bGluZScsXG4gICAgICAgICAgICBiYXNpYzogJ2VtYWlsLW91dGxpbmUnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhdGNoSWNvbihjb25maWcpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxuICAgIHBhdGNoSWNvbihjb25maWcpIHtcbiAgICAgICAgaWYgKCEoJ2ljb24nIGluIGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5pY29uID0ge1xuICAgICAgICAgICAgICAgIGljb246IHRoaXMuaWNvbnNbY29uZmlnLnN0YXR1c10gfHwgdGhpcy5pY29ucy5iYXNpYyxcbiAgICAgICAgICAgICAgICBwYWNrOiAnbmVidWxhci1lc3NlbnRpYWxzJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iVG9hc3RSZWYge1xuICAgIGNvbnN0cnVjdG9yKHRvYXN0Q29udGFpbmVyLCB0b2FzdCkge1xuICAgICAgICB0aGlzLnRvYXN0Q29udGFpbmVyID0gdG9hc3RDb250YWluZXI7XG4gICAgICAgIHRoaXMudG9hc3QgPSB0b2FzdDtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMudG9hc3RDb250YWluZXIuZGVzdHJveSh0aGlzLnRvYXN0KTtcbiAgICB9XG59XG5jbGFzcyBOYlRvYXN0Q29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbiwgY29udGFpbmVyUmVmLCBwb3NpdGlvbkhlbHBlcikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHRoaXMuY29udGFpbmVyUmVmID0gY29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGVscGVyID0gcG9zaXRpb25IZWxwZXI7XG4gICAgICAgIHRoaXMudG9hc3RzID0gW107XG4gICAgICAgIHRoaXMudG9hc3REdXBsaWNhdGVDb21wYXJlRnVuYyA9ICh0MSwgdDIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0MS5tZXNzYWdlID09PSB0Mi5tZXNzYWdlXG4gICAgICAgICAgICAgICAgJiYgdDEudGl0bGUgPT09IHQyLnRpdGxlXG4gICAgICAgICAgICAgICAgJiYgdDEuY29uZmlnLnN0YXR1cyA9PT0gdDIuY29uZmlnLnN0YXR1cztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBhdHRhY2godG9hc3QpIHtcbiAgICAgICAgaWYgKHRvYXN0LmNvbmZpZy5wcmV2ZW50RHVwbGljYXRlcyAmJiB0aGlzLmlzRHVwbGljYXRlKHRvYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlVG9hc3RJZkxpbWl0UmVhY2hlZCh0b2FzdCk7XG4gICAgICAgIGNvbnN0IHRvYXN0Q29tcG9uZW50ID0gdGhpcy5hdHRhY2hUb2FzdCh0b2FzdCk7XG4gICAgICAgIGlmICh0b2FzdC5jb25maWcuZGVzdHJveUJ5Q2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlT25DbGljayh0b2FzdENvbXBvbmVudCwgdG9hc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2FzdC5jb25maWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVzdHJveVRpbWVvdXQodG9hc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlRvYXN0ID0gdG9hc3Q7XG4gICAgICAgIHJldHVybiBuZXcgTmJUb2FzdFJlZih0aGlzLCB0b2FzdCk7XG4gICAgfVxuICAgIGRlc3Ryb3kodG9hc3QpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldlRvYXN0ID09PSB0b2FzdCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2VG9hc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9hc3RzID0gdGhpcy50b2FzdHMuZmlsdGVyKHQgPT4gdCAhPT0gdG9hc3QpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lcigpO1xuICAgIH1cbiAgICBpc0R1cGxpY2F0ZSh0b2FzdCkge1xuICAgICAgICByZXR1cm4gdG9hc3QuY29uZmlnLmR1cGxpY2F0ZXNCZWhhdmlvdXIgPT09ICdwcmV2aW91cydcbiAgICAgICAgICAgID8gdGhpcy5pc0R1cGxpY2F0ZVByZXZpb3VzKHRvYXN0KVxuICAgICAgICAgICAgOiB0aGlzLmlzRHVwbGljYXRlQW1vbmdBbGwodG9hc3QpO1xuICAgIH1cbiAgICBpc0R1cGxpY2F0ZVByZXZpb3VzKHRvYXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUb2FzdCAmJiB0aGlzLnRvYXN0RHVwbGljYXRlQ29tcGFyZUZ1bmModGhpcy5wcmV2VG9hc3QsIHRvYXN0KTtcbiAgICB9XG4gICAgaXNEdXBsaWNhdGVBbW9uZ0FsbCh0b2FzdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdHMuc29tZSh0ID0+IHRoaXMudG9hc3REdXBsaWNhdGVDb21wYXJlRnVuYyh0LCB0b2FzdCkpO1xuICAgIH1cbiAgICByZW1vdmVUb2FzdElmTGltaXRSZWFjaGVkKHRvYXN0KSB7XG4gICAgICAgIGlmICghdG9hc3QuY29uZmlnLmxpbWl0IHx8IHRoaXMudG9hc3RzLmxlbmd0aCA8IHRvYXN0LmNvbmZpZy5saW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uSGVscGVyLmlzVG9wUG9zaXRpb24odG9hc3QuY29uZmlnLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy50b2FzdHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvYXN0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRvYXN0KHRvYXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uSGVscGVyLmlzVG9wUG9zaXRpb24odG9hc3QuY29uZmlnLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVG9Ub3AodG9hc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoVG9Cb3R0b20odG9hc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRvVG9wKHRvYXN0KSB7XG4gICAgICAgIHRoaXMudG9hc3RzLnVuc2hpZnQodG9hc3QpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJSZWYuaW5zdGFuY2UudG9hc3RzLmZpcnN0O1xuICAgIH1cbiAgICBhdHRhY2hUb0JvdHRvbSh0b2FzdCkge1xuICAgICAgICB0aGlzLnRvYXN0cy5wdXNoKHRvYXN0KTtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyUmVmLmluc3RhbmNlLnRvYXN0cy5sYXN0O1xuICAgIH1cbiAgICBzZXREZXN0cm95VGltZW91dCh0b2FzdCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveSh0b2FzdCksIHRvYXN0LmNvbmZpZy5kdXJhdGlvbik7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uQ2xpY2sodG9hc3RDb21wb25lbnQsIHRvYXN0KSB7XG4gICAgICAgIHRvYXN0Q29tcG9uZW50LmRlc3Ryb3kuc3Vic2NyaWJlKCgpID0+IHRoaXMuZGVzdHJveSh0b2FzdCkpO1xuICAgIH1cbiAgICB1cGRhdGVDb250YWluZXIoKSB7XG4gICAgICAgIHBhdGNoKHRoaXMuY29udGFpbmVyUmVmLCB7IGNvbnRlbnQ6IHRoaXMudG9hc3RzLCBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbiB9KTtcbiAgICB9XG59XG5jbGFzcyBOYlRvYXN0ckNvbnRhaW5lclJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihvdmVybGF5LCBwb3NpdGlvbkJ1aWxkZXIsIHBvc2l0aW9uSGVscGVyLCBjZnIsIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGVscGVyID0gcG9zaXRpb25IZWxwZXI7XG4gICAgICAgIHRoaXMuY2ZyID0gY2ZyO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMub3ZlcmxheXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsb2dpY2FsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uSGVscGVyLnRvTG9naWNhbFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheVdpdGhDb250YWluZXIgPSB0aGlzLm92ZXJsYXlzLmdldChsb2dpY2FsUG9zaXRpb24pO1xuICAgICAgICBpZiAoIW92ZXJsYXlXaXRoQ29udGFpbmVyIHx8ICF0aGlzLmV4aXN0c0luRG9tKG92ZXJsYXlXaXRoQ29udGFpbmVyLnRvYXN0ckNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIGlmIChvdmVybGF5V2l0aENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlXaXRoQ29udGFpbmVyLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZUNvbnRhaW5lcihsb2dpY2FsUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlzLmdldChsb2dpY2FsUG9zaXRpb24pLnRvYXN0ckNvbnRhaW5lcjtcbiAgICB9XG4gICAgaW5zdGFudGlhdGVDb250YWluZXIocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgdG9hc3RyT3ZlcmxheVdpdGhDb250YWluZXIgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMub3ZlcmxheXMuc2V0KHBvc2l0aW9uLCB0b2FzdHJPdmVybGF5V2l0aENvbnRhaW5lcik7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcihwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBwb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5wb3NpdGlvbkJ1aWxkZXIuZ2xvYmFsKCkucG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICBjb25zdCByZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKHsgcG9zaXRpb25TdHJhdGVneSB9KTtcbiAgICAgICAgdGhpcy5hZGRDbGFzc1RvT3ZlcmxheUhvc3QocmVmKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVmID0gcmVmLmF0dGFjaChuZXcgTmJDb21wb25lbnRQb3J0YWwoTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQsIG51bGwsIG51bGwsIHRoaXMuY2ZyKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvdmVybGF5UmVmOiByZWYsXG4gICAgICAgICAgICB0b2FzdHJDb250YWluZXI6IG5ldyBOYlRvYXN0Q29udGFpbmVyKHBvc2l0aW9uLCBjb250YWluZXJSZWYsIHRoaXMucG9zaXRpb25IZWxwZXIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRDbGFzc1RvT3ZlcmxheUhvc3Qob3ZlcmxheVJlZikge1xuICAgICAgICBvdmVybGF5UmVmLmhvc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3RvYXN0ci1vdmVybGF5LWNvbnRhaW5lcicpO1xuICAgIH1cbiAgICBleGlzdHNJbkRvbSh0b2FzdENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRvYXN0Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbn1cbk5iVG9hc3RyQ29udGFpbmVyUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iVG9hc3RyQ29udGFpbmVyUmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYk92ZXJsYXlTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25IZWxwZXIgfSxcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ET0NVTUVOVCxdIH1dIH1cbl07XG4vKipcbiAqIFRoZSBgTmJUb2FzdHJTZXJ2aWNlYCBwcm92aWRlcyBhIGNhcGFiaWxpdHkgdG8gYnVpbGQgdG9hc3Qgbm90aWZpY2F0aW9ucy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0b2FzdHIvdG9hc3RyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgTmJUb2FzdHJTZXJ2aWNlLnNob3cobWVzc2FnZSwgdGl0bGUsIGNvbmZpZylgIGFjY2VwdHMgdGhyZWUgcGFyYW1zLCB0aXRsZSBhbmQgY29uZmlnIGFyZSBvcHRpb25hbC5cbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRvYXN0ck1vZHVsZS5mb3JSb290KClgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUb2FzdHJNb2R1bGUuZm9yUm9vdChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDYWxsaW5nIGBOYlRvYXN0clNlcnZpY2Uuc2hvdyguLi4pYCB3aWxsIHJlbmRlciBuZXcgdG9hc3QgYW5kIHJldHVybiBgTmJUb2FzdHJSZWZgIHdpdGhcbiAqIGhlbHAgb2Ygd2hpY2ggeW91IG1heSBjbG9zZSBuZXdseSBjcmVhdGVkIHRvYXN0IGJ5IGNhbGxpbmcgYGNsb3NlYCBtZXRob2QuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHRvYXN0UmVmOiBOYlRvYXN0UmVmID0gdGhpcy50b2FzdHJTZXJ2aWNlLnNob3coLi4uKTtcbiAqIHRvYXN0UmVmLmNsb3NlKCk7XG4gKiBgYGBcbiAqXG4gKiBDb25maWcgYWNjZXB0cyBmb2xsb3dpbmcgb3B0aW9uczpcbiAqXG4gKiBgcG9zaXRpb25gIC0gZGV0ZXJtaW5lcyB3aGVyZSBvbiB0aGUgc2NyZWVuIHRvYXN0IHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBEZWZhdWx0IGlzIGB0b3AtZW5kYC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvc2l0aW9uLCB0b2FzdHIvdG9hc3RyLXBvc2l0aW9ucy5jb21wb25lbnQpXG4gKlxuICogYHN0YXR1c2AgLSBjb2xvcmluZyBhbmQgaWNvbiBvZiB0aGUgdG9hc3QuXG4gKiBEZWZhdWx0IGlzIGBiYXNpY2AuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTdGF0dXMsIHRvYXN0ci90b2FzdHItc3RhdHVzZXMuY29tcG9uZW50KVxuICpcbiAqIGBkdXJhdGlvbmAgLSB0aGUgdGltZSBhZnRlciB3aGljaCB0aGUgdG9hc3Qgd2lsbCBiZSBkZXN0cm95ZWQuXG4gKiBgMGAgbWVhbnMgZW5kbGVzcyB0b2FzdCwgdGhhdCBtYXkgYmUgZGVzdHJveWVkIGJ5IGNsaWNrIG9ubHkuXG4gKiBEZWZhdWx0IGlzIDMwMDAgbXMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShEdXJhdGlvbiwgdG9hc3RyL3RvYXN0ci1kdXJhdGlvbi5jb21wb25lbnQpXG4gKlxuICogYGRlc3Ryb3lCeUNsaWNrYCAtIHByb3ZpZGVzIGEgY2FwYWJpbGl0eSB0byBkZXN0cm95IHRvYXN0IGJ5IGNsaWNrLlxuICogRGVmYXVsdCBpcyB0cnVlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGVzdHJveSBieSBjbGljaywgdG9hc3RyL3RvYXN0ci1kZXN0cm95LWJ5LWNsaWNrLmNvbXBvbmVudClcbiAqXG4gKiBgcHJldmVudER1cGxpY2F0ZXNgIC0gZG9uJ3QgY3JlYXRlIG5ldyB0b2FzdCBpZiBpdCBoYXMgdGhlIHNhbWUgdGl0bGUsIG1lc3NhZ2UgYW5kIHN0YXR1cy5cbiAqIERlZmF1bHQgaXMgZmFsc2UuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQcmV2ZW50IGR1cGxpY2F0ZXMsIHRvYXN0ci90b2FzdHItcHJldmVudC1kdXBsaWNhdGVzLmNvbXBvbmVudClcbiAqXG4gKiBgZHVwbGljYXRlc0JlaGF2aW91cmAgLSBkZXRlcm1pbmVzIGhvdyB0byB0cmVhdCB0aGUgdG9hc3RzIGR1cGxpY2F0aW9uLlxuICogQ29tcGFyZSB3aXRoIHRoZSBwcmV2aW91cyBtZXNzYWdlIGBwcmV2aW91c2BcbiAqIG9yIHdpdGggYWxsIHZpc2libGUgbWVzc2FnZXMgYGFsbGAuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQcmV2ZW50IGR1cGxpY2F0ZXMgYmVoYXZpb3VyICwgdG9hc3RyL3RvYXN0ci1wcmV2ZW50LWR1cGxpY2F0ZXMtYmVoYXZpb3VyLmNvbXBvbmVudClcbiAqXG4gKiBgbGltaXRgIC0gdGhlIG51bWJlciBvZiB2aXNpYmxlIHRvYXN0cyBpbiB0aGUgdG9hc3QgY29udGFpbmVyLiBUaGUgbnVtYmVyIG9mIHRvYXN0cyBpcyB1bmxpbWl0ZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFByZXZlbnQgZHVwbGljYXRlcyBiZWhhdmlvdXIgLCB0b2FzdHIvdG9hc3RyLWxpbWl0LmNvbXBvbmVudClcbiAqXG4gKiBgaGFzSWNvbmAgLSBpZiB0cnVlIHRoZW4gcmVuZGVyIHRvYXN0IGljb24uXG4gKiBgaWNvbmAgLSB5b3UgY2FuIHBhc3MgaWNvbiBjbGFzcyB0aGF0IHdpbGwgYmUgYXBwbGllZCBpbnRvIHRoZSB0b2FzdC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEhhcyBpY29uLCB0b2FzdHIvdG9hc3RyLWljb24uY29tcG9uZW50KVxuICogKi9cbmNsYXNzIE5iVG9hc3RyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZ2xvYmFsQ29uZmlnLCBjb250YWluZXJSZWdpc3RyeSkge1xuICAgICAgICB0aGlzLmdsb2JhbENvbmZpZyA9IGdsb2JhbENvbmZpZztcbiAgICAgICAgdGhpcy5jb250YWluZXJSZWdpc3RyeSA9IGNvbnRhaW5lclJlZ2lzdHJ5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIHNob3cobWVzc2FnZSwgdGl0bGUsIHVzZXJDb25maWcpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IE5iVG9hc3RyQ29uZmlnKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nbG9iYWxDb25maWcpLCB1c2VyQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyUmVnaXN0cnkuZ2V0KGNvbmZpZy5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHRvYXN0ID0geyBtZXNzYWdlLCB0aXRsZSwgY29uZmlnIH07XG4gICAgICAgIHJldHVybiBjb250YWluZXIuYXR0YWNoKHRvYXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3Mgc3VjY2VzcyB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIHN1Y2Nlc3MobWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgc3RhdHVzOiAnc3VjY2VzcycgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBpbmZvIHRvYXN0IHdpdGggbWVzc2FnZSwgdGl0bGUgYW5kIHVzZXIgY29uZmlnLlxuICAgICAqICovXG4gICAgaW5mbyhtZXNzYWdlLCB0aXRsZSwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3cobWVzc2FnZSwgdGl0bGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyBzdGF0dXM6ICdpbmZvJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHdhcm5pbmcgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICB3YXJuaW5nKG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IHN0YXR1czogJ3dhcm5pbmcnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgcHJpbWFyeSB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIHByaW1hcnkobWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgc3RhdHVzOiAncHJpbWFyeScgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBkYW5nZXIgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBkYW5nZXIobWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgc3RhdHVzOiAnZGFuZ2VyJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGRlZmF1bHQgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBkZWZhdWx0KG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IHN0YXR1czogJ2Jhc2ljJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGNvbnRyb2wgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBjb250cm9sKG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdChtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IHN0YXR1czogJ2NvbnRyb2wnIH0pKTtcbiAgICB9XG59XG5OYlRvYXN0clNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iVG9hc3RyU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iVG9hc3RyQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9UT0FTVFJfQ09ORklHLF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iVG9hc3RyQ29udGFpbmVyUmVnaXN0cnkgfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJUb2FzdHJNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KHRvYXN0ckNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJUb2FzdHJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYlRvYXN0clNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJUb2FzdHJDb250YWluZXJSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX1RPQVNUUl9DT05GSUcsIHVzZVZhbHVlOiB0b2FzdHJDb25maWcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuTmJUb2FzdHJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYlNoYXJlZE1vZHVsZSwgTmJPdmVybGF5TW9kdWxlLCBOYkljb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50LCBOYlRvYXN0Q29tcG9uZW50XSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCwgTmJUb2FzdENvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRvb2x0aXAgY29udGFpbmVyLlxuICogUmVuZGVycyBwcm92aWRlZCB0b29sdGlwIGluc2lkZS5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogdG9vbHRpcC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLWJvcmRlci1zdHlsZTpcbiAqIHRvb2x0aXAtYm9yZGVyLXdpZHRoOlxuICogdG9vbHRpcC1ib3JkZXItcmFkaXVzOlxuICogdG9vbHRpcC1wYWRkaW5nOlxuICogdG9vbHRpcC10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC10ZXh0LWZvbnQtZmFtaWx5OlxuICogdG9vbHRpcC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvb2x0aXAtdGV4dC1mb250LXdlaWdodDpcbiAqIHRvb2x0aXAtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRvb2x0aXAtaWNvbi1oZWlnaHQ6XG4gKiB0b29sdGlwLWljb24td2lkdGg6XG4gKiB0b29sdGlwLW1heC13aWR0aDpcbiAqIHRvb2x0aXAtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvb2x0aXAtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC1iYXNpYy10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiB0b29sdGlwLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvb2x0aXAtaW5mby1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLWluZm8tdGV4dC1jb2xvcjpcbiAqIHRvb2x0aXAtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIHRvb2x0aXAtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC13YXJuaW5nLXRleHQtY29sb3I6XG4gKiB0b29sdGlwLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHRvb2x0aXAtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHRvb2x0aXAtY29udHJvbC10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC1zaGFkb3c6XG4gKi9cbmNsYXNzIE5iVG9vbHRpcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9wb3ZlciBwb3NpdGlvbiByZWxhdGl2ZWx5IGhvc3QgZWxlbWVudC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IE5iUG9zaXRpb24uVE9QO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgZ2V0IGJpbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnBvc2l0aW9ufSAke3RoaXMuc3RhdHVzQ2xhc3N9YDtcbiAgICB9XG4gICAgZ2V0IHNob3coKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzQ2xhc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMuY29udGV4dC5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCBpcyBlbXB0eSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGFkZGl0aW9uYWxseVxuICAgICAqIHJlbmRlciBpcyBoYW5kbGVkIGJ5IGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKi9cbiAgICByZW5kZXJDb250ZW50KCkgeyB9XG59XG5OYlRvb2x0aXBDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRvb2x0aXAnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gY2xhc3M9XCJhcnJvd1wiPjwvc3Bhbj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgPG5iLWljb24gKm5nSWY9XCJjb250ZXh0Py5pY29uXCIgW2NvbmZpZ109XCJjb250ZXh0Lmljb25cIj48L25iLWljb24+XG4gICAgICA8c3BhbiAqbmdJZj1cImNvbnRlbnRcIj57eyBjb250ZW50IH19PC9zcGFuPlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcignc2hvd1Rvb2x0aXAnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSgnaW4nLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDEwMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDEwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ei1pbmRleDoxMDAwMH06aG9zdCAuY29udGVudHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfTpob3N0LnJpZ2h0IC5jb250ZW50e2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfTpob3N0IC5hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfTpob3N0IG5iLWljb24rc3BhbnttYXJnaW4tbGVmdDowLjVyZW19Omhvc3QucmlnaHQgbmItaWNvbitzcGFue21hcmdpbi1yaWdodDowLjVyZW19Omhvc3QgLmFycm93e2JvcmRlci1sZWZ0OjZweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NnB4IHNvbGlkIHRyYW5zcGFyZW50fTpob3N0KC5ib3R0b20pIC5hcnJvd3t0b3A6LTZweDtsZWZ0OmNhbGMoNTAlIC0gNnB4KX06aG9zdCguYm90dG9tLXN0YXJ0KSAuYXJyb3d7dG9wOi02cHh9W2Rpcj1sdHJdIDpob3N0KC5ib3R0b20tc3RhcnQpIC5hcnJvd3tyaWdodDo2cHh9W2Rpcj1ydGxdIDpob3N0KC5ib3R0b20tc3RhcnQpIC5hcnJvd3tsZWZ0OjZweH06aG9zdCguYm90dG9tLWVuZCkgLmFycm93e3RvcDotNnB4fVtkaXI9bHRyXSA6aG9zdCguYm90dG9tLWVuZCkgLmFycm93e2xlZnQ6NnB4fVtkaXI9cnRsXSA6aG9zdCguYm90dG9tLWVuZCkgLmFycm93e3JpZ2h0OjZweH06aG9zdCgubGVmdCkgLmFycm93LDpob3N0KC5zdGFydCkgLmFycm93e3RvcDpjYWxjKDUwJSAtIDIuNHB4KX1bZGlyPWx0cl0gOmhvc3QoLmxlZnQpIC5hcnJvdyxbZGlyPWx0cl0gOmhvc3QoLnN0YXJ0KSAuYXJyb3d7cmlnaHQ6LThweDt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX1bZGlyPXJ0bF0gOmhvc3QoLmxlZnQpIC5hcnJvdyxbZGlyPXJ0bF0gOmhvc3QoLnN0YXJ0KSAuYXJyb3d7bGVmdDotOHB4O3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX06aG9zdCguc3RhcnQtdG9wKSAuYXJyb3d7cmlnaHQ6LThweDtib3R0b206NnB4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTpob3N0KC5zdGFydC1ib3R0b20pIC5hcnJvd3tyaWdodDotOHB4O3RvcDo2cHg7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9Omhvc3QoLnRvcCkgLmFycm93e2JvdHRvbTotNnB4O2xlZnQ6Y2FsYyg1MCUgLSA2cHgpO3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX06aG9zdCgudG9wLXN0YXJ0KSAuYXJyb3d7Ym90dG9tOmNhbGMoLTEgKiA2cHggKyAxcHgpO3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX1bZGlyPWx0cl0gOmhvc3QoLnRvcC1zdGFydCkgLmFycm93e3JpZ2h0OjZweH1bZGlyPXJ0bF0gOmhvc3QoLnRvcC1zdGFydCkgLmFycm93e2xlZnQ6NnB4fTpob3N0KC50b3AtZW5kKSAuYXJyb3d7Ym90dG9tOmNhbGMoLTZweCArIDFweCk7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfVtkaXI9bHRyXSA6aG9zdCgudG9wLWVuZCkgLmFycm93e2xlZnQ6NnB4fVtkaXI9cnRsXSA6aG9zdCgudG9wLWVuZCkgLmFycm93e3JpZ2h0OjZweH06aG9zdCgucmlnaHQpIC5hcnJvdyw6aG9zdCguZW5kKSAuYXJyb3d7dG9wOmNhbGMoNTAlIC0gMi40cHgpfVtkaXI9bHRyXSA6aG9zdCgucmlnaHQpIC5hcnJvdyxbZGlyPWx0cl0gOmhvc3QoLmVuZCkgLmFycm93e2xlZnQ6LThweDt0cmFuc2Zvcm06cm90YXRlKDI3MGRlZyl9W2Rpcj1ydGxdIDpob3N0KC5yaWdodCkgLmFycm93LFtkaXI9cnRsXSA6aG9zdCguZW5kKSAuYXJyb3d7cmlnaHQ6LThweDt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX06aG9zdCguZW5kLXRvcCkgLmFycm93e2xlZnQ6Y2FsYygtNnB4IC0gNnB4IC8gMi41KTtib3R0b206NnB4O3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX06aG9zdCguZW5kLWJvdHRvbSkgLmFycm93e2xlZnQ6Y2FsYygtNnB4IC0gNnB4IC8gMi41KTt0b3A6NnB4O3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUb29sdGlwQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlRvb2x0aXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29udGVudDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcG9zaXRpb246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGJpbmRpbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIHNob3c6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ0BzaG93VG9vbHRpcCcsXSB9XSxcbiAgICBjb250ZXh0OiBbeyB0eXBlOiBJbnB1dCB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqXG4gKiBUb29sdGlwIGRpcmVjdGl2ZSBmb3Igc21hbGwgdGV4dC9pY29uIGhpbnRzLlxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iVG9vbHRpcE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUb29sdGlwTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0b29sdGlwL3Rvb2x0aXAtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFRvb2x0aXAgY2FuIGFjY2VwdCBhIGhpbnQgdGV4dCBhbmQvb3IgYW4gaWNvbjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBJY29uLCB0b29sdGlwL3Rvb2x0aXAtd2l0aC1pY29uLmNvbXBvbmVudClcbiAqXG4gKiBTYW1lIHdheSBhcyBQb3BvdmVyLCB0b29sdGlwIGNhbiBhY2NlcHQgcGxhY2VtZW50IHBvc2l0aW9uIHdpdGggYG5iVG9vbHRpcFBsYWNlbWVudGAgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFBsYWNlbWVudHMsIHRvb2x0aXAvdG9vbHRpcC1wbGFjZW1lbnRzLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHNwZWNpZnkgdG9vbHRpcCBjb2xvciB1c2luZyBgbmJUb29sdGlwU3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBUb29sdGlwcywgdG9vbHRpcC90b29sdGlwLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogVG9vbHRpcCBoYXMgYSBudW1iZXIgb2YgdHJpZ2dlcnMgd2hpY2ggcHJvdmlkZXMgYW4gYWJpbGl0eSB0byBzaG93IGFuZCBoaWRlIHRoZSBjb21wb25lbnQgaW4gZGlmZmVyZW50IHdheXM6XG4gKlxuICogLSBDbGljayBtb2RlIHNob3dzIHRoZSBjb21wb25lbnQgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIGhpZGVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzXG4gKiBzb21ld2hlcmUgb24gdGhlIGRvY3VtZW50IG91dHNpZGUgdGhlIGNvbXBvbmVudC5cbiAqIC0gSGludCBwcm92aWRlcyBjYXBhYmlsaXR5IHRvIHNob3cgdGhlIGNvbXBvbmVudCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoZSBob3N0IGVsZW1lbnRcbiAqIGFuZCBoaWRlIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG91dCBvZiB0aGUgaG9zdC5cbiAqIC0gSG92ZXIgd29ya3MgbGlrZSBoaW50IG1vZGUgd2l0aCBvbmUgZXhjZXB0aW9uIC0gd2hlbiB0aGUgdXNlciBtb3ZlcyBtb3VzZSBmcm9tIGhvc3QgZWxlbWVudCB0b1xuICogdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoZSBjb21wb25lbnQgcmVtYWlucyBvcGVuLCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGludGVyYWN0IHdpdGggaXQgY29udGVudC5cbiAqIC0gRm9jdXMgbW9kZSBpcyBhcHBsaWVkIHdoZW4gdXNlciBmb2N1c2VzIHRoZSBlbGVtZW50LlxuICogLSBOb29wIG1vZGUgLSB0aGUgY29tcG9uZW50IHdvbid0IHJlYWN0IHRvIHRoZSB1c2VyIGludGVyYWN0aW9uLlxuICovXG5jbGFzcyBOYlRvb2x0aXBEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYsIGR5bmFtaWNPdmVybGF5SGFuZGxlcikge1xuICAgICAgICB0aGlzLmhvc3RSZWYgPSBob3N0UmVmO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlciA9IGR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbXBvbmVudCA9IE5iVG9vbHRpcENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NpdGlvbiB3aWxsIGJlIGNhbGN1bGF0ZWQgcmVsYXRpdmVseSBob3N0IGVsZW1lbnQgYmFzZWQgb24gdGhlIHBvc2l0aW9uLlxuICAgICAgICAgKiBDYW4gYmUgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCBvciBlbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gTmJQb3NpdGlvbi5UT1A7XG4gICAgICAgIHRoaXMuX2FkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuQ0xPQ0tXSVNFO1xuICAgICAgICB0aGlzLl90b29sdGlwQ2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc2NyaWJlcyB3aGVuIHRoZSBjb250YWluZXIgd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQXZhaWxhYmxlIG9wdGlvbnM6IGBjbGlja2AsIGBob3ZlcmAsIGBoaW50YCwgYGZvY3VzYCBhbmQgYG5vb3BgXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IE5iVHJpZ2dlci5ISU5UO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0b29sdGlwIG92ZXJsYXkgb2Zmc2V0IChpbiBwaXhlbHMpLlxuICAgICAgICAgKiovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gODtcbiAgICAgICAgdGhpcy5uYlRvb2x0aXBTaG93U3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbmZpZyA9IHsgcGFuZWxDbGFzczogdGhpcy50b29sdGlwQ2xhc3MgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgY2hhbmdlIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhpcyBzdHJhdGVneSBpZiBjb250YWluZXIgY2FuJ3QgZml0IHZpZXcgcG9ydC5cbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbm9vcGAgdmFsdWUgaWYgeW91IHdhbnQgdG8gZGlzYWJsZSBhdXRvbWF0aWMgYWRqdXN0bWVudC5cbiAgICAgKiBBdmFpbGFibGUgdmFsdWVzOiBgY2xvY2t3aXNlYCAoZGVmYXVsdCksIGBjb3VudGVyY2xvY2t3aXNlYCwgYHZlcnRpY2FsYCwgYGhvcml6b250YWxgLCBgbm9vcGAuXG4gICAgICovXG4gICAgZ2V0IGFkanVzdG1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGp1c3RtZW50O1xuICAgIH1cbiAgICBzZXQgYWRqdXN0bWVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0b29sdGlwQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b29sdGlwQ2xhc3M7XG4gICAgfVxuICAgIHNldCB0b29sdGlwQ2xhc3ModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRvb2x0aXBDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcENsYXNzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlDb25maWcgPSB7IHBhbmVsQ2xhc3M6IHRoaXMudG9vbHRpcENsYXNzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXB0cyBpY29uIG5hbWUgb3IgaWNvbiBjb25maWcgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBOYkljb25Db25maWd9IGljb24gbmFtZSBvciBjb25maWcgb2JqZWN0XG4gICAgICovXG4gICAgc2V0IGljb24oaWNvbikge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBPYmplY3QuYXNzaWduKHRoaXMuY29udGV4dCwgeyBpY29uIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXQgc3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBPYmplY3QuYXNzaWduKHRoaXMuY29udGV4dCwgeyBzdGF0dXMgfSk7XG4gICAgfVxuICAgIGdldCBpc1Nob3duKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5keW5hbWljT3ZlcmxheSAmJiB0aGlzLmR5bmFtaWNPdmVybGF5LmlzQXR0YWNoZWQpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5ob3N0KHRoaXMuaG9zdFJlZilcbiAgICAgICAgICAgIC5jb21wb25lbnRUeXBlKHRoaXMudG9vbHRpcENvbXBvbmVudClcbiAgICAgICAgICAgIC5vZmZzZXQodGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuaXNTaG93blxuICAgICAgICAgICAgLnBpcGUoc2tpcCgxKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoaXNTaG93bikgPT4gdGhpcy5uYlRvb2x0aXBTaG93U3RhdGVDaGFuZ2UuZW1pdCh7IGlzU2hvd24gfSkpO1xuICAgIH1cbiAgICByZWJ1aWxkKCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5ID0gdGhpcy5jb25maWd1cmVEeW5hbWljT3ZlcmxheSgpXG4gICAgICAgICAgICAucmVidWlsZCgpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5oaWRlKCk7XG4gICAgfVxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS50b2dnbGUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgY29uZmlndXJlRHluYW1pY092ZXJsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlclxuICAgICAgICAgICAgLnBvc2l0aW9uKHRoaXMucG9zaXRpb24pXG4gICAgICAgICAgICAudHJpZ2dlcih0aGlzLnRyaWdnZXIpXG4gICAgICAgICAgICAuYWRqdXN0bWVudCh0aGlzLmFkanVzdG1lbnQpXG4gICAgICAgICAgICAuY29udGVudCh0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICAuY29udGV4dCh0aGlzLmNvbnRleHQpXG4gICAgICAgICAgICAub3ZlcmxheUNvbmZpZyh0aGlzLm92ZXJsYXlDb25maWcpO1xuICAgIH1cbn1cbk5iVG9vbHRpcERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iVG9vbHRpcF0nLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmJUb29sdGlwJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOYkR5bmFtaWNPdmVybGF5SGFuZGxlciwgTmJEeW5hbWljT3ZlcmxheV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVG9vbHRpcERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5iRHluYW1pY092ZXJsYXlIYW5kbGVyIH1cbl07XG5OYlRvb2x0aXBEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29udGVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUb29sdGlwJyxdIH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlRvb2x0aXBQbGFjZW1lbnQnLF0gfV0sXG4gICAgYWRqdXN0bWVudDogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUb29sdGlwQWRqdXN0bWVudCcsXSB9XSxcbiAgICB0b29sdGlwQ2xhc3M6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iVG9vbHRpcENsYXNzJyxdIH1dLFxuICAgIGljb246IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iVG9vbHRpcEljb24nLF0gfV0sXG4gICAgc3RhdHVzOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlRvb2x0aXBTdGF0dXMnLF0gfV0sXG4gICAgdHJpZ2dlcjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUb29sdGlwVHJpZ2dlcicsXSB9XSxcbiAgICBvZmZzZXQ6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iVG9vbHRpcE9mZnNldCcsXSB9XSxcbiAgICBuYlRvb2x0aXBTaG93U3RhdGVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYlRvb2x0aXBNb2R1bGUge1xufVxuTmJUb29sdGlwTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTmJTaGFyZWRNb2R1bGUsIE5iT3ZlcmxheU1vZHVsZSwgTmJJY29uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlRvb2x0aXBDb21wb25lbnQsIE5iVG9vbHRpcERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW05iVG9vbHRpcERpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTmJUb29sdGlwQ29tcG9uZW50XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG5jb25zdCBOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOJyk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLy8gQ29tcG9uZW50IGNsYXNzIHNjb3BlZCBjb3VudGVyIGZvciBhcmlhIGF0dHJpYnV0ZXMuXG5sZXQgbGFzdE9wdGlvbklkID0gMDtcbi8qKlxuICogTmJPcHRpb25Db21wb25lbnRcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogb3B0aW9uLWJhY2tncm91bmQtY29sb3I6XG4gKiBvcHRpb24tdGV4dC1jb2xvcjpcbiAqIG9wdGlvbi10ZXh0LWZvbnQtZmFtaWx5OlxuICogb3B0aW9uLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBvcHRpb24taG92ZXItdGV4dC1jb2xvcjpcbiAqIG9wdGlvbi1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG9wdGlvbi1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIG9wdGlvbi1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogb3B0aW9uLWZvY3VzLXRleHQtY29sb3I6XG4gKiBvcHRpb24tc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG9wdGlvbi1zZWxlY3RlZC10ZXh0LWNvbG9yOlxuICogb3B0aW9uLXNlbGVjdGVkLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBvcHRpb24tc2VsZWN0ZWQtaG92ZXItdGV4dC1jb2xvcjpcbiAqIG9wdGlvbi1zZWxlY3RlZC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG9wdGlvbi1zZWxlY3RlZC1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIG9wdGlvbi1zZWxlY3RlZC1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogb3B0aW9uLXNlbGVjdGVkLWZvY3VzLXRleHQtY29sb3I6XG4gKiBvcHRpb24tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG9wdGlvbi1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogb3B0aW9uLXRpbnktdGV4dC1mb250LXNpemU6XG4gKiBvcHRpb24tdGlueS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogb3B0aW9uLXRpbnktdGV4dC1saW5lLWhlaWdodDpcbiAqIG9wdGlvbi10aW55LXBhZGRpbmc6XG4gKiBvcHRpb24tc21hbGwtdGV4dC1mb250LXNpemU6XG4gKiBvcHRpb24tc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIG9wdGlvbi1zbWFsbC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogb3B0aW9uLXNtYWxsLXBhZGRpbmc6XG4gKiBvcHRpb24tbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICogb3B0aW9uLW1lZGl1bS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogb3B0aW9uLW1lZGl1bS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogb3B0aW9uLW1lZGl1bS1wYWRkaW5nOlxuICogb3B0aW9uLWxhcmdlLXRleHQtZm9udC1zaXplOlxuICogb3B0aW9uLWxhcmdlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBvcHRpb24tbGFyZ2UtdGV4dC1saW5lLWhlaWdodDpcbiAqIG9wdGlvbi1sYXJnZS1wYWRkaW5nOlxuICogb3B0aW9uLWdpYW50LXRleHQtZm9udC1zaXplOlxuICogb3B0aW9uLWdpYW50LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBvcHRpb24tZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIG9wdGlvbi1naWFudC1wYWRkaW5nOlxuICoqL1xuY2xhc3MgTmJPcHRpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZWxlbWVudFJlZiwgY2QsIHpvbmUsIHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRpc2FibGVkQnlHcm91cCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgdmFsdWUgd2hlbiBvcHRpb24gc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIG9wdGlvbiBjbGlja2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnQgc2NvcGVkIGlkIGZvciBhcmlhIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuaWQgPSBgbmItb3B0aW9uLSR7bGFzdE9wdGlvbklkKyt9YDtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkQnlHcm91cDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGNsaWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGljayQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgLy8gVE9ETzogIzIyNTRcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ25iLXRyYW5zaXRpb24nKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSByZW5kZXIgY2hlY2tib3guXG4gICAgICogKi9cbiAgICBnZXQgd2l0aENoZWNrYm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLnZhbHVlICE9IG51bGw7XG4gICAgfVxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBpc1Nob3dDaGVja2JveCBwcm9wZXJ0eSB0byBjb250cm9sIHRoaXMgYmVoYXZpb3VyIG91dHNpZGUsIGlzc3Vlcy8xOTY1XG4gICAgZ2V0IG11bHRpcGxlKCkge1xuICAgICAgICAvLyBXZSBjaGVjayBwYXJlbnQgZXhpc3RpbmcgYmVjYXVzZSBwYXJlbnQgY2FuIGJlIE5iU2VsZWN0Q29tcG9uZW50IG9yXG4gICAgICAgIC8vIE5iQXV0b2NvbXBsZXRlIGFuZCBgbWlsdGlwbGVgIHByb3BlcnR5IGV4aXN0cyBvbmx5IGluIE5iU2VsZWN0Q29tcG9uZW50XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50Lm11bHRpcGxlIDogZmFsc2U7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICcnIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gJy0xJztcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICAgIH1cbiAgICA7XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICB0aGlzLmNsaWNrJC5uZXh0KHRoaXMpO1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBvbiBzcGFjZSBjbGljaywgZXRjLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHRydWUpO1xuICAgIH1cbiAgICBkZXNlbGVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGRpc2FibGVkIGJ5IGdyb3VwIHN0YXRlIGFuZCBtYXJrcyBjb21wb25lbnQgZm9yIGNoZWNrLlxuICAgICAqL1xuICAgIHNldERpc2FibGVkQnlHcm91cFN0YXRlKGRpc2FibGVkKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb21wb25lbnQgc3RpbGwgYWxpdmUgYXMgdGhlIG9wdGlvbiBncm91cCBkZWZlciBtZXRob2QgY2FsbCBzbyB0aGUgY29tcG9uZW50IG1heSBiZWNvbWUgZGVzdHJveWVkLlxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEJ5R3JvdXAgIT09IGRpc2FibGVkICYmIHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWRCeUdyb3VwID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihzZWxlY3RlZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSBvZiBjaGFuZ2luZyBvcHRpb25zIGluIHJ1bnRpbWUgdGhlIHJlZmVyZW5jZSB0byB0aGUgc2VsZWN0ZWQgb3B0aW9uIHdpbGwgYmUga2VwdCBpbiBzZWxlY3QgY29tcG9uZW50LlxuICAgICAgICAgKiBUaGlzIG1heSBsZWFkIHRvIGV4Y2VwdGlvbnMgd2l0aCBkZXRlY3RpbmcgY2hhbmdlcyBpbiBkZXN0cm95ZWQgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbHNvIEFuZ3VsYXIgY2FuIGNhbGwgd3JpdGVWYWx1ZSBvbiBkZXN0cm95ZWQgdmlldyAoc2VsZWN0IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IpLlxuICAgICAgICAgKiBhbmd1bGFyL2FuZ3VsYXIjMjc4MDNcbiAgICAgICAgICogKi9cbiAgICAgICAgaWYgKHRoaXMuYWxpdmUgJiYgdGhpcy5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBnZXRMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9XG4gICAgc2V0QWN0aXZlU3R5bGVzKCkge1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBzZXRJbmFjdGl2ZVN0eWxlcygpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuTmJPcHRpb25Db21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLW9wdGlvbicsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2hlY2tib3ggKm5nSWY9XCJ3aXRoQ2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICBbY2hlY2tlZF09XCJzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgIDwvbmItY2hlY2tib3g+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiLyohXFxuICogQGxpY2Vuc2VcXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cXG4gKi86aG9zdHtkaXNwbGF5OmZsZXh9Omhvc3Q6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Omhvc3QgbmItY2hlY2tib3h7ZGlzcGxheTpmbGV4O3BvaW50ZXItZXZlbnRzOm5vbmV9W2Rpcj1sdHJdIDpob3N0IG5iLWNoZWNrYm94e21hcmdpbi1yaWdodDouNXJlbX1bZGlyPXJ0bF0gOmhvc3QgbmItY2hlY2tib3h7bWFyZ2luLWxlZnQ6LjVyZW19Omhvc3QgbmItY2hlY2tib3ggOjpuZy1kZWVwIC5sYWJlbHtwYWRkaW5nOjB9Omhvc3QoW2Rpc2FibGVkXSl7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdCgubmItdHJhbnNpdGlvbil7dHJhbnNpdGlvbi1kdXJhdGlvbjowLjE1czt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsY29sb3I7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbn1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJPcHRpb25Db21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfU0VMRUNUX0lOSkVDVElPTl9UT0tFTixdIH1dIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogTmdab25lIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfVxuXTtcbk5iT3B0aW9uQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0aW9uQ2hhbmdlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgaWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV0sXG4gICAgbXVsdGlwbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm11bHRpcGxlJyxdIH1dLFxuICAgIHNlbGVjdGVkQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNlbGVjdGVkJyxdIH1dLFxuICAgIGRpc2FibGVkQXR0cmlidXRlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpc2FibGVkJyxdIH1dLFxuICAgIHRhYmluZGV4OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWyd0YWJJbmRleCcsXSB9XSxcbiAgICBhY3RpdmVDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYWN0aXZlJyxdIH1dLFxuICAgIG9uQ2xpY2s6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsIFsnJGV2ZW50J10sXSB9LCB7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydrZXlkb3duLnNwYWNlJywgWyckZXZlbnQnXSxdIH0sIHsgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2tleWRvd24uZW50ZXInLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJTZWxlY3RMYWJlbENvbXBvbmVudCB7XG59XG5OYlNlbGVjdExhYmVsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1zZWxlY3QtbGFiZWwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PidcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuZnVuY3Rpb24gbmJTZWxlY3RGb3JtRmllbGRDb250cm9sQ29uZmlnRmFjdG9yeSgpIHtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgTmJGb3JtRmllbGRDb250cm9sQ29uZmlnKCk7XG4gICAgY29uZmlnLnN1cHBvcnRzU3VmZml4ID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbi8qKlxuICogVGhlIGBOYlNlbGVjdENvbXBvbmVudGAgcHJvdmlkZXMgYSBjYXBhYmlsaXR5IHRvIHNlbGVjdCBvbmUgb2YgdGhlIHBhc3NlZCBpdGVtcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBzZWxlY3Qvc2VsZWN0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlNlbGVjdE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJTZWxlY3RNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBpdCBhcyB0aGUgbXVsdGktc2VsZWN0IGNvbnRyb2wgeW91IGhhdmUgdG8gbWFyayBpdCBhcyBgbXVsdGlwbGVgLlxuICogSW4gdGhpcyBjYXNlLCBgbmItc2VsZWN0YCB3aWxsIHdvcmsgb25seSB3aXRoIGFycmF5cyAtIGFjY2VwdCBhcnJheXMgYW5kIHByb3BhZ2F0ZSBhcnJheXMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNdWx0aXBsZSwgc2VsZWN0L3NlbGVjdC1tdWx0aXBsZS5jb21wb25lbnQpXG4gKlxuICogSXRlbXMgd2l0aG91dCB2YWx1ZXMgd2lsbCBjbGVhbiB0aGUgc2VsZWN0aW9uLiBCb3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzIHdpbGwgYWxzbyBjbGVhbiB0aGUgc2VsZWN0aW9uLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ2xlYW4gc2VsZWN0aW9uLCBzZWxlY3Qvc2VsZWN0LWNsZWFuLmNvbXBvbmVudClcbiAqXG4gKiBTZWxlY3QgbWF5IGJlIGJvdW5kZWQgdXNpbmcgYHNlbGVjdGVkYCBpbnB1dDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItc2VsZWN0IFsoc2VsZWN0ZWQpXT1cInNlbGVjdGVkXCI+PC9uYi1zZWxlY3RlZD5cbiAqIGBgYFxuICpcbiAqIE9yIHlvdSBjYW4gYmluZCBjb250cm9sIHdpdGggZm9ybSBjb250cm9scyBvciBuZ01vZGVsOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2VsZWN0IGZvcm0gYmluZGluZywgc2VsZWN0L3NlbGVjdC1mb3JtLmNvbXBvbmVudClcbiAqXG4gKiBPcHRpb25zIGluIHRoZSBzZWxlY3QgbWF5IGJlIGdyb3VwZWQgdXNpbmcgYG5iLW9wdGlvbi1ncm91cGAgY29tcG9uZW50LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoR3JvdXBpbmcsIHNlbGVjdC9zZWxlY3QtZ3JvdXBzLmNvbXBvbmVudClcbiAqXG4gKiBTZWxlY3QgbWF5IGhhdmUgYSBwbGFjZWhvbGRlciB0aGF0IHdpbGwgYmUgc2hvd24gd2hlbiBub3RoaW5nIHNlbGVjdGVkOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUGxhY2Vob2xkZXIsIHNlbGVjdC9zZWxlY3QtcGxhY2Vob2xkZXIuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gZGlzYWJsZSBzZWxlY3QsIG9wdGlvbnMgYW5kIHdob2xlIGdyb3Vwcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIHNlbGVjdCwgc2VsZWN0L3NlbGVjdC1kaXNhYmxlZC5jb21wb25lbnQpXG4gKlxuICogQWxzbywgdGhlIGN1c3RvbSBsYWJlbCBtYXkgYmUgcHJvdmlkZWQgaW4gc2VsZWN0LlxuICogVGhpcyBjdXN0b20gbGFiZWwgd2lsbCBiZSB1c2VkIGZvciBpbnN0ZWFkIHBsYWNlaG9sZGVyIHdoZW4gc29tZXRoaW5nIHNlbGVjdGVkLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ3VzdG9tIGxhYmVsLCBzZWxlY3Qvc2VsZWN0LWxhYmVsLmNvbXBvbmVudClcbiAqXG4gKiBEZWZhdWx0IGBuYi1zZWxlY3RgIHNpemUgaXMgYG1lZGl1bWAgYW5kIHN0YXR1cyBpcyBgYmFzaWNgLlxuICogU2VsZWN0IGlzIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBjb2xvcnMgdXNpbmcgYHN0YXR1c2AgcHJvcGVydHk6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3Qgc3RhdHVzZXMsIHNlbGVjdC9zZWxlY3Qtc3RhdHVzLmNvbXBvbmVudClcbiAqXG4gKiBUaGVyZSBhcmUgZml2ZSBzZWxlY3Qgc2l6ZXM6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3Qgc2l6ZXMsIHNlbGVjdC9zZWxlY3Qtc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEFuZCB0d28gYWRkaXRpb25hbCBzdHlsZSB0eXBlcyAtIGBmaWxsZWRgOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRmlsbGVkIHNlbGVjdCwgc2VsZWN0L3NlbGVjdC1maWxsZWQuY29tcG9uZW50KVxuICpcbiAqIGFuZCBgaGVyb2A6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3QgY29sb3JzLCBzZWxlY3Qvc2VsZWN0LWhlcm8uY29tcG9uZW50KVxuICpcbiAqIFNlbGVjdCBpcyBhdmFpbGFibGUgaW4gZGlmZmVyZW50IHNoYXBlcywgdGhhdCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIHRoZSBvdGhlciBwcm9wZXJ0aWVzOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2VsZWN0IHNoYXBlcywgc2VsZWN0L3NlbGVjdC1zaGFwZXMuY29tcG9uZW50KVxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBjb21wb25lbnQgc2VsZWN0cyBvcHRpb25zIHdob3NlIHZhbHVlcyBhcmUgc3RyaWN0bHkgZXF1YWwgKGA9PT1gKSB3aXRoIHRoZSBzZWxlY3QgdmFsdWUuXG4gKiBUbyBjaGFuZ2Ugc3VjaCBiZWhhdmlvciwgcGFzcyBhIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIHRoZSBgY29tcGFyZVdpdGhgIGF0dHJpYnV0ZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNlbGVjdCBjdXN0b20gY29tcGFyYXRvciwgc2VsZWN0L3NlbGVjdC1jb21wYXJlLXdpdGguY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoSW50ZXJhY3RpdmUsIHNlbGVjdC9zZWxlY3QtaW50ZXJhY3RpdmUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBzZWxlY3QtY3Vyc29yOlxuICogc2VsZWN0LWRpc2FibGVkLWN1cnNvcjpcbiAqIHNlbGVjdC1taW4td2lkdGg6XG4gKiBzZWxlY3Qtb3V0bGluZS13aWR0aDpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbG9yOlxuICogc2VsZWN0LWljb24tb2Zmc2V0OlxuICogc2VsZWN0LXRleHQtZm9udC1mYW1pbHk6XG4gKiBzZWxlY3QtcGxhY2Vob2xkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHNlbGVjdC10aW55LXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LXRpbnktdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC10aW55LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzZWxlY3QtdGlueS1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC10aW55LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtdGlueS1tYXgtd2lkdGg6XG4gKiBzZWxlY3Qtc21hbGwtdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3Qtc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1zbWFsbC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc2VsZWN0LXNtYWxsLXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LXNtYWxsLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3Qtc21hbGwtbWF4LXdpZHRoOlxuICogc2VsZWN0LW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC1tZWRpdW0tdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1tZWRpdW0tdGV4dC1saW5lLWhlaWdodDpcbiAqIHNlbGVjdC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtbWVkaXVtLW1heC13aWR0aDpcbiAqIHNlbGVjdC1sYXJnZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC1sYXJnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc2VsZWN0LWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzZWxlY3QtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1sYXJnZS1tYXgtd2lkdGg6XG4gKiBzZWxlY3QtZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtZ2lhbnQtdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1naWFudC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc2VsZWN0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtZ2lhbnQtbWF4LXdpZHRoOlxuICogc2VsZWN0LXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogc2VsZWN0LXNlbWktcm91bmQtYm9yZGVyLXJhZGl1czpcbiAqIHNlbGVjdC1yb3VuZC1ib3JkZXItcmFkaXVzOlxuICogc2VsZWN0LW91dGxpbmUtYm9yZGVyLXN0eWxlOlxuICogc2VsZWN0LW91dGxpbmUtYm9yZGVyLXdpZHRoOlxuICogc2VsZWN0LW91dGxpbmUtdGlueS1wYWRkaW5nOlxuICogc2VsZWN0LW91dGxpbmUtc21hbGwtcGFkZGluZzpcbiAqIHNlbGVjdC1vdXRsaW5lLW1lZGl1bS1wYWRkaW5nOlxuICogc2VsZWN0LW91dGxpbmUtbGFyZ2UtcGFkZGluZzpcbiAqIHNlbGVjdC1vdXRsaW5lLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtd2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1kYW5nZXItcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWFkamFjZW50LWJvcmRlci1zdHlsZTpcbiAqIHNlbGVjdC1vdXRsaW5lLWFkamFjZW50LWJvcmRlci13aWR0aDpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLW9wZW4tYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtcHJpbWFyeS1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8tYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtd2FybmluZy1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLW9wZW4tYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtb3Blbi1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYm9yZGVyLXN0eWxlOlxuICogc2VsZWN0LWZpbGxlZC1ib3JkZXItd2lkdGg6XG4gKiBzZWxlY3QtZmlsbGVkLXRpbnktcGFkZGluZzpcbiAqIHNlbGVjdC1maWxsZWQtc21hbGwtcGFkZGluZzpcbiAqIHNlbGVjdC1maWxsZWQtbWVkaXVtLXBhZGRpbmc6XG4gKiBzZWxlY3QtZmlsbGVkLWxhcmdlLXBhZGRpbmc6XG4gKiBzZWxlY3QtZmlsbGVkLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tdGlueS1wYWRkaW5nOlxuICogc2VsZWN0LWhlcm8tc21hbGwtcGFkZGluZzpcbiAqIHNlbGVjdC1oZXJvLW1lZGl1bS1wYWRkaW5nOlxuICogc2VsZWN0LWhlcm8tbGFyZ2UtcGFkZGluZzpcbiAqIHNlbGVjdC1oZXJvLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8taWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiAqL1xuY2xhc3MgTmJTZWxlY3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBvdmVybGF5LCBob3N0UmVmLCBwb3NpdGlvbkJ1aWxkZXIsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXIsIGNkLCBmb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZSwgZm9jdXNNb25pdG9yLCByZW5kZXJlciwgem9uZSwgc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXIgPSB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuZm9jdXNLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UgPSBmb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZTtcbiAgICAgICAgdGhpcy5mb2N1c01vbml0b3IgPSBmb2N1c01vbml0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdCBzaXplLCBhdmFpbGFibGUgc2l6ZXM6XG4gICAgICAgICAqIGB0aW55YCwgYHNtYWxsYCwgYG1lZGl1bWAgKGRlZmF1bHQpLCBgbGFyZ2VgLCBgZ2lhbnRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdCBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3Qgc2hhcGVzOiBgcmVjdGFuZ2xlYCAoZGVmYXVsdCksIGByb3VuZGAsIGBzZW1pLXJvdW5kYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9ICdyZWN0YW5nbGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IGFwcGVhcmFuY2VzOiBgb3V0bGluZWAgKGRlZmF1bHQpLCBgZmlsbGVkYCwgYGhlcm9gXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnb3V0bGluZSc7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVycyBzZWxlY3QgcGxhY2Vob2xkZXIgaWYgbm90aGluZyBzZWxlY3RlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xuICAgICAgICB0aGlzLl9jb21wYXJlV2l0aCA9ICh2MSwgdjIpID0+IHYxID09PSB2MjtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgb3B0aW9ucyBvdmVybGF5IG9mZnNldCAoaW4gcGl4ZWxzKS5cbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLm9wdGlvbnNPdmVybGF5T2Zmc2V0ID0gODtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgb3B0aW9ucyBvdmVybGF5IHNjcm9sbCBzdHJhdGVneS5cbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLnNjcm9sbFN0cmF0ZWd5ID0gJ2Jsb2NrJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgYmUgZW1pdHRlZCB3aGVuIHNlbGVjdGVkIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIHNlbGVjdGVkIG9wdGlvbnMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgb3ZlcmxheSBwb3NpdGlvbiBiZWNhdXNlIG9mIHdlIGhhdmUgdG8gdG9nZ2xlIG92ZXJsYXlQb3NpdGlvblxuICAgICAgICAgKiBpbiBbbmdDbGFzc10gZGlyZWN0aW9uIGFuZCB0aGlzIGRpcmVjdGl2ZSBjYW4gdXNlIG9ubHkgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdmVybGF5UG9zaXRpb24gPSAnJztcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gcGFzc2VkIHRocm91Z2ggY29udHJvbCB2YWx1ZSBhY2Nlc3NvciB0byBwcm9wYWdhdGUgY2hhbmdlcy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLnN0YXR1cyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuc3RhdHVzKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKiovXG4gICAgICAgIHRoaXMuc2l6ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuc2l6ZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmRpc2FibGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3QodGhpcy5kaXNhYmxlZCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuZnVsbFdpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgb3V0bGluZWAgc3R5bGVzXG4gICAgICovXG4gICAgZ2V0IG91dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdvdXRsaW5lJztcbiAgICB9XG4gICAgc2V0IG91dGxpbmUodmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdvdXRsaW5lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGBmaWxsZWRgIHN0eWxlc1xuICAgICAqL1xuICAgIGdldCBmaWxsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdmaWxsZWQnO1xuICAgIH1cbiAgICBzZXQgZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZmlsbGVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGBoZXJvYCBzdHlsZXNcbiAgICAgKi9cbiAgICBnZXQgaGVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2hlcm8nO1xuICAgIH1cbiAgICBzZXQgaGVybyh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2hlcm8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzZWxlY3RcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgZWxlbWVudCB3aWxsIGZpbGwgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldCBmdWxsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxsV2lkdGg7XG4gICAgfVxuICAgIHNldCBmdWxsV2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZnVsbFdpZHRoID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBjb21wYXJlIG9wdGlvbiB2YWx1ZSB3aXRoIHNlbGVjdGVkIHZhbHVlLlxuICAgICAqIEJ5IGRlZmF1bHQsIHZhbHVlcyBhcmUgY29tcGFyZWQgd2l0aCBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKS5cbiAgICAgKi9cbiAgICBnZXQgY29tcGFyZVdpdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wYXJlV2l0aDtcbiAgICB9XG4gICAgc2V0IGNvbXBhcmVXaXRoKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wYXJlV2l0aCA9IGZuO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGggJiYgdGhpcy5jYW5TZWxlY3RWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIHNlbGVjdGVkIGl0ZW0gb3IgYXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbXMuXG4gICAgICogKi9cbiAgICBzZXQgc2VsZWN0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZVxuICAgICAgICAgICAgPyB0aGlzLnNlbGVjdGlvbk1vZGVsLm1hcChvID0+IG8udmFsdWUpXG4gICAgICAgICAgICA6IHRoaXMuc2VsZWN0aW9uTW9kZWxbMF0udmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVzIGNhcGFiaWxpdHkganVzdCB3cml0ZSBgbXVsdGlwbGVgIG92ZXIgdGhlIGVsZW1lbnQuXG4gICAgICogKi9cbiAgICBnZXQgbXVsdGlwbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aXBsZTtcbiAgICB9XG4gICAgc2V0IG11bHRpcGxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGFkZGl0aW9uYWxDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNTZXJ2aWNlLmlzQ3VzdG9tU3RhdHVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy5zdGF0dXMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaXMgc2VsZWN0IG9wZW5lZC5cbiAgICAgKiAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlzIHNlbGVjdCBoaWRkZW4uXG4gICAgICogKi9cbiAgICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc09wZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgdGhlIHNlbGVjdCBidXR0b24uXG4gICAgICogKi9cbiAgICBnZXQgaG9zdFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b24ubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdEJ1dHRvbkNsYXNzZXMoKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbk1vZGVsLmxlbmd0aCkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGggJiYgIXRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLm92ZXJsYXlQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgcmVuZGVyZWQgaW4gdGhlIGxhYmVsLlxuICAgICAqICovXG4gICAgZ2V0IHNlbGVjdGlvblZpZXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uY29udGVudCkuam9pbignLCAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbFswXS5jb250ZW50O1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyh7IGRpc2FibGVkLCBzdGF0dXMsIHNpemUsIGZ1bGxXaWR0aCB9KSB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCQubmV4dChkaXNhYmxlZC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzJC5uZXh0KHN0YXR1cy5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUkLm5leHQoc2l6ZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbFdpZHRoJC5uZXh0KHRoaXMuZnVsbFdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodGhpcy5vcHRpb25zKSwgZmlsdGVyKCgpID0+IHRoaXMucXVldWUgIT0gbnVsbCAmJiB0aGlzLmNhblNlbGVjdFZhbHVlKCkpLCBcbiAgICAgICAgLy8gQ2FsbCAnd3JpdGVWYWx1ZScgd2hlbiBjdXJyZW50IGNoYW5nZSBkZXRlY3Rpb24gcnVuIGlzIGZpbmlzaGVkLlxuICAgICAgICAvLyBXaGVuIHdyaXRpbmcgaXMgZmluaXNoZWQsIGNoYW5nZSBkZXRlY3Rpb24gc3RhcnRzIGFnYWluLCBzaW5jZVxuICAgICAgICAvLyBtaWNyb3Rhc2tzIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgICAvLyBQcmV2ZW50cyBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yLlxuICAgICAgICBzd2l0Y2hNYXAoKG9wdGlvbnMpID0+IGZyb20oUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy53cml0ZVZhbHVlKHRoaXMucXVldWUpKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneSA9IHRoaXMuY3JlYXRlVHJpZ2dlclN0cmF0ZWd5KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25CdXR0b25Gb2N1cygpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uVHJpZ2dlcnMoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPbk9wdGlvbkNsaWNrKCk7XG4gICAgICAgIC8vIFRPRE86ICMyMjU0XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQsICduYi10cmFuc2l0aW9uJyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlclN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9PdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9wdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhblNlbGVjdFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGVsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgb3B0aW9uIG9yIGNsZWFyIGFsbCBzZWxlY3RlZCBvcHRpb25zIGlmIHZhbHVlIGlzIG51bGwuXG4gICAgICogKi9cbiAgICBoYW5kbGVPcHRpb25DbGljayhvcHRpb24pIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb24udmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCBhbGwgc2VsZWN0ZWQgb3B0aW9ucy5cbiAgICAgKiAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmZvckVhY2goKG9wdGlvbikgPT4gb3B0aW9uLmRlc2VsZWN0KCkpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gW107XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB0aGlzLmJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZW1pdFNlbGVjdGVkKHRoaXMubXVsdGlwbGUgPyBbXSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGhvdyB0byBzZWxlY3Qgb3B0aW9uIGFzIG11bHRpcGxlIG9yIHNpbmdsZS5cbiAgICAgKiAqL1xuICAgIHNlbGVjdE9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTXVsdGlwbGVTZWxlY3Qob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlU2VsZWN0KG9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHNpbmdsZSBvcHRpb24uXG4gICAgICogKi9cbiAgICBoYW5kbGVTaW5nbGVTZWxlY3Qob3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5wb3AoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkICYmICF0aGlzLl9jb21wYXJlV2l0aChzZWxlY3RlZC52YWx1ZSwgb3B0aW9uLnZhbHVlKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuZGVzZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gW29wdGlvbl07XG4gICAgICAgIG9wdGlvbi5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWQob3B0aW9uLnZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGZvciBtdWx0aXBsZSBvcHRpb25zLlxuICAgICAqICovXG4gICAgaGFuZGxlTXVsdGlwbGVTZWxlY3Qob3B0aW9uKSB7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmZpbHRlcihzID0+ICF0aGlzLl9jb21wYXJlV2l0aChzLnZhbHVlLCBvcHRpb24udmFsdWUpKTtcbiAgICAgICAgICAgIG9wdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25Nb2RlbC5tYXAoKG9wdCkgPT4gb3B0LnZhbHVlKSk7XG4gICAgfVxuICAgIGF0dGFjaFRvT3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TWFuYWdlcigpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVPbk92ZXJsYXlLZXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWYuYXR0YWNoKHRoaXMucG9ydGFsKTtcbiAgICB9XG4gICAgc2V0QWN0aXZlT3B0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKHRoaXMuc2VsZWN0aW9uTW9kZWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVTY3JvbGxTdHJhdGVneSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMucG9zaXRpb25TdHJhdGVneSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5LFxuICAgICAgICAgICAgcGFuZWxDbGFzczogdGhpcy5vcHRpb25zUGFuZWxDbGFzcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUtleU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMua2V5TWFuYWdlciA9IHRoaXMuZm9jdXNLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UuY3JlYXRlKHRoaXMub3B0aW9ucykud2l0aFR5cGVBaGVhZCgyMDApO1xuICAgIH1cbiAgICBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbkJ1aWxkZXJcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLmJ1dHRvbilcbiAgICAgICAgICAgIC5wb3NpdGlvbihOYlBvc2l0aW9uLkJPVFRPTSlcbiAgICAgICAgICAgIC5vZmZzZXQodGhpcy5vcHRpb25zT3ZlcmxheU9mZnNldClcbiAgICAgICAgICAgIC5hZGp1c3RtZW50KE5iQWRqdXN0bWVudC5WRVJUSUNBTCk7XG4gICAgfVxuICAgIGNyZWF0ZVNjcm9sbFN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXNbdGhpcy5zY3JvbGxTdHJhdGVneV0oKTtcbiAgICB9XG4gICAgY3JlYXRlVHJpZ2dlclN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyXG4gICAgICAgICAgICAudHJpZ2dlcihOYlRyaWdnZXIuQ0xJQ0spXG4gICAgICAgICAgICAuaG9zdCh0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgIC5jb250YWluZXIoKCkgPT4gdGhpcy5nZXRDb250YWluZXIoKSlcbiAgICAgICAgICAgIC5idWlsZCgpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblRyaWdnZXJzKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5zaG93JC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zaG93KCkpO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5oaWRlJFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuaXNPcGVuKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCRldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNDbGlja2VkV2l0aGluQ29tcG9uZW50KCRldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25Qb3NpdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25PcHRpb25DbGljaygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB1c2VyIGNoYW5nZXMgcHJvdmlkZWQgb3B0aW9ucyBsaXN0IGluIHRoZSBydW50aW1lIHdlIGhhdmUgdG8gaGFuZGxlIHRoaXNcbiAgICAgICAgICogYW5kIHJlc3Vic2NyaWJlIG9uIG9wdGlvbnMgc2VsZWN0aW9uIGNoYW5nZXMgZXZlbnQuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBzZWxlY3QgbmV3IG9wdGlvbnMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodGhpcy5vcHRpb25zKSwgc3dpdGNoTWFwKChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UoLi4ub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5jbGljaykpO1xuICAgICAgICB9KSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoY2xpY2tlZE9wdGlvbikgPT4gdGhpcy5oYW5kbGVPcHRpb25DbGljayhjbGlja2VkT3B0aW9uKSk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uT3ZlcmxheUtleXMoKSB7XG4gICAgICAgIHRoaXMucmVmLmtleWRvd25FdmVudHMoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuaXNPcGVuKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2V5TWFuYWdlci50YWJPdXRcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25CdXR0b25Gb2N1cygpIHtcbiAgICAgICAgdGhpcy5mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLmJ1dHRvbilcbiAgICAgICAgICAgIC5waXBlKG1hcChvcmlnaW4gPT4gISFvcmlnaW4pLCBmaW5hbGl6ZSgoKSA9PiB0aGlzLmZvY3VzTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLmJ1dHRvbikpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuZm9jdXNlZCQpO1xuICAgIH1cbiAgICBnZXRDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpICYmIHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudDogdGhpcy5yZWYub3ZlcmxheUVsZW1lbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9wYWdhdGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAgICogKi9cbiAgICBlbWl0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChzZWxlY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3RlZCB2YWx1ZSBpbiBtb2RlbC5cbiAgICAgKiAqL1xuICAgIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYXNzaWduIHNpbmdsZSB2YWx1ZSBpZiBzZWxlY3QgaXMgbWFya2VkIGFzIG11bHRpcGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhc3NpZ24gYXJyYXkgaWYgc2VsZWN0IGlzIG5vdCBtYXJrZWQgYXMgbXVsdGlwbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c2x5U2VsZWN0ZWRPcHRpb25zID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IFtdO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChvcHRpb24gPT4gdGhpcy5zZWxlY3RWYWx1ZShvcHRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgb3B0aW9ucyB3aGljaCB3ZXJlIHNlbGVjdGVkIGJlZm9yZSBhbmQgdHJpZ2dlciBkZXNlbGVjdFxuICAgICAgICBwcmV2aW91c2x5U2VsZWN0ZWRPcHRpb25zXG4gICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+ICF0aGlzLnNlbGVjdGlvbk1vZGVsLmluY2x1ZGVzKG9wdGlvbikpXG4gICAgICAgICAgICAuZm9yRWFjaCgob3B0aW9uKSA9PiBvcHRpb24uZGVzZWxlY3QoKSk7XG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdmFsdWUuXG4gICAgICogKi9cbiAgICBzZWxlY3RWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjb3JyZXNwb25kaW5nID0gdGhpcy5vcHRpb25zLmZpbmQoKG9wdGlvbikgPT4gdGhpcy5fY29tcGFyZVdpdGgob3B0aW9uLnZhbHVlLCB2YWx1ZSkpO1xuICAgICAgICBpZiAoY29ycmVzcG9uZGluZykge1xuICAgICAgICAgICAgY29ycmVzcG9uZGluZy5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwucHVzaChjb3JyZXNwb25kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRvdWNoZWQgaWYgZm9jdXMgbW92ZWQgb3V0c2lkZSBvZiBidXR0b24gYW5kIG92ZXJsYXksXG4gICAgICogaWdub3JpbmcgdGhlIGNhc2Ugd2hlbiBmb2N1cyBtb3ZlZCB0byBvcHRpb25zIG92ZXJsYXkuXG4gICAgICovXG4gICAgdHJ5U2V0VG91Y2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNDbGlja2VkV2l0aGluQ29tcG9uZW50KCRldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQgPT09ICRldmVudC50YXJnZXQgfHwgdGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoJGV2ZW50LnRhcmdldCk7XG4gICAgfVxuICAgIGNhblNlbGVjdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICAgIGdldCByb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyb3VuZCc7XG4gICAgfVxuICAgIGdldCBzZW1pUm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAnc2VtaS1yb3VuZCc7XG4gICAgfVxufVxuTmJTZWxlY3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXNlbGVjdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGJ1dHRvbiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgIFtuZ0NsYXNzXT1cXFwic2VsZWN0QnV0dG9uQ2xhc3Nlc1xcXCJcXG4gICAgICAgIChibHVyKT1cXFwidHJ5U2V0VG91Y2hlZCgpXFxcIlxcbiAgICAgICAgKGtleWRvd24uYXJyb3dEb3duKT1cXFwic2hvdygpXFxcIlxcbiAgICAgICAgKGtleWRvd24uYXJyb3dVcCk9XFxcInNob3coKVxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJzZWxlY3QtYnV0dG9uXFxcIlxcbiAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgI3NlbGVjdEJ1dHRvbj5cXG5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwic2VsZWN0aW9uTW9kZWwubGVuZ3RoOyBlbHNlIHBsYWNlaG9sZGVyVGVtcGxhdGVcXFwiPlxcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcImN1c3RvbUxhYmVsOyBlbHNlIGRlZmF1bHRTZWxlY3Rpb25UZW1wbGF0ZVxcXCI+XFxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIm5iLXNlbGVjdC1sYWJlbFxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgIDwvbmctY29udGFpbmVyPlxcblxcbiAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFNlbGVjdGlvblRlbXBsYXRlPnt7IHNlbGVjdGlvblZpZXcgfX08L25nLXRlbXBsYXRlPlxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG5cXG4gICAgPG5nLXRlbXBsYXRlICNwbGFjZWhvbGRlclRlbXBsYXRlPnt7IHBsYWNlaG9sZGVyIH19PC9uZy10ZW1wbGF0ZT5cXG5cXG4gICAgPG5iLWljb24gaWNvbj1cXFwiY2hldnJvbi1kb3duLW91dGxpbmVcXFwiIHBhY2s9XFxcIm5lYnVsYXItZXNzZW50aWFsc1xcXCIgKGNsaWNrKT1cXFwiZGlzYWJsZWQgJiYgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICAgIDwvbmItaWNvbj5cXG48L2J1dHRvbj5cXG5cXG48bmItb3B0aW9uLWxpc3QgKm5iUG9ydGFsIFtzaXplXT1cXFwic2l6ZVxcXCIgW3Bvc2l0aW9uXT1cXFwib3ZlcmxheVBvc2l0aW9uXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJob3N0V2lkdGhcXFwiIFtuZ0NsYXNzXT1cXFwib3B0aW9uc0xpc3RDbGFzc1xcXCI+XFxuICA8bmctY29udGVudCBzZWxlY3Q9XFxcIm5iLW9wdGlvbiwgbmItb3B0aW9uLWdyb3VwXFxcIj48L25nLWNvbnRlbnQ+XFxuPC9uYi1vcHRpb24tbGlzdD5cXG5cIixcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYlNlbGVjdENvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOLCB1c2VFeGlzdGluZzogTmJTZWxlY3RDb21wb25lbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkZvcm1GaWVsZENvbnRyb2wsIHVzZUV4aXN0aW5nOiBOYlNlbGVjdENvbXBvbmVudCB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5iRm9ybUZpZWxkQ29udHJvbENvbmZpZywgdXNlRmFjdG9yeTogbmJTZWxlY3RGb3JtRmllbGRDb250cm9sQ29uZmlnRmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCIvKiFcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxcbiAqLzpob3N0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO21heC13aWR0aDoxMDAlfVtkaXI9bHRyXSA6aG9zdCAuc2VsZWN0LWJ1dHRvbnt0ZXh0LWFsaWduOmxlZnR9W2Rpcj1sdHJdIDpob3N0IC5zZWxlY3QtYnV0dG9uIG5iLWljb257cmlnaHQ6MC4yZW19W2Rpcj1ydGxdIDpob3N0IC5zZWxlY3QtYnV0dG9ue3RleHQtYWxpZ246cmlnaHR9W2Rpcj1ydGxdIDpob3N0IC5zZWxlY3QtYnV0dG9uIG5iLWljb257bGVmdDowLjJlbX06aG9zdCguZnVsbC13aWR0aCl7d2lkdGg6MTAwJX06aG9zdCgubmItdHJhbnNpdGlvbikgLnNlbGVjdC1idXR0b257dHJhbnNpdGlvbi1kdXJhdGlvbjowLjE1czt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsYm9yZGVyLWNvbG9yLGJvcmRlci1yYWRpdXMsYm94LXNoYWRvdyxjb2xvcjt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWlufS5zZWxlY3QtYnV0dG9ue3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7dGV4dC10cmFuc2Zvcm06bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXB9bmItaWNvbntmb250LXNpemU6MS41ZW07cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW59W2Rpcj1sdHJdIG5iLWljb257cmlnaHQ6LjVyZW19W2Rpcj1ydGxdIG5iLWljb257bGVmdDouNXJlbX06aG9zdCgub3BlbikgbmItaWNvbnt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoMTgwZGVnKX1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJTZWxlY3RDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iT3ZlcmxheVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5iRm9jdXNLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iRm9jdXNNb25pdG9yIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlNlbGVjdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBzaXplOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNoYXBlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhcHBlYXJhbmNlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcHRpb25zTGlzdENsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcHRpb25zUGFuZWxDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3V0bGluZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hcHBlYXJhbmNlLW91dGxpbmUnLF0gfV0sXG4gICAgZmlsbGVkOiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFwcGVhcmFuY2UtZmlsbGVkJyxdIH1dLFxuICAgIGhlcm86IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuYXBwZWFyYW5jZS1oZXJvJyxdIH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmdWxsV2lkdGg6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuZnVsbC13aWR0aCcsXSB9XSxcbiAgICBwbGFjZWhvbGRlcjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY29tcGFyZVdpdGg6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNlbGVjdGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBtdWx0aXBsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgb3B0aW9uc092ZXJsYXlPZmZzZXQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNjcm9sbFN0cmF0ZWd5OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBhZGRpdGlvbmFsQ2xhc3NlczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MnLF0gfV0sXG4gICAgc2VsZWN0ZWRDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBvcHRpb25zOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYk9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgY3VzdG9tTGFiZWw6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW05iU2VsZWN0TGFiZWxDb21wb25lbnQsXSB9XSxcbiAgICBwb3J0YWw6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iUG9ydGFsRGlyZWN0aXZlLF0gfV0sXG4gICAgYnV0dG9uOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsnc2VsZWN0QnV0dG9uJywgeyByZWFkOiBFbGVtZW50UmVmIH0sXSB9XSxcbiAgICBpc09wZW46IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm9wZW4nLF0gfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgcHJpbWFyeTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXByaW1hcnknLF0gfV0sXG4gICAgaW5mbzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWluZm8nLF0gfV0sXG4gICAgc3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgd2FybmluZzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXdhcm5pbmcnLF0gfV0sXG4gICAgZGFuZ2VyOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtZGFuZ2VyJyxdIH1dLFxuICAgIGJhc2ljOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtYmFzaWMnLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgcmVjdGFuZ2xlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaGFwZS1yZWN0YW5nbGUnLF0gfV0sXG4gICAgcm91bmQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNoYXBlLXJvdW5kJyxdIH1dLFxuICAgIHNlbWlSb3VuZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2hhcGUtc2VtaS1yb3VuZCcsXSB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIE5iT3B0aW9uR3JvdXBDb21wb25lbnRcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogb3B0aW9uLWdyb3VwLXRleHQtY29sb3I6XG4gKiBvcHRpb24tZ3JvdXAtdGlueS1zdGFydC1wYWRkaW5nOlxuICogb3B0aW9uLWdyb3VwLXNtYWxsLXN0YXJ0LXBhZGRpbmc6XG4gKiBvcHRpb24tZ3JvdXAtbWVkaXVtLXN0YXJ0LXBhZGRpbmc6XG4gKiBvcHRpb24tZ3JvdXAtbGFyZ2Utc3RhcnQtcGFkZGluZzpcbiAqIG9wdGlvbi1ncm91cC1naWFudC1zdGFydC1wYWRkaW5nOlxuICoqL1xuY2xhc3MgTmJPcHRpb25Hcm91cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnJyA6IG51bGw7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNVcGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuYXN5bmNVcGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgZGlzYWJsZWQgc3RhdGUgZm9yIGVhY2ggb3B0aW9uIHRvIGN1cnJlbnQgZ3JvdXAgZGlzYWJsZWQgc3RhdGUuXG4gICAgICovXG4gICAgdXBkYXRlT3B0aW9uc0Rpc2FibGVkU3RhdGUoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IG9wdGlvbi5zZXREaXNhYmxlZEJ5R3JvdXBTdGF0ZSh0aGlzLmRpc2FibGVkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgb3B0aW9ucyBkaXNhYmxlZCBzdGF0ZSBhZnRlciBwcm9taXNlIHJlc29sdXRpb24uXG4gICAgICogVGhpcyB3YXkgY2hhbmdlIGRldGVjdGlvbiB3aWxsIGJlIHRyaWdnZXJlZCBhZnRlciBvcHRpb25zIHN0YXRlIHVwZGF0ZWQuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gdXBkYXRpbmcgb3B0aW9ucyBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbiBydW4gKGUuZy4gUXVlcnlMaXN0LmNoYW5nZXMsIGxpZmVjeWNsZSBob29rcykuXG4gICAgICovXG4gICAgYXN5bmNVcGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICAgICAgLy8gV3JhcCBQcm9taXNlIGludG8gT2JzZXJ2YWJsZSB3aXRoIGB0YWtlVW50aWwodGhpcy5kZXN0cm95JClgIHRvIHByZXZlbnQgdXBkYXRlIGlmIGNvbXBvbmVudCBkZXN0cm95ZWQuXG4gICAgICAgIGZyb20oUHJvbWlzZS5yZXNvbHZlKCkpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlT3B0aW9uc0Rpc2FibGVkU3RhdGUoKSk7XG4gICAgfVxufVxuTmJPcHRpb25Hcm91cENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItb3B0aW9uLWdyb3VwJyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwib3B0aW9uLWdyb3VwLXRpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItb3B0aW9uLCBuZy1jb250YWluZXJcIj48L25nLWNvbnRlbnQ+XG4gIGAsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrfS5vcHRpb24tZ3JvdXAtdGl0bGV7ZGlzcGxheTpibG9ja31cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJPcHRpb25Hcm91cENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0aXRsZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkQXR0cmlidXRlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmRpc2FibGVkJyxdIH1dLFxuICAgIG9wdGlvbnM6IFt7IHR5cGU6IENvbnRlbnRDaGlsZHJlbiwgYXJnczogW05iT3B0aW9uQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0sXSB9XVxufTtcblxuLyoqXG4gKiBUaGUgYE5iT3B0aW9uTGlzdENvbXBvbmVudGAgaXMgY29udGFpbmVyIGNvbXBvbmVudCBmb3IgYE5iT3B0aW9uR3JvdXBDb21wb25lbnRgIGFuZGBOYk9wdGlvbkNvbXBvbmVudGAgbGlzdC5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogb3B0aW9uLWxpc3QtbWF4LWhlaWdodDpcbiAqIG9wdGlvbi1saXN0LXNoYWRvdzpcbiAqIG9wdGlvbi1saXN0LWJhY2tncm91bmQtY29sb3I6XG4gKiBvcHRpb24tbGlzdC1ib3JkZXItc3R5bGU6XG4gKiBvcHRpb24tbGlzdC1ib3JkZXItd2lkdGg6XG4gKiBvcHRpb24tbGlzdC1ib3JkZXItY29sb3I6XG4gKiBvcHRpb24tbGlzdC1ib3JkZXItcmFkaXVzOlxuICogb3B0aW9uLWxpc3QtYWRqYWNlbnQtYm9yZGVyLWNvbG9yOlxuICogb3B0aW9uLWxpc3QtYWRqYWNlbnQtYm9yZGVyLXN0eWxlOlxuICogb3B0aW9uLWxpc3QtYWRqYWNlbnQtYm9yZGVyLXdpZHRoOlxuICogKi9cbmNsYXNzIE5iT3B0aW9uTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgcG9zaXRpb25Ub3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLlRPUDtcbiAgICB9XG4gICAgZ2V0IHBvc2l0aW9uQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5CT1RUT007XG4gICAgfVxuICAgIGdldCBzaXplVGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc2l6ZVNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgc2l6ZU1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBzaXplTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBzaXplR2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxufVxuTmJPcHRpb25MaXN0Q29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1vcHRpb24tbGlzdCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8dWwgY2xhc3M9XCJvcHRpb24tbGlzdFwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvdWw+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJPcHRpb25MaXN0Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHBvc2l0aW9uOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwb3NpdGlvblRvcDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MucG9zaXRpb24tdG9wJyxdIH1dLFxuICAgIHBvc2l0aW9uQm90dG9tOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5wb3NpdGlvbi1ib3R0b20nLF0gfV0sXG4gICAgc2l6ZVRpbnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtdGlueScsXSB9XSxcbiAgICBzaXplU21hbGw6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtc21hbGwnLF0gfV0sXG4gICAgc2l6ZU1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgc2l6ZUxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dLFxuICAgIHNpemVHaWFudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1naWFudCcsXSB9XVxufTtcblxuY29uc3QgTkJfT1BUSU9OX0xJU1RfQ09NUE9ORU5UUyA9IFtcbiAgICBOYk9wdGlvbkxpc3RDb21wb25lbnQsXG4gICAgTmJPcHRpb25Db21wb25lbnQsXG4gICAgTmJPcHRpb25Hcm91cENvbXBvbmVudCxcbl07XG5jbGFzcyBOYk9wdGlvbk1vZHVsZSB7XG59XG5OYk9wdGlvbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX09QVElPTl9MSVNUX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJDaGVja2JveE1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfT1BUSU9OX0xJU1RfQ09NUE9ORU5UUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbmNvbnN0IE5CX1NFTEVDVF9DT01QT05FTlRTID0gW1xuICAgIE5iU2VsZWN0Q29tcG9uZW50LFxuICAgIE5iU2VsZWN0TGFiZWxDb21wb25lbnQsXG5dO1xuY2xhc3MgTmJTZWxlY3RNb2R1bGUge1xufVxuTmJTZWxlY3RNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJCdXR0b25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSW5wdXRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FyZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYk9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgLi4uTkJfU0VMRUNUX0NPTVBPTkVOVFMsXG4gICAgICAgICAgICAgICAgICAgIE5iT3B0aW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbLi4uTkJfU0VMRUNUX0NPTVBPTkVOVFNdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8vIENvbXBvbmVudCBjbGFzcyBzY29wZWQgY291bnRlciBmb3IgYXJpYSBhdHRyaWJ1dGVzLlxubGV0IGxhc3RBdXRvY29tcGxldGVJZCA9IDA7XG4vKipcbiAqIFRoZSBgTmJBdXRvY29tcGxldGVDb21wb25lbnRgIG92ZXJsYXkgY29tcG9uZW50LlxuICogUHJvdmlkZXMgYW4gYE5iT3B0aW9uTGlzdGAgb3ZlcmxheSBjb21wb25lbnQuXG4gKiAqL1xuY2xhc3MgTmJBdXRvY29tcGxldGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnQgc2NvcGVkIGlkIGZvciBhcmlhIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuaWQgPSBgbmItYXV0b2NvbXBsZXRlLSR7bGFzdEF1dG9jb21wbGV0ZUlkKyt9YDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgICAgICogQ3VycmVudCBvdmVybGF5IHBvc2l0aW9uIGJlY2F1c2Ugb2Ygd2UgaGF2ZSB0byB0b2dnbGUgb3ZlcmxheVBvc2l0aW9uXG4gICAgICAgICAqIGluIFtuZ0NsYXNzXSBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vdmVybGF5UG9zaXRpb24gPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF1dG9jb21wbGV0ZSBzaXplLCBhdmFpbGFibGUgc2l6ZXM6XG4gICAgICAgICAqIGB0aW55YCwgYHNtYWxsYCwgYG1lZGl1bWAgKGRlZmF1bHQpLCBgbGFyZ2VgLCBgZ2lhbnRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgcGFzc2VkIGFzIGlucHV0IHRvIGFsd2F5cyBtYWtlIGZpcnN0IG9wdGlvbiBhY3RpdmUuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYWN0aXZlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgYmUgZW1pdHRlZCB3aGVuIHNlbGVjdGVkIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBvdmVybGF5UG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UG9zaXRpb247XG4gICAgfVxuICAgIHNldCBvdmVybGF5UG9zaXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgIC8vIE5lZWQgcnVuIGNoYW5nZSBkZXRlY3Rpb24gYWZ0ZXIgZmlyc3Qgc2V0IGZyb20gTmJBdXRvY29tcGxldGVEaXJlY3RpdmVcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgdGhlIGlucHV0LlxuICAgICAqICovXG4gICAgZ2V0IGhvc3RXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9jb21wbGV0ZSBrbm93cyBub3RoaW5nIGFib3V0IGhvc3QgaHRtbCBpbnB1dCBlbGVtZW50LlxuICAgICAqIFNvLCBhdHRhY2ggbWV0aG9kIHNldCBpbnB1dCBob3N0UmVmIGZvciBzdHlsaW5nLlxuICAgICAqICovXG4gICAgc2V0SG9zdChob3N0UmVmKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3BhZ2F0ZSBzZWxlY3RlZCB2YWx1ZS5cbiAgICAgKiAqL1xuICAgIGVtaXRTZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWQpO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG59XG5OYkF1dG9jb21wbGV0ZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItYXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmItb3B0aW9uLWxpc3QgKm5iUG9ydGFsXFxuICAgICAgICAgICAgICAgIFtzaXplXT1cXFwic2l6ZVxcXCJcXG4gICAgICAgICAgICAgICAgW3Bvc2l0aW9uXT1cXFwib3ZlcmxheVBvc2l0aW9uXFxcIlxcbiAgICAgICAgICAgICAgICBbc3R5bGUud2lkdGgucHhdPVxcXCJob3N0V2lkdGhcXFwiXFxuICAgICAgICAgICAgICAgIHJvbGU9XFxcImxpc3Rib3hcXFwiXFxuICAgICAgICAgICAgICAgIFtpZF09XFxcImlkXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MuZW1wdHldPVxcXCIhb3B0aW9ucz8ubGVuZ3RoXFxcIlxcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XFxcIm9wdGlvbnNMaXN0Q2xhc3NcXFwiPlxcbiAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJuYi1vcHRpb24sIG5iLW9wdGlvbi1ncm91cFxcXCI+PC9uZy1jb250ZW50PlxcbjwvbmItb3B0aW9uLWxpc3Q+XFxuXCIsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCg6aG92ZXIpe2N1cnNvcjpwb2ludGVyfW5iLW9wdGlvbi1saXN0LmVtcHR5e2JvcmRlcjpub25lfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkF1dG9jb21wbGV0ZUNvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5OYkF1dG9jb21wbGV0ZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBoYW5kbGVEaXNwbGF5Rm46IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFjdGl2ZUZpcnN0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcHRpb25zTGlzdENsYXNzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBvcHRpb25zUGFuZWxDbGFzczogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2VsZWN0ZWRDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBvcHRpb25zOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYk9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgcG9ydGFsOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFtOYlBvcnRhbERpcmVjdGl2ZSxdIH1dLFxuICAgIHRpbnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtdGlueScsXSB9XSxcbiAgICBzbWFsbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1zbWFsbCcsXSB9XSxcbiAgICBtZWRpdW06IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbWVkaXVtJyxdIH1dLFxuICAgIGxhcmdlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWxhcmdlJyxdIH1dLFxuICAgIGdpYW50OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLWdpYW50JyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJBdXRvY29tcGxldGVEaXJlY3RpdmVgIHByb3ZpZGVzIGEgY2FwYWJpbGl0eSB0byBleHBhbmQgaW5wdXQgd2l0aFxuICogYE5iQXV0b2NvbXBsZXRlQ29tcG9uZW50YCBvdmVybGF5IGNvbnRhaW5pbmcgb3B0aW9ucyB0byBzZWxlY3QgYW5kIGZpbGwgaW5wdXQgd2l0aC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBhdXRvY29tcGxldGUvYXV0b2NvbXBsZXRlLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkF1dG9jb21wbGV0ZU1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJBdXRvY29tcGxldGVNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFlvdSBjYW4gYmluZCBjb250cm9sIHdpdGggZm9ybSBjb250cm9scyBvciBuZ01vZGVsLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQXV0b2NvbXBsZXRlIGZvcm0gYmluZGluZywgYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS1mb3JtLmNvbXBvbmVudClcbiAqXG4gKiBPcHRpb25zIGluIHRoZSBhdXRvY29tcGxldGUgbWF5IGJlIGdyb3VwZWQgdXNpbmcgYG5iLW9wdGlvbi1ncm91cGAgY29tcG9uZW50LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoR3JvdXBpbmcsIGF1dG9jb21wbGV0ZS9hdXRvY29tcGxldGUtZ3JvdXAuY29tcG9uZW50KVxuICpcbiAqIEF1dG9jb21wbGV0ZSBtYXkgY2hhbmdlIHNlbGVjdGVkIG9wdGlvbiB2YWx1ZSB2aWEgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gZGlzcGxheSwgYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS1jdXN0b20tZGlzcGxheS5jb21wb25lbnQpXG4gKlxuICogQWxzbywgYXV0b2NvbXBsZXRlIG1heSBtYWtlIGZpcnN0IG9wdGlvbiBpbiBvcHRpb24gbGlzdCBhY3RpdmUgYXV0b21hdGljYWxseS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEFjdGl2ZSBmaXJzdCwgYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS1hY3RpdmUtZmlyc3QuY29tcG9uZW50KVxuICpcbiAqICovXG5jbGFzcyBOYkF1dG9jb21wbGV0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZiwgb3ZlcmxheSwgY2QsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXIsIHBvc2l0aW9uQnVpbGRlciwgYWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5LCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmhvc3RSZWYgPSBob3N0UmVmO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlciA9IHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLmFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyRmFjdG9yeSA9IGFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgb3B0aW9ucyBvdmVybGF5IG9mZnNldCAoaW4gcGl4ZWxzKS5cbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLm92ZXJsYXlPZmZzZXQgPSA4O1xuICAgICAgICB0aGlzLl9mb2N1c0lucHV0T25WYWx1ZUNoYW5nZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIG9wdGlvbnMgb3ZlcmxheSBzY3JvbGwgc3RyYXRlZ3kuXG4gICAgICAgICAqKi9cbiAgICAgICAgdGhpcy5zY3JvbGxTdHJhdGVneSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMucm9sZSA9ICdjb21ib2JveCc7XG4gICAgICAgIHRoaXMuYXJpYUF1dG9jb21wbGV0ZSA9ICdsaXN0JztcbiAgICAgICAgdGhpcy5oYXNQb3B1cCA9ICd0cnVlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpcyBhdXRvY29tcGxldGUgb3ZlcmxheSBvcGVuZWQuXG4gICAgICogKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmICYmIHRoaXMub3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlzIGF1dG9jb21wbGV0ZSBvdmVybGF5IGNsb3NlZC5cbiAgICAgKiAqL1xuICAgIGdldCBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYXV0b2NvbXBsZXRlIGNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIGdldCBhdXRvY29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvY29tcGxldGU7XG4gICAgfVxuICAgIHNldCBhdXRvY29tcGxldGUoYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2F1dG9jb21wbGV0ZSA9IGF1dG9jb21wbGV0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgd2lsbCBiZSBmb2N1c2VkIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgaXMgY2hhbmdlZFxuICAgICAqICovXG4gICAgZ2V0IGZvY3VzSW5wdXRPblZhbHVlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNJbnB1dE9uVmFsdWVDaGFuZ2U7XG4gICAgfVxuICAgIHNldCBmb2N1c0lucHV0T25WYWx1ZUNoYW5nZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mb2N1c0lucHV0T25WYWx1ZUNoYW5nZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT3BlbiAmJiB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLmxlbmd0aCAmJiB0aGlzLmF1dG9jb21wbGV0ZS5vdmVybGF5UG9zaXRpb24gPT09IE5iUG9zaXRpb24uVE9QO1xuICAgIH1cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09wZW4gJiYgdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5sZW5ndGggJiYgdGhpcy5hdXRvY29tcGxldGUub3ZlcmxheVBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkJPVFRPTTtcbiAgICB9XG4gICAgZ2V0IGFyaWFFeHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuICYmIHRoaXMuaXNPcGVuLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCBhcmlhT3ducygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcGVuID8gdGhpcy5hdXRvY29tcGxldGUuaWQgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgYXJpYUFjdGl2ZURlc2NlbmRhbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc09wZW4gJiYgdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pID8gdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0uaWQgOiBudWxsO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVUcmlnZ2VyU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblRyaWdnZXJzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXQoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgICB0aGlzLl9vbkNoYW5nZShjdXJyZW50VmFsdWUpO1xuICAgICAgICB0aGlzLnNldEhvc3RJbnB1dFZhbHVlKHRoaXMuZ2V0RGlzcGxheVZhbHVlKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgaGFuZGxlS2V5ZG93bigpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIGhhbmRsZUJsdXIoKSB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCgpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hUb092ZXJsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gTmVlZCB0byB1cGRhdGUgY2xhc3MgdmlhIEBIb3N0QmluZGluZ1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXRWYWx1ZVVwZGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkID0gZm47XG4gICAgfVxuICAgIHNldERpc2FibGVkU3RhdGUoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPbk9wdGlvbkNsaWNrKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHVzZXIgY2hhbmdlcyBwcm92aWRlZCBvcHRpb25zIGxpc3QgaW4gdGhlIHJ1bnRpbWUgd2UgaGF2ZSB0byBoYW5kbGUgdGhpc1xuICAgICAgICAgKiBhbmQgcmVzdWJzY3JpYmUgb24gb3B0aW9ucyBzZWxlY3Rpb24gY2hhbmdlcyBldmVudC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlbGVjdCBuZXcgb3B0aW9ucy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0YXAoKCkgPT4gdGhpcy5zZXRBY3RpdmVJdGVtKCkpLCBzdGFydFdpdGgodGhpcy5hdXRvY29tcGxldGUub3B0aW9ucyksIHN3aXRjaE1hcCgob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlKC4uLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uY2xpY2spKTtcbiAgICAgICAgfSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGNsaWNrZWRPcHRpb24pID0+IHRoaXMuaGFuZGxlSW5wdXRWYWx1ZVVwZGF0ZShjbGlja2VkT3B0aW9uLnZhbHVlKSk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneS5wb3NpdGlvbkNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLm92ZXJsYXlQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBY3RpdmVJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW07XG4gICAgfVxuICAgIHNldHVwQXV0b2NvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRIb3N0KHRoaXMuY3VzdG9tT3ZlcmxheUhvc3QgfHwgdGhpcy5ob3N0UmVmKTtcbiAgICB9XG4gICAgZ2V0RGlzcGxheVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlGbiA9IHRoaXMuYXV0b2NvbXBsZXRlLmhhbmRsZURpc3BsYXlGbjtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlGbiA/IGRpc3BsYXlGbih2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmICYmIHRoaXMuaXNPcGVuICYmIHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudDogdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFuZGxlSW5wdXRWYWx1ZVVwZGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SG9zdElucHV0VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzSW5wdXRPblZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLmVtaXRTZWxlY3RlZCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblRyaWdnZXJzKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5zaG93JFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuaXNDbG9zZWQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNob3coKSk7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LmhpZGUkXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5pc09wZW4pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhpZGUoKSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlclxuICAgICAgICAgICAgLnRyaWdnZXIoTmJUcmlnZ2VyLkZPQ1VTKVxuICAgICAgICAgICAgLmhvc3QodGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICAuY29udGFpbmVyKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyKCkpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICB9XG4gICAgY3JlYXRlS2V5TWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5rZXlNYW5hZ2VyID0gdGhpcy5hY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlckZhY3RvcnlcbiAgICAgICAgICAgIC5jcmVhdGUodGhpcy5hdXRvY29tcGxldGUub3B0aW9ucyk7XG4gICAgfVxuICAgIHNldEhvc3RJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5nZXREaXNwbGF5VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbkJ1aWxkZXJcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLmN1c3RvbU92ZXJsYXlIb3N0IHx8IHRoaXMuaG9zdFJlZilcbiAgICAgICAgICAgIC5wb3NpdGlvbihOYlBvc2l0aW9uLkJPVFRPTSlcbiAgICAgICAgICAgIC5vZmZzZXQodGhpcy5vdmVybGF5T2Zmc2V0KVxuICAgICAgICAgICAgLmFkanVzdG1lbnQoTmJBZGp1c3RtZW50LlZFUlRJQ0FMKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25PdmVybGF5S2V5cygpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmLmtleWRvd25FdmVudHMoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEUgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBFTlRFUikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IHRoaXMuZ2V0QWN0aXZlSXRlbSgpO1xuICAgICAgICAgICAgICAgIGlmICghYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5wdXRWYWx1ZVVwZGF0ZShhY3RpdmVJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0QWN0aXZlSXRlbSgpIHtcbiAgICAgICAgLy8gSWYgYXV0b2NvbXBsZXRlIGhhcyBhY3RpdmVGaXJzdCBpbnB1dCBzZXQgdG8gdHJ1ZSxcbiAgICAgICAgLy8ga2V5TWFuYWdlciBzZXQgZmlyc3Qgb3B0aW9uIGFjdGl2ZSwgb3RoZXJ3aXNlIC0gcmVzZXQgYWN0aXZlIG9wdGlvbi5cbiAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMuYXV0b2NvbXBsZXRlLmFjdGl2ZUZpcnN0XG4gICAgICAgICAgICA/IE5iS2V5TWFuYWdlckFjdGl2ZUl0ZW1Nb2RlLkZJUlNUX0FDVElWRVxuICAgICAgICAgICAgOiBOYktleU1hbmFnZXJBY3RpdmVJdGVtTW9kZS5SRVNFVF9BQ1RJVkU7XG4gICAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKG1vZGUpO1xuICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgYXR0YWNoVG9PdmVybGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMub3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5zZXR1cEF1dG9jb21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0T3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheVJlZi5hdHRhY2godGhpcy5hdXRvY29tcGxldGUucG9ydGFsKTtcbiAgICB9XG4gICAgY3JlYXRlT3ZlcmxheSgpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVNjcm9sbFN0cmF0ZWd5KCk7XG4gICAgICAgIHRoaXMub3ZlcmxheVJlZiA9IHRoaXMub3ZlcmxheS5jcmVhdGUoeyBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLnBvc2l0aW9uU3RyYXRlZ3ksIHNjcm9sbFN0cmF0ZWd5LCBwYW5lbENsYXNzOiB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zUGFuZWxDbGFzcyB9KTtcbiAgICB9XG4gICAgaW5pdE92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUtleU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblBvc2l0aW9uQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25PcHRpb25DbGljaygpO1xuICAgICAgICB0aGlzLmNoZWNrT3ZlcmxheVZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25PdmVybGF5S2V5cygpO1xuICAgIH1cbiAgICBjaGVja092ZXJsYXlWaXNpYmlsaXR5KCkge1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5vcHRpb25zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdXRvY29tcGxldGUub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjcm9sbFN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXNbdGhpcy5zY3JvbGxTdHJhdGVneV0oKTtcbiAgICB9XG59XG5OYkF1dG9jb21wbGV0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbbmJBdXRvY29tcGxldGVdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iQXV0b2NvbXBsZXRlRGlyZWN0aXZlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJBdXRvY29tcGxldGVEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOYk92ZXJsYXlTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuTmJBdXRvY29tcGxldGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgYXV0b2NvbXBsZXRlOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkF1dG9jb21wbGV0ZScsXSB9XSxcbiAgICBvdmVybGF5T2Zmc2V0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBmb2N1c0lucHV0T25WYWx1ZUNoYW5nZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2Nyb2xsU3RyYXRlZ3k6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGN1c3RvbU92ZXJsYXlIb3N0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0b3A6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLWF1dG9jb21wbGV0ZS1wb3NpdGlvbi10b3AnLF0gfV0sXG4gICAgYm90dG9tOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5uYi1hdXRvY29tcGxldGUtcG9zaXRpb24tYm90dG9tJyxdIH1dLFxuICAgIHJvbGU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIucm9sZScsXSB9XSxcbiAgICBhcmlhQXV0b2NvbXBsZXRlOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtYXV0b2NvbXBsZXRlJyxdIH1dLFxuICAgIGhhc1BvcHVwOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmhhc3BvcHVwJyxdIH1dLFxuICAgIGFyaWFFeHBhbmRlZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWV4cGFuZGVkJyxdIH1dLFxuICAgIGFyaWFPd25zOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLmFyaWEtb3ducycsXSB9XSxcbiAgICBhcmlhQWN0aXZlRGVzY2VuZGFudDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLF0gfV0sXG4gICAgaGFuZGxlSW5wdXQ6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydpbnB1dCcsXSB9XSxcbiAgICBoYW5kbGVLZXlkb3duOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bi5hcnJvd0Rvd24nLF0gfSwgeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bi5hcnJvd1VwJyxdIH1dLFxuICAgIGhhbmRsZUJsdXI6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydibHVyJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9BVVRPQ09NUExFVEVfQ09NUE9ORU5UUyA9IFtcbiAgICBOYkF1dG9jb21wbGV0ZUNvbXBvbmVudCxcbiAgICBOYkF1dG9jb21wbGV0ZURpcmVjdGl2ZSxcbl07XG5jbGFzcyBOYkF1dG9jb21wbGV0ZU1vZHVsZSB7XG59XG5OYkF1dG9jb21wbGV0ZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYk92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FyZE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJPcHRpb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX0FVVE9DT01QTEVURV9DT01QT05FTlRTLFxuICAgICAgICAgICAgICAgICAgICBOYk9wdGlvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWy4uLk5CX0FVVE9DT01QTEVURV9DT01QT05FTlRTXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG52YXIgTmJXaW5kb3dTdGF0ZTtcbihmdW5jdGlvbiAoTmJXaW5kb3dTdGF0ZSkge1xuICAgIE5iV2luZG93U3RhdGVbXCJNSU5JTUlaRURcIl0gPSBcIm1pbmltaXplZFwiO1xuICAgIE5iV2luZG93U3RhdGVbXCJNQVhJTUlaRURcIl0gPSBcIm1heGltaXplZFwiO1xuICAgIE5iV2luZG93U3RhdGVbXCJGVUxMX1NDUkVFTlwiXSA9IFwiZnVsbC1zY3JlZW5cIjtcbn0pKE5iV2luZG93U3RhdGUgfHwgKE5iV2luZG93U3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBXaW5kb3cgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICovXG5jbGFzcyBOYldpbmRvd0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoLi4uY29uZmlncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2luZG93IHRpdGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbCB3aW5kb3cgc3RhdGUuIEZ1bGwgc2NyZWVuIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IE5iV2luZG93U3RhdGUuRlVMTF9TQ1JFRU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIHRoYW4gYmFja2Ryb3Agd2lsbCBiZSByZW5kZXJlZCBiZWhpbmQgd2luZG93LlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHNldCB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNCYWNrZHJvcCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSBtb3VzZSBjbGlja3Mgb24gYmFja2Ryb3Agd2lsbCBjbG9zZSBhIHdpbmRvdy5cbiAgICAgICAgICogRGVmYXVsdCBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZU9uQmFja2Ryb3BDbGljayA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIHRoZW4gZXNjYXBlIHByZXNzIHdpbGwgY2xvc2UgYSB3aW5kb3cuXG4gICAgICAgICAqIERlZmF1bHQgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VPbkVzYyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSB3aW5kb3cuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpbmRvd0NsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb3RoLCB0ZW1wbGF0ZSBhbmQgY29tcG9uZW50IG1heSByZWNlaXZlIGRhdGEgdGhyb3VnaCBgY29uZmlnLmNvbnRleHRgIHByb3BlcnR5LlxuICAgICAgICAgKiBGb3IgY29tcG9uZW50cywgdGhpcyBkYXRhIHdpbGwgYmUgc2V0IGFzIGNvbXBvbmVudCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBGb3IgdGVtcGxhdGVzLCB5b3UgY2FuIGFjY2VzcyBpdCBpbnNpZGUgdGVtcGxhdGUgYXMgJGltcGxpY2l0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVyZSB0aGUgYXR0YWNoZWQgY29tcG9uZW50IHNob3VsZCBsaXZlIGluIEFuZ3VsYXIncyAqbG9naWNhbCogY29tcG9uZW50IHRyZWUuXG4gICAgICAgICAqIFRoaXMgYWZmZWN0cyB3aGF0IGlzIGF2YWlsYWJsZSBmb3IgaW5qZWN0aW9uIGFuZCB0aGUgY2hhbmdlIGRldGVjdGlvbiBvcmRlciBmb3IgdGhlXG4gICAgICAgICAqIGNvbXBvbmVudCBpbnN0YW50aWF0ZWQgaW5zaWRlIG9mIHRoZSB3aW5kb3cuIFRoaXMgZG9lcyBub3QgYWZmZWN0IHdoZXJlIHRoZSB3aW5kb3dcbiAgICAgICAgICogY29udGVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCAuLi5jb25maWdzKTtcbiAgICB9XG59XG5jb25zdCBOQl9XSU5ET1dfQ09OVEVOVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmVidWxhciBXaW5kb3cgQ29udGVudCcpO1xuY29uc3QgTkJfV0lORE9XX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmVidWxhciBXaW5kb3cgQ29uZmlnJyk7XG5jb25zdCBOQl9XSU5ET1dfQ09OVEVYVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmVidWxhciBXaW5kb3cgQ29udGV4dCcpO1xuXG4vKipcbiAqIFRoZSBgTmJXaW5kb3dSZWZgIGhlbHBzIHRvIG1hbmlwdWxhdGUgd2luZG93IGFmdGVyIGl0IHdhcyBjcmVhdGVkLlxuICogVGhlIHdpbmRvdyBjYW4gYmUgZGlzbWlzc2VkIGJ5IHVzaW5nIGBjbG9zZWAgbWV0aG9kIG9mIHRoZSB3aW5kb3dSZWYuXG4gKiBZb3UgY2FuIGFjY2VzcyByZW5kZXJlZCBjb21wb25lbnQgYXMgYGNvbXBvbmVudFJlZmAgcHJvcGVydHkgb2YgdGhlIHdpbmRvd1JlZi5cbiAqL1xuY2xhc3MgTmJXaW5kb3dSZWYge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZSQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBjb25maWcuaW5pdGlhbFN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHdpbmRvdyBzdGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlVmFsdWU7XG4gICAgfVxuICAgIHNldCBzdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAobmV3U3RhdGUgJiYgdGhpcy5zdGF0ZVZhbHVlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2U3RhdGVWYWx1ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVmFsdWUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UkLm5leHQoeyBvbGRTdGF0ZTogdGhpcy5wcmV2U3RhdGVWYWx1ZSwgbmV3U3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB3aW5kb3cgc3RhdGUgY2hhbmdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2UkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHdpbmRvdyB3YXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWQkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaW5pbWl6ZSB3aW5kb3cuXG4gICAgICovXG4gICAgbWluaW1pemUoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBOYldpbmRvd1N0YXRlLk1JTklNSVpFRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF4aW1pemUgd2luZG93LlxuICAgICAqL1xuICAgIG1heGltaXplKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gTmJXaW5kb3dTdGF0ZS5NQVhJTUlaRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB3aW5kb3cgb24gdG9wLlxuICAgICAqL1xuICAgIGZ1bGxTY3JlZW4oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBOYldpbmRvd1N0YXRlLkZVTExfU0NSRUVOO1xuICAgIH1cbiAgICB0b1ByZXZpb3VzU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByZXZTdGF0ZVZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgd2luZG93LlxuICAgICAqICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2UkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuY2xvc2VkJC5uZXh0KCk7XG4gICAgICAgIHRoaXMuY2xvc2VkJC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuY2xhc3MgTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50IHtcbn1cbk5iV2luZG93c0NvbnRhaW5lckNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItd2luZG93cy1jb250YWluZXInLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAjdmlld0NvbnRhaW5lclJlZj48L25nLWNvbnRhaW5lcj5gLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmZsZXgtZW5kO292ZXJmbG93LXg6YXV0b306aG9zdCA6Om5nLWRlZXAgbmItd2luZG93Om5vdCguZnVsbC1zY3JlZW4pe21hcmdpbjowIDJyZW19XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iV2luZG93c0NvbnRhaW5lckNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB2aWV3Q29udGFpbmVyUmVmOiBbeyB0eXBlOiBWaWV3Q2hpbGQsIGFyZ3M6IFsndmlld0NvbnRhaW5lclJlZicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0sXSB9XVxufTtcblxuY2xhc3MgTmJXaW5kb3dDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIGNvbnRleHQsIHdpbmRvd1JlZiwgY29uZmlnLCBmb2N1c1RyYXBGYWN0b3J5LCBlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLndpbmRvd1JlZiA9IHdpbmRvd1JlZjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwRmFjdG9yeSA9IGZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9XG4gICAgZ2V0IGlzRnVsbFNjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93UmVmLnN0YXRlID09PSBOYldpbmRvd1N0YXRlLkZVTExfU0NSRUVOO1xuICAgIH1cbiAgICBnZXQgbWF4aW1pemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dSZWYuc3RhdGUgPT09IE5iV2luZG93U3RhdGUuTUFYSU1JWkVEO1xuICAgIH1cbiAgICBnZXQgbWluaW1pemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dSZWYuc3RhdGUgPT09IE5iV2luZG93U3RhdGUuTUlOSU1JWkVEO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAgPSB0aGlzLmZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuYmx1clByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy53aW5kb3dDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5jb25maWcud2luZG93Q2xhc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlDb250YWluZXIgfHwgdGhpcy5vdmVybGF5Q29udGFpbmVyLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoVGVtcGxhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAucmVzdG9yZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBtaW5pbWl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud2luZG93UmVmLnN0YXRlID09PSBOYldpbmRvd1N0YXRlLk1JTklNSVpFRCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dSZWYudG9QcmV2aW91c1N0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd1JlZi5taW5pbWl6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heGltaXplKCkge1xuICAgICAgICB0aGlzLndpbmRvd1JlZi5tYXhpbWl6ZSgpO1xuICAgIH1cbiAgICBmdWxsU2NyZWVuKCkge1xuICAgICAgICB0aGlzLndpbmRvd1JlZi5mdWxsU2NyZWVuKCk7XG4gICAgfVxuICAgIG1heGltaXplT3JGdWxsU2NyZWVuKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3dSZWYuc3RhdGUgPT09IE5iV2luZG93U3RhdGUuTUlOSU1JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLm1heGltaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dSZWYuY2xvc2UoKTtcbiAgICB9XG4gICAgYXR0YWNoVGVtcGxhdGUoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclxuICAgICAgICAgICAgLmF0dGFjaFRlbXBsYXRlUG9ydGFsKG5ldyBOYlRlbXBsYXRlUG9ydGFsKHRoaXMuY29udGVudCwgbnVsbCwgdGhpcy5jb250ZXh0KSk7XG4gICAgfVxuICAgIGF0dGFjaENvbXBvbmVudCgpIHtcbiAgICAgICAgY29uc3QgcG9ydGFsID0gbmV3IE5iQ29tcG9uZW50UG9ydGFsKHRoaXMuY29udGVudCwgbnVsbCwgbnVsbCwgdGhpcy5jZnIpO1xuICAgICAgICBjb25zdCByZWYgPSB0aGlzLm92ZXJsYXlDb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgcmVmLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59XG5OYldpbmRvd0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItd2luZG93JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1jYXJkPlxuICAgICAgPG5iLWNhcmQtaGVhZGVyPlxuICAgICAgICA8ZGl2IGNka0ZvY3VzSW5pdGlhbCBjbGFzcz1cInRpdGxlXCIgdGFiaW5kZXg9XCItMVwiPnt7IGNvbmZpZy50aXRsZSB9fTwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zXCI+XG4gICAgICAgICAgPGJ1dHRvbiBuYkJ1dHRvbiBnaG9zdCAoY2xpY2spPVwibWluaW1pemUoKVwiPlxuICAgICAgICAgICAgPG5iLWljb24gaWNvbj1cIm1pbnVzLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gbmJCdXR0b24gZ2hvc3QgKm5nSWY9XCJpc0Z1bGxTY3JlZW5cIiAoY2xpY2spPVwibWF4aW1pemUoKVwiPlxuICAgICAgICAgICAgPG5iLWljb24gaWNvbj1cImNvbGxhcHNlLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gbmJCdXR0b24gZ2hvc3QgKm5nSWY9XCJtaW5pbWl6ZWQgfHwgbWF4aW1pemVkXCIgKGNsaWNrKT1cIm1heGltaXplT3JGdWxsU2NyZWVuKClcIj5cbiAgICAgICAgICAgIDxuYi1pY29uIGljb249XCJleHBhbmQtb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBuYkJ1dHRvbiBnaG9zdCAoY2xpY2spPVwiY2xvc2UoKVwiPlxuICAgICAgICAgICAgPG5iLWljb24gaWNvbj1cImNsb3NlLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmItY2FyZC1oZWFkZXI+XG4gICAgICA8bmItY2FyZC1ib2R5ICpuZ0lmPVwibWF4aW1pemVkIHx8IGlzRnVsbFNjcmVlblwiPlxuICAgICAgICA8bmItb3ZlcmxheS1jb250YWluZXI+PC9uYi1vdmVybGF5LWNvbnRhaW5lcj5cbiAgICAgIDwvbmItY2FyZC1ib2R5PlxuICAgIDwvbmItY2FyZD5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2ZsZXg6MSAwIGF1dG87bWluLXdpZHRoOjIwcmVtfTpob3N0IG5iLWNhcmR7bWFyZ2luOjB9Omhvc3QgbmItY2FyZC1oZWFkZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtvdmVyZmxvdzpoaWRkZW59Omhvc3QgLnRpdGxle2ZsZXg6MSAwIGF1dG87bWFyZ2luLXJpZ2h0OjNyZW07b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwfTpob3N0IC5idXR0b25ze3dpZHRoOjkuNXJlbTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWV2ZW5seX06aG9zdCAuYnV0dG9ucyBbbmJCdXR0b25de2ZsZXg6MCAwIDNyZW19Omhvc3QoLmZ1bGwtc2NyZWVuKXtwb3NpdGlvbjpmaXhlZDt0b3A6NTAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSl9Omhvc3QoLm1heGltaXplZCkgbmItY2FyZHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH06aG9zdCgubWluaW1pemVkKSBuYi1jYXJke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2hlaWdodDphdXRvfTpob3N0KC5taW5pbWl6ZWQpIG5iLWNhcmQgbmItY2FyZC1oZWFkZXJ7Ym9yZGVyLWJvdHRvbTpub25lfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYldpbmRvd0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfV0lORE9XX0NPTlRFTlQsXSB9XSB9LFxuICAgIHsgdHlwZTogT2JqZWN0LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9XSU5ET1dfQ09OVEVYVCxdIH1dIH0sXG4gICAgeyB0eXBlOiBOYldpbmRvd1JlZiB9LFxuICAgIHsgdHlwZTogTmJXaW5kb3dDb25maWcgfSxcbiAgICB7IHR5cGU6IE5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuTmJXaW5kb3dDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2ZyOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBpc0Z1bGxTY3JlZW46IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmZ1bGwtc2NyZWVuJyxdIH1dLFxuICAgIG1heGltaXplZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWF4aW1pemVkJyxdIH1dLFxuICAgIG1pbmltaXplZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubWluaW1pemVkJyxdIH1dLFxuICAgIG92ZXJsYXlDb250YWluZXI6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogW05iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCxdIH1dXG59O1xuXG4vKipcbiAqIFRoZSBgTmJXaW5kb3dTZXJ2aWNlYCBjYW4gYmUgdXNlZCB0byBvcGVuIHdpbmRvd3MuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgd2luZG93L3dpbmRvdy1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJXaW5kb3dNb2R1bGVgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJXaW5kb3dNb2R1bGUuZm9yUm9vdChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3UgYXJlIHVzaW5nIGl0IGluIGEgbGF6eSBsb2FkZWQgbW9kdWxlIHRoYW4geW91IGhhdmUgdG8gaW5zdGFsbCBgTmJXaW5kb3dNb2R1bGUuZm9yQ2hpbGRgOlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYldpbmRvd01vZHVsZS5mb3JDaGlsZChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBMYXp5TG9hZGVkTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogQSBuZXcgd2luZG93IGNhbiBiZSBvcGVuZWQgYnkgY2FsbGluZyB0aGUgYG9wZW5gIG1ldGhvZCB3aXRoIGEgY29tcG9uZW50IG9yIHRlbXBsYXRlIHRvIGJlIGxvYWRlZFxuICogYW5kIGFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uXG4gKiBgb3BlbmAgbWV0aG9kIHdpbGwgcmV0dXJuIGBOYldpbmRvd1JlZmAgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIGZ1cnRoZXIgbWFuaXB1bGF0aW9ucy5cbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgd2luZG93UmVmID0gdGhpcy53aW5kb3dTZXJ2aWNlLm9wZW4oTXlDb21wb25lbnQsIHsgLi4uIH0pO1xuICogYGBgXG4gKlxuICogYE5iV2luZG93UmVmYCBnaXZlcyB5b3UgYWJpbGl0eSBtYW5pcHVsYXRlIG9wZW5lZCB3aW5kb3cuXG4gKiBBbHNvLCB5b3UgY2FuIGluamVjdCBgTmJXaW5kb3dSZWZgIGluc2lkZSBwcm92aWRlZCBjb21wb25lbnQgd2hpY2ggcmVuZGVyZWQgaW4gd2luZG93LlxuICpcbiAqIGBgYHRzXG4gKiB0aGlzLndpbmRvd1NlcnZpY2Uub3BlbihNeVdpbmRvd0NvbXBvbmVudCwgeyAuLi4gfSk7XG4gKlxuICogLy8gbXkuY29tcG9uZW50LnRzXG4gKiBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgd2luZG93UmVmOiBOYldpbmRvd1JlZikge1xuICogfVxuICpcbiAqIG1pbmltaXplKCkge1xuICogICB0aGlzLndpbmRvd1JlZi5taW5pbWl6ZSgpO1xuICogfVxuICpcbiAqIGNsb3NlKCkge1xuICogICB0aGlzLndpbmRvd1JlZi5jbG9zZSgpO1xuICogfVxuICogYGBgXG4gKlxuICogSW5zdGVhZCBvZiBjb21wb25lbnQgeW91IGNhbiBjcmVhdGUgd2luZG93IGZyb20gVGVtcGxhdGVSZWYuIEFzIHVzdWFsIHlvdSBjYW4gYWNjZXNzIGNvbnRleHQgcHJvdmlkZWQgdmlhIGNvbmZpZ1xuICogdmlhIGBsZXQtYCB2YXJpYWJsZXMuIEFsc28geW91IGNhbiBnZXQgcmVmZXJlbmNlIHRvIHRoZSBgTmJXaW5kb3dSZWZgIGluIGNvbnRleHQncyBgd2luZG93UmVmYCBwcm9wZXJ0eS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpbmRvdyBjb250ZW50IGZyb20gVGVtcGxhdGVSZWYsIHdpbmRvdy90ZW1wbGF0ZS13aW5kb3cuY29tcG9uZW50KVxuICpcbiAqICMjIyBDb25maWd1cmF0aW9uXG4gKlxuICogQXMgbWVudGlvbmVkIGFib3ZlLCBgb3BlbmAgbWV0aG9kIG9mIHRoZSBgTmJXaW5kb3dTZXJ2aWNlYCBtYXkgcmVjZWl2ZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBBbHNvLCB5b3UgY2FuIG1vZGlmeSBkZWZhdWx0IHdpbmRvd3MgY29uZmlndXJhdGlvbiB0aHJvdWdoIGBOYldpbmRvd01vZHVsZS5mb3JSb290KHsgLi4uIH0pYC5cbiAqIFlvdSBjYW4gcmVhZCBhYm91dCBhbGwgYXZhaWxhYmxlIG9wdGlvbnMgb24gW0FQSSB0YWJdKGRvY3MvY29tcG9uZW50cy93aW5kb3cvYXBpI25id2luZG93Y29uZmlnKS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbmZpZ3VyYXRpb24sIHdpbmRvdy93aW5kb3dzLWJhY2tkcm9wLmNvbXBvbmVudClcbiAqL1xuY2xhc3MgTmJXaW5kb3dTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIG92ZXJsYXlTZXJ2aWNlLCBvdmVybGF5UG9zaXRpb25CdWlsZGVyLCBibG9ja1Njcm9sbFN0cmF0ZWd5LCBkZWZhdWx0V2luZG93c0NvbmZpZywgY2ZyLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZSA9IG92ZXJsYXlTZXJ2aWNlO1xuICAgICAgICB0aGlzLm92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSBvdmVybGF5UG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLmJsb2NrU2Nyb2xsU3RyYXRlZ3kgPSBibG9ja1Njcm9sbFN0cmF0ZWd5O1xuICAgICAgICB0aGlzLmRlZmF1bHRXaW5kb3dzQ29uZmlnID0gZGVmYXVsdFdpbmRvd3NDb25maWc7XG4gICAgICAgIHRoaXMuY2ZyID0gY2ZyO1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3dzID0gW107XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgbmV3IHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gd2luZG93Q29udGVudFxuICAgICAqIEBwYXJhbSB3aW5kb3dDb25maWdcbiAgICAgKiAqL1xuICAgIG9wZW4od2luZG93Q29udGVudCwgd2luZG93Q29uZmlnID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ3JlYXRlV2luZG93c0NvbnRhaW5lcigpKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVdpbmRvd3NDb250YWluZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgTmJXaW5kb3dDb25maWcodGhpcy5kZWZhdWx0V2luZG93c0NvbmZpZywgd2luZG93Q29uZmlnKTtcbiAgICAgICAgY29uc3Qgd2luZG93UmVmID0gbmV3IE5iV2luZG93UmVmKGNvbmZpZyk7XG4gICAgICAgIHdpbmRvd1JlZi5jb21wb25lbnRSZWYgPSB0aGlzLmFwcGVuZFdpbmRvdyh3aW5kb3dDb250ZW50LCBjb25maWcsIHdpbmRvd1JlZik7XG4gICAgICAgIHRoaXMub3BlbldpbmRvd3MucHVzaCh3aW5kb3dSZWYpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKHdpbmRvd1JlZik7XG4gICAgICAgIHJldHVybiB3aW5kb3dSZWY7XG4gICAgfVxuICAgIHNob3VsZENyZWF0ZVdpbmRvd3NDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd3NDb250YWluZXJWaWV3UmVmKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMud2luZG93c0NvbnRhaW5lclZpZXdSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmRvY3VtZW50LmJvZHkuY29udGFpbnMoY29udGFpbmVyRWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVXaW5kb3dzQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3ZlcmxheVJlZiA9IHRoaXMub3ZlcmxheVNlcnZpY2UuY3JlYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiB0aGlzLm92ZXJsYXlTZXJ2aWNlLnNjcm9sbFN0cmF0ZWdpZXMubm9vcCgpLFxuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogdGhpcy5vdmVybGF5UG9zaXRpb25CdWlsZGVyLmdsb2JhbCgpLmJvdHRvbSgpLnJpZ2h0KCksXG4gICAgICAgICAgICBoYXNCYWNrZHJvcDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdpbmRvd3NDb250YWluZXJQb3J0YWwgPSBuZXcgTmJDb21wb25lbnRQb3J0YWwoTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50LCBudWxsLCBudWxsLCB0aGlzLmNmcik7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXlSZWYuYXR0YWNoKHdpbmRvd3NDb250YWluZXJQb3J0YWwpO1xuICAgICAgICB0aGlzLndpbmRvd3NDb250YWluZXJWaWV3UmVmID0gb3ZlcmxheVJlZi5pbnN0YW5jZS52aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBhcHBlbmRXaW5kb3coY29udGVudCwgY29uZmlnLCB3aW5kb3dSZWYpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZlxuICAgICAgICAgICAgPyB7ICRpbXBsaWNpdDogY29uZmlnLmNvbnRleHQsIHdpbmRvd1JlZiB9XG4gICAgICAgICAgICA6IGNvbmZpZy5jb250ZXh0O1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSBbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5CX1dJTkRPV19DT05URU5ULCB1c2VWYWx1ZTogY29udGVudCB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1dfQ09OVEVYVCwgdXNlVmFsdWU6IGNvbnRleHQgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTmJXaW5kb3dDb25maWcsIHVzZVZhbHVlOiBjb25maWcgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTmJXaW5kb3dSZWYsIHVzZVZhbHVlOiB3aW5kb3dSZWYgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcGFyZW50SW5qZWN0b3IgPSBjb25maWcudmlld0NvbnRhaW5lclJlZlxuICAgICAgICAgICAgPyBjb25maWcudmlld0NvbnRhaW5lclJlZi5pbmplY3RvclxuICAgICAgICAgICAgOiB0aGlzLndpbmRvd3NDb250YWluZXJWaWV3UmVmLmluamVjdG9yO1xuICAgICAgICBjb25zdCBpbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7IHBhcmVudDogcGFyZW50SW5qZWN0b3IsIHByb3ZpZGVycyB9KTtcbiAgICAgICAgY29uc3Qgd2luZG93RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KE5iV2luZG93Q29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy53aW5kb3dzQ29udGFpbmVyVmlld1JlZi5jcmVhdGVDb21wb25lbnQod2luZG93RmFjdG9yeSwgbnVsbCwgaW5qZWN0b3IpO1xuICAgICAgICByZWYuaW5zdGFuY2UuY2ZyID0gdGhpcy5jZnI7XG4gICAgICAgIHJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvRXZlbnRzKHdpbmRvd1JlZikge1xuICAgICAgICBpZiAod2luZG93UmVmLmNvbmZpZy5jbG9zZU9uQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoKCkgPT4gd2luZG93UmVmLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3dSZWYuY29uZmlnLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5rZXlkb3duRXZlbnRzKClcbiAgICAgICAgICAgICAgICAucGlwZShmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC5rZXlDb2RlID09PSAyNykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB3aW5kb3dSZWYuY2xvc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93UmVmLnN0YXRlQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoZWNrQW5kVXBkYXRlT3ZlcmxheSgpKTtcbiAgICAgICAgd2luZG93UmVmLm9uQ2xvc2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3BlbldpbmRvd3Muc3BsaWNlKHRoaXMub3BlbldpbmRvd3MuaW5kZXhPZih3aW5kb3dSZWYpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja0FuZFVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxTY3JlZW5XaW5kb3dzID0gdGhpcy5vcGVuV2luZG93cy5maWx0ZXIodyA9PiB3LnN0YXRlID09PSBOYldpbmRvd1N0YXRlLkZVTExfU0NSRUVOKTtcbiAgICAgICAgaWYgKGZ1bGxTY3JlZW5XaW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tTY3JvbGxTdHJhdGVneS5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tTY3JvbGxTdHJhdGVneS5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bGxTY3JlZW5XaW5kb3dzLnNvbWUodyA9PiB3LmNvbmZpZy5oYXNCYWNrZHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5iYWNrZHJvcEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5iYWNrZHJvcEVsZW1lbnQuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5OYldpbmRvd1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iV2luZG93U2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyIH0sXG4gICAgeyB0eXBlOiBOYkJsb2NrU2Nyb2xsU3RyYXRlZ3lBZGFwdGVyIH0sXG4gICAgeyB0eXBlOiBOYldpbmRvd0NvbmZpZywgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfV0lORE9XX0NPTkZJRyxdIH1dIH0sXG4gICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfRE9DVU1FTlQsXSB9XSB9XG5dO1xuXG5jbGFzcyBOYldpbmRvd01vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoZGVmYXVsdENvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iV2luZG93TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTmJXaW5kb3dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfV0lORE9XX0NPTkZJRywgdXNlVmFsdWU6IGRlZmF1bHRDb25maWcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDaGlsZChkZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJXaW5kb3dNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYldpbmRvd1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1dfQ09ORklHLCB1c2VWYWx1ZTogZGVmYXVsdENvbmZpZyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5OYldpbmRvd01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTmJPdmVybGF5TW9kdWxlLCBOYkNhcmRNb2R1bGUsIE5iSWNvbk1vZHVsZSwgTmJCdXR0b25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iV2luZG93Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50LCBOYldpbmRvd0NvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBUaGUgYE5iVGltZVBpY2tlckRpcmVjdGl2ZWAgaXMgZm9ybSBjb250cm9sIHRoYXQgZ2l2ZXMgeW91IGFiaWxpdHkgdG8gc2VsZWN0IGEgdGltZS4gVGhlIHRpbWVwaWNrZXJcbiAqIGlzIHNob3duIHdoZW4gaW5wdXQgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiPlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9uYi10aW1lcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdGltZXBpY2tlci90aW1lcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRpbWVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIHJvb3QgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRpbWVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIEFuZCBgTmJUaW1lcGlja2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRpbWVwaWNrZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKlxuICogYGBgXG4gKiA8ZGl2IGlkPVwibmF0aXZlLXBhcnNlLWlzc3VlXCIgY2xhc3M9XCJub3RlIG5vdGUtd2FybmluZ1wiPlxuICogPGRpdiBjbGFzcz1cIm5vdGUtdGl0bGVcIj5Ob3RlPC9kaXY+XG4gKiA8ZGl2IGNsYXNzPVwibm90ZS1ib2R5XCI+XG4gKiBUaW1lcGlja2VyIHVzZXMgbmF0aXZlIERhdGUgb2JqZWN0IGJ5IGRlZmF1bHQsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwYXJzaW5nIGJ5IGN1c3RvbSBmb3JtYXQuXG4gKiBBY2NvcmRpbmcgdG8gdGhlIEVDTUFTY3JpcHQgc3BlY2lmaWNhdGlvbiwgdGhlIG9ubHkgc3VwcG9ydGVkIGZvcm1hdCBpcyBhIGZvcm1hdCBkZXNjcmliZWQgYnkgSVNPIDgwNjEgc3RhbmRhcmQuXG4gKiBUaGlzIHN0YW5kYXJkIHJlcXVpcmVzIGRhdGUgcGFydCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBzdHJpbmcsXG4gKiBtZWFuaW5nIHlvdSBoYXZlIHRvIHR5cGUgYSBkYXRlK3RpbWUgaW4gdGhlIGlucHV0LlxuICogV2UgaGlnaGx5IHJlY29tbWVuZCB5b3UgdG8gdXNlIE5iRGF0ZUZuc0RhdGVNb2R1bGUgb3IgTmJNb21lbnREYXRlTW9kdWxlIHRvIGJlIGFibGUgdG8gc3VwcG9ydCB0aW1lIG9ubHkgc3RyaW5ncyBpblxuICogdGhlIHRpbWVwaWNrZXIgaW5wdXRzLiBUaGVzZSBtb2R1bGVzIHVzZSBkYXRlLWZucyBhbmQgbW9tZW50IGRhdGUgbGlicmFyaWVzLCB3aGljaCBwcm92aWRlIGNhcGFiaWxpdGllc1xuICogdG8gcGFyc2UgdGltZSBvbmx5IHN0cmluZ3MuXG4gKiBTZWUgXCJGb3JtYXR0aW5nIElzc3VlXCIgYXRcbiAqIDxhIGhyZWY9XCJodHRwczovL2FrdmVvLmdpdGh1Yi5pby9uZWJ1bGFyL2RvY3MvY29tcG9uZW50cy9kYXRlcGlja2VyL292ZXJ2aWV3I2Zvcm1hdHRpbmctaXNzdWVcIj5EYXRlIHBpY2tlciBkb2NzPC9hPlxuICogZm9yIGluc3RhbGxhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiA8L2Rpdj5cbiAqIDwvZGl2PlxuICogPGhyPlxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRvIHNob3cgc2Vjb25kcyBjb2x1bW4gYWxvbmcgd2l0aCBob3VycyBhbmQgbWludXRlcyB1c2UgYHdpdGhTZWNvbmRzYCBpbnB1dFxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJUaW1lcGlja2VyXT1cInRpbWVwaWNrZXJcIj5cbiAqIDxuYi10aW1lcGlja2VyICN0aW1lcGlja2VyIHdpdGhTZWNvbmRzPjwvbmItdGltZXBpY2tlcj5cbiAqIGBgYFxuICogQHN0YWNrZWQtZXhhbXBsZShUaW1lIHBpY2tlciB3aXRoIHNlY29uZHMsIHRpbWVwaWNrZXIvdGltZXBpY2tlci13aXRoLXNlY29uZHMuY29tcG9uZW50KVxuICpcbiAqIFRvIGZvcmNlIHRpbWVwaWNrZXIgd29yayBpbiAxMiBob3VycyBmb3JtYXQsIHVzZSBgdHdlbHZlSG91cnNGb3JtYXRgIGlucHV0LlxuICogQnkgZGVmYXVsdCwgdGltZXBpY2tlciBjaG9vc2UgMTIgb3IgMjQgZm9ybWF0cyBiYXNlZCBvbiBhcHBsaWNhdGlvbiBsb2NhbGUgc3RhbmRhcmRzXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiIHR3ZWx2ZUhvdXJzRm9ybWF0PlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9uYi10aW1lcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShUd2VsdmUgaG91cnMgZm9ybWF0IHNob3djYXNlLCB0aW1lcGlja2VyL3RpbWVwaWNrZXItdHdlbHZlLWhvdXJzLWZvcm1hdC5jb21wb25lbnQpXG4gKlxuICogQSBzaW5nbGUgY29sdW1uIHBpY2tlciB3aXRoIG9wdGlvbnMgdmFsdWUgYXMgdGltZSBhbmQgbWludXRlLCBzbyB1c2VycyB3b27igJl0IGJlIGFibGUgdG8gcGlja1xuICogaG91cnMgYW5kIG1pbnV0ZXMgaW5kaXZpZHVhbGx5LlxuICogWW91IGNhbiBjb250cm9sIG9wdGlvbnMgbWludXRlcyBvZmZzZXQgdmlhIGBzdGVwYCBpbnB1dCwgZS5nLjogMTE6MDAsIDExOjIwLCAxMTo0MC4uLidcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbmdsZSBjb2x1bW4sIHRpbWVwaWNrZXIvdGltZXBpY2tlci1zaW5nbGUtY29sdW1uLmNvbXBvbmVudClcbiAqXG4gKiBUaW1lcGlja2VyIHN1cHBvcnQgZm9ybXMgYW5kIHJlYWN0aXZlIGZvcm1zIEFQSSBzbyB5b3UgY2FuIHByb3ZpZGUgdmFsdWUgdXNpbmcgYGZvcm1Db250cm9sYCBhbmQgYG5nTW9kZWxgIGRpcmVjdGl2ZXNcbiAqIEBzdGFja2VkLWV4YW1wbGUoRm9ybSBjb250cm9sLCB0aW1lcGlja2VyL3RpbWVwaWNrZXItZm9ybS1jb250cm9sLmNvbXBvbmVudClcbiAqXG4gKiA8aW5wdXQgW25iVGltZXBpY2tlcl09XCJ0aW1lcGlja2VyXCIgdHdlbHZlSG91cnNGb3JtYXQ+XG4gKiA8bmItdGltZXBpY2tlciAjdGltZXBpY2tlIFtmb3JtQ29udHJvbF09XCJmb3JtQ29udHJvbFwiPjwvbmItdGltZXBpY2tlcj5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKE5nTW9kZWwsIHRpbWVwaWNrZXIvdGltZXBpY2tlci1uZy1tb2RlbC5jb21wb25lbnQpXG4gKlxuICogPGlucHV0IFtuYlRpbWVwaWNrZXJdPVwidGltZXBpY2tlclwiIHR3ZWx2ZUhvdXJzRm9ybWF0PlxuICogPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZSBbbmdNb2RlbF09XCJkYXRlXCI+PC9uYi10aW1lcGlja2VyPlxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0aW1lcGlja2VyLWNlbGwtdGV4dC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItY2VsbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWhvdmVyLXRleHQtY29sb3I6XG4gKiB0aW1lcGlja2VyLWNlbGwtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItY2VsbC1mb2N1cy10ZXh0LWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogdGltZXBpY2tlci1jZWxsLXRleHQtZm9udC1zaXplOlxuICogdGltZXBpY2tlci1jZWxsLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0aW1lcGlja2VyLWNlbGwtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItY2VsbC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGltZXBpY2tlci1jZWxsLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1mb250LXNpemU6XG4gKiB0aW1lcGlja2VyLWhlYWRlci1jZWxsLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0aW1lcGlja2VyLWhlYWRlci1jZWxsLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItaGVhZGVyLWNlbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIHRpbWVwaWNrZXItYm9yZGVyLWNvbG9yOlxuICogdGltZXBpY2tlci1ib3JkZXItc3R5bGU6XG4gKiB0aW1lcGlja2VyLWJvcmRlci13aWR0aDpcbiAqIHRpbWVwaWNrZXItc2Nyb2xsYmFyLWNvbG9yOlxuICogdGltZXBpY2tlci1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRpbWVwaWNrZXItc2Nyb2xsYmFyLXdpZHRoOlxuICogdGltZXBpY2tlci1zaW5nbGUtY29sdW1uLXdpZHRoOlxuICogdGltZXBpY2tlci1tdWx0aXBsZS1jb2x1bW4td2lkdGg6XG4gKiB0aW1lcGlja2VyLXRpdGxlLWhlaWdodDpcbiAqIHRpbWVwaWNrZXItdGl0bGUtcGFkZGluZzpcbiAqIHRpbWVwaWNrZXItY29udGFpbmVyLXdpZHRoOlxuICogdGltZXBpY2tlci1jb250YWluZXItaGVpZ2h0OlxuICogKi9cbmNsYXNzIE5iVGltZVBpY2tlckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHBvc2l0aW9uQnVpbGRlciwgaG9zdFJlZiwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgb3ZlcmxheSwgY2QsIGNhbGVuZGFyVGltZU1vZGVsU2VydmljZSwgZGF0ZVNlcnZpY2UsIHJlbmRlcmVyLCBwbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLmhvc3RSZWYgPSBob3N0UmVmO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXIgPSB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlID0gY2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZSBwaWNrZXIgb3ZlcmxheSBvZmZzZXQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMub3ZlcmxheU9mZnNldCA9IDg7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGltZXBpY2tlciBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBnZXQgdGltZXBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVQaWNrZXJDb21wb25lbnQ7XG4gICAgfVxuICAgIHNldCB0aW1lcGlja2VyKHRpbWVQaWNrZXIpIHtcbiAgICAgICAgdGhpcy5fdGltZVBpY2tlckNvbXBvbmVudCA9IHRpbWVQaWNrZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaHRtbCBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiAqL1xuICAgIGdldCBpbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlzIHRpbWVwaWNrZXIgb3ZlcmxheSBvcGVuZWQuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqICovXG4gICAgZ2V0IGlzT3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZiAmJiB0aGlzLm92ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpcyB0aW1lcGlja2VyIG92ZXJsYXkgY2xvc2VkLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiAqL1xuICAgIGdldCBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3N0IGlucHV0IHZhbHVlLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiAqL1xuICAgIGdldCBpbnB1dFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTtcbiAgICB9XG4gICAgc2V0IGlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25JbnB1dENoYW5nZSgpO1xuICAgICAgICBpZiAoIXRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dCwgJ3BsYWNlaG9sZGVyJywgdGhpcy50aW1lcGlja2VyLnRpbWVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVUcmlnZ2VyU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblRyaWdnZXJzKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9CbHVyKCk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFRvT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBwaWNrZXIgdG8gdGhlIHRpbWVwaWNrZXIgcG9ydGFsLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiAqL1xuICAgIGF0dGFjaFRvT3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBUaW1lcGlja2VyKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5UmVmLmF0dGFjaCh0aGlzLnRpbWVwaWNrZXIucG9ydGFsKTtcbiAgICB9XG4gICAgc2V0dXBUaW1lcGlja2VyKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlU2VydmljZS5nZXRJZCgpID09PSAnbmF0aXZlJyAmJiBpc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEYXRlLnBhcnNlIG5vZXMgbm90IHN1cHBvcnQgcGFyc2luZyB0aW1lIHdpdGggY3VzdG9tIGZvcm1hdC4nICtcbiAgICAgICAgICAgICAgICAnIFNlZSBkZXRhaWxzIGhlcmUgaHR0cHM6Ly9ha3Zlby5naXRodWIuaW8vbmVidWxhci9kb2NzL2NvbXBvbmVudHMvZGF0ZXBpY2tlci9vdmVydmlldyNuYXRpdmUtcGFyc2UtaXNzdWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVwaWNrZXIuc2V0SG9zdCh0aGlzLmhvc3RSZWYpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLmRhdGVTZXJ2aWNlLmdldElkKCkgPT09ICduYXRpdmUnID8gdGhpcy5wYXJzZU5hdGl2ZURhdGVTdHJpbmcodGhpcy5pbnB1dFZhbHVlKSA6IHRoaXMuaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudGltZXBpY2tlci5kYXRlID0gdGhpcy5kYXRlU2VydmljZS5wYXJzZSh2YWwsIHRoaXMudGltZXBpY2tlci50aW1lRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZXBpY2tlci5kYXRlID0gdGhpcy5jYWxlbmRhclRpbWVNb2RlbFNlcnZpY2UuZ2V0UmVzZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdE92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uQXBwbHlDbGljaygpO1xuICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25BcHBseUNsaWNrKCkge1xuICAgICAgICB0aGlzLnRpbWVwaWNrZXIub25TZWxlY3RUaW1lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQodmFsdWUudGltZSwgdGhpcy50aW1lcGlja2VyLnRpbWVGb3JtYXQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB0aW1lO1xuICAgICAgICAgICAgdGhpcy50aW1lcGlja2VyLmRhdGUgPSB2YWx1ZS50aW1lO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh2YWx1ZS50aW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zYXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVPdmVybGF5KCkge1xuICAgICAgICBjb25zdCBzY3JvbGxTdHJhdGVneSA9IHRoaXMuY3JlYXRlU2Nyb2xsU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZSh7IHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMucG9zaXRpb25TdHJhdGVneSwgc2Nyb2xsU3RyYXRlZ3kgfSk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uVHJpZ2dlcnMoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LnNob3ckXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5pc0Nsb3NlZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2hvdygpKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuaGlkZSRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmlzT3BlbikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHRoaXMubGFzdElucHV0VmFsdWUgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlclxuICAgICAgICAgICAgLnRyaWdnZXIoTmJUcmlnZ2VyLkZPQ1VTKVxuICAgICAgICAgICAgLmhvc3QodGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICAuY29udGFpbmVyKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyKCkpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICB9XG4gICAgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25CdWlsZGVyXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5ob3N0UmVmKVxuICAgICAgICAgICAgLnBvc2l0aW9uKE5iUG9zaXRpb24uQk9UVE9NKVxuICAgICAgICAgICAgLm9mZnNldCh0aGlzLm92ZXJsYXlPZmZzZXQpXG4gICAgICAgICAgICAuYWRqdXN0bWVudChOYkFkanVzdG1lbnQuVkVSVElDQUwpO1xuICAgIH1cbiAgICBnZXRDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWYgJiYgdGhpcy5pc09wZW4gJiYge1xuICAgICAgICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgICAgICAgICBuYXRpdmVFbGVtZW50OiB0aGlzLm92ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVTY3JvbGxTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmJsb2NrKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uSW5wdXRDaGFuZ2UoKSB7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKVxuICAgICAgICAgICAgLnBpcGUobWFwKCgpID0+IHRoaXMuaW5wdXRWYWx1ZSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlKSk7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvQmx1cigpIHtcbiAgICAgICAgbWVyZ2UodGhpcy50aW1lcGlja2VyLmJsdXIsIGZyb21FdmVudCh0aGlzLmlucHV0LCAnYmx1cicpLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLmlzT3BlbiAmJiB0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuaW5wdXQpKSkucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Ub3VjaGVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgaW5wdXQgdmFsdWUgYW5kIHdyaXRlIGlmIGl0IGlzbid0IG51bGwuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqICovXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlcnZpY2UuZ2V0SWQoKSA9PT0gJ25hdGl2ZScpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmF0aXZlIGRhdGUgc2VydmljZSBkb250IHBhcnNlIG9ubHkgdGltZSBzdHJpbmcgdmFsdWUsXG4gICAgICAgICAgICAgKiBhbmQgd2UgYWRkaW5nIHllYXIgbW91dGggYW5kIGRheSB0byBjb252ZXJ0IHN0cmluZyB0byB2YWxpZCBkYXRlIGZvcm1hdFxuICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlTmF0aXZlRGF0ZVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNWYWxpZERhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmlzVmFsaWREYXRlU3RyaW5nKHZhbHVlLCB0aGlzLnRpbWVwaWNrZXIudGltZUZvcm1hdCk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0SW5wdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UucGFyc2UodmFsdWUsIHRoaXMudGltZXBpY2tlci50aW1lRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnRpbWVwaWNrZXIuZGF0ZSA9IGRhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVwaWNrZXIuZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQodmFsdWUsIHRoaXMudGltZXBpY2tlci50aW1lRm9ybWF0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICBwYXJzZU5hdGl2ZURhdGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhcihkYXRlKTtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmNhbGVuZGFyVGltZU1vZGVsU2VydmljZS5wYWRkVG9Ud29TeW1ib2xzKHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGgoZGF0ZSkpO1xuICAgICAgICBjb25zdCBkYXkgPSB0aGlzLmNhbGVuZGFyVGltZU1vZGVsU2VydmljZS5wYWRkVG9Ud29TeW1ib2xzKHRoaXMuZGF0ZVNlcnZpY2UuZ2V0RGF0ZShkYXRlKSk7XG4gICAgICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX0gJHt2YWx1ZX1gO1xuICAgIH1cbn1cbk5iVGltZVBpY2tlckRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbbmJUaW1lcGlja2VyXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYlRpbWVQaWNrZXJEaXJlY3RpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRpbWVQaWNrZXJEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX0RPQ1VNRU5ULF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJPdmVybGF5U2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5iQ2FsZW5kYXJUaW1lTW9kZWxTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IFN0cmluZywgZGVjb3JhdG9yczogW3sgdHlwZTogQXR0cmlidXRlLCBhcmdzOiBbJ3BsYWNlaG9sZGVyJyxdIH1dIH1cbl07XG5OYlRpbWVQaWNrZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdGltZXBpY2tlcjogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUaW1lcGlja2VyJyxdIH1dLFxuICAgIG92ZXJsYXlPZmZzZXQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuXG5jbGFzcyBOYlRpbWVQaWNrZXJDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUsIHBsYXRmb3JtU2VydmljZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybVNlcnZpY2UgPSBwbGF0Zm9ybVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdGVkJCA9IHRoaXMuc2VsZWN0ZWRDaGFuZ2UkLnBpcGUoZmlsdGVyKChzZWxlY3RlZCkgPT4gIXNlbGVjdGVkKSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9FbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZSQubmV4dChzZWxlY3RlZCk7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh7IHZhbHVlOiB0aGlzLnZhbHVlIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByZW5kZXIgdGltZXBpY2tlciBpbiB0aGUgb3ZlcmxheSwgYXQgdGhlIG1vbWVudCB0aGlzIGhvb2sgY2FsbGVkLFxuICAgICAgICAgICAgLy8gdGltZXBpY2tlciBjb3VsZCBiZSBub3QgZnVsbHkgcmVuZGVyZWQgYW5kIHBsYWNlZC4gQmVjYXVzZSBvZiBpdCwgd2UncmUgd2FpdGluZyBmb3IgQW5ndWxhclxuICAgICAgICAgICAgLy8gdG8gZmluaXNoIGNoYW5nZSBkZXRlY3Rpb24gcnVuIGFuZCBvbmx5IHRoZW4gc2Nyb2xsIHRvIHRoZSBzZWxlY3RlZCBjZWxsLlxuICAgICAgICAgICAgdGhpcy5uZ1pvbmUub25TdGFibGVcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpLCB0YWtlVW50aWwobWVyZ2UodGhpcy51bnNlbGVjdGVkJCwgdGhpcy5kZXN0cm95JCkpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zY3JvbGxUb0VsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsVG9FbGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZUNvbnRhaW5lckVsZW1lbnQgJiYgdGhpcy5wbGF0Zm9ybVNlcnZpY2UuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLnZhbHVlQ29udGFpbmVyRWxlbWVudC5uYXRpdmVFbGVtZW50LnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICdjZW50ZXInIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG59XG5OYlRpbWVQaWNrZXJDZWxsQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi10aW1lcGlja2VyLWNlbGwnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiAjdmFsdWVDb250YWluZXI+e3sgdmFsdWUgfX08L2Rpdj5cbiAgYCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3VzZXItc2VsZWN0Om5vbmV9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVGltZVBpY2tlckNlbGxDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IE5iUGxhdGZvcm0gfVxuXTtcbk5iVGltZVBpY2tlckNlbGxDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgc2VsZWN0ZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3Q6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICB2YWx1ZUNvbnRhaW5lckVsZW1lbnQ6IFt7IHR5cGU6IFZpZXdDaGlsZCwgYXJnczogWyd2YWx1ZUNvbnRhaW5lcicsXSB9XSxcbiAgICBvbkNsaWNrOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJUaW1lcGlja2VyTW9kdWxlIHtcbiAgICBzdGF0aWMgZm9yUm9vdChjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iVGltZXBpY2tlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkJfVElNRV9QSUNLRVJfQ09ORklHLCB1c2VWYWx1ZTogY29uZmlnIH1dLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZm9yQ2hpbGQoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYlRpbWVwaWNrZXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5CX1RJTUVfUElDS0VSX0NPTkZJRywgdXNlVmFsdWU6IGNvbmZpZyB9XSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5OYlRpbWVwaWNrZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYk92ZXJsYXlNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iTGlzdE1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJDYXJkTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkNhbGVuZGFyS2l0TW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTmJDYWxlbmRhclRpbWVNb2RlbFNlcnZpY2VdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYlRpbWVQaWNrZXJDb21wb25lbnQsIE5iVGltZVBpY2tlckNlbGxDb21wb25lbnQsIE5iVGltZVBpY2tlckRpcmVjdGl2ZV0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJUaW1lUGlja2VyQ29tcG9uZW50LCBOYlRpbWVQaWNrZXJDZWxsQ29tcG9uZW50LCBOYlRpbWVQaWNrZXJEaXJlY3RpdmVdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJEYXRlQWRhcHRlclNlcnZpY2UgZXh0ZW5kcyBOYkRhdGVwaWNrZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucGlja2VyID0gTmJEYXRlcGlja2VyQ29tcG9uZW50O1xuICAgIH1cbiAgICBwYXJzZShkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UucGFyc2UoZGF0ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgZm9ybWF0KGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQoZGF0ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgaXNWYWxpZChkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcoZGF0ZSwgZm9ybWF0KTtcbiAgICB9XG59XG5OYkRhdGVBZGFwdGVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJEYXRlQWRhcHRlclNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYkRhdGVTZXJ2aWNlIH1cbl07XG5jbGFzcyBOYlJhbmdlQWRhcHRlclNlcnZpY2UgZXh0ZW5kcyBOYkRhdGVwaWNrZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucGlja2VyID0gTmJSYW5nZXBpY2tlckNvbXBvbmVudDtcbiAgICB9XG4gICAgcGFyc2UocmFuZ2UsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSByYW5nZS5zcGxpdCgnLScpLm1hcChzdWJEYXRlID0+IHN1YkRhdGUudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmRhdGVTZXJ2aWNlLnBhcnNlKHN0YXJ0LCBmb3JtYXQpLFxuICAgICAgICAgICAgZW5kOiB0aGlzLmRhdGVTZXJ2aWNlLnBhcnNlKGVuZCwgZm9ybWF0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9ybWF0KHJhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQocmFuZ2Uuc3RhcnQsIGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGlzU3RhcnRWYWxpZCA9IHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcoc3RhcnQsIGZvcm1hdCk7XG4gICAgICAgIGlmICghaXNTdGFydFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQocmFuZ2UuZW5kLCBmb3JtYXQpO1xuICAgICAgICBjb25zdCBpc0VuZFZhbGlkID0gdGhpcy5kYXRlU2VydmljZS5pc1ZhbGlkRGF0ZVN0cmluZyhlbmQsIGZvcm1hdCk7XG4gICAgICAgIGlmIChpc0VuZFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhcnR9IC0gJHtlbmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1ZhbGlkKHJhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcmFuZ2Uuc3BsaXQoJy0nKS5tYXAoc3ViRGF0ZSA9PiBzdWJEYXRlLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzVmFsaWREYXRlU3RyaW5nKHN0YXJ0LCBmb3JtYXQpICYmIHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcoZW5kLCBmb3JtYXQpO1xuICAgIH1cbn1cbk5iUmFuZ2VBZGFwdGVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJSYW5nZUFkYXB0ZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJEYXRlU2VydmljZSB9XG5dO1xuY2xhc3MgTmJEYXRlVGltZUFkYXB0ZXJTZXJ2aWNlIGV4dGVuZHMgTmJEYXRlcGlja2VyQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnBpY2tlciA9IE5iRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQ7XG4gICAgfVxuICAgIHBhcnNlKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5wYXJzZShkYXRlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpc1ZhbGlkKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1ZhbGlkRGF0ZVN0cmluZyhkYXRlLCBmb3JtYXQpO1xuICAgIH1cbn1cbk5iRGF0ZVRpbWVBZGFwdGVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuTmJEYXRlVGltZUFkYXB0ZXJTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJEYXRlU2VydmljZSB9XG5dO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iRGF0ZXBpY2tlck1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJEYXRlcGlja2VyTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgRGF0ZVBpcGUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOQl9EQVRFX0FEQVBURVIsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VDbGFzczogTmJEYXRlQWRhcHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5CX0RBVEVfQURBUFRFUixcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBOYlJhbmdlQWRhcHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5CX0RBVEVfQURBUFRFUixcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBOYkRhdGVUaW1lQWRhcHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufVxuTmJEYXRlcGlja2VyTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYkNhcmRNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQmFzZUNhbGVuZGFyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBOYlRpbWVwaWNrZXJNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJLaXRNb2R1bGUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE5iRGF0ZXBpY2tlckRpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgTmJEYXRlcGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlJhbmdlcGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYkRhdGVUaW1lUGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYkNhbGVuZGFyV2l0aFRpbWVDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJEYXRlcGlja2VyRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICBOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJXaXRoVGltZUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJEYXRlVGltZVBpY2tlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJEYXRlcGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlJhbmdlcGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYkJhc2VQaWNrZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIE5iQ2FsZW5kYXJXaXRoVGltZUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBUaGUgYE5iUmFkaW9Db21wb25lbnRgIHByb3ZpZGVzIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkgYXMgbmF0aXZlIGA8aW5wdXQgdHlwZT1cInJhZGlvXCI+YFxuICogd2l0aCBOZWJ1bGFyIHN0eWxlcyBhbmQgYW5pbWF0aW9ucy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCByYWRpby9yYWRpby1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJSYWRpb01vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUmFkaW9Nb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBSYWRpbyBidXR0b25zIHNob3VsZCBiZSB3cmFwcGVkIGluIGBuYi1yYWRpby1ncm91cGAgdG8gcHJvdmlkZSBmb3JtIGJpbmRpbmdzLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1yYWRpby1ncm91cCBbKG5nTW9kZWwpXT1cInNlbGVjdGVkT3B0aW9uXCI+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjFcIj5PcHRpb24gMTwvbmItcmFkaW8+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjJcIj5PcHRpb24gMjwvbmItcmFkaW8+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjNcIj5PcHRpb24gMzwvbmItcmFkaW8+XG4gKiA8L25iLXJhZGlvLWdyb3VwPlxuICogYGBgXG4gKlxuICogWW91IGNhbiBkaXNhYmxlIHNvbWUgcmFkaW9zIGluIHRoZSBncm91cCB1c2luZyBhIGBkaXNhYmxlZGAgYXR0cmlidXRlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQsIHJhZGlvL3JhZGlvLWRpc2FibGVkLmNvbXBvbmVudClcbiAqXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHJhZGlvLXdpZHRoOlxuICogcmFkaW8taGVpZ2h0OlxuICogcmFkaW8tYm9yZGVyLXN0eWxlOlxuICogcmFkaW8tYm9yZGVyLXdpZHRoOlxuICogcmFkaW8tdGV4dC1mb250LWZhbWlseTpcbiAqIHJhZGlvLXRleHQtZm9udC1zaXplOlxuICogcmFkaW8tdGV4dC1mb250LXdlaWdodDpcbiAqIHJhZGlvLXRleHQtbGluZS1oZWlnaHQ6XG4gKiByYWRpby1vdXRsaW5lLWNvbG9yOlxuICogcmFkaW8tb3V0bGluZS13aWR0aDpcbiAqIHJhZGlvLWJhc2ljLXRleHQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1mb2N1cy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtaG92ZXItaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWFjdGl2ZS1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWRpc2FibGVkLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtZGlzYWJsZWQtY2hlY2tlZC1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWZvY3VzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1ob3Zlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktYWN0aXZlLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWRpc2FibGVkLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1kaXNhYmxlZC1jaGVja2VkLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZm9jdXMtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWhvdmVyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1hY3RpdmUtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWRpc2FibGVkLWNoZWNrZWQtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8taW5mby10ZXh0LWNvbG9yOlxuICogcmFkaW8taW5mby1ib3JkZXItY29sb3I6XG4gKiByYWRpby1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1pbmZvLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWluZm8tY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1pbmZvLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8taW5mby1mb2N1cy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8taG92ZXItaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8taW5mby1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiByYWRpby1pbmZvLWFjdGl2ZS1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1pbmZvLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8taW5mby1kaXNhYmxlZC1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZGlzYWJsZWQtY2hlY2tlZC1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLXRleHQtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWZvY3VzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1ob3Zlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctYWN0aXZlLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcmFkaW8td2FybmluZy1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWRpc2FibGVkLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1kaXNhYmxlZC1jaGVja2VkLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci10ZXh0LWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1kYW5nZXItZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWZvY3VzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1ob3Zlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1kYW5nZXItaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiByYWRpby1kYW5nZXItYWN0aXZlLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1kaXNhYmxlZC1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1kaXNhYmxlZC1jaGVja2VkLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZm9jdXMtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWhvdmVyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1hY3RpdmUtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZGlzYWJsZWQtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWRpc2FibGVkLWNoZWNrZWQtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogKi9cbmNsYXNzIE5iUmFkaW9Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNkLCByZW5kZXJlciwgc3RhdHVzU2VydmljZSkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYmx1ciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbmFtZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgfVxuICAgIHNldCBjaGVja2VkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGJvb2xWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja2VkICE9PSBib29sVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBib29sVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYm9vbFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KGRpc2FibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBib29sVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gYm9vbFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1ByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaXNTdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGlzV2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBpc0RhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGlzSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBpc0Jhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBpc0NvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgYWRkaXRpb25hbENsYXNzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1NlcnZpY2UuaXNDdXN0b21TdGF0dXModGhpcy5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc3RhdHVzU2VydmljZS5nZXRTdGF0dXNDbGFzcyh0aGlzLnN0YXR1cyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICogV2UgdXNlIHRoaXMgbWV0aG9kIHdoZW4gc2V0dGluZyByYWRpbyBpbnB1dHMgZnJvbSByYWRpbyBncm91cCBjb21wb25lbnQuXG4gICAgICogT3RoZXJ3aXNlIEFuZ3VsYXIgd29uJ3QgZGV0ZWN0IGNoYW5nZXMgaW4gcmFkaW8gdGVtcGxhdGUgYXMgY2FjaGVkIGxhc3QgcmVuZGVyZWRcbiAgICAgKiB2YWx1ZSBkaWRuJ3QgdXBkYXRlZC5cbiAgICAgKiovXG4gICAgX21hcmtGb3JDaGVjaygpIHtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gc2V0dGluZyByYWRpbyBuYW1lIGZyb20gcmFkaW8gZ3JvdXAgY29tcG9uZW50LlxuICAgICAqIEluIGNhc2Ugb3B0aW9uICduYW1lJyBpc24ndCBzZXQgb24gbmItcmFkaW8gY29tcG9uZW50IHdlIG5lZWQgdG8gc2V0IG5hbWVcbiAgICAgKiByaWdodCBhd2F5LCBzbyBpdCB3b24ndCBvdmVybGFwIHdpdGggb3B0aW9ucyB3aXRob3V0IG5hbWVzIGZyb20gb3RoZXIgcmFkaW9cbiAgICAgKiBncm91cHMuIE90aGVyd2lzZSB0aGV5IGFsbCB3b3VsZCBoYXZlIHNhbWUgbmFtZSBhbmQgd2lsbCBiZSBjb25zaWRlcmVkIGFzXG4gICAgICogb3B0aW9ucyBmcm9tIG9uZSBncm91cCBzbyBvbmx5IHRoZSBsYXN0IG9wdGlvbiB3aWxsIHN0YXkgc2VsZWN0ZWQuXG4gICAgICoqL1xuICAgIF9zZXROYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LCAnbmFtZScsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuTmJSYWRpb0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItcmFkaW8nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGxhYmVsPlxuICAgICAgPGlucHV0XG4gICAgICAgICNpbnB1dFxuICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICBjbGFzcz1cIm5hdGl2ZS1pbnB1dCB2aXN1YWxseS1oaWRkZW5cIlxuICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgW2NoZWNrZWRdPVwiY2hlY2tlZFwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgIChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwib3V0ZXItY2lyY2xlXCI+PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJpbm5lci1jaXJjbGVcIj48L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgPC9zcGFuPlxuICAgIDwvbGFiZWw+XG4gIGAsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0IGxhYmVse2Rpc3BsYXk6aW5saW5lLWZsZXg7bWFyZ2luOjA7bWluLWhlaWdodDppbmhlcml0O3BhZGRpbmc6MC4zNzVyZW0gMDthbGlnbi1pdGVtczpjZW50ZXJ9W2Rpcj1sdHJdIDpob3N0IGxhYmVse3BhZGRpbmctcmlnaHQ6MS41cmVtfVtkaXI9cnRsXSA6aG9zdCBsYWJlbHtwYWRkaW5nLWxlZnQ6MS41cmVtfTpob3N0IC5vdXRlci1jaXJjbGUsOmhvc3QgLmlubmVyLWNpcmNsZXtib3JkZXItcmFkaXVzOjUwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfVtkaXI9bHRyXSA6aG9zdCAub3V0ZXItY2lyY2xlLFtkaXI9bHRyXSA6aG9zdCAuaW5uZXItY2lyY2xle2xlZnQ6MH1bZGlyPXJ0bF0gOmhvc3QgLm91dGVyLWNpcmNsZSxbZGlyPXJ0bF0gOmhvc3QgLmlubmVyLWNpcmNsZXtyaWdodDowfTpob3N0IC5pbm5lci1jaXJjbGV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSkgc2NhbGUoMC42KX1bZGlyPWx0cl0gOmhvc3QgLnRleHR7cGFkZGluZy1sZWZ0Oi41cmVtfVtkaXI9cnRsXSA6aG9zdCAudGV4dHtwYWRkaW5nLXJpZ2h0Oi41cmVtfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlJhZGlvQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlJhZGlvQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIG5hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNoZWNrZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHZhbHVlOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc3RhdHVzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB2YWx1ZUNoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIGJsdXI6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBpbnB1dDogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2lucHV0JywgeyByZWFkOiBFbGVtZW50UmVmIH0sXSB9XSxcbiAgICBpc1ByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIGlzU3VjY2VzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnLF0gfV0sXG4gICAgaXNXYXJuaW5nOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtd2FybmluZycsXSB9XSxcbiAgICBpc0RhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBpc0luZm86IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1pbmZvJyxdIH1dLFxuICAgIGlzQmFzaWM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1iYXNpYycsXSB9XSxcbiAgICBpc0NvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJSYWRpb0dyb3VwQ29tcG9uZW50YCBpcyB0aGUgd3JhcHBlciBmb3IgYG5iLXJhZGlvYCBidXR0b24uXG4gKiBJdCBwcm92aWRlcyBmb3JtIGJpbmRpbmdzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1yYWRpby1ncm91cCBbKG5nTW9kZWwpXT1cInNlbGVjdGVkT3B0aW9uXCI+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjFcIj5PcHRpb24gMTwvbmItcmFkaW8+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjJcIj5PcHRpb24gMjwvbmItcmFkaW8+XG4gKiAgIDxuYi1yYWRpbyB2YWx1ZT1cIjNcIj5PcHRpb24gMzwvbmItcmFkaW8+XG4gKiA8L25iLXJhZGlvLWdyb3VwPlxuICogYGBgXG4gKlxuICogQWxzbywgeW91IGNhbiB1c2UgYHZhbHVlYCBhbmQgYHZhbHVlQ2hhbmdlYCBmb3IgYmluZGluZyB3aXRob3V0IGZvcm1zLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1yYWRpby1ncm91cCBbKHZhbHVlKV09XCJzZWxlY3RlZE9wdGlvblwiPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIxXCI+T3B0aW9uIDE8L25iLXJhZGlvPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIyXCI+T3B0aW9uIDI8L25iLXJhZGlvPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIzXCI+T3B0aW9uIDM8L25iLXJhZGlvPlxuICogPC9uYi1yYWRpby1ncm91cD5cbiAqIGBgYFxuICpcbiAqIFJhZGlvIGl0ZW1zIG5hbWUgaGFzIHRvIGJlIHByb3ZpZGVkIHRocm91Z2ggYG5hbWVgIGlucHV0IHByb3BlcnR5IG9mIHRoZSByYWRpbyBncm91cC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItcmFkaW8tZ3JvdXAgbmFtZT1cIm15LXJhZGlvLWdyb3VwXCI+XG4gKiAgIC4uLlxuICogPC9uYi1yYWRpby1ncm91cD5cbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIHJhZGlvIGdyb3VwIHN0YXR1cyBieSBzZXR0aW5nIGBzdGF0dXNgIGlucHV0LlxuICogQHN0YWNrZWQtZXhhbXBsZShTdGF0dXNlcywgcmFkaW8vcmFkaW8tc3RhdHVzZXMuY29tcG9uZW50KVxuICpcbiAqIEFsc28sIHlvdSBjYW4gZGlzYWJsZSB0aGUgd2hvbGUgZ3JvdXAgdXNpbmcgYGRpc2FibGVkYCBhdHRyaWJ1dGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIGdyb3VwLCByYWRpby9yYWRpby1kaXNhYmxlZC1ncm91cC5jb21wb25lbnQpXG4gKlxuICogKi9cbmNsYXNzIE5iUmFkaW9Hcm91cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdEVsZW1lbnQsIHBsYXRmb3JtSWQsIGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuaG9zdEVsZW1lbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICh2YWx1ZSkgPT4geyB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudXBkYXRlTmFtZXMoKTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eShkaXNhYmxlZCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGlzYWJsZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFkaW8gYnV0dG9ucyBzdGF0dXMuXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgcHJpbWFyeWAgKGRlZmF1bHQpLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBpbmZvYC5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXMgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICAvLyBJbiBjYXNlIG9wdGlvbiAnbmFtZScgaXNuJ3Qgc2V0IG9uIG5iLXJhZGlvIGNvbXBvbmVudCxcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzZXQgaXQncyBuYW1lIHJpZ2h0IGF3YXksIHNvIGl0IHdvbid0IG92ZXJsYXAgd2l0aCBvcHRpb25zXG4gICAgICAgIC8vIHdpdGhvdXQgbmFtZXMgZnJvbSBvdGhlciByYWRpbyBncm91cHMuIE90aGVyd2lzZSB0aGV5IGFsbCB3b3VsZCBoYXZlXG4gICAgICAgIC8vIHNhbWUgbmFtZSBhbmQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIG9wdGlvbnMgZnJvbSBvbmUgZ3JvdXAgc28gb25seSB0aGVcbiAgICAgICAgLy8gbGFzdCBvcHRpb24gd2lsbCBzdGF5IHNlbGVjdGVkLlxuICAgICAgICB0aGlzLnVwZGF0ZU5hbWVzKCk7XG4gICAgICAgIHRoaXMucmFkaW9zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLnJhZGlvcyksIFxuICAgICAgICAvLyAnY2hhbmdlcycgZW1pdCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvbiBydW4gYW5kIHdlIGNhbid0IHVwZGF0ZVxuICAgICAgICAvLyBvcHRpb24gcHJvcGVydGllcyByaWdodCBvZiBzaW5jZSB0aGV5IGFscmVhZHkgd2FzIGluaXRpYWxpemVkLlxuICAgICAgICAvLyBJbnN0ZWFkIHdlIHNjaGVkdWxlIG1pY3JvdGFzayB0byB1cGRhdGUgcmFkaW9zIGFmdGVyIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgLy8gcnVuIGlzIGZpbmlzaGVkIGFuZCB0cmlnZ2VyIG9uZSBtb3JlIGNoYW5nZSBkZXRlY3Rpb24gcnVuLlxuICAgICAgICBzd2l0Y2hNYXAoKHJhZGlvcykgPT4gZnJvbShQcm9taXNlLnJlc29sdmUocmFkaW9zKSkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlQW5kU3Vic2NyaWJlVG9SYWRpb3MoKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHVwZGF0ZUFuZFN1YnNjcmliZVRvUmFkaW9zKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlRnJvbUNoZWNrZWRPcHRpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVOYW1lcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25SYWRpb3NWYWx1ZUNoYW5nZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uUmFkaW9zQmx1cigpO1xuICAgIH1cbiAgICB1cGRhdGVOYW1lcygpIHtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9zKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGlvcy5mb3JFYWNoKChyYWRpbykgPT4gcmFkaW8uX3NldE5hbWUodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmFsdWVzKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE1hcmtGb3JDaGVja1JhZGlvcygocmFkaW8pID0+IHJhZGlvLmNoZWNrZWQgPSByYWRpby52YWx1ZSA9PT0gdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHVwZGF0ZURpc2FibGVkKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuZE1hcmtGb3JDaGVja1JhZGlvcygocmFkaW8pID0+IHJhZGlvLmRpc2FibGVkID0gdGhpcy5kaXNhYmxlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlT25SYWRpb3NWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJhZGlvcyB8fCAhdGhpcy5yYWRpb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2UoLi4udGhpcy5yYWRpb3MubWFwKChyYWRpbykgPT4gcmFkaW8udmFsdWVDaGFuZ2UpKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKG1lcmdlKHRoaXMucmFkaW9zLmNoYW5nZXMsIHRoaXMuZGVzdHJveSQpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9wYWdhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25SYWRpb3NCbHVyKCkge1xuICAgICAgICBjb25zdCBoYXNOb1JhZGlvcyA9ICF0aGlzLnJhZGlvcyB8fCAhdGhpcy5yYWRpb3MubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgfHwgaGFzTm9SYWRpb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZnJvbUV2ZW50KGhvc3RFbGVtZW50LCAnZm9jdXNpbicpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoZXZlbnQgPT4gaG9zdEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSksIHN3aXRjaE1hcCgoKSA9PiBtZXJnZShmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ2ZvY3VzaW4nKSwgZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdjbGljaycpKSksIGZpbHRlcihldmVudCA9PiAhaG9zdEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSksIHRha2VVbnRpbChtZXJnZSh0aGlzLnJhZGlvcy5jaGFuZ2VzLCB0aGlzLmRlc3Ryb3kkKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Ub3VjaGVkKCkpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQW5kTWFya0ZvckNoZWNrUmFkaW9zKChyYWRpbykgPT4gcmFkaW8uc3RhdHVzID0gdGhpcy5zdGF0dXMpO1xuICAgIH1cbiAgICB1cGRhdGVBbmRNYXJrRm9yQ2hlY2tSYWRpb3ModXBkYXRlRm4pIHtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9zKSB7XG4gICAgICAgICAgICB0aGlzLnJhZGlvcy5mb3JFYWNoKChyYWRpbykgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZuKHJhZGlvKTtcbiAgICAgICAgICAgICAgICByYWRpby5fbWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVWYWx1ZUZyb21DaGVja2VkT3B0aW9uKCkge1xuICAgICAgICBjb25zdCBjaGVja2VkUmFkaW8gPSB0aGlzLnJhZGlvcy5maW5kKChyYWRpbykgPT4gcmFkaW8uY2hlY2tlZCk7XG4gICAgICAgIGNvbnN0IGlzVmFsdWVNaXNzaW5nID0gdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09IG51bGw7XG4gICAgICAgIGlmIChjaGVja2VkUmFkaW8gJiYgaXNWYWx1ZU1pc3NpbmcgJiYgY2hlY2tlZFJhZGlvLnZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gY2hlY2tlZFJhZGlvLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuTmJSYWRpb0dyb3VwQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1yYWRpby1ncm91cCcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1yYWRpb1wiPjwvbmctY29udGVudD5gLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iUmFkaW9Hcm91cENvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iUmFkaW9Hcm91cENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ET0NVTUVOVCxdIH1dIH1cbl07XG5OYlJhZGlvR3JvdXBDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdmFsdWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIG5hbWU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGRpc2FibGVkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzdGF0dXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHJhZGlvczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmJSYWRpb0NvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgdmFsdWVDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYlJhZGlvTW9kdWxlIHtcbn1cbk5iUmFkaW9Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYlJhZGlvQ29tcG9uZW50LCBOYlJhZGlvR3JvdXBDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW05iUmFkaW9Db21wb25lbnQsIE5iUmFkaW9Hcm91cENvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xubGV0IHRhZ1VuaXF1ZUlkID0gMDtcbi8qKlxuICpcbiAqIFRvIHNob3cgYSBjcm9zcyBvbiBhIHRhZyBhbmQgZW5hYmxlIGByZW1vdmVgIGV2ZW50IGFkZCB0aGUgYHJlbW92YWJsZWAgYXR0cmlidXRlLlxuICogQHN0YWNrZWQtZXhhbXBsZShSZW1vdmFibGUgdGFncywgdGFnL3RhZy1yZW1vdmFibGUuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gY2hhbmdlIGFwcGVhcmFuY2UgdmlhIGBhcHBlYXJhbmNlYCBpbnB1dDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVGFnIEFwcGVhcmFuY2UsIHRhZy90YWctYXBwZWFyYW5jZS5jb21wb25lbnQpXG4gKlxuICogWW91IGNhbiBjaGFuZ2Ugc3RhdHVzIHZpYSBgc3RhdHVzYCBpbnB1dDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVGFnIFN0YXR1cywgdGFnL3RhZy1zdGF0dXMuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0YWctdGV4dC1mb250LWZhbWlseTpcbiAqIHRhZy10ZXh0LXRyYW5zZm9ybTpcbiAqIHRhZy1ib3JkZXItd2lkdGg6XG4gKiB0YWctYm9yZGVyLXN0eWxlOlxuICogdGFnLWJvcmRlci1yYWRpdXM6XG4gKiB0YWctdGlueS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRhZy10aW55LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0YWctdGlueS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFnLXRpbnktcGFkZGluZzpcbiAqIHRhZy10aW55LWNsb3NlLW9mZnNldDpcbiAqIHRhZy1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRhZy1zbWFsbC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGFnLXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0YWctc21hbGwtcGFkZGluZzpcbiAqIHRhZy1zbWFsbC1jbG9zZS1vZmZzZXQ6XG4gKiB0YWctbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICogdGFnLW1lZGl1bS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGFnLW1lZGl1bS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFnLW1lZGl1bS1wYWRkaW5nOlxuICogdGFnLW1lZGl1bS1jbG9zZS1vZmZzZXQ6XG4gKiB0YWctbGFyZ2UtdGV4dC1mb250LXNpemU6XG4gKiB0YWctbGFyZ2UtdGV4dC1mb250LXdlaWdodDpcbiAqIHRhZy1sYXJnZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFnLWxhcmdlLXBhZGRpbmc6XG4gKiB0YWctbGFyZ2UtY2xvc2Utb2Zmc2V0OlxuICogdGFnLWdpYW50LXRleHQtZm9udC1zaXplOlxuICogdGFnLWdpYW50LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0YWctZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRhZy1naWFudC1wYWRkaW5nOlxuICogdGFnLWdpYW50LWNsb3NlLW9mZnNldDpcbiAqIHRhZy1maWxsZWQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1iYXNpYy10ZXh0LWNvbG9yOlxuICogdGFnLWZpbGxlZC1iYXNpYy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtYmFzaWMtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1iYXNpYy1zZWxlY3RlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1iYXNpYy1zZWxlY3RlZC1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtcHJpbWFyeS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtcHJpbWFyeS1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1wcmltYXJ5LXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXByaW1hcnktc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXN1Y2Nlc3MtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXN1Y2Nlc3MtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtc3VjY2Vzcy1zZWxlY3RlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1zdWNjZXNzLXNlbGVjdGVkLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtaW5mby10ZXh0LWNvbG9yOlxuICogdGFnLWZpbGxlZC1pbmZvLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLWluZm8tc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtaW5mby1zZWxlY3RlZC1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtd2FybmluZy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtd2FybmluZy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC13YXJuaW5nLXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctZmlsbGVkLXdhcm5pbmctc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiB0YWctZmlsbGVkLWRhbmdlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLWZpbGxlZC1kYW5nZXItc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtZGFuZ2VyLXNlbGVjdGVkLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1maWxsZWQtY29udHJvbC10ZXh0LWNvbG9yOlxuICogdGFnLWZpbGxlZC1jb250cm9sLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLWZpbGxlZC1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0YWctZmlsbGVkLWNvbnRyb2wtc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1maWxsZWQtY29udHJvbC1zZWxlY3RlZC1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWJhc2ljLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWJhc2ljLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWJhc2ljLWhvdmVyLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1iYXNpYy1zZWxlY3RlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtYmFzaWMtc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtcHJpbWFyeS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktYWN0aXZlLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktaG92ZXItdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXByaW1hcnktc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtcHJpbWFyeS1zZWxlY3RlZC10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1zdWNjZXNzLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1ob3Zlci10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1zZWxlY3RlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtc3VjY2Vzcy1zZWxlY3RlZC1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1zdWNjZXNzLXNlbGVjdGVkLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWluZm8tdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtaW5mby1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLWhvdmVyLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1pbmZvLXNlbGVjdGVkLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWluZm8tc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtd2FybmluZy10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtd2FybmluZy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctYWN0aXZlLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctaG92ZXItdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLXdhcm5pbmctc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtd2FybmluZy1zZWxlY3RlZC10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1kYW5nZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1kYW5nZXItYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWRhbmdlci1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWRhbmdlci1ob3Zlci10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtZGFuZ2VyLXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1kYW5nZXItc2VsZWN0ZWQtYm9yZGVyLWNvbG9yOlxuICogdGFnLW91dGxpbmUtZGFuZ2VyLXNlbGVjdGVkLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWNvbnRyb2wtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogdGFnLW91dGxpbmUtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFnLW91dGxpbmUtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLWhvdmVyLXRleHQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLXNlbGVjdGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWctb3V0bGluZS1jb250cm9sLXNlbGVjdGVkLWJvcmRlci1jb2xvcjpcbiAqIHRhZy1vdXRsaW5lLWNvbnRyb2wtc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqL1xuY2xhc3MgTmJUYWdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKF9ob3N0RWxlbWVudCwgY2QsIHJlbmRlcmVyLCB6b25lLCBzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX2hvc3RFbGVtZW50ID0gX2hvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZW1vdmFibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhZyBhcHBlYXJhbmNlOiBgZmlsbGVkYCwgYG91dGxpbmVgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2ZpbGxlZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWcgc3RhdHVzOiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWcgc2l6ZTogYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCwgYGxhcmdlYCwgYGdpYW50YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLnJvbGUgPSAnb3B0aW9uJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgcmVtb3ZlcyB0aGUgdGFnXG4gICAgICAgICAqICh3aGV0aGVyIGJ5IGNsaWNraW5nIG9uIHRoZSByZW1vdmUgYnV0dG9uIG9yIGJ5IHByZXNzaW5nIGBkZWxldGVgIG9yIGBiYWNrc3BhY2VgIGtleSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbW92ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSBgbmItdGFnLSR7dGFnVW5pcXVlSWQrK31gO1xuICAgIH1cbiAgICBnZXQgZGVzdHJveSQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95JC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh7IHRhZzogdGhpcywgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hldGhlciB0aGUgdXNlciBjYW4gcmVtb3ZlIGEgdGFnIG9yIG5vdC5cbiAgICAgKi9cbiAgICBnZXQgcmVtb3ZhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZhYmxlO1xuICAgIH1cbiAgICBzZXQgcmVtb3ZhYmxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92YWJsZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBmaWxsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdmaWxsZWQnO1xuICAgIH1cbiAgICBzZXQgZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZmlsbGVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3V0bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ291dGxpbmUnO1xuICAgIH1cbiAgICBzZXQgb3V0bGluZSh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ291dGxpbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCBhZGRpdGlvbmFsQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzU2VydmljZS5pc0N1c3RvbVN0YXR1cyh0aGlzLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMuc3RhdHVzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBfcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5yZW1vdmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlLmVtaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBUT0RPOiAjMjI1NFxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2hvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICduYi10cmFuc2l0aW9uJyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kkLm5leHQodGhpcyk7XG4gICAgfVxuICAgIF90b2dnbGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgc2V0QWN0aXZlU3R5bGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEluYWN0aXZlU3R5bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuTmJUYWdDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRhZycsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwie3sgdGV4dCB9fVxcbjxuYi1pY29uICpuZ0lmPVxcXCJyZW1vdmFibGVcXFwiXFxuICAgICAgICAgKGNsaWNrKT1cXFwiX3JlbW92ZSgpXFxcIlxcbiAgICAgICAgIGNsYXNzPVxcXCJuYi10YWctcmVtb3ZlIHNpemUte3tzaXplfX1cXFwiXFxuICAgICAgICAgaWNvbj1cXFwiY2xvc2Utb3V0bGluZVxcXCJcXG4gICAgICAgICBwYWNrPVxcXCJuZWJ1bGFyLWVzc2VudGlhbHNcXFwiXFxuICAgICAgICAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcbjwvbmItaWNvbj5cXG5cIixcbiAgICAgICAgICAgICAgICBleHBvcnRBczogJ25iVGFnJyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRhZ0NvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlRhZ0NvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0ZXh0OiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzZWxlY3RlZDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zZWxlY3RlZCcsXSB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuYXJpYS1zZWxlY3RlZCcsXSB9XSxcbiAgICByZW1vdmFibGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGFwcGVhcmFuY2U6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgc2l6ZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLnJvbGUnLF0gfV0sXG4gICAgcmVtb3ZlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgc2VsZWN0ZWRDaGFuZ2U6IFt7IHR5cGU6IE91dHB1dCB9XSxcbiAgICBfaXNBY3RpdmU6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmFjdGl2ZScsXSB9XSxcbiAgICBfaWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIuaWQnLF0gfV0sXG4gICAgZmlsbGVkOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hcHBlYXJhbmNlLWZpbGxlZCcsXSB9XSxcbiAgICBvdXRsaW5lOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5hcHBlYXJhbmNlLW91dGxpbmUnLF0gfV0sXG4gICAgYmFzaWM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1iYXNpYycsXSB9XSxcbiAgICBwcmltYXJ5OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtcHJpbWFyeScsXSB9XSxcbiAgICBzdWNjZXNzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtc3VjY2VzcycsXSB9XSxcbiAgICBpbmZvOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtaW5mbycsXSB9XSxcbiAgICB3YXJuaW5nOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtd2FybmluZycsXSB9XSxcbiAgICBkYW5nZXI6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1kYW5nZXInLF0gfV0sXG4gICAgY29udHJvbDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWNvbnRyb2wnLF0gfV0sXG4gICAgdGlueTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS10aW55JyxdIH1dLFxuICAgIHNtYWxsOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zaXplLXNtYWxsJyxdIH1dLFxuICAgIG1lZGl1bTogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc2l6ZS1tZWRpdW0nLF0gfV0sXG4gICAgbGFyZ2U6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtbGFyZ2UnLF0gfV0sXG4gICAgZ2lhbnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnNpemUtZ2lhbnQnLF0gfV0sXG4gICAgYWRkaXRpb25hbENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dLFxuICAgIF9yZW1vdmU6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydrZXlkb3duLmRlbGV0ZScsXSB9LCB7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydrZXlkb3duLmJhY2tzcGFjZScsXSB9XVxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKlxuICogYFtuYlRhZ0lucHV0XWAgZGlyZWN0aXZlIGNvbm5lY3RzIGlucHV0IHdpdGggYSBgbmItdGFnLWxpc3RgIGNvbXBvbmVudC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFRhZyBJbnB1dCwgdGFnL3RhZy1pbnB1dC5jb21wb25lbnQpXG4gKlxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShUYWcgSW5wdXQgd2l0aCBBdXRvY29tcGxldGUsIHRhZy90YWctaW5wdXQtd2l0aC1hdXRvY29tcGxldGUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0YWctbGlzdC10aW55LXRhZy1vZmZzZXQ6XG4gKiB0YWctbGlzdC1zbWFsbC10YWctb2Zmc2V0OlxuICogdGFnLWxpc3QtbWVkaXVtLXRhZy1vZmZzZXQ6XG4gKiB0YWctbGlzdC1sYXJnZS10YWctb2Zmc2V0OlxuICogdGFnLWxpc3QtZ2lhbnQtdGFnLW9mZnNldDpcbiAqIHRhZy1saXN0LXdpdGgtaW5wdXQtdGlueS1wYWRkaW5nOlxuICogdGFnLWxpc3Qtd2l0aC1pbnB1dC1zbWFsbC1wYWRkaW5nOlxuICogdGFnLWxpc3Qtd2l0aC1pbnB1dC1tZWRpdW0tcGFkZGluZzpcbiAqIHRhZy1saXN0LXdpdGgtaW5wdXQtbGFyZ2UtcGFkZGluZzpcbiAqIHRhZy1saXN0LXdpdGgtaW5wdXQtZ2lhbnQtcGFkZGluZzpcbiAqL1xuY2xhc3MgTmJUYWdJbnB1dERpcmVjdGl2ZSBleHRlbmRzIE5iSW5wdXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKF9ob3N0RWxlbWVudCwgZm9jdXNNb25pdG9yLCByZW5kZXJlciwgem9uZSwgc3RhdHVzU2VydmljZSkge1xuICAgICAgICBzdXBlcihfaG9zdEVsZW1lbnQsIGZvY3VzTW9uaXRvciwgcmVuZGVyZXIsIHpvbmUsIHN0YXR1c1NlcnZpY2UpO1xuICAgICAgICB0aGlzLl9ob3N0RWxlbWVudCA9IF9ob3N0RWxlbWVudDtcbiAgICAgICAgdGhpcy5mb2N1c01vbml0b3IgPSBmb2N1c01vbml0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTZXJ2aWNlID0gc3RhdHVzU2VydmljZTtcbiAgICAgICAgdGhpcy5rZXlEb3duJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB3aGljaCBrZXlzIHNob3VsZCB0cmlnZ2VyIHRhZyBhZGQgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcGFyYXRvcktleXMgPSBbRU5URVJdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbiBhIHRhZyBuZWVkIHRvIGJlIGFkZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdBZGQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubmJUYWdJbnB1dENsYXNzID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IF92YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIF9vbktleWRvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5rZXlEb3duJC5uZXh0KGV2ZW50KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyVmlld0luaXQoKTtcbiAgICAgICAgdGhpcy5rZXlEb3duJFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IGtleUNvZGUgfSkgPT4gdGhpcy5pc1NlcGFyYXRvcktleShrZXlDb2RlKSksIG1hcCgoKSA9PiB0aGlzLl92YWx1ZSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLnRhZ0FkZC5lbWl0KHsgdmFsdWUsIGlucHV0OiB0aGlzLl9ob3N0RWxlbWVudCB9KSk7XG4gICAgfVxuICAgIGlzU2VwYXJhdG9yS2V5KGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VwYXJhdG9yS2V5cy5pbmNsdWRlcyhrZXlDb2RlKTtcbiAgICB9XG59XG5OYlRhZ0lucHV0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtuYlRhZ0lucHV0XScsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduYlRhZ0lucHV0JyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkZvcm1GaWVsZENvbnRyb2wsIHVzZUV4aXN0aW5nOiBOYlRhZ0lucHV0RGlyZWN0aXZlIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUYWdJbnB1dERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IE5iRm9jdXNNb25pdG9yIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJTdGF0dXNTZXJ2aWNlIH1cbl07XG5OYlRhZ0lucHV0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNlcGFyYXRvcktleXM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhZ0FkZDogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIG5iVGFnSW5wdXRDbGFzczogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MubmItdGFnLWlucHV0JyxdIH1dLFxuICAgIF9vbktleWRvd246IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydrZXlkb3duJywgWyckZXZlbnQnXSxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqXG4gKiBgbmItdGFnLWxpc3RgIGNvbXBvbmVudCBkaXNwbGF5cyBhIGxpc3Qgb2YgYG5iLXRhZ2AgY29tcG9uZW50cy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFRhZyBMaXN0IFNob3djYXNlLCB0YWcvdGFnLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogdGFnLWxpc3QtdGlueS10YWctb2Zmc2V0OlxuICogdGFnLWxpc3Qtc21hbGwtdGFnLW9mZnNldDpcbiAqIHRhZy1saXN0LW1lZGl1bS10YWctb2Zmc2V0OlxuICogdGFnLWxpc3QtbGFyZ2UtdGFnLW9mZnNldDpcbiAqIHRhZy1saXN0LWdpYW50LXRhZy1vZmZzZXQ6XG4gKiB0YWctbGlzdC13aXRoLWlucHV0LXRpbnktcGFkZGluZzpcbiAqIHRhZy1saXN0LXdpdGgtaW5wdXQtc21hbGwtcGFkZGluZzpcbiAqIHRhZy1saXN0LXdpdGgtaW5wdXQtbWVkaXVtLXBhZGRpbmc6XG4gKiB0YWctbGlzdC13aXRoLWlucHV0LWxhcmdlLXBhZGRpbmc6XG4gKiB0YWctbGlzdC13aXRoLWlucHV0LWdpYW50LXBhZGRpbmc6XG4gKiB0YWctbGlzdC13aXRoLWlucHV0LXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogdGFnLWxpc3Qtd2l0aC1pbnB1dC1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiB0YWctbGlzdC13aXRoLWlucHV0LXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKi9cbmNsYXNzIE5iVGFnTGlzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoaG9zdEVsZW1lbnQsIGNkLCByZW5kZXJlciwgem9uZSwgZm9jdXNNb25pdG9yLCBhY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlckZhY3RvcnksIGRpcmVjdGlvblNlcnZpY2UsIHN0YXR1c1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcbiAgICAgICAgdGhpcy5mb2N1c01vbml0b3IgPSBmb2N1c01vbml0b3I7XG4gICAgICAgIHRoaXMuYWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5ID0gYWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLmRpcmVjdGlvblNlcnZpY2UgPSBkaXJlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5rZXlEb3duJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMudGFnQ2xpY2skID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB0YWdzIG9mZnNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yb2xlID0gJ2xpc3Rib3gnO1xuICAgICAgICB0aGlzLl9tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZVRhZ0lkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gdGFnIG5lZWQgdG8gYmUgcmVtb3ZlZCAod2hldGhlciBiZWNhdXNlIG9mIGNsaWNrIG9uIHRoZSByZW1vdmUgYnV0dG9uXG4gICAgICAgICAqIG9yIHdoZW4gYGRlbGV0ZWAgb3IgYGJhY2tzcGFjZWAga2V5IHByZXNzZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdSZW1vdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBtdWx0aXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpcGxlO1xuICAgIH1cbiAgICBzZXQgbXVsdGlwbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgX2hhc0lucHV0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnRhZ0lucHV0O1xuICAgIH1cbiAgICBnZXQgX2lzRm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNlZDtcbiAgICB9XG4gICAgZ2V0IF9pc0Z1bGxXaWR0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gISEoKF9hID0gdGhpcy50YWdJbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZ1bGxXaWR0aCk7XG4gICAgfVxuICAgIGdldCBfaW5wdXRDbGFzc2VzKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYHNoYXBlLSR7dGhpcy50YWdJbnB1dC5zaGFwZX1gLFxuICAgICAgICAgICAgICAgIGBzaXplLSR7dGhpcy50YWdJbnB1dC5maWVsZFNpemV9YCxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UuZ2V0U3RhdHVzQ2xhc3ModGhpcy50YWdJbnB1dC5zdGF0dXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2BzaXplLSR7dGhpcy5zaXplfWBdO1xuICAgIH1cbiAgICBfb25LZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIHRoaXMua2V5RG93biQubmV4dChldmVudCk7XG4gICAgfVxuICAgIF9vbkNsaWNrKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgY29uc3QgY2xpY2tlZFRhZyA9IHRoaXMudGFncy5maW5kKCh0YWcpID0+IHRhZy5faG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgaWYgKGNsaWNrZWRUYWcpIHtcbiAgICAgICAgICAgIHRoaXMudGFnQ2xpY2skLm5leHQoY2xpY2tlZFRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNNb25pdG9yLm1vbml0b3IodGhpcy5ob3N0RWxlbWVudCwgdHJ1ZSlcbiAgICAgICAgICAgIC5waXBlKG1hcChvcmlnaW4gPT4gISFvcmlnaW4pLCBmaW5hbGl6ZSgoKSA9PiB0aGlzLmZvY3VzTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLmhvc3RFbGVtZW50KSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGlzRm9jdXNlZCkgPT4gdGhpcy5vbkZvY3VzQ2hhbmdlKGlzRm9jdXNlZCkpO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdEtleU1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5zZXRBdXRvY29tcGxldGVDdXN0b21Ib3N0KCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ub0xheW91dERpcmVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB0aGlzLmxpc3Rlbkxpc3RLZXlEb3duKCk7XG4gICAgICAgIHRoaXMubGlzdGVuSW5wdXRLZXlEb3duKCk7XG4gICAgICAgIHRoaXMubGlzdGVuVGFnQ2xpY2soKTtcbiAgICAgICAgdGhpcy5saXN0ZW5UYWdSZW1vdmUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5UYWdEZXN0cm95KCk7XG4gICAgICAgIHRoaXMubGlzdGVuQWN0aXZlVGFnQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMubGlzdGVuTm9UYWdzKCk7XG4gICAgICAgIC8vIFRPRE86ICMyMjU0XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbmItdHJhbnNpdGlvbicpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICB9XG4gICAgaW5pdEtleU1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMua2V5TWFuYWdlciA9IHRoaXMuYWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5XG4gICAgICAgICAgICAuY3JlYXRlKHRoaXMudGFncylcbiAgICAgICAgICAgIC53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKHRoaXMuZGlyZWN0aW9uU2VydmljZS5nZXREaXJlY3Rpb24oKSlcbiAgICAgICAgICAgIC53aXRoV3JhcCgpO1xuICAgIH1cbiAgICBsaXN0ZW5Ub0xheW91dERpcmVjdGlvbkNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRpcmVjdGlvbikgPT4gdGhpcy5rZXlNYW5hZ2VyLndpdGhIb3Jpem9udGFsT3JpZW50YXRpb24oZGlyZWN0aW9uKSk7XG4gICAgfVxuICAgIGxpc3Rlbkxpc3RLZXlEb3duKCkge1xuICAgICAgICBjb25zdCB0YWdMaXN0S2V5RG93biQgPSB0aGlzLmtleURvd24kXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsgdGFyZ2V0IH0pID0+IHRhcmdldCA9PT0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhZ0tleURvd24kID0gdGFnTGlzdEtleURvd24kXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gISF0aGlzLmtleU1hbmFnZXIuYWN0aXZlSXRlbSkpO1xuICAgICAgICB0YWdMaXN0S2V5RG93biRcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50KSA9PiB0aGlzLmtleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KSk7XG4gICAgICAgIGFjdGl2ZVRhZ0tleURvd24kXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKHsga2V5Q29kZSB9KSA9PiBrZXlDb2RlID09PSBTUEFDRSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRhZyh0aGlzLmtleU1hbmFnZXIuYWN0aXZlSXRlbSk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWdlIHNjcm9sbC5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3RpdmVUYWdLZXlEb3duJFxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IGtleUNvZGUgfSkgPT4gdGhpcy5pc0JhY2tzcGFjZU9yRGVsZXRlKGtleUNvZGUpKSwgbWFwKCgpID0+IHRoaXMua2V5TWFuYWdlci5hY3RpdmVJdGVtKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgodGFnVG9SZW1vdmUpID0+IHRhZ1RvUmVtb3ZlLl9yZW1vdmUoKSk7XG4gICAgfVxuICAgIGxpc3RlbklucHV0S2V5RG93bigpIHtcbiAgICAgICAgY29uc3QgaW5wdXRLZXlEb3duJCA9IHRoaXMua2V5RG93biRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyB0YXJnZXQgfSkgPT4geyB2YXIgX2E7IHJldHVybiB0YXJnZXQgPT09ICgoX2EgPSB0aGlzLnRhZ0lucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2hvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpOyB9KSk7XG4gICAgICAgIGlucHV0S2V5RG93biRcbiAgICAgICAgICAgIC5waXBlKGZpbHRlcigoeyBrZXlDb2RlIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhZ0lucHV0Ll92YWx1ZSA9PT0gJycgJiYgdGhpcy5pc0JhY2tzcGFjZU9yRGVsZXRlKGtleUNvZGUpICYmIHRoaXMudGFncy5sZW5ndGggPiAwO1xuICAgICAgICB9KSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlblRhZ0NsaWNrKCkge1xuICAgICAgICB0aGlzLnRhZ0NsaWNrJFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoY2xpY2tlZFRhZykgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUYWcoY2xpY2tlZFRhZyk7XG4gICAgICAgICAgICB0aGlzLmtleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShjbGlja2VkVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlblRhZ1JlbW92ZSgpIHtcbiAgICAgICAgdGhpcy50YWdzLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLnRhZ3MpLCBzd2l0Y2hNYXAoKHRhZ3MpID0+IG1lcmdlKC4uLnRhZ3MubWFwKCh0YWcpID0+IHRhZy5yZW1vdmUpKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHRhZ1RvUmVtb3ZlKSA9PiB0aGlzLnRhZ1JlbW92ZS5lbWl0KHRhZ1RvUmVtb3ZlKSk7XG4gICAgfVxuICAgIGxpc3RlblRhZ0Rlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudGFncy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodGhpcy50YWdzKSwgc3dpdGNoTWFwKCh0YWdzKSA9PiBtZXJnZSguLi50YWdzLm1hcCgodGFnKSA9PiB0YWcuZGVzdHJveSQpKSksIGZpbHRlcigoZGVzdHJveWVkVGFnKSA9PiBkZXN0cm95ZWRUYWcgPT09IHRoaXMua2V5TWFuYWdlci5hY3RpdmVJdGVtKSwgbWFwKChkZXN0cm95ZWRUYWcpID0+IGRlc3Ryb3llZFRhZyA9PT0gdGhpcy50YWdzLmxhc3QpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChpc0xhc3RUYWdEZXN0cm95ZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0xhc3RUYWdEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleU1hbmFnZXIuc2V0UHJldmlvdXNJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleU1hbmFnZXIuc2V0TmV4dEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3Rlbk5vVGFncygpIHtcbiAgICAgICAgdGhpcy50YWdzLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLnRhZ3MpLCBmaWx0ZXIoKHRhZ3MpID0+IHRhZ3MubGVuZ3RoID09PSAwKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmZvY3VzSW5wdXQoKSk7XG4gICAgfVxuICAgIGxpc3RlbkFjdGl2ZVRhZ0NoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLmNoYW5nZVxuICAgICAgICAgICAgLnBpcGUobWFwKCgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5faWQ7IH0pLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChhY3RpdmVUYWdJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYWdJZCA9IGFjdGl2ZVRhZ0lkO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRm9jdXNDaGFuZ2UoaXNGb2N1c2VkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gaXNGb2N1c2VkO1xuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICBpZiAoIWlzRm9jdXNlZCB8fCAoKF9hID0gdGhpcy50YWdJbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzZWQkLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oLTEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvY3VzIGlucHV0IHdoZW4gZm9jdXNpbmcgdGFnIGxpc3Qgd2l0aG91dCB0YWdzLiBPdGhlcndpc2Ugc2VsZWN0IGZpcnN0IHRhZy5cbiAgICAgICAgaWYgKHRoaXMudGFncy5sZW5ndGggPT09IDAgJiYgdGhpcy5faGFzSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQmFja3NwYWNlT3JEZWxldGUoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4ga2V5Q29kZSA9PT0gQkFDS1NQQUNFIHx8IGtleUNvZGUgPT09IERFTEVURTtcbiAgICB9XG4gICAgc2V0QXV0b2NvbXBsZXRlQ3VzdG9tSG9zdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b2NvbXBsZXRlRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZURpcmVjdGl2ZS5jdXN0b21PdmVybGF5SG9zdCA9IHRoaXMuaG9zdEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlVGFnKHRhZ1RvVG9nZ2xlKSB7XG4gICAgICAgIHRhZ1RvVG9nZ2xlLl90b2dnbGVTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRhZ1RvVG9nZ2xlLnNlbGVjdGVkICYmICF0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gdGFnVG9Ub2dnbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9jdXNJbnB1dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLnRhZ0lucHV0Ll9ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5OYlRhZ0xpc3RDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25iLXRhZy1saXN0JyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJuYi10YWctbGlzdC10YWdzLXdyYXBwZXJcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLXRhZywgaW5wdXRbbmJUYWdJbnB1dF1cIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduYlRhZ0xpc3QnLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVGFnTGlzdENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogTmJGb2N1c01vbml0b3IgfSxcbiAgICB7IHR5cGU6IE5iQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXJGYWN0b3J5U2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlN0YXR1c1NlcnZpY2UgfVxuXTtcbk5iVGFnTGlzdENvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICB0YWdzOiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYlRhZ0NvbXBvbmVudCxdIH1dLFxuICAgIHRhZ0lucHV0OiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOYlRhZ0lucHV0RGlyZWN0aXZlLF0gfV0sXG4gICAgYXV0b2NvbXBsZXRlRGlyZWN0aXZlOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOYkF1dG9jb21wbGV0ZURpcmVjdGl2ZSxdIH1dLFxuICAgIHNpemU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRhYkluZGV4OiBbeyB0eXBlOiBJbnB1dCB9LCB7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2F0dHIudGFiaW5kZXgnLF0gfV0sXG4gICAgcm9sZTogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydhdHRyLnJvbGUnLF0gfV0sXG4gICAgbXVsdGlwbGU6IFt7IHR5cGU6IElucHV0IH0sIHsgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScsXSB9XSxcbiAgICBhY3RpdmVUYWdJZDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLF0gfV0sXG4gICAgdGFnUmVtb3ZlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgX2hhc0lucHV0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5uYi10YWctbGlzdC13aXRoLWlucHV0JyxdIH1dLFxuICAgIF9pc0ZvY3VzZWQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLmZvY3VzJyxdIH1dLFxuICAgIF9pc0Z1bGxXaWR0aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3MuaW5wdXQtZnVsbC13aWR0aCcsXSB9XSxcbiAgICBfaW5wdXRDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XSxcbiAgICBfb25LZXlkb3duOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsna2V5ZG93bicsIFsnJGV2ZW50J10sXSB9XSxcbiAgICBfb25DbGljazogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2NsaWNrJywgWyckZXZlbnQnXSxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYlRhZ01vZHVsZSB7XG59XG5OYlRhZ01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICBOYlRhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJUYWdMaXN0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlRhZ0lucHV0RGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICBOYlRhZ0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgTmJUYWdMaXN0Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBOYlRhZ0lucHV0RGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9ERUZBVUxUX1JPV19MRVZFTCA9IDA7XG4vKipcbiAqIEltcGxpY2l0IGNvbnRleHQgb2YgY2VsbHMgYW5kIHJvd3NcbiAqL1xuY2xhc3MgTmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIERhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCByb3dcbiAgICAgKi9cbiAgICBkYXRhLCBjaGlsZHJlbiwgXG4gICAgLyoqXG4gICAgICogUm93IGV4cGFuZCBzdGF0ZVxuICAgICAqL1xuICAgIGV4cGFuZGVkLCBsZXZlbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBleHBhbmRlZDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHJvdyBoYXMgY2hpbGQgcm93c1xuICAgICAqL1xuICAgIGhhc0NoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNoaWxkcmVuICYmICEhdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxufVxuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iVHJlZUdyaWREYXRhU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEdldHRlcnMgPSB7XG4gICAgICAgICAgICBkYXRhR2V0dGVyOiBub2RlID0+IG5vZGUuZGF0YSxcbiAgICAgICAgICAgIGNoaWxkcmVuR2V0dGVyOiBkID0+IGQuY2hpbGRyZW4gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXhwYW5kZWRHZXR0ZXI6IGQgPT4gISFkLmV4cGFuZGVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1ByZXNlbnRhdGlvbk5vZGVzKG5vZGVzLCBjdXN0b21HZXR0ZXJzLCBsZXZlbCA9IE5CX0RFRkFVTFRfUk9XX0xFVkVMKSB7XG4gICAgICAgIGNvbnN0IGdldHRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdEdldHRlcnMpLCBjdXN0b21HZXR0ZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwTm9kZXMobm9kZXMsIGdldHRlcnMsIGxldmVsKTtcbiAgICB9XG4gICAgbWFwTm9kZXMobm9kZXMsIGdldHRlcnMsIGxldmVsKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YUdldHRlciwgY2hpbGRyZW5HZXR0ZXIsIGV4cGFuZGVkR2V0dGVyIH0gPSBnZXR0ZXJzO1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlcyA9IGNoaWxkcmVuR2V0dGVyKG5vZGUpO1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMudG9QcmVzZW50YXRpb25Ob2RlcyhjaGlsZHJlbk5vZGVzLCBnZXR0ZXJzLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYlRyZWVHcmlkUHJlc2VudGF0aW9uTm9kZShkYXRhR2V0dGVyKG5vZGUpLCBjaGlsZHJlbiwgZXhwYW5kZWRHZXR0ZXIobm9kZSksIGxldmVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZsYXR0ZW5FeHBhbmRlZChub2Rlcykge1xuICAgICAgICByZXR1cm4gbm9kZXMucmVkdWNlKChyZXMsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIHJlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGUuZXhwYW5kZWQgJiYgbm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goLi4udGhpcy5mbGF0dGVuRXhwYW5kZWQobm9kZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBjb3B5KG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY29weShub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGUobm9kZS5kYXRhLCBjaGlsZHJlbiwgbm9kZS5leHBhbmRlZCwgbm9kZS5sZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbk5iVHJlZUdyaWREYXRhU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8qKlxuICogU2VydmljZSB1c2VkIHRvIGZpbHRlciB0cmVlIGdyaWQgZGF0YS4gU2VhcmNoZWQgc2VhcmNoU3RyaW5nIGluIGFsbCBvYmplY3QgdmFsdWVzLlxuICogSWYgeW91IG5lZWQgY3VzdG9tIGZpbHRlciwgeW91IGNhbiBleHRlbmQgdGhpcyBzZXJ2aWNlIGFuZCBvdmVycmlkZSBmaWx0ZXJQcmVkaWNhdGUgb3Igd2hvbGUgZmlsdGVyIG1ldGhvZC5cbiAqL1xuY2xhc3MgTmJUcmVlR3JpZEZpbHRlclNlcnZpY2Uge1xuICAgIGZpbHRlcihxdWVyeSwgZGF0YSkge1xuICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5yZWR1Y2UoKGZpbHRlcmVkLCBub2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRDaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRDaGlsZHJlbiA9IHRoaXMuZmlsdGVyKHF1ZXJ5LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gZmlsdGVyZWRDaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZENoaWxkcmVuICYmIGZpbHRlcmVkQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZmlsdGVyUHJlZGljYXRlKG5vZGUuZGF0YSwgcXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBmaWx0ZXJQcmVkaWNhdGUoZGF0YSwgc2VhcmNoUXVlcnkpIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRRdWVyeSA9IHNlYXJjaFF1ZXJ5LnRyaW0oKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiBPYmplY3QudmFsdWVzKGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZFZhbCA9IGAke3ZhbH1gLnRyaW0oKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkVmFsLmluY2x1ZGVzKHByZXBhcmVkUXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIE5iU29ydERpcmVjdGlvbjtcbihmdW5jdGlvbiAoTmJTb3J0RGlyZWN0aW9uKSB7XG4gICAgTmJTb3J0RGlyZWN0aW9uW1wiQVNDRU5ESU5HXCJdID0gXCJhc2NcIjtcbiAgICBOYlNvcnREaXJlY3Rpb25bXCJERVNDRU5ESU5HXCJdID0gXCJkZXNjXCI7XG4gICAgTmJTb3J0RGlyZWN0aW9uW1wiTk9ORVwiXSA9IFwiXCI7XG59KShOYlNvcnREaXJlY3Rpb24gfHwgKE5iU29ydERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBzb3J0RGlyZWN0aW9ucyA9IFtcbiAgICBOYlNvcnREaXJlY3Rpb24uQVNDRU5ESU5HLFxuICAgIE5iU29ydERpcmVjdGlvbi5ERVNDRU5ESU5HLFxuICAgIE5iU29ydERpcmVjdGlvbi5OT05FLFxuXTtcbi8qKlxuICogRGlyZWN0aXZlIHRyaWdnZXJzIHNvcnQgbWV0aG9kIG9mIHBhc3NlZCBvYmplY3Qgd2hlbiBzb3J0IGhlYWRlciBjaGFuZ2VzIGRpcmVjdGlvblxuICovXG5jbGFzcyBOYlNvcnREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGVtaXRTb3J0KHNvcnRSZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnNvcnRhYmxlICYmIHRoaXMuc29ydGFibGUuc29ydCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0YWJsZS5zb3J0KHNvcnRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnQuZW1pdChzb3J0UmVxdWVzdCk7XG4gICAgfVxufVxuTmJTb3J0RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25iU29ydF0nIH0sXSB9XG5dO1xuTmJTb3J0RGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNvcnRhYmxlOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYlNvcnQnLF0gfV0sXG4gICAgc29ydDogW3sgdHlwZTogT3V0cHV0IH1dXG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIGhlYWRlcnMgc29ydCBpY29ucy4gTWFyayB5b3UgaWNvbiBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoaXMgc3RydWN0dXJhbCBkaXJlY3RpdmUgYW5kXG4gKiBpdCdsbCBzZXQgdGVtcGxhdGUncyBpbXBsaWNpdCBjb250ZXh0IHdpdGggY3VycmVudCBkaXJlY3Rpb24uIENvbnRleHQgYWxzbyBoYXMgYGlzQXNjZW5kaW5nYCxcbiAqIGBpc0Rlc2NlbmRpbmdgIGFuZCBgaXNOb25lYCBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlIHtcbn1cbk5iU29ydEhlYWRlckljb25EaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmJTb3J0SGVhZGVySWNvbl0nIH0sXSB9XG5dO1xuY2xhc3MgTmJTb3J0SWNvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gTmJTb3J0RGlyZWN0aW9uLk5PTkU7XG4gICAgfVxuICAgIGlzQXNjZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IE5iU29ydERpcmVjdGlvbi5BU0NFTkRJTkc7XG4gICAgfVxuICAgIGlzRGVzY2VuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYlNvcnREaXJlY3Rpb24uREVTQ0VORElORztcbiAgICB9XG4gICAgaXNEaXJlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNjZW5kaW5nKCkgfHwgdGhpcy5pc0Rlc2NlbmRpbmcoKTtcbiAgICB9XG59XG5OYlNvcnRJY29uQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1zb3J0LWljb24nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImlzRGlyZWN0aW9uU2V0KClcIj5cbiAgICAgIDxuYi1pY29uICpuZ0lmPVwiaXNBc2NlbmRpbmcoKVwiIGljb249XCJjaGV2cm9uLWRvd24tb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L25iLWljb24+XG4gICAgICA8bmItaWNvbiAqbmdJZj1cImlzRGVzY2VuZGluZygpXCIgaWNvbj1cImNoZXZyb24tdXAtb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L25iLWljb24+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJTb3J0SWNvbkNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBkaXJlY3Rpb246IFt7IHR5cGU6IElucHV0IH1dXG59O1xuLyoqXG4gKiBNYXJrcyBoZWFkZXIgYXMgc29ydCBoZWFkZXIgc28gaXQgZW1pdHRpbmcgc29ydCBldmVudCB3aGVuIGNsaWNrZWQuXG4gKi9cbmNsYXNzIE5iU29ydEhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc29ydCwgY29sdW1uRGVmKSB7XG4gICAgICAgIHRoaXMuc29ydCA9IHNvcnQ7XG4gICAgICAgIHRoaXMuY29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICB0aGlzLmRpc2FibGVkVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBzb3J0IGhlYWRlclxuICAgICAqL1xuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpc2FibGVkVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkVmFsdWU7XG4gICAgfVxuICAgIHNvcnRJZkVuYWJsZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0RGF0YSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQXNjZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IE5iU29ydERpcmVjdGlvbi5BU0NFTkRJTkc7XG4gICAgfVxuICAgIGlzRGVzY2VuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYlNvcnREaXJlY3Rpb24uREVTQ0VORElORztcbiAgICB9XG4gICAgc29ydERhdGEoKSB7XG4gICAgICAgIGNvbnN0IHNvcnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVTb3J0UmVxdWVzdCgpO1xuICAgICAgICB0aGlzLnNvcnQuZW1pdFNvcnQoc29ydFJlcXVlc3QpO1xuICAgIH1cbiAgICBnZXRJY29uQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogdGhpcy5kaXJlY3Rpb24sXG4gICAgICAgICAgICBpc0FzY2VuZGluZzogdGhpcy5pc0FzY2VuZGluZygpLFxuICAgICAgICAgICAgaXNEZXNjZW5kaW5nOiB0aGlzLmlzRGVzY2VuZGluZygpLFxuICAgICAgICAgICAgaXNOb25lOiAhdGhpcy5pc0FzY2VuZGluZygpICYmICF0aGlzLmlzRGVzY2VuZGluZygpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXREaXNhYmxlZEF0dHJpYnV0ZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICcnIDogbnVsbDtcbiAgICB9XG4gICAgY3JlYXRlU29ydFJlcXVlc3QoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5nZXROZXh0RGlyZWN0aW9uKCk7XG4gICAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sIGNvbHVtbjogdGhpcy5jb2x1bW5EZWYubmFtZSB9O1xuICAgIH1cbiAgICBnZXROZXh0RGlyZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb3J0RGlyZWN0aW9uQ3ljbGUgPSBzb3J0RGlyZWN0aW9ucztcbiAgICAgICAgbGV0IG5leHREaXJlY3Rpb25JbmRleCA9IHNvcnREaXJlY3Rpb25DeWNsZS5pbmRleE9mKHRoaXMuZGlyZWN0aW9uKSArIDE7XG4gICAgICAgIGlmIChuZXh0RGlyZWN0aW9uSW5kZXggPj0gc29ydERpcmVjdGlvbkN5Y2xlLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dERpcmVjdGlvbkluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydERpcmVjdGlvbkN5Y2xlW25leHREaXJlY3Rpb25JbmRleF07XG4gICAgfVxufVxuTmJTb3J0SGVhZGVyQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJTb3J0SGVhZGVyXScsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzcz1cIm5iLXRyZWUtZ3JpZC1oZWFkZXItY2hhbmdlLXNvcnQtYnV0dG9uXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgW2F0dHIuZGlzYWJsZWRdPVwiZ2V0RGlzYWJsZWRBdHRyaWJ1dGVWYWx1ZSgpXCJcbiAgICAgIChjbGljayk9XCJzb3J0RGF0YSgpXCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9idXR0b24+XG4gICAgPG5iLXNvcnQtaWNvbiAqbmdJZj1cIiFzb3J0SWNvbjsgZWxzZSBjdXN0b21JY29uXCIgW2RpcmVjdGlvbl09XCJkaXJlY3Rpb25cIj48L25iLXNvcnQtaWNvbj5cbiAgICA8bmctdGVtcGxhdGUgI2N1c3RvbUljb24gW25nVGVtcGxhdGVPdXRsZXRdPVwic29ydEljb25cIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiZ2V0SWNvbkNvbnRleHQoKVwiPjwvbmctdGVtcGxhdGU+XG4gIGBcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJTb3J0SGVhZGVyQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJTb3J0RGlyZWN0aXZlIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYsXSB9XSB9XG5dO1xuTmJTb3J0SGVhZGVyQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNvcnRJY29uOiBbeyB0eXBlOiBDb250ZW50Q2hpbGQsIGFyZ3M6IFtOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0sXSB9XSxcbiAgICBkaXJlY3Rpb246IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iU29ydEhlYWRlcicsXSB9XSxcbiAgICBkaXNhYmxlZDogW3sgdHlwZTogSW5wdXQgfSwgeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5kaXNhYmxlZCcsXSB9XSxcbiAgICBzb3J0SWZFbmFibGVkOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBTZXJ2aWNlIHVzZWQgdG8gc29ydCB0cmVlIGdyaWQgZGF0YS4gVXNlcyBBcnJheS5wcm90b3R5cGUuc29ydCBtZXRob2QuXG4gKiBJZiB5b3UgbmVlZCBjdXN0b20gc29ydGluZywgeW91IGNhbiBleHRlbmQgdGhpcyBzZXJ2aWNlIGFuZCBvdmVycmlkZSBjb21wYXJhdG9yIG9yIHdob2xlIHNvcnQgbWV0aG9kLlxuICovXG5jbGFzcyBOYlRyZWVHcmlkU29ydFNlcnZpY2Uge1xuICAgIHNvcnQocmVxdWVzdCwgZGF0YSkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IGRhdGEuc29ydCgobmEsIG5iKSA9PiB0aGlzLmNvbXBhcmF0b3IocmVxdWVzdCwgbmEsIG5iKSk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSB0aGlzLnNvcnQocmVxdWVzdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9XG4gICAgY29tcGFyYXRvcihyZXF1ZXN0LCBuYSwgbmIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVxdWVzdC5jb2x1bW47XG4gICAgICAgIGNvbnN0IGRpciA9IHJlcXVlc3QuZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBhID0gbmEuZGF0YVtrZXldO1xuICAgICAgICBjb25zdCBiID0gbmIuZGF0YVtrZXldO1xuICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpciA9PT0gTmJTb3J0RGlyZWN0aW9uLkFTQ0VORElORyA/IHJlcyA6IHJlcyAqIC0xO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRTb3J0U2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iVHJlZUdyaWRTZXJ2aWNlIHtcbiAgICBleHBhbmQoZGF0YSwgcm93LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZmluZChkYXRhLCByb3cpO1xuICAgICAgICBub2RlLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVlcCAmJiBub2RlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgobikgPT4gdGhpcy5leHBhbmQoZGF0YSwgbi5kYXRhLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGFwc2UoZGF0YSwgcm93LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZmluZChkYXRhLCByb3cpO1xuICAgICAgICBub2RlLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmRlZXAgJiYgbm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKG4pID0+IHRoaXMuY29sbGFwc2UoZGF0YSwgbi5kYXRhLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9nZ2xlKGRhdGEsIHJvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmQoZGF0YSwgcm93KTtcbiAgICAgICAgaWYgKG5vZGUuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoZGF0YSwgcm93LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKGRhdGEsIHJvdywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZChkYXRhLCByb3cpIHtcbiAgICAgICAgY29uc3QgdG9DaGVjayA9IFsuLi5kYXRhXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRvQ2hlY2spIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09IHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIHRvQ2hlY2sucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbk5iVHJlZUdyaWRTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJUcmVlR3JpZERhdGFTb3VyY2UgZXh0ZW5kcyBOYkRhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvcnRTZXJ2aWNlLCBmaWx0ZXJTZXJ2aWNlLCB0cmVlR3JpZFNlcnZpY2UsIHRyZWVHcmlkRGF0YVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZSA9IHNvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UgPSBmaWx0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRyZWVHcmlkU2VydmljZSA9IHRyZWVHcmlkU2VydmljZTtcbiAgICAgICAgdGhpcy50cmVlR3JpZERhdGFTZXJ2aWNlID0gdHJlZUdyaWREYXRhU2VydmljZTtcbiAgICAgICAgLyoqIFN0cmVhbSBlbWl0dGluZyByZW5kZXIgZGF0YSB0byB0aGUgdGFibGUgKGRlcGVuZHMgb24gb3JkZXJlZCBkYXRhIGNoYW5nZXMpLiAqL1xuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5maWx0ZXJSZXF1ZXN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgnJyk7XG4gICAgICAgIHRoaXMuc29ydFJlcXVlc3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgIH1cbiAgICBzZXREYXRhKGRhdGEsIGN1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgbGV0IHByZXNlbnRhdGlvbkRhdGEgPSBbXTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbkRhdGEgPSB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UudG9QcmVzZW50YXRpb25Ob2RlcyhkYXRhLCBjdXN0b21HZXR0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHByZXNlbnRhdGlvbkRhdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0KGNvbGxlY3Rpb25WaWV3ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRGF0YTtcbiAgICB9XG4gICAgZGlzY29ubmVjdChjb2xsZWN0aW9uVmlld2VyKSB7XG4gICAgfVxuICAgIGV4cGFuZChyb3cpIHtcbiAgICAgICAgdGhpcy50cmVlR3JpZFNlcnZpY2UuZXhwYW5kKHRoaXMuZGF0YS52YWx1ZSwgcm93KTtcbiAgICAgICAgdGhpcy5kYXRhLm5leHQodGhpcy5kYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgY29sbGFwc2Uocm93KSB7XG4gICAgICAgIHRoaXMudHJlZUdyaWRTZXJ2aWNlLmNvbGxhcHNlKHRoaXMuZGF0YS52YWx1ZSwgcm93KTtcbiAgICAgICAgdGhpcy5kYXRhLm5leHQodGhpcy5kYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgdG9nZ2xlKHJvdywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRyZWVHcmlkU2VydmljZS50b2dnbGUodGhpcy5kYXRhLnZhbHVlLCByb3csIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRhdGEubmV4dCh0aGlzLmRhdGEudmFsdWUpO1xuICAgIH1cbiAgICB0b2dnbGVCeUluZGV4KGRhdGFJbmRleCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5yZW5kZXJEYXRhLnZhbHVlICYmIHRoaXMucmVuZGVyRGF0YS52YWx1ZVtkYXRhSW5kZXhdO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUobm9kZS5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMZXZlbChyb3dJbmRleCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLnJlbmRlckRhdGEudmFsdWVbcm93SW5kZXhdO1xuICAgICAgICByZXR1cm4gcm93ID8gcm93LmxldmVsIDogTkJfREVGQVVMVF9ST1dfTEVWRUw7XG4gICAgfVxuICAgIHNvcnQoc29ydFJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zb3J0UmVxdWVzdC5uZXh0KHNvcnRSZXF1ZXN0KTtcbiAgICB9XG4gICAgZmlsdGVyKHNlYXJjaFF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUmVxdWVzdC5uZXh0KHNlYXJjaFF1ZXJ5KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hhbmdlU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhU3RyZWFtID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBjb21iaW5lTGF0ZXN0KGRhdGFTdHJlYW0sIHRoaXMuZmlsdGVyUmVxdWVzdClcbiAgICAgICAgICAgIC5waXBlKG1hcCgoW2RhdGFdKSA9PiB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UuY29weShkYXRhKSksIG1hcChkYXRhID0+IHRoaXMuZmlsdGVyRGF0YShkYXRhKSkpO1xuICAgICAgICBjb25zdCBzb3J0ZWREYXRhID0gY29tYmluZUxhdGVzdChmaWx0ZXJlZERhdGEsIHRoaXMuc29ydFJlcXVlc3QpXG4gICAgICAgICAgICAucGlwZShtYXAoKFtkYXRhXSkgPT4gdGhpcy5zb3J0RGF0YShkYXRhKSkpO1xuICAgICAgICBzb3J0ZWREYXRhXG4gICAgICAgICAgICAucGlwZShtYXAoKGRhdGEpID0+IHRoaXMudHJlZUdyaWREYXRhU2VydmljZS5mbGF0dGVuRXhwYW5kZWQoZGF0YSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZGF0YSkgPT4gdGhpcy5yZW5kZXJEYXRhLm5leHQoZGF0YSkpO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU2VydmljZS5maWx0ZXIodGhpcy5maWx0ZXJSZXF1ZXN0LnZhbHVlLCBkYXRhKTtcbiAgICB9XG4gICAgc29ydERhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0U2VydmljZS5zb3J0KHRoaXMuc29ydFJlcXVlc3QudmFsdWUsIGRhdGEpO1xuICAgIH1cbn1cbmNsYXNzIE5iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyU2VydmljZSwgc29ydFNlcnZpY2UsIHRyZWVHcmlkU2VydmljZSwgdHJlZUdyaWREYXRhU2VydmljZSkge1xuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UgPSBmaWx0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNvcnRTZXJ2aWNlID0gc29ydFNlcnZpY2U7XG4gICAgICAgIHRoaXMudHJlZUdyaWRTZXJ2aWNlID0gdHJlZUdyaWRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UgPSB0cmVlR3JpZERhdGFTZXJ2aWNlO1xuICAgIH1cbiAgICBjcmVhdGUoZGF0YSwgY3VzdG9tR2V0dGVycykge1xuICAgICAgICBjb25zdCBkYXRhU291cmNlID0gbmV3IE5iVHJlZUdyaWREYXRhU291cmNlKHRoaXMuc29ydFNlcnZpY2UsIHRoaXMuZmlsdGVyU2VydmljZSwgdGhpcy50cmVlR3JpZFNlcnZpY2UsIHRoaXMudHJlZUdyaWREYXRhU2VydmljZSk7XG4gICAgICAgIGRhdGFTb3VyY2Uuc2V0RGF0YShkYXRhLCBjdXN0b21HZXR0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGRhdGFTb3VyY2U7XG4gICAgfVxufVxuTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBJbmplY3RhYmxlIH1cbl07XG5OYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlRyZWVHcmlkRmlsdGVyU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUcmVlR3JpZFNvcnRTZXJ2aWNlIH0sXG4gICAgeyB0eXBlOiBOYlRyZWVHcmlkU2VydmljZSB9LFxuICAgIHsgdHlwZTogTmJUcmVlR3JpZERhdGFTZXJ2aWNlIH1cbl07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfVFJFRV9HUklEID0gbmV3IEluamVjdGlvblRva2VuKCdOQl9UUkVFX0dSSUQnKTtcblxuY2xhc3MgTmJDb2x1bW5zU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZGlmZmVycykge1xuICAgICAgICB0aGlzLmRpZmZlcnMgPSBkaWZmZXJzO1xuICAgICAgICB0aGlzLmNvbHVtbkhpZGUkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5TaG93JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIHNldENvbHVtbnMoY29sdW1ucykge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbmdlc0RpZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzRGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQoY29sdW1ucyB8fCBbXSkuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlc0RpZmZlci5kaWZmKGNvbHVtbnMpKSB7XG4gICAgICAgICAgICB0aGlzLmFsbENvbHVtbnMgPSBBcnJheS5mcm9tKGNvbHVtbnMpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucyA9IEFycmF5LmZyb20oY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zO1xuICAgIH1cbiAgICBoaWRlQ29sdW1uKGNvbHVtbikge1xuICAgICAgICBjb25zdCB0b1JlbW92ZSA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xuICAgICAgICBpZiAodG9SZW1vdmUgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucy5zcGxpY2UodG9SZW1vdmUsIDEpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5IaWRlJC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvd0NvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZUNvbHVtbnMuaW5jbHVkZXMoY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMuc3BsaWNlKHRoaXMuZmluZEluc2VydEluZGV4KGNvbHVtbiksIDAsIGNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uU2hvdyQubmV4dCgpO1xuICAgIH1cbiAgICBvbkNvbHVtbnNDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBtZXJnZSh0aGlzLmNvbHVtblNob3ckLCB0aGlzLmNvbHVtbkhpZGUkKTtcbiAgICB9XG4gICAgZmluZEluc2VydEluZGV4KGNvbHVtbikge1xuICAgICAgICBjb25zdCBpbml0aWFsSW5kZXggPSB0aGlzLmFsbENvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xuICAgICAgICBpZiAoaW5pdGlhbEluZGV4ID09PSAwIHx8ICF0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxJbmRleCA9PT0gdGhpcy5hbGxDb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0U2libGluZ0luZGV4ID0gaW5pdGlhbEluZGV4IC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlZnRTaWJsaW5nSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0U2libGluZyA9IHRoaXMuYWxsQ29sdW1uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy52aXNpYmxlQ29sdW1ucy5pbmRleE9mKGxlZnRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0U2libGluZ0luZGV4ID0gaW5pdGlhbEluZGV4ICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJpZ2h0U2libGluZ0luZGV4OyBpIDwgdGhpcy5hbGxDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodFNpYmxpbmcgPSB0aGlzLmFsbENvbHVtbnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihyaWdodFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHJlc3RvcmUgY29sdW1uIHBvc2l0aW9uLmApO1xuICAgIH1cbn1cbk5iQ29sdW1uc1NlcnZpY2UuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbk5iQ29sdW1uc1NlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBJdGVyYWJsZURpZmZlcnMgfVxuXTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRyZWUgZ3JpZCBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5lc3RlZCByb3dzIG9mIGRhdGEuXG4gKiBTdXBwb3J0cyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRyZWVHcmlkTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRyZWVHcmlkTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogQXMgdGhlIG1vc3QgYmFzaWMgdXNhZ2UgeW91IG5lZWQgdG8gZGVmaW5lIFtuYlRyZWVHcmlkUm93RGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZWdyaWQvYXBpI25idHJlZWdyaWRyb3dkZWZkaXJlY3RpdmUpXG4gKiB3aGVyZSB5b3Ugc2hvdWxkIHBhc3MgY29sdW1ucyB0byBkaXNwbGF5IGluIHJvd3MgYW5kXG4gKiBbbmJUcmVlR3JpZENvbHVtbkRlZl0oZG9jcy9jb21wb25lbnRzL3RyZWVncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSAtIGNvbXBvbmVudCBjb250YWluaW5nIGNlbGxcbiAqIGRlZmluaXRpb25zIGZvciBlYWNoIGNvbHVtbiBwYXNzZWQgdG8gcm93IGRlZmluaXRpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJhc2ljLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWJhc2ljLmNvbXBvbmVudClcbiAqXG4gKiBgTmJUcmVlR3JpZENvbXBvbmVudGAncyBzb3VyY2UgaW5wdXQgYW5kIGBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIuY3JlYXRlYCBleHBlY3RpbmcgZGF0YSB0byBiZSBhbiBhcnJheSBvZlxuICogb2JqZWN0cyB3aXRoIGBkYXRhYCwgYGNoaWxkcmVuYCBhbmQgYGV4cGFuZGVkYCBwcm9wZXJ0aWVzLiBJZiB5b3VyIGRhdGEgZG9lc24ndCBtYXRjaCB0aGlzIGludGVyZmFjZSwgeW91IGNhbiBwYXNzXG4gKiBnZXR0ZXIgZnVuY3Rpb25zIGZvciBlYWNoIHByb3BlcnR5IGFzIGFyZ3VtZW50cyB0byBgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLmNyZWF0ZWAgbWV0aG9kLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gbm9kZSBzdHJ1Y3R1cmUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLW5vZGUtc3RydWN0dXJlLmNvbXBvbmVudClcbiAqXG4gKiBUbyB1c2Ugc29ydGluZyB5b3UgY2FuIGFkZCBgbmJTb3J0YCBkaXJlY3RpdmUgdG8gdGFibGUgYW5kIHN1YnNjcmliZSB0byBgc29ydGAgbWV0aG9kLiBXaGVuIHVzZXIgY2xpY2sgb24gaGVhZGVyLFxuICogc29ydCBldmVudCB3aWxsIGJlIGVtaXR0ZWQuIEV2ZW50IG9iamVjdCBjb250YWluIGNsaWNrZWQgY29sdW1uIG5hbWUgYW5kIGRlc2lyZWQgc29ydCBkaXJlY3Rpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNvcnRhYmxlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNvcnRhYmxlLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIHVzZSBgRGF0YSBTb3VyY2UgQnVpbGRlcmAgdG8gY3JlYXRlIGBOYlRyZWVHcmlkRGF0YVNvdXJjZWAgd2hpY2ggd291bGQgaGF2ZSB0b2dnbGUsIHNvcnQgYW5kXG4gKiBmaWx0ZXIgbWV0aG9kcy4gVGhlbiB5b3UgY2FuIGNhbGwgdGhpcyBtZXRob2RzIHRvIGNoYW5nZSBzb3J0IG9yIHRvZ2dsZSByb3dzIHByb2dyYW1tYXRpY2FsbHkuIEFsc28gYG5iU29ydGAgYW5kXG4gKiBgbmJGaWx0ZXJJbnB1dGAgZGlyZWN0aXZlcyBib3RoIHN1cHBvcnQgYE5iVHJlZUdyaWREYXRhU291cmNlYCwgc28geW91IGNhbiBwYXNzIGl0IGRpcmVjdGx5IGFzIGFuIGlucHV0IGFuZFxuICogZGlyZWN0aXZlcyB3aWxsIHRyaWdnZXIgc29ydCwgdG9nZ2xlIHRoZW1zZWx2ZXMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERhdGEgU291cmNlIEJ1aWxkZXIsIHRyZWUtZ3JpZC90cmVlLWdyaWQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIHJlc3BvbnNpdmUgZ3JpZCBieSBzZXR0aW5nIGBoaWRlT25gIGFuZCBgc2hvd09uYCBpbnB1dHMgb2ZcbiAqIFtuYlRyZWVHcmlkQ29sdW1uRGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZS1ncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSBkaXJlY3RpdmUuXG4gKiBXaGVuIHZpZXdwb3J0IHJlYWNoZXMgc3BlY2lmaWVkIHdpZHRoIGdyaWQgaGlkZXMgb3Igc2hvd3MgY29sdW1ucy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoUmVzcG9uc2l2ZSBjb2x1bW5zLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXJlc3BvbnNpdmUuY29tcG9uZW50KVxuICpcbiAqIFRvIGN1c3RvbWl6ZSBzb3J0IG9yIHJvdyB0b2dnbGUgaWNvbnMgeW91IGNhbiB1c2UgYG5iU29ydEhlYWRlckljb25gIGFuZCBgbmJUcmVlR3JpZFJvd1RvZ2dsZWAgZGlyZWN0aXZlc1xuICogcmVzcGVjdGl2ZWx5LiBgbmJTb3J0SGVhZGVySWNvbmAgaXMgYSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBhbmQgaXQncyBpbXBsaWNpdCBjb250ZXh0IHNldCB0byBjdXJyZW50IGRpcmVjdGlvbi5cbiAqIEFsc28gY29udGV4dCBoYXMgdGhyZWUgcHJvcGVydGllczogYGlzQXNjZW5kaW5nYCwgYGlzRGVzY2VuZGluZ2AgYW5kIGBpc05vbmVgLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gaWNvbnMsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLWljb25zLmNvbXBvbmVudClcbiAqXG4gKiBCeSBkZWZhdWx0LCByb3cgdG8gdG9nZ2xlIGhhcHBlbnMgd2hlbiB1c2VyIGNsaWNrcyBhbnl3aGVyZSBpbiB0aGUgcm93LiBBbHNvIGRvdWJsZSBjbGljayBleHBhbmRzIHJvdyBkZWVwbHkuXG4gKiBUbyBkaXNhYmxlIHRoaXMgeW91IGNhbiBzZXQgYFtjbGlja1RvVG9nZ2xlXT1cImZhbHNlXCJgIGlucHV0IG9mIGBuYlRyZWVHcmlkUm93YC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZSBjbGljayB0b2dnbGUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtZGlzYWJsZS1jbGljay10b2dnbGUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItd2lkdGg6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItc3R5bGU6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LW1pbi1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtY2VsbC1wYWRkaW5nOlxuICogdHJlZS1ncmlkLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1mb290ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LWV2ZW4tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJvcmRlcjpcbiAqIHRyZWUtZ3JpZC1zb3J0LWhlYWRlci1idXR0b24tcGFkZGluZzpcbiAqL1xuY2xhc3MgTmJUcmVlR3JpZENvbXBvbmVudCBleHRlbmRzIE5iVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VCdWlsZGVyLCBkaWZmZXJzLCBjaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZiwgcm9sZSwgZGlyLCBkb2N1bWVudCwgcGxhdGZvcm0sIHdpbmRvdywgX3ZpZXdSZXBlYXRlciwgX2NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyKSB7XG4gICAgICAgIHN1cGVyKGRpZmZlcnMsIGNoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50UmVmLCByb2xlLCBkaXIsIGRvY3VtZW50LCBwbGF0Zm9ybSwgX3ZpZXdSZXBlYXRlciwgX2NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlQnVpbGRlciA9IGRhdGFTb3VyY2VCdWlsZGVyO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgdGhpcy5fdmlld1JlcGVhdGVyID0gX3ZpZXdSZXBlYXRlcjtcbiAgICAgICAgdGhpcy5fY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgPSBfY29hbGVzY2VkU3R5bGVTY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmxldmVsUGFkZGluZyA9ICcnO1xuICAgICAgICB0aGlzLmVxdWFsQ29sdW1uc1dpZHRoVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmVlQ2xhc3MgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0YWJsZSdzIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEB0eXBlIHs8VD5bXSB8IE5iVHJlZUdyaWREYXRhU291cmNlfVxuICAgICAqL1xuICAgIHNldCBzb3VyY2UoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE5iVHJlZUdyaWREYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlID0gdGhpcy5kYXRhU291cmNlQnVpbGRlci5jcmVhdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fc291cmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGFsbCBjb2x1bW5zIGVxdWFsIHdpZHRoLiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHNldCBlcXVhbENvbHVtbnNXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmVxdWFsQ29sdW1uc1dpZHRoVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZXF1YWxDb2x1bW5zV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFsQ29sdW1uc1dpZHRoVmFsdWU7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0RlZnNDb3VudCgpO1xuICAgICAgICBjb25zdCByb3dzQ2hhbmdlJCA9IG1lcmdlKHRoaXMuX2NvbnRlbnRSb3dEZWZzLmNoYW5nZXMsIHRoaXMuX2NvbnRlbnRIZWFkZXJSb3dEZWZzLmNoYW5nZXMsIHRoaXMuX2NvbnRlbnRGb290ZXJSb3dEZWZzLmNoYW5nZXMpO1xuICAgICAgICByb3dzQ2hhbmdlJC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jaGVja0RlZnNDb3VudCgpKTtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2libGVDb2x1bW5zKCk7XG4gICAgICAgICAgICBjb25zdCB3aW5kb3dSZXNpemUkID0gZnJvbUV2ZW50KHRoaXMud2luZG93LCAncmVzaXplJykucGlwZShkZWJvdW5jZVRpbWUoNTApKTtcbiAgICAgICAgICAgIG1lcmdlKHJvd3NDaGFuZ2UkLCB0aGlzLl9jb250ZW50Q29sdW1uRGVmcy5jaGFuZ2VzLCB3aW5kb3dSZXNpemUkKVxuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlVmlzaWJsZUNvbHVtbnMoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIHRvZ2dsZVJvdyhyb3csIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Um93Q29udGV4dChyb3cpO1xuICAgICAgICB0aGlzLl9zb3VyY2UudG9nZ2xlKGNvbnRleHQuJGltcGxpY2l0LmRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0b2dnbGVDZWxsUm93KGNlbGwpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q2VsbENvbnRleHQoY2VsbCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZS50b2dnbGUoY29udGV4dC4kaW1wbGljaXQuZGF0YSk7XG4gICAgfVxuICAgIGdldENvbHVtbldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5lcXVhbENvbHVtbnNXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGAkezEwMCAvIHRoaXMuZ2V0Q29sdW1uc0NvdW50KCl9JWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRDZWxsTGV2ZWwoY2VsbCwgY29sdW1uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc0ZpcnN0Q29sdW1uKGNvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsQ29udGV4dChjZWxsKS4kaW1wbGljaXQubGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5CX0RFRkFVTFRfUk9XX0xFVkVMO1xuICAgIH1cbiAgICBnZXRSb3dDb250ZXh0KHJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0QnlSb3dFbChyb3cuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgZ2V0Q2VsbENvbnRleHQoY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0QnlDZWxsRWwoY2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICBnZXRDb250ZXh0QnlDZWxsRWwoY2VsbEVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRleHRCeVJvd0VsKGNlbGxFbC5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG4gICAgZ2V0Q29udGV4dEJ5Um93RWwocm93RWwpIHtcbiAgICAgICAgY29uc3Qgcm93c0NvbnRhaW5lciA9IHRoaXMuX3Jvd091dGxldC52aWV3Q29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NDb250YWluZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvd1ZpZXdSZWYgPSByb3dzQ29udGFpbmVyLmdldChpKTtcbiAgICAgICAgICAgIGlmIChyb3dWaWV3UmVmLnJvb3ROb2Rlcy5pbmNsdWRlcyhyb3dFbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Vmlld1JlZi5jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbHVtbnMoKSB7XG4gICAgICAgIGxldCByb3dEZWY7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50SGVhZGVyUm93RGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvd0RlZiA9IHRoaXMuX2NvbnRlbnRIZWFkZXJSb3dEZWZzLmZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93RGVmID0gdGhpcy5fY29udGVudFJvd0RlZnMuZmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocm93RGVmLmdldFZpc2libGVDb2x1bW5zKCkgfHwgW10pO1xuICAgIH1cbiAgICBnZXRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbnMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGlzRmlyc3RDb2x1bW4oY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5zKClbMF0gPT09IGNvbHVtbk5hbWU7XG4gICAgfVxuICAgIGNoZWNrRGVmc0NvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudFJvd0RlZnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBtdWx0aXBsZSByb3cgZGVmaW5pdGlvbnNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGVudEhlYWRlclJvd0RlZnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBtdWx0aXBsZSBoZWFkZXIgcm93IGRlZmluaXRpb25zYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRGb290ZXJSb3dEZWZzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgbXVsdGlwbGUgZm9vdGVyIHJvdyBkZWZpbml0aW9uc2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMud2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnMgPSB0aGlzLl9jb250ZW50Q29sdW1uRGVmcztcbiAgICAgICAgY29uc3QgY29sdW1uc1RvSGlkZSA9IGNvbHVtbkRlZnNcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbCkgPT4gY29sLnNob3VsZEhpZGUod2lkdGgpKVxuICAgICAgICAgICAgLm1hcChjb2wgPT4gY29sLm5hbWUpO1xuICAgICAgICBjb25zdCBjb2x1bW5zVG9TaG93ID0gY29sdW1uRGVmc1xuICAgICAgICAgICAgLmZpbHRlcigoY29sKSA9PiBjb2wuc2hvdWxkU2hvdyh3aWR0aCkpXG4gICAgICAgICAgICAubWFwKGNvbCA9PiBjb2wubmFtZSk7XG4gICAgICAgIGlmICghY29sdW1uc1RvSGlkZS5sZW5ndGggJiYgIWNvbHVtbnNUb1Nob3cubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93RGVmcyA9IFtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRIZWFkZXJSb3dEZWZzLmZpcnN0LFxuICAgICAgICAgICAgdGhpcy5fY29udGVudFJvd0RlZnMuZmlyc3QsXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Rm9vdGVyUm93RGVmcy5maXJzdCxcbiAgICAgICAgXS5maWx0ZXIoZCA9PiAhIWQpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvd0RlZiBvZiByb3dEZWZzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zVG9IaWRlKSB7XG4gICAgICAgICAgICAgICAgcm93RGVmLmhpZGVDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICByb3dEZWYuc2hvd0NvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuTmJUcmVlR3JpZENvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndGFibGVbbmJUcmVlR3JpZF0nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBOQl9UQUJMRV9URU1QTEFURSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9UUkVFX0dSSUQsIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkQ29tcG9uZW50IH0sXG4gICAgICAgICAgICAgICAgICAgIE5iQ29sdW1uc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIC4uLk5CX1RBQkxFX1BST1ZJREVSUyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7dGFibGUtbGF5b3V0OmZpeGVkO2JvcmRlci1zcGFjaW5nOjA7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6YXV0b306Om5nLWRlZXAgLm5iLXRyZWUtZ3JpZC1jZWxsLDo6bmctZGVlcCAubmItdHJlZS1ncmlkLWhlYWRlci1jZWxsLDo6bmctZGVlcCAubmItdHJlZS1ncmlkLWZvb3Rlci1jZWxse292ZXJmbG93OmhpZGRlbn1cXG5cIl1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUcmVlR3JpZENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlciB9LFxuICAgIHsgdHlwZTogSXRlcmFibGVEaWZmZXJzIH0sXG4gICAgeyB0eXBlOiBDaGFuZ2VEZXRlY3RvclJlZiB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogU3RyaW5nLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBBdHRyaWJ1dGUsIGFyZ3M6IFsncm9sZScsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJEaXJlY3Rpb25hbGl0eSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9ET0NVTUVOVCxdIH1dIH0sXG4gICAgeyB0eXBlOiBOYlBsYXRmb3JtIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX1dJTkRPVyxdIH1dIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfVklFV19SRVBFQVRFUl9TVFJBVEVHWSxdIH1dIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUixdIH1dIH1cbl07XG5OYlRyZWVHcmlkQ29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNvdXJjZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUcmVlR3JpZCcsXSB9XSxcbiAgICBsZXZlbFBhZGRpbmc6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGVxdWFsQ29sdW1uc1dpZHRoOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICB0cmVlQ2xhc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLm5iLXRyZWUtZ3JpZCcsXSB9XVxufTtcblxuY29uc3QgTmJDZGtSb3dEZWYgPSBDZGtSb3dEZWY7XG5jb25zdCBOYkNka1JvdyA9IENka1JvdztcbmNvbnN0IE5iQ2RrQ2VsbERlZiA9IENka0NlbGxEZWY7XG5jb25zdCBOYkNka0hlYWRlclJvd0RlZiA9IENka0hlYWRlclJvd0RlZjtcbmNvbnN0IE5iQ2RrSGVhZGVyUm93ID0gQ2RrSGVhZGVyUm93O1xuY29uc3QgTmJDZGtIZWFkZXJDZWxsRGVmID0gQ2RrSGVhZGVyQ2VsbERlZjtcbmNvbnN0IE5iQ2RrRm9vdGVyUm93RGVmID0gQ2RrRm9vdGVyUm93RGVmO1xuY29uc3QgTmJDZGtGb290ZXJSb3cgPSBDZGtGb290ZXJSb3c7XG5jb25zdCBOYkNka0Zvb3RlckNlbGxEZWYgPSBDZGtGb290ZXJDZWxsRGVmO1xuY29uc3QgTmJDZGtDb2x1bW5EZWYgPSBDZGtDb2x1bW5EZWY7XG5jb25zdCBOYkNka0NlbGwgPSBDZGtDZWxsO1xuY29uc3QgTmJDZGtIZWFkZXJDZWxsID0gQ2RrSGVhZGVyQ2VsbDtcbmNvbnN0IE5iQ2RrRm9vdGVyQ2VsbCA9IENka0Zvb3RlckNlbGw7XG5cbi8qKlxuICogRGF0YSByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIHRyZWUtZ3JpZC5cbiAqIENhcHR1cmVzIHRoZSBoZWFkZXIgcm93J3MgdGVtcGxhdGUgYW5kIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xuY2xhc3MgTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIE5iUm93RGVmRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgZGlmZmVycywgY29sdW1uc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIodGVtcGxhdGUsIGRpZmZlcnMpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlID0gY29sdW1uc1NlcnZpY2U7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIGlmIChjaGFuZ2VzWydjb2x1bW5zJ10pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1ucyh0aGlzLmNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtbnMoY29sdW1ucykge1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlLnNldENvbHVtbnMoY29sdW1ucyk7XG4gICAgfVxuICAgIGdldFZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zU2VydmljZS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGhpZGVDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuaGlkZUNvbHVtbihjb2x1bW4pO1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHNob3dDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2Uuc2hvd0NvbHVtbihjb2x1bW4pO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYlRyZWVHcmlkUm93RGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka1Jvd0RlZiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9LFxuICAgIHsgdHlwZTogSXRlcmFibGVEaWZmZXJzIH0sXG4gICAgeyB0eXBlOiBOYkNvbHVtbnNTZXJ2aWNlIH1cbl07XG5OYlRyZWVHcmlkUm93RGVmRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iVHJlZUdyaWRSb3dEZWZDb2x1bW5zJyxdIH1dXG59O1xuY2xhc3MgTmJUcmVlR3JpZEhlYWRlclJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIE5iSGVhZGVyUm93RGVmRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgZGlmZmVycywgY29sdW1uc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIodGVtcGxhdGUsIGRpZmZlcnMpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlID0gY29sdW1uc1NlcnZpY2U7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIGlmIChjaGFuZ2VzWydjb2x1bW5zJ10pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29sdW1ucyh0aGlzLmNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUNvbHVtbnMoY29sdW1ucykge1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlLnNldENvbHVtbnMoY29sdW1ucyk7XG4gICAgfVxuICAgIGdldFZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zU2VydmljZS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGhpZGVDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuaGlkZUNvbHVtbihjb2x1bW4pO1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHNob3dDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2Uuc2hvd0NvbHVtbihjb2x1bW4pO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYlRyZWVHcmlkSGVhZGVyUm93RGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka0hlYWRlclJvd0RlZiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9LFxuICAgIHsgdHlwZTogSXRlcmFibGVEaWZmZXJzIH0sXG4gICAgeyB0eXBlOiBOYkNvbHVtbnNTZXJ2aWNlIH1cbl07XG5OYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbnM6IFt7IHR5cGU6IElucHV0LCBhcmdzOiBbJ25iVHJlZUdyaWRIZWFkZXJSb3dEZWYnLF0gfV1cbn07XG5jbGFzcyBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlIGV4dGVuZHMgTmJGb290ZXJSb3dEZWZEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBkaWZmZXJzLCBjb2x1bW5zU2VydmljZSkge1xuICAgICAgICBzdXBlcih0ZW1wbGF0ZSwgZGlmZmVycyk7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2UgPSBjb2x1bW5zU2VydmljZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2NvbHVtbnMnXSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5zKHRoaXMuY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ29sdW1ucyhjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2Uuc2V0Q29sdW1ucyhjb2x1bW5zKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNTZXJ2aWNlLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgaGlkZUNvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5oaWRlQ29sdW1uKGNvbHVtbik7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgc2hvd0NvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5zaG93Q29sdW1uKGNvbHVtbik7XG4gICAgfVxufVxuTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRGb290ZXJSb3dEZWZdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrRm9vdGVyUm93RGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IFRlbXBsYXRlUmVmIH0sXG4gICAgeyB0eXBlOiBJdGVyYWJsZURpZmZlcnMgfSxcbiAgICB7IHR5cGU6IE5iQ29sdW1uc1NlcnZpY2UgfVxuXTtcbk5iVHJlZUdyaWRGb290ZXJSb3dEZWZEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY29sdW1uczogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUcmVlR3JpZEZvb3RlclJvd0RlZicsXSB9XVxufTtcbi8qKlxuICogQ2VsbCBkZWZpbml0aW9uIGZvciBhIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZGF0YSByb3cgY2VsbCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmUgZXh0ZW5kcyBOYkNlbGxEZWZEaXJlY3RpdmUge1xufVxuTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYlRyZWVHcmlkQ2VsbERlZl0nLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbi8qKlxuICogSGVhZGVyIGNlbGwgZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgaGVhZGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIE5iSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSB7XG59XG5OYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRIZWFkZXJDZWxsRGVmXScsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka0hlYWRlckNlbGxEZWYsIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuLyoqXG4gKiBGb290ZXIgY2VsbCBkZWZpbml0aW9uIGZvciB0aGUgbmItdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBmb290ZXIgY2VsbCBhbmQgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIE5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlIGV4dGVuZHMgTmJGb290ZXJDZWxsRGVmRGlyZWN0aXZlIHtcbn1cbk5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJUcmVlR3JpZEZvb3RlckNlbGxEZWZdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrRm9vdGVyQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbmNvbnN0IE5CX1JPV19ET1VCTEVfQ0xJQ0tfREVMQVkgPSAyMDA7XG4vKipcbiAqIENlbGxzIGNvbnRhaW5lci4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuXG4gKi9cbmNsYXNzIE5iVHJlZUdyaWRSb3dDb21wb25lbnQgZXh0ZW5kcyBOYlJvd0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IodHJlZSwgZWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmRvdWJsZUNsaWNrJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIHRvIHdhaXQgZm9yIHNlY29uZCBjbGljayB0byBleHBhbmQgcm93IGRlZXBseS5cbiAgICAgICAgICogMjAwbXMgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IE5CX1JPV19ET1VCTEVfQ0xJQ0tfREVMQVk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgcm93IG9uIGNsaWNrLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrVG9Ub2dnbGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICB0b2dnbGVJZkVuYWJsZWROb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpY2tUb1RvZ2dsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyKE5CX1JPV19ET1VCTEVfQ0xJQ0tfREVMQVkpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpLCB0YWtlVW50aWwodGhpcy5kb3VibGVDbGljayQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRyZWUudG9nZ2xlUm93KHRoaXMpKTtcbiAgICB9XG4gICAgdG9nZ2xlSWZFbmFibGVkTm9kZURlZXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGlja1RvVG9nZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb3VibGVDbGljayQubmV4dCgpO1xuICAgICAgICB0aGlzLnRyZWUudG9nZ2xlUm93KHRoaXMsIHsgZGVlcDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZG91YmxlQ2xpY2skLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuTmJUcmVlR3JpZFJvd0NvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndHJbbmJUcmVlR3JpZFJvd10nLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciBuYkNlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+YCxcbiAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICduYi10cmVlLWdyaWQtcm93JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncm93JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtSb3csIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkUm93Q29tcG9uZW50IH1dXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRSb3dDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW05CX1RSRUVfR1JJRCxdIH1dIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH1cbl07XG5OYlRyZWVHcmlkUm93Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGRvdWJsZUNsaWNrRGVsYXk6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGNsaWNrVG9Ub2dnbGU6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHRvZ2dsZUlmRW5hYmxlZE5vZGU6IFt7IHR5cGU6IEhvc3RMaXN0ZW5lciwgYXJnczogWydjbGljaycsXSB9XSxcbiAgICB0b2dnbGVJZkVuYWJsZWROb2RlRGVlcDogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ2RibGNsaWNrJyxdIH1dXG59O1xuY2xhc3MgTmJUcmVlR3JpZEhlYWRlclJvd0NvbXBvbmVudCBleHRlbmRzIE5iSGVhZGVyUm93Q29tcG9uZW50IHtcbn1cbk5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RyW25iVHJlZUdyaWRIZWFkZXJSb3ddJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgbmJDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPmAsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbmItdHJlZS1ncmlkLWhlYWRlci1yb3cnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka0hlYWRlclJvdywgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnQgfV1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuY2xhc3MgTmJUcmVlR3JpZEZvb3RlclJvd0NvbXBvbmVudCBleHRlbmRzIE5iRm9vdGVyUm93Q29tcG9uZW50IHtcbn1cbk5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RyW25iVHJlZUdyaWRGb290ZXJSb3ddJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgbmJDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPmAsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbmItdHJlZS1ncmlkLWZvb3Rlci1yb3cnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka0Zvb3RlclJvdywgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQgfV1cbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIENvbHVtbiBkZWZpbml0aW9uIGZvciB0aGUgdHJlZS1ncmlkLlxuICogRGVmaW5lcyBhIHNldCBvZiBjZWxscyBhdmFpbGFibGUgZm9yIGEgdGFibGUgY29sdW1uLlxuICovXG5jbGFzcyBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlIGV4dGVuZHMgTmJDb2x1bW5EZWZEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhpZGVPblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaG93T25WYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbHVtbiBuYW1lXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zZXROYW1lSW5wdXQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWxzIG9mIHZpZXdwb3J0IGF0IHdoaWNoIGNvbHVtbiBzaG91bGQgYmUgaGlkZGVuLlxuICAgICAqIHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IGhpZGVPbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU9uVmFsdWU7XG4gICAgfVxuICAgIHNldCBoaWRlT24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5oaWRlT25WYWx1ZSA9ICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBwaXhlbHMgb2Ygdmlld3BvcnQgYXQgd2hpY2ggY29sdW1uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKiB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBzaG93T24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dPblZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2hvd09uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2hvd09uVmFsdWUgPSAhdmFsdWUgJiYgdmFsdWUgIT09IDBcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU9uICE9IG51bGwgJiYgdGhpcy5zaG93T24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoaWRlT24gYW5kIHNob3dPbiBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIGFuZCBjYW4ndCBiZSB1c2VkIHNpbXVsdGFuZW91c2x5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEhpZGUod2lkdGgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNob3VsZFNob3cod2lkdGgpO1xuICAgIH1cbiAgICBzaG91bGRTaG93KHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPbiA9PSBudWxsICYmIHRoaXMuc2hvd09uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVPbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiB0aGlzLmhpZGVPbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGggPj0gdGhpcy5zaG93T247XG4gICAgfVxufVxuTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRDb2x1bW5EZWZdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkNka0NvbHVtbkRlZiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9TT1JUX0hFQURFUl9DT0xVTU5fREVGLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgbmFtZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJUcmVlR3JpZENvbHVtbkRlZicsXSB9XSxcbiAgICBoaWRlT246IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dPbjogW3sgdHlwZTogSW5wdXQgfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUgZXh0ZW5kcyBOYkNlbGxEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZiwgZWxlbWVudFJlZiwgdHJlZSwgcGxhdGZvcm1JZCwgd2luZG93LCBzYW5pdGl6ZXIsIGRpcmVjdGlvblNlcnZpY2UsIGNvbHVtblNlcnZpY2UsIGNkKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIHRoaXMucGxhdGZvcm1JZCA9IHBsYXRmb3JtSWQ7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25TZXJ2aWNlID0gZGlyZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2x1bW5TZXJ2aWNlID0gY29sdW1uU2VydmljZTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsTGVmdFBhZGRpbmcgPSAnJztcbiAgICAgICAgdGhpcy5pbml0aWFsUmlnaHRQYWRkaW5nID0gJyc7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMuY29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgIH1cbiAgICBnZXQgY29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0V2lkdGggPSB0aGlzLnRyZWUuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgbGVmdFBhZGRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNMdHIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRQYWRkaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCByaWdodFBhZGRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNSdGwoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRQYWRkaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUkJDEgPSB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbExlZnRQYWRkaW5nID0gc3R5bGUkJDEucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxSaWdodFBhZGRpbmcgPSBzdHlsZSQkMS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5TZXJ2aWNlLm9uQ29sdW1uc0NoYW5nZSgpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5sYXRlc3RXaWR0aCAhPT0gdGhpcy50cmVlLmdldENvbHVtbldpZHRoKCkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIHRvZ2dsZVJvdygpIHtcbiAgICAgICAgdGhpcy50cmVlLnRvZ2dsZUNlbGxSb3codGhpcyk7XG4gICAgfVxuICAgIGdldCBpbml0aWFsU3RhcnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLmlzTHRyKClcbiAgICAgICAgICAgID8gdGhpcy5pbml0aWFsTGVmdFBhZGRpbmdcbiAgICAgICAgICAgIDogdGhpcy5pbml0aWFsUmlnaHRQYWRkaW5nO1xuICAgIH1cbiAgICBnZXRTdGFydFBhZGRpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJvd0xldmVsID0gdGhpcy50cmVlLmdldENlbGxMZXZlbCh0aGlzLCB0aGlzLmNvbHVtbkRlZi5uYW1lKTtcbiAgICAgICAgaWYgKHJvd0xldmVsID09PSBOQl9ERUZBVUxUX1JPV19MRVZFTCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVzdGluZ0xldmVsID0gcm93TGV2ZWwgKyAxO1xuICAgICAgICBsZXQgcGFkZGluZyA9ICcnO1xuICAgICAgICBpZiAodGhpcy50cmVlLmxldmVsUGFkZGluZykge1xuICAgICAgICAgICAgcGFkZGluZyA9IGBjYWxjKCR7dGhpcy50cmVlLmxldmVsUGFkZGluZ30gKiAke25lc3RpbmdMZXZlbH0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluaXRpYWxTdGFydFBhZGRpbmcpIHtcbiAgICAgICAgICAgIHBhZGRpbmcgPSBgY2FsYygke3RoaXMuaW5pdGlhbFN0YXJ0UGFkZGluZ30gKiAke25lc3RpbmdMZXZlbH0pYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhZGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUocGFkZGluZyk7XG4gICAgfVxufVxuTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RkW25iVHJlZUdyaWRDZWxsXScsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbmItdHJlZS1ncmlkLWNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdncmlkY2VsbCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrQ2VsbCwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfVFJFRV9HUklELF0gfV0gfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9XSU5ET1csXSB9XSB9LFxuICAgIHsgdHlwZTogRG9tU2FuaXRpemVyIH0sXG4gICAgeyB0eXBlOiBOYkxheW91dERpcmVjdGlvblNlcnZpY2UgfSxcbiAgICB7IHR5cGU6IE5iQ29sdW1uc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5OYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb2x1bW5XaWR0aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUud2lkdGgnLF0gfV0sXG4gICAgbGVmdFBhZGRpbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLnBhZGRpbmctbGVmdCcsXSB9XSxcbiAgICByaWdodFBhZGRpbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ3N0eWxlLnBhZGRpbmctcmlnaHQnLF0gfV1cbn07XG5jbGFzcyBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZSBleHRlbmRzIE5iSGVhZGVyQ2VsbERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmLCB0cmVlLCBjb2x1bW5TZXJ2aWNlLCBjZCkge1xuICAgICAgICBzdXBlcihjb2x1bW5EZWYsIGVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UgPSBjb2x1bW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICBnZXQgY29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0V2lkdGggPSB0aGlzLnRyZWUuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0V2lkdGggfHwgbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VydmljZS5vbkNvbHVtbnNDaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMubGF0ZXN0V2lkdGggIT09IHRoaXMudHJlZS5nZXRDb2x1bW5XaWR0aCgpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLmRldGVjdENoYW5nZXMoKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRIZWFkZXJDZWxsRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICd0aFtuYlRyZWVHcmlkSGVhZGVyQ2VsbF0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ25iLXRyZWUtZ3JpZC1oZWFkZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrSGVhZGVyQ2VsbCwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRIZWFkZXJDZWxsRGlyZWN0aXZlIH1dLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbTkJfVFJFRV9HUklELF0gfV0gfSxcbiAgICB7IHR5cGU6IE5iQ29sdW1uc1NlcnZpY2UgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH1cbl07XG5OYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBjb2x1bW5XaWR0aDogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnc3R5bGUud2lkdGgnLF0gfV1cbn07XG5jbGFzcyBOYlRyZWVHcmlkRm9vdGVyQ2VsbERpcmVjdGl2ZSBleHRlbmRzIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmLCB0cmVlLCBjb2x1bW5TZXJ2aWNlLCBjZCkge1xuICAgICAgICBzdXBlcihjb2x1bW5EZWYsIGVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UgPSBjb2x1bW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICBnZXQgY29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0V2lkdGggPSB0aGlzLnRyZWUuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0V2lkdGggfHwgbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VydmljZS5vbkNvbHVtbnNDaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMubGF0ZXN0V2lkdGggIT09IHRoaXMudHJlZS5nZXRDb2x1bW5XaWR0aCgpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLmRldGVjdENoYW5nZXMoKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbk5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZFtuYlRyZWVHcmlkRm9vdGVyQ2VsbF0nLFxuICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ25iLXRyZWUtZ3JpZC1mb290ZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ2dyaWRjZWxsJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtGb290ZXJDZWxsLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmUgfV0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZSB9LFxuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtOQl9UUkVFX0dSSUQsXSB9XSB9LFxuICAgIHsgdHlwZTogTmJDb2x1bW5zU2VydmljZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIGNvbHVtbldpZHRoOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydzdHlsZS53aWR0aCcsXSB9XVxufTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkZpbHRlckRpcmVjdGl2ZSB7XG4gICAgZmlsdGVyKGZpbHRlclJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJhYmxlLmZpbHRlcihmaWx0ZXJSZXF1ZXN0KTtcbiAgICB9XG59XG5OYkZpbHRlckRpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuYkZpbHRlcl0nIH0sXSB9XG5dO1xuTmJGaWx0ZXJEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgZmlsdGVyYWJsZTogW3sgdHlwZTogSW5wdXQsIGFyZ3M6IFsnbmJGaWx0ZXInLF0gfV1cbn07XG4vKipcbiAqIEhlbHBlciBkaXJlY3RpdmUgdG8gdHJpZ2dlciBkYXRhIHNvdXJjZSdzIGZpbHRlciBtZXRob2Qgd2hlbiB1c2VyIHR5cGVzIGluIGlucHV0XG4gKi9cbmNsYXNzIE5iRmlsdGVySW5wdXREaXJlY3RpdmUgZXh0ZW5kcyBOYkZpbHRlckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2VhcmNoJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVib3VuY2UgdGltZSBiZWZvcmUgdHJpZ2dlcmluZyBmaWx0ZXIgbWV0aG9kLiBTZXQgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKiBEZWZhdWx0IDIwMC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVib3VuY2VUaW1lID0gMjAwO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2gkXG4gICAgICAgICAgICAucGlwZShkZWJvdW5jZVRpbWUodGhpcy5kZWJvdW5jZVRpbWUpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChxdWVyeSkgPT4ge1xuICAgICAgICAgICAgc3VwZXIuZmlsdGVyKHF1ZXJ5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnNlYXJjaCQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZmlsdGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2VhcmNoJC5uZXh0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfVxufVxuTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25iRmlsdGVySW5wdXRdJyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iRmlsdGVyRGlyZWN0aXZlLCB1c2VFeGlzdGluZzogTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZSB9XSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBmaWx0ZXJhYmxlOiBbeyB0eXBlOiBJbnB1dCwgYXJnczogWyduYkZpbHRlcklucHV0JyxdIH1dLFxuICAgIGRlYm91bmNlVGltZTogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZmlsdGVyOiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnaW5wdXQnLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBXaGVuIHVzaW5nIGN1c3RvbSByb3cgdG9nZ2xlLCBhcHBseSB0aGlzIGRpcmVjdGl2ZSBvbiB5b3VyIHRvZ2dsZSB0byB0b2dnbGUgcm93IG9uIGVsZW1lbnQgY2xpY2suXG4gKi9cbmNsYXNzIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNlbGwpIHtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB9XG4gICAgdG9nZ2xlUm93KCRldmVudCkge1xuICAgICAgICB0aGlzLmNlbGwudG9nZ2xlUm93KCk7XG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG59XG5OYlRyZWVHcmlkUm93VG9nZ2xlRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJUcmVlR3JpZFJvd1RvZ2dsZV0nLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYlRyZWVHcmlkUm93VG9nZ2xlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUgfVxuXTtcbk5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgdG9nZ2xlUm93OiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLyoqXG4gKiBOYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50XG4gKi9cbmNsYXNzIE5iVHJlZUdyaWRSb3dUb2dnbGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNlbGwpIHtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB9XG4gICAgc2V0IGV4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkVmFsdWU7XG4gICAgfVxuICAgIHRvZ2dsZVJvdygkZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jZWxsLnRvZ2dsZVJvdygpO1xuICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxufVxuTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItdHJlZS1ncmlkLXJvdy10b2dnbGUnLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiBjbGFzcz1cInJvdy10b2dnbGUtYnV0dG9uXCIgW2F0dHIuYXJpYS1sYWJlbF09XCJleHBhbmRlZCA/ICdjb2xsYXBzZScgOiAnZXhwYW5kJ1wiPlxuICAgICAgPG5iLWljb24gW2ljb25dPVwiZXhwYW5kZWQgPyAnY2hldnJvbi1kb3duLW91dGxpbmUnIDogJ2NoZXZyb24tcmlnaHQtb3V0bGluZSdcIlxuICAgICAgICAgICAgICAgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiXG4gICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgIDwvbmItaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgYCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtgXG4gICAgYnV0dG9uIHtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgcGFkZGluZzogMDtcbiAgICB9XG4gIGBdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVHJlZUdyaWRSb3dUb2dnbGVDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSB9XG5dO1xuTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICBleHBhbmRlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgdG9nZ2xlUm93OiBbeyB0eXBlOiBIb3N0TGlzdGVuZXIsIGFyZ3M6IFsnY2xpY2snLCBbJyRldmVudCddLF0gfV1cbn07XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgQ09NUE9ORU5UUyQyID0gW1xuICAgIC8vIFRyZWUgR3JpZFxuICAgIE5iVHJlZUdyaWRDb21wb25lbnQsXG4gICAgTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkUm93Q29tcG9uZW50LFxuICAgIE5iVHJlZUdyaWRDZWxsRGVmRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZEhlYWRlclJvd0NvbXBvbmVudCxcbiAgICBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQsXG4gICAgTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZSxcbiAgICAvLyBTb3J0IGRpcmVjdGl2ZXNcbiAgICBOYlNvcnREaXJlY3RpdmUsXG4gICAgTmJTb3J0SGVhZGVyQ29tcG9uZW50LFxuICAgIE5iU29ydEljb25Db21wb25lbnQsXG4gICAgLy8gRmlsdGVyIGRpcmVjdGl2ZXNcbiAgICBOYkZpbHRlckRpcmVjdGl2ZSxcbiAgICBOYkZpbHRlcklucHV0RGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudCxcbiAgICBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlLFxuXTtcbmNsYXNzIE5iVHJlZUdyaWRNb2R1bGUge1xufVxuTmJUcmVlR3JpZE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTmJUYWJsZU1vZHVsZSwgTmJJY29uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFsuLi5DT01QT05FTlRTJDJdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYlRhYmxlTW9kdWxlLCAuLi5DT01QT05FTlRTJDJdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICBOYlRyZWVHcmlkU29ydFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIE5iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYlRyZWVHcmlkU2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgTmJUcmVlR3JpZERhdGFTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICAgICBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRvZ2dsZSBpcyBhIGNvbnRyb2wgcmVwcmVzZW50aW5nIGBvbmAgYW5kIGBvZmZgIHN0YXRlcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0b2dnbGUvdG9nZ2xlLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRvZ2dsZUNvbXBvbmVudGAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUb2dnbGVNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFRvZ2dsZSBtYXkgaGF2ZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdGF0dXNlczogYGJhc2ljYCwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBpbmZvYCwgYGNvbnRyb2xgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShUb2dnbGUgc3RhdHVzLCB0b2dnbGUvdG9nZ2xlLXN0YXR1cy5jb21wb25lbnQpXG4gKlxuICogVG9nZ2xlIGNhbiBiZSBkaXNhYmxlZCB2aWEgYGRpc2FibGVkYCBpbnB1dC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIFRvZ2dsZXMsIHRvZ2dsZS90b2dnbGUtZGlzYWJsZWQuY29tcG9uZW50KVxuICpcbiAqIFRvZ2dsZSBtYXkgaGF2ZSBhIGxhYmVsIHdpdGggZm9sbG93aW5nIHBvc2l0aW9uczogYGxlZnRgLCBgcmlnaHRgLCBgc3RhcnRgLCBgZW5kYCAoZGVmYXVsdClcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFRvZ2dsZXMgV2l0aCBMYWJlbHMsIHRvZ2dsZS90b2dnbGUtbGFiZWwtcG9zaXRpb24uY29tcG9uZW50LnRzKVxuICpcbiAqIFlvdSBjYW4gc2V0IGNvbnRyb2wgc3RhdGUgdmlhIGBjaGVja2VkYCBiaW5kaW5nOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi10b2dnbGUgWyhjaGVja2VkKV09XCJjaGVja2VkXCI+PC9uYi10b2dnbGU+XG4gKiBgYGBcbiAqXG4gKiBPciBpdCBjb3VsZCBiZSBzZXQgdmlhIHJlYWN0aXZlIGZvcm1zIG9yIG5nTW9kZWwgYmluZGluZ3M6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShUb2dnbGUgZm9ybSBiaW5kaW5nLCB0b2dnbGUvdG9nZ2xlLWZvcm0uY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0b2dnbGUtaGVpZ2h0OlxuICogdG9nZ2xlLXdpZHRoOlxuICogdG9nZ2xlLWJvcmRlci13aWR0aDpcbiAqIHRvZ2dsZS1ib3JkZXItcmFkaXVzOlxuICogdG9nZ2xlLW91dGxpbmUtd2lkdGg6XG4gKiB0b2dnbGUtb3V0bGluZS1jb2xvcjpcbiAqIHRvZ2dsZS1zd2l0Y2hlci1zaXplOlxuICogdG9nZ2xlLXN3aXRjaGVyLWljb24tc2l6ZTpcbiAqIHRvZ2dsZS10ZXh0LWZvbnQtZmFtaWx5OlxuICogdG9nZ2xlLXRleHQtZm9udC1zaXplOlxuICogdG9nZ2xlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0b2dnbGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIHRvZ2dsZS1jdXJzb3I6XG4gKiB0b2dnbGUtZGlzYWJsZWQtY3Vyc29yOlxuICogdG9nZ2xlLWJhc2ljLXRleHQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1kaXNhYmxlZC1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLWluZm8tdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWRpc2FibGVkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWNoZWNrZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICovXG5jbGFzcyBOYlRvZ2dsZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY2hhbmdlRGV0ZWN0b3IsIGxheW91dERpcmVjdGlvbiwgcmVuZGVyZXIsIGhvc3RFbGVtZW50LCB6b25lLCBzdGF0dXNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5sYXlvdXREaXJlY3Rpb24gPSBsYXlvdXREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLnN0YXR1c1NlcnZpY2UgPSBzdGF0dXNTZXJ2aWNlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZ2dsZSBzdGF0dXMuXG4gICAgICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGBiYXNpY2AsIGBwcmltYXJ5YCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgaW5mb2AsIGBjb250cm9sYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRvZ2dsZSBsYWJlbCBwb3NpdGlvbi5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzIGFyZTogYGxlZnRgLCBgcmlnaHRgLCBgc3RhcnRgLCBgZW5kYCAoZGVmYXVsdClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxQb3NpdGlvbiA9ICdlbmQnO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3V0cHV0IHdoZW4gY2hlY2tlZCBzdGF0ZSBpcyBjaGFuZ2VkIGJ5IGEgdXNlclxuICAgICAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8Ym9vbGVhbj5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGNoZWNrZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgfVxuICAgIHNldCBjaGVja2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyBpbnB1dCBkaXNhYmxlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIGdldCBhZGRpdGlvbmFsQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzU2VydmljZS5pc0N1c3RvbVN0YXR1cyh0aGlzLnN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdGF0dXNTZXJ2aWNlLmdldFN0YXR1c0NsYXNzKHRoaXMuc3RhdHVzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgbGFiZWxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgfVxuICAgIGdldCBsYWJlbFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgIH1cbiAgICBnZXQgbGFiZWxTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxQb3NpdGlvbiA9PT0gJ3N0YXJ0JztcbiAgICB9XG4gICAgZ2V0IGxhYmVsRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnZW5kJztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCkpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIC8vIFRPRE86ICMyMjU0XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbmItdHJhbnNpdGlvbicpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBjaGVja1N0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXREaXJlY3Rpb24uaXNMdHIoKSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RGlyZWN0aW9uLmlzTHRyKCkgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gdmFsO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZFN0YXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuICAgICAgICB0aGlzLmNoZWNrZWRDaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG4gICAgfVxuICAgIG9uSW5wdXRDbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG59XG5OYlRvZ2dsZUNvbXBvbmVudC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcG9uZW50LCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmItdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoJ3Bvc2l0aW9uJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUoJ3JpZ2h0Jywgc3R5bGUoeyByaWdodDogMCwgbGVmdDogJyonIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlKCdsZWZ0Jywgc3R5bGUoeyBsZWZ0OiAwLCByaWdodDogJyonIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFthbmltYXRlKDApXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdyaWdodCA8PT4gbGVmdCcsIFthbmltYXRlKCcwLjE1cycpXSksXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGFiZWwgY2xhc3M9XCJ0b2dnbGUtbGFiZWxcIj5cbiAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgIGNsYXNzPVwibmF0aXZlLWlucHV0IHZpc3VhbGx5LWhpZGRlblwiXG4gICAgICAgICAgICAgcm9sZT1cInN3aXRjaFwiXG4gICAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgW2NoZWNrZWRdPVwiY2hlY2tlZFwiXG4gICAgICAgICAgICAgKGNoYW5nZSk9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAoYmx1cik9XCJvblRvdWNoZWQoKVwiXG4gICAgICAgICAgICAgKGNsaWNrKT1cIm9uSW5wdXRDbGljaygkZXZlbnQpXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlXCIgW2NsYXNzLmNoZWNrZWRdPVwiY2hlY2tlZFwiPlxuICAgICAgICA8c3BhbiBbQHBvc2l0aW9uXT1cImNoZWNrU3RhdGUoKVwiIGNsYXNzPVwidG9nZ2xlLXN3aXRjaGVyXCI+XG4gICAgICAgICAgPG5iLWljb24gKm5nSWY9XCJjaGVja2VkXCIgaWNvbj1cImNoZWNrbWFyay1ib2xkLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L3NwYW4+XG4gICAgPC9sYWJlbD5cbiAgYCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iVG9nZ2xlQ29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6aW5saW5lLWZsZXg7b3V0bGluZTpub25lfTpob3N0KC50b2dnbGUtbGFiZWwtbGVmdCkgLnRleHQ6bm90KDplbXB0eSl7cGFkZGluZy1yaWdodDowLjY4NzVyZW19W2Rpcj1sdHJdIDpob3N0KC50b2dnbGUtbGFiZWwtbGVmdCkgLnRleHQ6bm90KDplbXB0eSl7b3JkZXI6LTF9W2Rpcj1ydGxdIDpob3N0KC50b2dnbGUtbGFiZWwtbGVmdCkgLnRleHQ6bm90KDplbXB0eSl7b3JkZXI6MX06aG9zdCgudG9nZ2xlLWxhYmVsLXJpZ2h0KSAudGV4dDpub3QoOmVtcHR5KXtwYWRkaW5nLWxlZnQ6MC42ODc1cmVtfVtkaXI9bHRyXSA6aG9zdCgudG9nZ2xlLWxhYmVsLXJpZ2h0KSAudGV4dDpub3QoOmVtcHR5KXtvcmRlcjoxfVtkaXI9cnRsXSA6aG9zdCgudG9nZ2xlLWxhYmVsLXJpZ2h0KSAudGV4dDpub3QoOmVtcHR5KXtvcmRlcjotMX06aG9zdCgudG9nZ2xlLWxhYmVsLXN0YXJ0KSAudG9nZ2xlLWxhYmVse2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfVtkaXI9bHRyXSA6aG9zdCgudG9nZ2xlLWxhYmVsLXN0YXJ0KSAudG9nZ2xlLWxhYmVsIC50ZXh0Om5vdCg6ZW1wdHkpe3BhZGRpbmctcmlnaHQ6LjY4NzVyZW19W2Rpcj1ydGxdIDpob3N0KC50b2dnbGUtbGFiZWwtc3RhcnQpIC50b2dnbGUtbGFiZWwgLnRleHQ6bm90KDplbXB0eSl7cGFkZGluZy1sZWZ0Oi42ODc1cmVtfVtkaXI9bHRyXSA6aG9zdCgudG9nZ2xlLWxhYmVsLWVuZCkgLnRleHQ6bm90KDplbXB0eSl7cGFkZGluZy1sZWZ0Oi42ODc1cmVtfVtkaXI9cnRsXSA6aG9zdCgudG9nZ2xlLWxhYmVsLWVuZCkgLnRleHQ6bm90KDplbXB0eSl7cGFkZGluZy1yaWdodDouNjg3NXJlbX06aG9zdCgubmItdHJhbnNpdGlvbikgLnRvZ2dsZXt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcixib3JkZXIsYm94LXNoYWRvdzt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWlufS50b2dnbGUtbGFiZWx7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnRvZ2dsZXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1mbGV4O2JveC1zaXppbmc6Y29udGVudC1ib3h9LnRvZ2dsZS1zd2l0Y2hlcntwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXItcmFkaXVzOjUwJTttYXJnaW46MXB4fS50b2dnbGUtc3dpdGNoZXIgbmItaWNvbntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSl9XFxuXCJdXG4gICAgICAgICAgICB9LF0gfVxuXTtcbk5iVG9nZ2xlQ29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfSxcbiAgICB7IHR5cGU6IE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSB9LFxuICAgIHsgdHlwZTogUmVuZGVyZXIyIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50UmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IE5iU3RhdHVzU2VydmljZSB9XG5dO1xuTmJUb2dnbGVDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgY2hlY2tlZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgZGlzYWJsZWQ6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHN0YXR1czogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgbGFiZWxQb3NpdGlvbjogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgY2hlY2tlZENoYW5nZTogW3sgdHlwZTogT3V0cHV0IH1dLFxuICAgIHByaW1hcnk6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyxdIH1dLFxuICAgIHN1Y2Nlc3M6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyxdIH1dLFxuICAgIHdhcm5pbmc6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyxdIH1dLFxuICAgIGRhbmdlcjogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWRhbmdlcicsXSB9XSxcbiAgICBpbmZvOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy5zdGF0dXMtaW5mbycsXSB9XSxcbiAgICBiYXNpYzogW3sgdHlwZTogSG9zdEJpbmRpbmcsIGFyZ3M6IFsnY2xhc3Muc3RhdHVzLWJhc2ljJyxdIH1dLFxuICAgIGNvbnRyb2w6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnN0YXR1cy1jb250cm9sJyxdIH1dLFxuICAgIGFkZGl0aW9uYWxDbGFzc2VzOiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcycsXSB9XSxcbiAgICBsYWJlbExlZnQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnRvZ2dsZS1sYWJlbC1sZWZ0JyxdIH1dLFxuICAgIGxhYmVsUmlnaHQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnRvZ2dsZS1sYWJlbC1yaWdodCcsXSB9XSxcbiAgICBsYWJlbFN0YXJ0OiBbeyB0eXBlOiBIb3N0QmluZGluZywgYXJnczogWydjbGFzcy50b2dnbGUtbGFiZWwtc3RhcnQnLF0gfV0sXG4gICAgbGFiZWxFbmQ6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzLnRvZ2dsZS1sYWJlbC1lbmQnLF0gfV1cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iVG9nZ2xlTW9kdWxlIHtcbn1cbk5iVG9nZ2xlTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJUb2dnbGVDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtOYlRvZ2dsZUNvbXBvbmVudF0sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuY2xhc3MgTmJQcmVmaXhEaXJlY3RpdmUge1xufVxuTmJQcmVmaXhEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IERpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuYlByZWZpeF0nLFxuICAgICAgICAgICAgfSxdIH1cbl07XG5cbmNsYXNzIE5iU3VmZml4RGlyZWN0aXZlIHtcbn1cbk5iU3VmZml4RGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmJTdWZmaXhdJyxcbiAgICAgICAgICAgIH0sXSB9XG5dO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvd0Zvcm1Db250cm9sRWxlbWVudE5vdEZvdW5kKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTmJGb3JtRmllbGRDb21wb25lbnQgbXVzdCBjb250YWluIFtuYklucHV0XWApO1xufVxuLypcbiAqIE5iRm9ybUZpZWxkQ29tcG9uZW50XG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGZvcm0tZmllbGQtYWRkb24tYmFzaWMtdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24tYmFzaWMtaGlnaGxpZ2h0LXRleHQtY29sb3I6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24tcHJpbWFyeS1oaWdobGlnaHQtdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24tc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogZm9ybS1maWVsZC1hZGRvbi1zdWNjZXNzLWhpZ2hsaWdodC10ZXh0LWNvbG9yOlxuICogZm9ybS1maWVsZC1hZGRvbi1pbmZvLXRleHQtY29sb3I6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWluZm8taGlnaGxpZ2h0LXRleHQtY29sb3I6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24td2FybmluZy1oaWdobGlnaHQtdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24tZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWRhbmdlci1oaWdobGlnaHQtdGV4dC1jb2xvcjpcbiAqIGZvcm0tZmllbGQtYWRkb24tY29udHJvbC10ZXh0LWNvbG9yOlxuICogZm9ybS1maWVsZC1hZGRvbi1jb250cm9sLWhpZ2hsaWdodC10ZXh0LWNvbG9yOlxuICogZm9ybS1maWVsZC1hZGRvbi1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogZm9ybS1maWVsZC1hZGRvbi10aW55LWhlaWdodDpcbiAqIGZvcm0tZmllbGQtYWRkb24tdGlueS13aWR0aDpcbiAqIGZvcm0tZmllbGQtYWRkb24tdGlueS1pY29uLXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXRpbnktZm9udC1zaXplOlxuICogZm9ybS1maWVsZC1hZGRvbi10aW55LWxpbmUtaGVpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi10aW55LWZvbnQtd2VpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi1zbWFsbC1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXNtYWxsLXdpZHRoOlxuICogZm9ybS1maWVsZC1hZGRvbi1zbWFsbC1pY29uLXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXNtYWxsLWZvbnQtc2l6ZTpcbiAqIGZvcm0tZmllbGQtYWRkb24tc21hbGwtbGluZS1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLXNtYWxsLWZvbnQtd2VpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi1tZWRpdW0taGVpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi1tZWRpdW0td2lkdGg6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLW1lZGl1bS1pY29uLXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLW1lZGl1bS1mb250LXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLW1lZGl1bS1saW5lLWhlaWdodDpcbiAqIGZvcm0tZmllbGQtYWRkb24tbWVkaXVtLWZvbnQtd2VpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi1sYXJnZS1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWxhcmdlLXdpZHRoOlxuICogZm9ybS1maWVsZC1hZGRvbi1sYXJnZS1pY29uLXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWxhcmdlLWZvbnQtc2l6ZTpcbiAqIGZvcm0tZmllbGQtYWRkb24tbGFyZ2UtbGluZS1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWxhcmdlLWZvbnQtd2VpZ2h0OlxuICogZm9ybS1maWVsZC1hZGRvbi1naWFudC1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWdpYW50LXdpZHRoOlxuICogZm9ybS1maWVsZC1hZGRvbi1naWFudC1pY29uLXNpemU6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWdpYW50LWZvbnQtc2l6ZTpcbiAqIGZvcm0tZmllbGQtYWRkb24tZ2lhbnQtbGluZS1oZWlnaHQ6XG4gKiBmb3JtLWZpZWxkLWFkZG9uLWdpYW50LWZvbnQtd2VpZ2h0OlxuICoqL1xuY2xhc3MgTmJGb3JtRmllbGRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNkLCB6b25lLCBlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5kZXN0cm95JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2xTdGF0ZSQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbiAgICAgICAgdGhpcy5wcmVmaXhDbGFzc2VzJCA9IHRoaXMuZm9ybUNvbnRyb2xTdGF0ZSQucGlwZShtYXAocyA9PiB0aGlzLmdldEFkZG9uQ2xhc3NlcygncHJlZml4JywgcykpKTtcbiAgICAgICAgdGhpcy5zdWZmaXhDbGFzc2VzJCA9IHRoaXMuZm9ybUNvbnRyb2xTdGF0ZSQucGlwZShtYXAocyA9PiB0aGlzLmdldEFkZG9uQ2xhc3Nlcygnc3VmZml4JywgcykpKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRocm93Rm9ybUNvbnRyb2xFbGVtZW50Tm90Rm91bmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9Gb3JtQ29udHJvbFN0YXRlQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9BZGRvbkNoYW5nZSgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIC8vIFRPRE86ICMyMjU0XG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICduYi10cmFuc2l0aW9uJyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIH1cbiAgICBzaG91bGRTaG93UHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtQ29udHJvbENvbmZpZygpLnN1cHBvcnRzUHJlZml4ICYmICEhdGhpcy5wcmVmaXgubGVuZ3RoO1xuICAgIH1cbiAgICBzaG91bGRTaG93U3VmZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtQ29udHJvbENvbmZpZygpLnN1cHBvcnRzU3VmZml4ICYmICEhdGhpcy5zdWZmaXgubGVuZ3RoO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0Zvcm1Db250cm9sU3RhdGVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZWQkLCBmb2N1c2VkJCwgc2l6ZSQsIHN0YXR1cyQsIGZ1bGxXaWR0aCQgfSA9IHRoaXMuZm9ybUNvbnRyb2w7XG4gICAgICAgIGNvbWJpbmVMYXRlc3QoW2Rpc2FibGVkJCwgZm9jdXNlZCQsIHNpemUkLCBzdGF0dXMkLCBmdWxsV2lkdGgkXSlcbiAgICAgICAgICAgIC5waXBlKG1hcCgoW2Rpc2FibGVkLCBmb2N1c2VkLCBzaXplLCBzdGF0dXMsIGZ1bGxXaWR0aF0pID0+ICh7IGRpc2FibGVkLCBmb2N1c2VkLCBzaXplLCBzdGF0dXMsIGZ1bGxXaWR0aCB9KSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKChvbGRTdGF0ZSwgc3RhdGUkJDEpID0+IHRoaXMuaXNTdGF0ZXNFcXVhbChvbGRTdGF0ZSwgc3RhdGUkJDEpKSwgdGFwKCh7IHNpemUsIGZ1bGxXaWR0aCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRDbGFzc2VzID0gW2BuYi1mb3JtLWZpZWxkLXNpemUtJHtzaXplfWBdO1xuICAgICAgICAgICAgaWYgKCFmdWxsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBmb3JtRmllbGRDbGFzc2VzLnB1c2goJ25iLWZvcm0tZmllbGQtbGltaXRlZC13aWR0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtRmllbGRDbGFzc2VzID0gZm9ybUZpZWxkQ2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgIH0pLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuZm9ybUNvbnRyb2xTdGF0ZSQpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0FkZG9uQ2hhbmdlKCkge1xuICAgICAgICBtZXJnZSh0aGlzLnByZWZpeC5jaGFuZ2VzLCB0aGlzLnN1ZmZpeC5jaGFuZ2VzKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9XG4gICAgZ2V0QWRkb25DbGFzc2VzKGFkZG9uLCBzdGF0ZSQkMSkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gW1xuICAgICAgICAgICAgJ25iLWZvcm0tZmllbGQtYWRkb24nLFxuICAgICAgICAgICAgYG5iLWZvcm0tZmllbGQtJHthZGRvbn0tJHtzdGF0ZSQkMS5zaXplfWAsXG4gICAgICAgIF07XG4gICAgICAgIGlmIChzdGF0ZSQkMS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGBuYi1mb3JtLWZpZWxkLWFkZG9uLWRpc2FibGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUkJDEuZm9jdXNlZCkge1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGBuYi1mb3JtLWZpZWxkLWFkZG9uLSR7c3RhdGUkJDEuc3RhdHVzfS1oaWdobGlnaHRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChgbmItZm9ybS1maWVsZC1hZGRvbi0ke3N0YXRlJCQxLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgZ2V0Rm9ybUNvbnRyb2xDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1Db250cm9sQ29uZmlnIHx8IG5ldyBOYkZvcm1GaWVsZENvbnRyb2xDb25maWcoKTtcbiAgICB9XG4gICAgaXNTdGF0ZXNFcXVhbChvbGRTdGF0ZSwgc3RhdGUkJDEpIHtcbiAgICAgICAgcmV0dXJuIG9sZFN0YXRlLnN0YXR1cyA9PT0gc3RhdGUkJDEuc3RhdHVzICYmXG4gICAgICAgICAgICBvbGRTdGF0ZS5kaXNhYmxlZCA9PT0gc3RhdGUkJDEuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgIG9sZFN0YXRlLmZvY3VzZWQgPT09IHN0YXRlJCQxLmZvY3VzZWQgJiZcbiAgICAgICAgICAgIG9sZFN0YXRlLmZ1bGxXaWR0aCA9PT0gc3RhdGUkJDEuZnVsbFdpZHRoICYmXG4gICAgICAgICAgICBvbGRTdGF0ZS5zaXplID09PSBzdGF0ZSQkMS5zaXplO1xuICAgIH1cbn1cbk5iRm9ybUZpZWxkQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduYi1mb3JtLWZpZWxkJyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2ICpuZ0lmPVxcXCJzaG91bGRTaG93UHJlZml4KClcXFwiIFtuZ0NsYXNzXT1cXFwicHJlZml4Q2xhc3NlcyQgfCBhc3luY1xcXCI+XFxuICA8bmctY29udGVudCBzZWxlY3Q9XFxcIltuYlByZWZpeF1cXFwiPjwvbmctY29udGVudD5cXG48L2Rpdj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJuYi1mb3JtLWNvbnRyb2wtY29udGFpbmVyXFxcIlxcbiAgICAgW2NsYXNzLm5iLWZvcm0tZmllbGQtY29udHJvbC13aXRoLXByZWZpeF09XFxcInNob3VsZFNob3dQcmVmaXgoKVxcXCJcXG4gICAgIFtjbGFzcy5uYi1mb3JtLWZpZWxkLWNvbnRyb2wtd2l0aC1zdWZmaXhdPVxcXCJzaG91bGRTaG93U3VmZml4KClcXFwiPlxcbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbjwvZGl2PlxcblxcbjxkaXYgKm5nSWY9XFxcInNob3VsZFNob3dTdWZmaXgoKVxcXCIgW25nQ2xhc3NdPVxcXCJzdWZmaXhDbGFzc2VzJCB8IGFzeW5jXFxcIj5cXG4gIDxuZy1jb250ZW50IHNlbGVjdD1cXFwiW25iU3VmZml4XVxcXCI+PC9uZy1jb250ZW50PlxcbjwvZGl2PlxcblwiLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0ubmItZm9ybS1jb250cm9sLWNvbnRhaW5lcnt3aWR0aDoxMDAlfVxcblwiXVxuICAgICAgICAgICAgfSxdIH1cbl07XG5OYkZvcm1GaWVsZENvbXBvbmVudC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRSZWYgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyMiB9XG5dO1xuTmJGb3JtRmllbGRDb21wb25lbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgcHJlZml4OiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYlByZWZpeERpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgc3VmZml4OiBbeyB0eXBlOiBDb250ZW50Q2hpbGRyZW4sIGFyZ3M6IFtOYlN1ZmZpeERpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9LF0gfV0sXG4gICAgZm9ybUNvbnRyb2w6IFt7IHR5cGU6IENvbnRlbnRDaGlsZCwgYXJnczogW05iRm9ybUZpZWxkQ29udHJvbCwgeyBzdGF0aWM6IGZhbHNlIH0sXSB9XSxcbiAgICBmb3JtQ29udHJvbENvbmZpZzogW3sgdHlwZTogQ29udGVudENoaWxkLCBhcmdzOiBbTmJGb3JtRmllbGRDb250cm9sQ29uZmlnLCB7IHN0YXRpYzogZmFsc2UgfSxdIH1dLFxuICAgIGZvcm1GaWVsZENsYXNzZXM6IFt7IHR5cGU6IEhvc3RCaW5kaW5nLCBhcmdzOiBbJ2NsYXNzJyxdIH1dXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBDT01QT05FTlRTJDMgPSBbXG4gICAgTmJGb3JtRmllbGRDb21wb25lbnQsXG4gICAgTmJQcmVmaXhEaXJlY3RpdmUsXG4gICAgTmJTdWZmaXhEaXJlY3RpdmUsXG5dO1xuY2xhc3MgTmJGb3JtRmllbGRNb2R1bGUge1xufVxuTmJGb3JtRmllbGRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVFMkM10sXG4gICAgICAgICAgICAgICAgZXhwb3J0czogWy4uLkNPTVBPTkVOVFMkM10sXG4gICAgICAgICAgICB9LF0gfVxuXTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuLy8gVE9ETzogZXhwb3J0IGFsbCBjb21wb25lbnRzXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgTmJDYWxlbmRhckFjdGlvbnNDb21wb25lbnQgYXMgybVlLCBOYkFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UgYXMgybVkLCBOYkZvY3VzS2V5TWFuYWdlckZhY3RvcnlTZXJ2aWNlIGFzIMm1YywgTmJDYWxlbmRhcldpdGhUaW1lQ29tcG9uZW50IGFzIMm1ZywgTmJNZW51SW50ZXJuYWxTZXJ2aWNlIGFzIMm1YSwgTmJTaGFyZWRNb2R1bGUgYXMgybViLCBOYlRpbWVQaWNrZXJDZWxsQ29tcG9uZW50IGFzIMm1ZiwgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQsIE5iRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50LCBOYkNhbGVuZGFyTW9udGhQaWNrZXJDb21wb25lbnQsIE1PTlRIU19JTl9WSUVXLCBNT05USFNfSU5fQ09MVU1OLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LCBOYkNhbGVuZGFyVmlld01vZGVDb21wb25lbnQsIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQsIE5iQ2FsZW5kYXJEYXlzTmFtZXNDb21wb25lbnQsIE5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50LCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQsIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQsIE5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQsIE5iQ2FsZW5kYXJNb250aE1vZGVsU2VydmljZSwgTmJOYXRpdmVEYXRlU2VydmljZSwgTmJEYXRlU2VydmljZSwgTmJNZW51U2VydmljZSwgTmJNZW51SXRlbSwgTmJTaWRlYmFyU2VydmljZSwgTkJfVEhFTUVfT1BUSU9OUywgTkJfTUVESUFfQlJFQUtQT0lOVFMsIE5CX0JVSUxUX0lOX0pTX1RIRU1FUywgTkJfSlNfVEhFTUVTLCBOQl9XSU5ET1csIE5CX0RPQ1VNRU5ULCB3aW5kb3dGYWN0b3J5LCBOYlRoZW1lTW9kdWxlLCBOYlRoZW1lU2VydmljZSwgTmJTcGlubmVyU2VydmljZSwgREVGQVVMVF9NRURJQV9CUkVBS1BPSU5UUywgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSwgTmJDb2xvckhlbHBlciwgTmJMYXlvdXREaXJlY3Rpb24sIE5CX0xBWU9VVF9ESVJFQ1RJT04sIE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSwgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLCBOYkxheW91dFJ1bGVyU2VydmljZSwgTmJTdGF0dXNTZXJ2aWNlLCBCVUlMVF9JTl9USEVNRVMsIE5iSlNUaGVtZXNSZWdpc3RyeSwgQ09SUE9SQVRFX1RIRU1FLCBDT1NNSUNfVEhFTUUsIERFRkFVTFRfVEhFTUUsIERBUktfVEhFTUUsIE5iQ2FyZE1vZHVsZSwgTmJDYXJkSGVhZGVyQ29tcG9uZW50LCBOYkNhcmRCb2R5Q29tcG9uZW50LCBOYkNhcmRGb290ZXJDb21wb25lbnQsIE5iQ2FyZENvbXBvbmVudCwgTmJGbGlwQ2FyZENvbXBvbmVudCwgTmJSZXZlYWxDYXJkQ29tcG9uZW50LCBOYkNhcmRGcm9udENvbXBvbmVudCwgTmJDYXJkQmFja0NvbXBvbmVudCwgTmJDYWxlbmRhck1vZHVsZSwgTmJDYWxlbmRhckNvbXBvbmVudCwgTmJDYWxlbmRhclJhbmdlTW9kdWxlLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQsIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LCBOYkJhc2VDYWxlbmRhck1vZHVsZSwgTmJCYXNlQ2FsZW5kYXJSYW5nZUNlbGwsIE5iQ2FsZW5kYXJSYW5nZURheUNlbGxDb21wb25lbnQsIE5iQ2FsZW5kYXJSYW5nZU1vbnRoQ2VsbENvbXBvbmVudCwgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQsIE5iQ2FsZW5kYXJZZWFyTW9kZWxTZXJ2aWNlLCBOYkNhbGVuZGFyVGltZU1vZGVsU2VydmljZSwgTmJDYWxlbmRhclZpZXdNb2RlLCBOYkNhbGVuZGFyU2l6ZSwgTmJDYWxlbmRhcktpdE1vZHVsZSwgTmJMYXlvdXRNb2R1bGUsIE5iTGF5b3V0Q29tcG9uZW50LCBOYkxheW91dENvbHVtbkNvbXBvbmVudCwgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQsIE5iTGF5b3V0Rm9vdGVyQ29tcG9uZW50LCBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIsIE5iTWVudU1vZHVsZSwgTmJUb2dnbGVTdGF0ZXMsIE5iTWVudUl0ZW1Db21wb25lbnQsIE5iTWVudUNvbXBvbmVudCwgTmJSb3V0ZVRhYnNldE1vZHVsZSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudCwgTmJTaWRlYmFyTW9kdWxlLCBOYlNpZGViYXJIZWFkZXJDb21wb25lbnQsIE5iU2lkZWJhckZvb3RlckNvbXBvbmVudCwgTmJTaWRlYmFyQ29tcG9uZW50LCBOYlRhYnNldE1vZHVsZSwgTmJUYWJDb21wb25lbnQsIE5iVGFic2V0Q29tcG9uZW50LCBOYlVzZXJNb2R1bGUsIE5iVXNlckNvbXBvbmVudCwgTmJBY3Rpb25zTW9kdWxlLCBOYkFjdGlvbkNvbXBvbmVudCwgTmJBY3Rpb25zQ29tcG9uZW50LCBOYlNlYXJjaE1vZHVsZSwgTmJTZWFyY2hTZXJ2aWNlLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LCBOYlNlYXJjaENvbXBvbmVudCwgTmJDaGVja2JveENvbXBvbmVudCwgTmJDaGVja2JveE1vZHVsZSwgTmJCYWRnZUNvbXBvbmVudCwgTmJCYWRnZU1vZHVsZSwgTmJQb3BvdmVyRGlyZWN0aXZlLCBOYlBvcG92ZXJNb2R1bGUsIE5iUG9wb3ZlckNvbXBvbmVudCwgTmJDb250ZXh0TWVudURpcmVjdGl2ZSwgTmJDb250ZXh0TWVudUNvbXBvbmVudCwgTmJDb250ZXh0TWVudU1vZHVsZSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudCwgTmJQcm9ncmVzc0Jhck1vZHVsZSwgTmJBbGVydENvbXBvbmVudCwgTmJBbGVydE1vZHVsZSwgTmJDaGF0Q29tcG9uZW50LCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LCBOYkNoYXRNZXNzYWdlTWFwQ29tcG9uZW50LCBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudCwgTmJDaGF0TWVzc2FnZVF1b3RlQ29tcG9uZW50LCBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudCwgTmJDaGF0Rm9ybUNvbXBvbmVudCwgTmJDaGF0TW9kdWxlLCBOYkNoYXRPcHRpb25zLCBOYlNwaW5uZXJDb21wb25lbnQsIE5iU3Bpbm5lckRpcmVjdGl2ZSwgTmJTcGlubmVyTW9kdWxlLCBOQl9TVEVQUEVSLCBOYlN0ZXBwZXJDb21wb25lbnQsIE5iU3RlcENvbXBvbmVudCwgTmJTdGVwcGVyTmV4dERpcmVjdGl2ZSwgTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUsIE5iU3RlcHBlck1vZHVsZSwgTmJBY2NvcmRpb25Db21wb25lbnQsIE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCwgTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudCwgTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50LCBOYkFjY29yZGlvbk1vZHVsZSwgTmJCdXR0b24sIE5iQnV0dG9uQ29tcG9uZW50LCBOYkJ1dHRvbk1vZHVsZSwgTmJCdXR0b25Hcm91cENvbXBvbmVudCwgTmJCdXR0b25Hcm91cE1vZHVsZSwgTmJCdXR0b25Ub2dnbGVEaXJlY3RpdmUsIE5iTGlzdENvbXBvbmVudCwgTmJMaXN0SXRlbUNvbXBvbmVudCwgTmJMaXN0TW9kdWxlLCBOYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZSwgTmJTY3JvbGxhYmxlQ29udGFpbmVyRGltZW50aW9ucywgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUsIE5iSW5wdXREaXJlY3RpdmUsIE5iSW5wdXRNb2R1bGUsIE5iT3ZlcmxheU1vZHVsZSwgcGF0Y2gsIGNyZWF0ZUNvbnRhaW5lciwgTmJPdmVybGF5U2VydmljZSwgTmJBZGp1c3RtZW50LCBOYlBvc2l0aW9uLCBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LCBOYkdsb2JhbFBvc2l0aW9uU3RyYXRlZ3ksIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyQ29tcG9uZW50LCBOYk92ZXJsYXlDb250YWluZXJDb21wb25lbnQsIE5iVHJpZ2dlciwgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlLCBOYkNsaWNrVHJpZ2dlclN0cmF0ZWd5LCBOYkhvdmVyVHJpZ2dlclN0cmF0ZWd5LCBOYkhpbnRUcmlnZ2VyU3RyYXRlZ3ksIE5iRm9jdXNUcmlnZ2VyU3RyYXRlZ3ksIE5iTm9vcFRyaWdnZXJTdHJhdGVneSwgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSwgTmJQb3J0YWxEaXJlY3RpdmUsIE5iUG9ydGFsT3V0bGV0RGlyZWN0aXZlLCBOYkNvbXBvbmVudFBvcnRhbCwgTmJPdmVybGF5LCBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsIE5iVGVtcGxhdGVQb3J0YWwsIE5iT3ZlcmxheUNvbnRhaW5lciwgTmJGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIE5iUG9ydGFsSW5qZWN0b3IsIE5iQ2RrTWFwcGluZ01vZHVsZSwgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24sIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbiwgTmJQb3NpdGlvbkhlbHBlciwgTmJEeW5hbWljT3ZlcmxheSwgTmJEeW5hbWljT3ZlcmxheUNoYW5nZSwgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIsIE5iUGxhdGZvcm0sIE5iRm9jdXNNb25pdG9yLCBOYkExMXlNb2R1bGUsIE5iRm9jdXNUcmFwLCBOYkZvY3VzVHJhcEZhY3RvcnlTZXJ2aWNlLCBOYkNka0FkYXB0ZXJNb2R1bGUsIE5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIsIE5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zLCBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyLCBOYlNjcm9sbERpc3BhdGNoZXJBZGFwdGVyLCBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyLCBOYkRpcmVjdGlvbmFsaXR5LCBOYkJpZGlNb2R1bGUsIE5iQ2VsbERlZkRpcmVjdGl2ZSwgTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlLCBOYkZvb3RlckNlbGxEZWZEaXJlY3RpdmUsIE5CX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYsIE5iQ29sdW1uRGVmRGlyZWN0aXZlLCBOYkhlYWRlckNlbGxEaXJlY3RpdmUsIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSwgTmJDZWxsRGlyZWN0aXZlLCBOYkRhdGFTb3VyY2UsIE5iRGF0YVJvd091dGxldERpcmVjdGl2ZSwgTmJIZWFkZXJSb3dPdXRsZXREaXJlY3RpdmUsIE5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlLCBOYk5vRGF0YVJvd091dGxldERpcmVjdGl2ZSwgTmJDZWxsT3V0bGV0RGlyZWN0aXZlLCBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZSwgTmJGb290ZXJSb3dEZWZEaXJlY3RpdmUsIE5iUm93RGVmRGlyZWN0aXZlLCBOYkhlYWRlclJvd0NvbXBvbmVudCwgTmJGb290ZXJSb3dDb21wb25lbnQsIE5iUm93Q29tcG9uZW50LCBOQl9UQUJMRV9URU1QTEFURSwgTkJfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgTkJfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUiwgTkJfVEFCTEVfUFJPVklERVJTLCBOYlRhYmxlLCBOYlRhYmxlTW9kdWxlLCBOQl9ESUFMT0dfQ09ORklHLCBOYkRpYWxvZ0NvbmZpZywgTmJEaWFsb2dSZWYsIE5iRGlhbG9nU2VydmljZSwgTmJEaWFsb2dNb2R1bGUsIE5iVG9hc3RyTW9kdWxlLCBOYlRvYXN0UmVmLCBOYlRvYXN0Q29udGFpbmVyLCBOYlRvYXN0ckNvbnRhaW5lclJlZ2lzdHJ5LCBOYlRvYXN0clNlcnZpY2UsIE5iVG9hc3QsIE5iVG9hc3RDb21wb25lbnQsIE5CX1RPQVNUUl9DT05GSUcsIE5iVG9hc3RyQ29uZmlnLCBOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCwgTmJUb29sdGlwTW9kdWxlLCBOYlRvb2x0aXBEaXJlY3RpdmUsIE5iVG9vbHRpcENvbXBvbmVudCwgTmJTZWxlY3RNb2R1bGUsIE5iU2VsZWN0TGFiZWxDb21wb25lbnQsIG5iU2VsZWN0Rm9ybUZpZWxkQ29udHJvbENvbmZpZ0ZhY3RvcnksIE5iU2VsZWN0Q29tcG9uZW50LCBOYk9wdGlvbk1vZHVsZSwgTmJPcHRpb25Db21wb25lbnQsIE5iT3B0aW9uR3JvdXBDb21wb25lbnQsIE5iT3B0aW9uTGlzdENvbXBvbmVudCwgTkJfU0VMRUNUX0lOSkVDVElPTl9UT0tFTiwgTmJBdXRvY29tcGxldGVNb2R1bGUsIE5iQXV0b2NvbXBsZXRlQ29tcG9uZW50LCBOYkF1dG9jb21wbGV0ZURpcmVjdGl2ZSwgTmJXaW5kb3dNb2R1bGUsIE5iV2luZG93U2VydmljZSwgTmJXaW5kb3dSZWYsIE5iV2luZG93U3RhdGUsIE5iV2luZG93Q29uZmlnLCBOQl9XSU5ET1dfQ09OVEVOVCwgTkJfV0lORE9XX0NPTkZJRywgTkJfV0lORE9XX0NPTlRFWFQsIE5iV2luZG93Q29tcG9uZW50LCBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQsIE5iVGltZXBpY2tlck1vZHVsZSwgTkJfVElNRV9QSUNLRVJfQ09ORklHLCBOYlRpbWVQaWNrZXJDb21wb25lbnQsIE5iVGltZVBpY2tlckRpcmVjdGl2ZSwgTmJEYXRlcGlja2VyTW9kdWxlLCBOYkRhdGVwaWNrZXJBZGFwdGVyLCBOYkRhdGVwaWNrZXIsIE5CX0RBVEVfQURBUFRFUiwgTkJfREFURV9TRVJWSUNFX09QVElPTlMsIE5iRGF0ZXBpY2tlckRpcmVjdGl2ZSwgTmJEYXRlQWRhcHRlclNlcnZpY2UsIE5iUmFuZ2VBZGFwdGVyU2VydmljZSwgTmJEYXRlVGltZUFkYXB0ZXJTZXJ2aWNlLCBOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQsIE5iQmFzZVBpY2tlciwgTmJCYXNlUGlja2VyQ29tcG9uZW50LCBOYkRhdGVwaWNrZXJDb21wb25lbnQsIE5iUmFuZ2VwaWNrZXJDb21wb25lbnQsIE5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50LCBOYlJhZGlvTW9kdWxlLCBOYlJhZGlvR3JvdXBDb21wb25lbnQsIE5iUmFkaW9Db21wb25lbnQsIE5iVGFnTW9kdWxlLCBOYlRhZ0NvbXBvbmVudCwgTmJUYWdMaXN0Q29tcG9uZW50LCBOYlRhZ0lucHV0RGlyZWN0aXZlLCBOYlRyZWVHcmlkTW9kdWxlLCBOYlRyZWVHcmlkQ29tcG9uZW50LCBOQl9ST1dfRE9VQkxFX0NMSUNLX0RFTEFZLCBOYlRyZWVHcmlkUm93Q29tcG9uZW50LCBOYlRyZWVHcmlkSGVhZGVyUm93Q29tcG9uZW50LCBOYlRyZWVHcmlkRm9vdGVyUm93Q29tcG9uZW50LCBOQl9UUkVFX0dSSUQsIE5iU29ydERpcmVjdGlvbiwgTmJTb3J0RGlyZWN0aXZlLCBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlLCBOYlNvcnRJY29uQ29tcG9uZW50LCBOYlNvcnRIZWFkZXJDb21wb25lbnQsIE5iVHJlZUdyaWRSb3dUb2dnbGVDb21wb25lbnQsIE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUsIE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlLCBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZSwgTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmUsIE5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUsIE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUsIE5iVHJlZUdyaWRGb290ZXJSb3dEZWZEaXJlY3RpdmUsIE5iVHJlZUdyaWRDZWxsRGVmRGlyZWN0aXZlLCBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSwgTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmUsIE5iRmlsdGVyRGlyZWN0aXZlLCBOYkZpbHRlcklucHV0RGlyZWN0aXZlLCBOYlRyZWVHcmlkUm93VG9nZ2xlRGlyZWN0aXZlLCBOQl9ERUZBVUxUX1JPV19MRVZFTCwgTmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGUsIE5iVHJlZUdyaWREYXRhU291cmNlLCBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIsIE5iVHJlZUdyaWREYXRhU2VydmljZSwgTmJUcmVlR3JpZEZpbHRlclNlcnZpY2UsIE5iVHJlZUdyaWRTZXJ2aWNlLCBOYlRyZWVHcmlkU29ydFNlcnZpY2UsIE5iQ29sdW1uc1NlcnZpY2UsIE5iSWNvbk1vZHVsZSwgTmJJY29uQ29tcG9uZW50LCBOYkZvbnRJY29uLCBOYlN2Z0ljb24sIE5iSWNvblBhY2tUeXBlLCBOYkljb25EZWZpbml0aW9uLCBOYkljb25MaWJyYXJpZXMsIE5iVG9nZ2xlTW9kdWxlLCBOYlRvZ2dsZUNvbXBvbmVudCwgTmJGb3JtRmllbGRNb2R1bGUsIE5iRm9ybUZpZWxkQ29tcG9uZW50LCBOYlByZWZpeERpcmVjdGl2ZSwgTmJTdWZmaXhEaXJlY3RpdmUsIE5iRm9ybUZpZWxkQ29udHJvbCwgTmJGb3JtRmllbGRDb250cm9sQ29uZmlnIH07XG4iXX0=